/** @const */
const TWO_PI = 2.0 * Math.PI;
/** @const */
const PI_TWO = Math.PI / 2.0;
const X = 0;
const Y = 1;
const Z = 2;
const W$1 = 3;
const MAX_FLOAT = Number.MAX_VALUE || 1.7976931348623157e308;
/** @const */
const LOG2 = Math.log(2);
/** @const */
const MAX32 = 2147483647;
/** @const */
const MAX = 549755748352;
/** @const */
const MIN = -MAX;
/** @const */
const RADIANS = Math.PI / 180.0;
/** @const */
const DEGREES = 180.0 / Math.PI;
/** @const */
const DEGREES_DOUBLE = 2.0 * DEGREES;
/** @const */
const RADIANS_HALF = 0.5 * RADIANS;
/** @const */
const ARCSECONDS_TO_RADIANS = 0.00000484813681109536;
/** @const */
const RADIANS_TO_HOURS = 3.8197186342054880584532103209403;
/** @const */
const HOURS_TO_RADIANS = 0.26179938779914943653855361527329;
/** @const */
const HOURS_TO_DEGREES = 15.0;
/** @const */
const DEGREES_TO_HOURS = 1.0 / 15.0;
/** @const */
const SQRT_HALF = Math.sqrt(0.5);
const EPS1 = 1e-1;
const EPS2 = 1e-2;
const EPS3 = 1e-3;
const EPS4 = 1e-4;
const EPS5 = 1e-5;
const EPS6 = 1e-6;
const EPS7 = 1e-7;
const EPS8 = 1e-8;
const EPS9 = 1e-9;
const EPS10 = 1e-10;
const EPS11 = 1e-11;
const EPS12 = 1e-12;
const EPS13 = 1e-13;
const EPS14 = 1e-14;
const EPS15 = 1e-15;
const EPS16 = 1e-16;
const EPS17 = 1e-17;
const EPS18 = 1e-18;
const EPS19 = 1e-19;
const EPS20 = 1e-20;
/**
 * The log function returns the power to which the base value has to be raised to produce n.
 * @function
 * @param {number} n - Produce value.
 * @param {number} base - Base value.
 * @returns {number} -
 * @example
 * log(64, 2)
 * //returns 6
 */
function log(n, base) {
    return Math.log(n) / Math.log(base);
}
/**
 * Clamp the number.
 * @function
 * @param {number} number - Input number.
 * @param {number} min - Minimal edge.
 * @param {number} max - Maximal edge.
 * @returns {number} -
 * @example
 * clamp(12, 1, 5)
 * //returns 5
 */
function clamp(number, min, max) {
    return Math.max(min, Math.min(number, max));
}
/**
 * Converts degrees value to radians.
 * @function
 * @param {number} degrees - Degree value.
 * @returns {number} -
 */
function DEG2RAD(degrees) {
    return degrees * RADIANS;
}
/**
 * Converts radians value to degrees.
 * @function
 * @param {number} angle - Degree value.
 * @returns {number} -
 */
function RAD2DEG(angle) {
    return angle * DEGREES;
}
/**
 * Check the number is a power of two.
 * @function
 * @param {number} x - Input value.
 * @returns {boolean} -
 */
function isPowerOfTwo(x) {
    return (x & (x - 1)) === 0;
}
/**
 * Returns next value that is power of two.
 * @function
 * @param {number} x - Input value.
 * @param {number} [maxValue=4096] - Maximal value.
 * @returns {number} -
 */
function nextHighestPowerOfTwo(x, maxValue = 4096) {
    --x;
    for (let i = 1; i < 32; i <<= 1) {
        x = x | (x >> i);
    }
    return (x + 1) > maxValue ? maxValue : x + 1;
}
/**
 * Returns random integer number within the bounds.
 * @function
 * @param {number} min - Minimal bound.
 * @param {number} max - Maximal bound.
 * @returns {number} -
 */
function randomi(min = 0, max = 1) {
    return Math.floor(Math.random() * (max - min)) + min;
}
/**
 * Returns random number within the bounds.
 * @function
 * @param {number} [min=0] - Minimal bound.
 * @param {number} [max=1] - Maximal bound.
 * @returns {number} -
 */
function random(min = 0, max = 1) {
    return Math.random() * (max - min) + min;
}
/**
 * Converts degrees value to decimal.
 * @function
 * @param {number} d - Degrees.
 * @param {number} m - Minutes.
 * @param {number} s - Seconds.
 * @param {boolean} [p] - Positive flag. False - default.
 * @returns {number} -
 **/
function degToDec(d, m, s, p) {
    if (p) {
        return d + m / 60.0 + s / 3600.0;
    }
    else {
        return -d - m / 60.0 - s / 3600.0;
    }
}
/**
 * The modulo operation that also works for negative dividends.
 * @function
 * @param {number} m - The dividend.
 * @param {number} n - The divisor.
 * @returns {number} The remainder.
 */
function mod(m, n) {
    return ((m % n) + n) % n;
}
/**
 * Returns an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.
 * @function
 * @param {number} a - Angle in radians
 * @returns {number} -
 */
function zeroTwoPI(a) {
    const res = mod(a, TWO_PI);
    if (Math.abs(res) < EPS14 && Math.abs(a) > EPS14) {
        return TWO_PI;
    }
    return res;
}
/**
 * Returns 0.0 if x is smaller than edge and otherwise 1.0.
 * @function
 * @param {number} edge -
 * @param {number} x - Value to edge.
 * @returns {number} -
 */
function step(edge, x) {
    return x < edge ? 0.0 : 1.0;
}
/**
 * The frac function returns the fractional part of x, i.e. x minus floor(x).
 * @function
 * @param {number} x - Input value.
 * @returns {number} -
 */
function frac(x) {
    const mx = Math.abs(x);
    return mx - Math.floor(mx);
}
/**
 * Returns Math.log(x) / Math.log(2)
 * @function
 * @param {number} x - Input value.
 * @returns {number} -
 */
function log2(x) {
    return Math.log(x) / LOG2;
}
/**
 * Returns two power of n.
 * @function
 * @param {number} n - Power value.
 * @returns {number} -
 */
function exp2(n) {
    return Math.pow(2, n);
}
/**
 * Returns two power of integer n.
 * @function
 * @param {number} n - Integer power value.
 * @returns {number} -
 */
function pow2i(n) {
    return 2 << (n - 1);
}
/**
 * Returns a slice of linear interpolation t * (h1 - h0)
 * @param {number} t - A value that linearly interpolates between the h0 parameter and the h1 parameter.
 * @param {number} h1 - End value.
 * @param {number} h0 - Start value.
 * @returns {number} -
 */
function slice(t, h1, h0) {
    return t * (h1 - h0);
}
/**
 * Performs a linear interpolation.
 * @function
 * @param {number} t - A value that linearly interpolates between the h0 parameter and the h1 parameter.
 * @param {number} h1 - End value.
 * @param {number} h0 - Start value.
 * @returns {number} -
 */
function lerp(t, h1, h0) {
    return h0 + t * (h1 - h0);
}
function cube(f) {
    return f * f * f;
}
function square(f) {
    return f * f;
}
function bezier1v(t, p0, p1, p2, p3) {
    return (cube(1 - t) * p0 + 3 * square(1 - t) * t * p1 + 3 * (1 - t) * square(t) * p2 + cube(t) * p3);
}
/**
 * Performs a 3D bezier interpolation.
 * @function
 * @param {number} t - Interpolation value.
 * @param {Vec3} p0 - First control point.
 * @param {Vec3} p1 - Second control point.
 * @param {Vec3} p2 - Third control point.
 * @param {Vec3} p3 - Fourth control point.
 * @returns {Vec3} -
 */
function bezier3v(t, p0, p1, p2, p3) {
    let u = 1 - t;
    let tt = t * t;
    let uu = u * u;
    let uuu = uu * u;
    let ttt = tt * t;
    return p0.scaleTo(uuu)
        .addA(p1.scaleTo(3 * uu * t))
        .addA(p2.scaleTo(3 * u * tt))
        .addA(p3.scaleTo(ttt));
}
/**
 * Clamp angle value within 360.
 * @function
 * @param {number} x - Input angle.
 * @returns {number} -
 */
function rev(x) {
    return x - Math.floor(x / 360.0) * 360.0;
}
/**
 * Clamp longitude within: -180 to +180 degrees.
 * @function
 * @param {number} lon - Longitude.
 * @returns {number} -
 */
function norm_lon(lon) {
    return lon > 180 ? ((lon + 180) % 360) - 180 : lon < -180 ? ((lon - 180) % 360) + 180 : lon;
}
/**
 * Returns an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.
 * @function
 * @param {number} a - Angle in radians.
 * @returns {number} -
 */
function negativePItoPI(a) {
    return zeroTwoPI(a + Math.PI) - Math.PI;
}
/**
 * Solve using iteration method and a fixed number of steps.
 * @function
 * @param {Function} f - Equation. Used in Euler's equation(see og.orbit) solving.
 * @param {number} x0 - First approximation.
 * @param {number} maxIter - Maximum iterations.
 * @returns {number} -
 */
function solve_iteration_fixed(f, x0, maxIter) {
    let x = 0;
    let x2 = x0;
    for (let i = 0; i < maxIter; i++) {
        x = x2;
        x2 = f(x);
    }
    return x2;
}
/**
 * Solve using iteration; terminate when error is below err or the maximum
 * number of iterations is reached. Used in Euler's equation(see og.orbit) solving.
 * @function
 * @param {(x: number) => number} f - Equation.
 * @param {number} x0 - First approximation.
 * @param {number} err - Maximal accepted error value.
 * @param {number} maxIter - Maximum iterations.
 * @returns {number} -
 */
function solve_iteration(f, x0, err, maxIter = 50) {
    let x = 0;
    let x2 = x0;
    for (let i = 0; i < maxIter; i++) {
        x = x2;
        x2 = f(x);
        if (Math.abs(x2 - x) < err) {
            return x2;
        }
    }
    return x2;
}
/**
 * Returns angle between two azimuths
 * @param {number} a - First azimuth angle
 * @param {number} b - Second azimuth angle
 * @returns {number}
 */
function getAngleBetweenAzimuths(a, b) {
    a = zeroTwoPI(a);
    b = zeroTwoPI(b);
    return ((((a - b) % 360) + 360 + 180) % 360) - 180;
}

var math = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ARCSECONDS_TO_RADIANS: ARCSECONDS_TO_RADIANS,
    DEG2RAD: DEG2RAD,
    DEGREES: DEGREES,
    DEGREES_DOUBLE: DEGREES_DOUBLE,
    DEGREES_TO_HOURS: DEGREES_TO_HOURS,
    EPS1: EPS1,
    EPS10: EPS10,
    EPS11: EPS11,
    EPS12: EPS12,
    EPS13: EPS13,
    EPS14: EPS14,
    EPS15: EPS15,
    EPS16: EPS16,
    EPS17: EPS17,
    EPS18: EPS18,
    EPS19: EPS19,
    EPS2: EPS2,
    EPS20: EPS20,
    EPS3: EPS3,
    EPS4: EPS4,
    EPS5: EPS5,
    EPS6: EPS6,
    EPS7: EPS7,
    EPS8: EPS8,
    EPS9: EPS9,
    HOURS_TO_DEGREES: HOURS_TO_DEGREES,
    HOURS_TO_RADIANS: HOURS_TO_RADIANS,
    LOG2: LOG2,
    MAX: MAX,
    MAX32: MAX32,
    MAX_FLOAT: MAX_FLOAT,
    MIN: MIN,
    PI_TWO: PI_TWO,
    RAD2DEG: RAD2DEG,
    RADIANS: RADIANS,
    RADIANS_HALF: RADIANS_HALF,
    RADIANS_TO_HOURS: RADIANS_TO_HOURS,
    SQRT_HALF: SQRT_HALF,
    TWO_PI: TWO_PI,
    W: W$1,
    X: X,
    Y: Y,
    Z: Z,
    bezier1v: bezier1v,
    bezier3v: bezier3v,
    clamp: clamp,
    cube: cube,
    degToDec: degToDec,
    exp2: exp2,
    frac: frac,
    getAngleBetweenAzimuths: getAngleBetweenAzimuths,
    isPowerOfTwo: isPowerOfTwo,
    lerp: lerp,
    log: log,
    log2: log2,
    mod: mod,
    negativePItoPI: negativePItoPI,
    nextHighestPowerOfTwo: nextHighestPowerOfTwo,
    norm_lon: norm_lon,
    pow2i: pow2i,
    random: random,
    randomi: randomi,
    rev: rev,
    slice: slice,
    solve_iteration: solve_iteration,
    solve_iteration_fixed: solve_iteration_fixed,
    square: square,
    step: step,
    zeroTwoPI: zeroTwoPI
});

const HALF_PI$1 = Math.PI * 0.5;
const INV_PI_BY_180$1 = 180.0 / Math.PI;
const INV_PI_BY_360 = INV_PI_BY_180$1 * 2.0;
const PI_BY_360$1 = Math.PI / 360.0;
const INV_PI_BY_180_HALF_PI = INV_PI_BY_180$1 * HALF_PI$1;
/**
 * Represents a geographical point with a certain latitude, longitude and height.
 * @class
 * @param {number} [lon] - Longitude.
 * @param {number} [lat] - Latitude.
 * @param {number} [height] - Height over the surface.
 */
class LonLat {
    constructor(lon = 0, lat = 0, height = 0) {
        /**
         * Longitude.
         * @public
         * @type {number}
         */
        this.lon = 0;
        /**
         * Latitude.
         * @public
         * @type {number}
         */
        this.lat = 0;
        /**
         * Height.
         * @public
         * @type {number}
         */
        this.height = 0;
        this.lon = lon;
        this.lat = lat;
        this.height = height;
    }
    /**
     * Check zero coordinates
     * @returns {boolean} -
     */
    isZero() {
        return this.lon === 0.0 && this.lat === 0.0 && this.height === 0.0;
    }
    /**
     * Creates coordinates array.
     * @static
     * @param{Array.<Array<number>>} arr - Coordinates array data. (exactly 3 entries)
     * @return{Array.<LonLat>} the same coordinates array but each element is LonLat instance.
     */
    static join(arr) {
        let res = [];
        for (let i = 0; i < arr.length; i++) {
            let ai = arr[i];
            res[i] = new LonLat(ai[0], ai[1], ai[2]);
        }
        return res;
    }
    /**
     * Creates an object by coordinate array.
     * @static
     * @param {Array.<number>} arr - Coordinates array, where first is longitude, second is latitude and third is a height. (exactly 3 entries)
     * @returns {LonLat} -
     */
    static createFromArray(arr) {
        return new LonLat(arr[0], arr[1], arr[2]);
    }
    /**
     * Create array from lonLat
     * @param lonLat
     * @returns {number[]}
     */
    static toArray(lonLat) {
        return [lonLat.lon, lonLat.lat, lonLat.height];
    }
    /**
     * Create array from lonLat
     * @returns {number[]}
     */
    toArray() {
        return LonLat.toArray(this);
    }
    /**
     * Converts degrees to mercator coordinates.
     * @static
     * @param {number} lon - Degrees longitude.
     * @param {number} lat - Degrees latitude.
     * @param {number} [height] - Height.
     * @returns {LonLat} -
     */
    static forwardMercator(lon, lat, height) {
        return new LonLat(lon * POLE_BY_180, Math.log(Math.tan((90.0 + lat) * PI_BY_360$1)) * POLE_BY_PI, height);
    }
    /**
     * Converts degrees to mercator coordinates.
     * @static
     * @param {LonLat} lonLat - Input geodetic degree coordinates
     * @param {LonLat} res - Output mercator coordinates
     * @returns {LonLat} - Output mercator coordinates
     */
    static forwardMercatorRes(lonLat, res) {
        res.lon = lonLat.lon * POLE_BY_180;
        res.lat = Math.log(Math.tan((90.0 + lonLat.lat) * PI_BY_360$1)) * POLE_BY_PI,
            res.height = lonLat.height;
        return res;
    }
    /**
     * Converts mercator to degrees coordinates.
     * @static
     * @param {number} x - Mercator longitude.
     * @param {number} y - Mercator latitude.
     * @param {number} [height] - Height.
     * @returns {LonLat} -
     */
    static inverseMercator(x, y, height = 0) {
        return new LonLat(x * INV_POLE_BY_180, INV_PI_BY_360 * Math.atan(Math.exp(y * PI_BY_POLE)) - INV_PI_BY_180_HALF_PI, height);
    }
    /**
     * Sets coordinates.
     * @public
     * @param {number} [lon] - Longitude.
     * @param {number} [lat] - Latitude.
     * @param {number} [height] - Height.
     * @returns {LonLat} -
     */
    set(lon = 0, lat = 0, height = 0) {
        this.lon = lon;
        this.lat = lat;
        this.height = height;
        return this;
    }
    /**
     * Copy coordinates.
     * @public
     * @param {LonLat} [lonLat] - Coordinates to copy.
     * @returns {LonLat} -
     */
    copy(lonLat) {
        this.lon = lonLat.lon;
        this.lat = lonLat.lat;
        this.height = lonLat.height;
        return this;
    }
    /**
     * Clone the coordinates.
     * @public
     * @returns {LonLat} -
     */
    clone() {
        return new LonLat(this.lon, this.lat, this.height);
    }
    /**
     * Converts to mercator coordinates.
     * @public
     * @returns {LonLat} -
     */
    forwardMercator() {
        return LonLat.forwardMercator(this.lon, this.lat, this.height);
    }
    forwardMercatorEPS01() {
        let lat = this.lat;
        if (lat > 89.9) {
            lat = 89.9;
        }
        else if (lat < -89.9) {
            lat = -89.9;
        }
        return new LonLat(this.lon * POLE_BY_180, Math.log(Math.tan((90.0 + lat) * PI_BY_360$1)) * POLE_BY_PI);
    }
    /**
     * Converts from mercator coordinates.
     * @public
     * @returns {LonLat} -
     */
    inverseMercator() {
        return LonLat.inverseMercator(this.lon, this.lat, this.height);
    }
    /**
     * Compares coordinates.
     * @public
     * @param {LonLat} b - Coordinate to compare with.
     * @returns {boolean} -
     */
    equal(b) {
        if (b.height) {
            return this.lon === b.lon && this.lat === b.lat && this.height === b.height;
        }
        else {
            return this.lon === b.lon && this.lat === b.lat;
        }
    }
}

/**
 * Mercator size.
 * @const
 * @type {number}
 */
const POLE = 20037508.34;
const POLE2 = POLE * 2.0;
const PI_BY_POLE = Math.PI / POLE;
const POLE_BY_PI = POLE / Math.PI;
const HALF_PI = Math.PI * 0.5;
const POLE_BY_180 = POLE / 180.0;
const INV_POLE_BY_180 = 180.0 / POLE;
const PI_BY_360 = Math.PI / 360.0;
const PI_BY_180 = Math.PI / 180.0;
const INV_PI_BY_180 = 180.0 / Math.PI;
/**
 * Double mercator size.
 * @const
 * @type {number}
 */
const POLE_DOUBLE = 2.0 * POLE;
/**
 * One by mercator double size.
 * @const
 * @type {number}
 */
const ONE_BY_POLE_DOUBLE = 1.0 / POLE_DOUBLE;
function forward(lonLat) {
    return new LonLat(lonLat.lon * POLE / 180.0, Math.log(Math.tan((90.0 + lonLat.lat) * PI_BY_360)) * POLE_BY_PI, lonLat.height);
}
/**
 * Converts degrees longitude to mercator coordinate.
 * @function
 * @param {number} lon - Degrees geodetic longitude.
 * @returns {number} -
 */
function forward_lon(lon) {
    return lon * POLE / 180.0;
}
/**
 * Converts degrees latitude to mercator coordinate.
 * @function
 * @param {number} lat - Degrees geodetic latitude.
 * @returns {number} -
 */
function forward_lat(lat) {
    return Math.log(Math.tan((90.0 + lat) * PI_BY_360)) * POLE_BY_PI;
}
/**
 * Converts mercator longitude to degrees coordinate.
 * @function
 * @param {number} lon - Mercator longitude.
 * @returns {number} -
 */
function inverse_lon(lon) {
    return 180 * lon / POLE;
}
/**
 * Converts mercator latitude to degrees coordinate.
 * @function
 * @param {number} lon - Mercator latitude.
 * @returns {number} -
 */
function inverse_lat(lat) {
    return INV_PI_BY_180 * (2.0 * Math.atan(Math.exp(lat * PI_BY_POLE)) - HALF_PI);
}
/**
 * Returns mercator map tile grid horizontal coordinate index by geodetic
 * longitude and zoom level. Where top left corner of the grid is 0 coordinate index.
 * @function
 * @param {number} lon - Geodetic degrees longitude.
 * @param {number} zoom - Zoom level.
 * @returns {number}
 */
function getTileX(lon, zoom) {
    return Math.floor((lon + 180) / 360.0 * Math.pow(2, zoom));
}
/**
 * Returns mercator map tile grid vertical coordinate index by geodetic
 * latitude and zoom level. Where top left corner of the grid is 0 coordinate index.
 * @function
 * @param {number} lat - Geodetic degrees latitude.
 * @param {number} zoom - Zoom level.
 * @returns {number}
 */
function getTileY(lat, zoom) {
    return Math.floor((1.0 - Math.log(Math.tan(lat * PI_BY_180) + 1.0 / Math.cos(lat * PI_BY_180)) / Math.PI) * 0.5 * Math.pow(2, zoom));
}
/**
 * Converts geodetic coordinate array to mercator coordinate array.
 * @function
 * @param {Array.<LonLat>} lonLatArr - LonLat array to convert.
 * @returns {Array.<LonLat>}
 */
function forwardArray(lonlatArr) {
    let res = [];
    for (let i = 0; i < lonlatArr.length; i++) {
        res.push(lonlatArr[i].forwardMercator());
    }
    return res;
}
function getTileExtent(x, y, z) {
    let size = POLE2 / (1 << z), //Math.pow(2, z),
    sw = new LonLat(-POLE + x * size, POLE - y * size - size);
    return new Extent(sw, new LonLat(sw.lon + size, sw.lat + size));
}
/**
 * Max mercator latitude.
 * @const
 * @type {number}
 */
const MAX_LAT = inverse_lat(POLE);
/**
 * Min mercator latitude.
 * @const
 * @type {number}
 */
const MIN_LAT = -MAX_LAT;

var mercator = /*#__PURE__*/Object.freeze({
    __proto__: null,
    INV_POLE_BY_180: INV_POLE_BY_180,
    MAX_LAT: MAX_LAT,
    MIN_LAT: MIN_LAT,
    ONE_BY_POLE_DOUBLE: ONE_BY_POLE_DOUBLE,
    PI_BY_POLE: PI_BY_POLE,
    POLE: POLE,
    POLE2: POLE2,
    POLE_BY_180: POLE_BY_180,
    POLE_BY_PI: POLE_BY_PI,
    POLE_DOUBLE: POLE_DOUBLE,
    forward: forward,
    forwardArray: forwardArray,
    forward_lat: forward_lat,
    forward_lon: forward_lon,
    getTileExtent: getTileExtent,
    getTileX: getTileX,
    getTileY: getTileY,
    inverse_lat: inverse_lat,
    inverse_lon: inverse_lon
});

/**
 * Represents geographical coordinates extent.
 * @class
 * @param {LonLat} [sw] - South West extent corner coordinates.
 * @param {LonLat} [ne] - North East extent corner coordinates.
 */
class Extent {
    constructor(sw = new LonLat(), ne = new LonLat()) {
        this.southWest = sw;
        this.northEast = ne;
    }
    /**
     * Creates extent instance from values in array.
     * @static
     * @param {Array.<number>} arr - South west and north-east longitude and latitudes packed in array. (exactly 4 entries)
     * @return {Extent} Extent object.
     */
    static createFromArray(arr) {
        return new Extent(new LonLat(arr[0], arr[1]), new LonLat(arr[2], arr[3]));
    }
    /**
     * Creates bound extent instance by coordinate array.
     * @static
     * @param {Array.<LonLat>} arr - Coordinate array.
     * @return {Extent} Extent object.
     */
    static createByCoordinates(arr) {
        let lonmin = MAX, lonmax = MIN, latmin = MAX, latmax = MIN;
        for (let i = 0; i < arr.length; i++) {
            const vi = arr[i];
            if (vi.lon < lonmin)
                lonmin = vi.lon;
            if (vi.lon > lonmax)
                lonmax = vi.lon;
            if (vi.lat < latmin)
                latmin = vi.lat;
            if (vi.lat > latmax)
                latmax = vi.lat;
        }
        return new Extent(new LonLat(lonmin, latmin), new LonLat(lonmax, latmax));
    }
    /**
     * Creates bound extent instance by coordinates array.
     * @static
     * @param {Array.<Array<number>>} arr - Coordinate array. (exactly 2 entries)
     * @return {Extent} Extent object.
     */
    static createByCoordinatesArr(arr) {
        let lonmin = MAX, lonmax = MIN, latmin = MAX, latmax = MIN;
        for (let i = 0; i < arr.length; i++) {
            const vi = arr[i];
            if (vi[0] < lonmin)
                lonmin = vi[0];
            if (vi[0] > lonmax)
                lonmax = vi[0];
            if (vi[1] < latmin)
                latmin = vi[1];
            if (vi[1] > latmax)
                latmax = vi[1];
        }
        return new Extent(new LonLat(lonmin, latmin), new LonLat(lonmax, latmax));
    }
    /**
     * Creates extent by mer—Åator grid tile coordinates.
     * @static
     * @param {number} x -
     * @param {number} y -
     * @param {number} z -
     * @param {number} width -
     * @param {number} height -
     * @returns {Extent} -
     */
    static fromTile(x, y, z, width = POLE_DOUBLE, height = POLE_DOUBLE) {
        const H = 1 << z; //Math.pow(2, z);
        const W = H; //Math.pow(2, z);
        const lnSize = width / W;
        const ltSize = height / H;
        const left = -width * 0.5 + x * lnSize, top = height * 0.5 - y * ltSize, bottom = top - ltSize, right = left + lnSize;
        return new Extent(new LonLat(left, bottom), new LonLat(right, top));
    }
    /**
     * Sets current bounding extent object by coordinate array.
     * @public
     * @param {Array.<LonLat>} arr - Coordinate array.
     * @return {Extent} Current extent.
     */
    setByCoordinates(arr) {
        let lonmin = MAX, lonmax = MIN, latmin = MAX, latmax = MIN;
        for (let i = 0; i < arr.length; i++) {
            const vi = arr[i];
            if (vi.lon < lonmin)
                lonmin = vi.lon;
            if (vi.lon > lonmax)
                lonmax = vi.lon;
            if (vi.lat < latmin)
                latmin = vi.lat;
            if (vi.lat > latmax)
                latmax = vi.lat;
        }
        this.southWest.lon = lonmin;
        this.southWest.lat = latmin;
        this.northEast.lon = lonmax;
        this.northEast.lat = latmax;
        return this;
    }
    /**
     * Determines if point inside extent.
     * @public
     * @param {LonLat} lonlat - Coordinate point.
     * @return {boolean} Returns true if point inside extent.
     */
    isInside(lonlat) {
        const sw = this.southWest;
        const ne = this.northEast;
        return (lonlat.lon >= sw.lon && lonlat.lon <= ne.lon &&
            lonlat.lat >= sw.lat && lonlat.lat <= ne.lat);
    }
    /**
     * Returns true if two extent overlap each other.
     * @public
     * @param {Extent} e - Another extent.
     * @return {boolean} -
     */
    overlaps(e) {
        const sw = this.southWest;
        const ne = this.northEast;
        return (sw.lon <= e.northEast.lon &&
            ne.lon >= e.southWest.lon &&
            sw.lat <= e.northEast.lat &&
            ne.lat >= e.southWest.lat);
    }
    /**
     * Gets extent width.
     * @public
     * @return {number} Extent width.
     */
    getWidth() {
        return this.northEast.lon - this.southWest.lon;
    }
    /**
     * Gets extent height.
     * @public
     * @return {number} Extent height.
     */
    getHeight() {
        return this.northEast.lat - this.southWest.lat;
    }
    /**
     * Creates clone instance of the current extent.
     * @public
     * @return {Extent} Extent clone.
     */
    clone() {
        return new Extent(this.southWest.clone(), this.northEast.clone());
    }
    /**
     * Gets the center coordinate of the extent.
     * @public
     * @return {number} Center coordinate.
     */
    getCenter() {
        const sw = this.southWest;
        const ne = this.northEast;
        return new LonLat(sw.lon + (ne.lon - sw.lon) * 0.5, sw.lat + (ne.lat - sw.lat) * 0.5);
    }
    /**
     * @public
     */
    getNorthWest() {
        return new LonLat(this.southWest.lon, this.northEast.lat);
    }
    /**
     * @public
     */
    getNorthEast() {
        return new LonLat(this.northEast.lon, this.northEast.lat);
    }
    /**
     * @public
     */
    getSouthWest() {
        return new LonLat(this.southWest.lon, this.southWest.lat);
    }
    /**
     * @public
     */
    getSouthEast() {
        return new LonLat(this.northEast.lon, this.southWest.lat);
    }
    /**
     * @public
     */
    getNorth() {
        return this.northEast.lat;
    }
    getEast() {
        return this.northEast.lon;
    }
    /**
     * @public
     */
    getWest() {
        return this.southWest.lon;
    }
    /**
     * @public
     */
    getSouth() {
        return this.southWest.lat;
    }
    /**
     * Returns extents are equals.
     * @param {Extent} extent - Extent.
     * @returns {boolean} -
     */
    equals(extent) {
        return (this.southWest.lon === extent.southWest.lon &&
            this.southWest.lat === extent.southWest.lat &&
            this.northEast.lon === extent.northEast.lon &&
            this.northEast.lat === extent.northEast.lat);
    }
    /**
     * Converts extent coordinates to mercator projection coordinates.
     * @public
     * @return {Extent} New instance of the current extent.
     */
    forwardMercator() {
        return new Extent(this.southWest.forwardMercator(), this.northEast.forwardMercator());
    }
    /**
     * Converts extent coordinates from mercator projection to degrees.
     * @public
     * @return {Extent} New instance of the current extent.
     */
    inverseMercator() {
        return new Extent(this.southWest.inverseMercator(), this.northEast.inverseMercator());
    }
    /**
     * Gets cartesian bounding bounds of the current ellipsoid.
     * @public
     * @param {Ellipsoid} ellipsoid - Ellipsoid.
     * @return {Array.<number>} Cartesian 3d coordinate array. (exactly 6 entries)
     */
    getCartesianBounds(ellipsoid) {
        let xmin = MAX, xmax = MIN, ymin = MAX, ymax = MIN, zmin = MAX, zmax = MIN;
        const v = [
            new LonLat(this.southWest.lon, this.southWest.lat),
            new LonLat(this.southWest.lon, this.northEast.lat),
            new LonLat(this.northEast.lon, this.northEast.lat),
            new LonLat(this.northEast.lon, this.southWest.lat)
        ];
        for (let i = 0; i < v.length; i++) {
            const coord = ellipsoid.lonLatToCartesian(v[i]);
            const x = coord.x;
            const y = coord.y;
            const z = coord.z;
            if (x < xmin)
                xmin = x;
            if (x > xmax)
                xmax = x;
            if (y < ymin)
                ymin = y;
            if (y > ymax)
                ymax = y;
            if (z < zmin)
                zmin = z;
            if (z > zmax)
                zmax = z;
        }
        return [xmin, ymin, zmin, xmax, ymax, zmax];
    }
    toString() {
        return (`[${this.southWest.lon.toFixed(5)}, ${this.southWest.lat.toFixed(5)}, ${this.northEast.lon.toFixed(5)}, ${this.northEast.lat.toFixed(5)}]`);
    }
}

/**
 * Class represents a 3x3 matrix.
 * @class
 */
class Mat3 {
    constructor() {
        /**
         * A 3x3 matrix, indexing as a column-major order array.
         * @public
         * @type {Array.<number>}
         */
        this._m = [
            0, 0, 0,
            0, 0, 0,
            0, 0, 0
        ];
    }
    /**
     * Sets column-major order array matrix.
     * @public
     * @param {Array.<number>} m - Matrix array.
     * @returns {Mat3}
     */
    set(m) {
        this._m[0] = m[0];
        this._m[1] = m[1];
        this._m[2] = m[2];
        this._m[3] = m[3];
        this._m[4] = m[4];
        this._m[5] = m[5];
        this._m[6] = m[6];
        this._m[7] = m[7];
        this._m[8] = m[8];
        return this;
    }
    /**
     * Duplicates a Mat3 instance.
     * @public
     * @returns {Mat3}
     */
    clone() {
        let res = new Mat3();
        res.set(this._m);
        return res;
    }
    /**
     * Copy matrix.
     * @public
     * @param {Mat3} a - Matrix to copy.
     * @returns {Mat3}
     */
    copy(a) {
        return this.set(a._m);
    }
    /**
     * Creates transposed matrix from the current.
     * @public
     * @returns {Mat3}
     */
    transposeTo() {
        let res = new Mat3();
        let m = this._m;
        res._m[0] = m[0];
        res._m[1] = m[3];
        res._m[2] = m[6];
        res._m[3] = m[1];
        res._m[4] = m[4];
        res._m[5] = m[7];
        res._m[6] = m[2];
        res._m[7] = m[5];
        res._m[8] = m[8];
        return res;
    }
    /**
     * Sets matrix to identity.
     * @public
     * @returns {Mat3}
     */
    setIdentity() {
        this._m[0] = 1;
        this._m[1] = 0;
        this._m[2] = 0;
        this._m[3] = 0;
        this._m[4] = 1;
        this._m[5] = 0;
        this._m[6] = 0;
        this._m[7] = 0;
        this._m[8] = 1;
        return this;
    }
    /**
     * Multiply to 3d vector.
     * @public
     * @params {Vec3} p - 3d vector.
     * @returns {Vec3}
     */
    mulVec(p) {
        let d = p.x, e = p.y, g = p.z;
        let m = this._m;
        return new Vec3(m[0] * d + m[3] * e + m[6] * g, m[1] * d + m[4] * e + m[7] * g, m[2] * d + m[5] * e + m[8] * g);
    }
    /**
     * Converts to 4x4 matrix.
     * @public
     * @returns {Mat4}
     */
    toMatrix4() {
        let res = new Mat4();
        let b = res._m;
        let a = this._m;
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = 0;
        b[4] = a[3];
        b[5] = a[4];
        b[6] = a[5];
        b[7] = 0;
        b[8] = a[6];
        b[9] = a[7];
        b[10] = a[8];
        b[11] = 0;
        b[12] = 0;
        b[13] = 0;
        b[14] = 0;
        b[15] = 1;
        return res;
    }
}

/**
 * Class represents a 4d vector.
 * @class
 * @param {number} [x] - First value.
 * @param {number} [y] - Second value.
 * @param {number} [z] - Third value.
 * @param {number} [w] - Fourth value.
 */
class Vec4 {
    constructor(x = 0.0, y = 0.0, z = 0.0, w = 0.0) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    /**
     * Identity vector [0,0,0,1].
     * @const
     * @type {Vec4}
     */
    static get identity() {
        return new Vec4(0, 0, 0, 1);
    }
    /**
     * Creates 4d vector from array.
     * @function
     * @param {Array.<number>} arr - Array of four values
     * @returns {Vec4}
     */
    static fromVec(arr) {
        return new Vec4(arr[0], arr[1], arr[2], arr[3]);
    }
    /**
     * Converts to Vec3, without fourth value.
     * @public
     * @returns {Vec3}
     */
    toVec3() {
        return new Vec3(this.x, this.y, this.z);
    }
    /**
     * Returns clone vector.
     * @public
     * @returns {Vec4}
     */
    clone() {
        return new Vec4(this.x, this.y, this.z, this.w);
    }
    /**
     * Compares with vector. Returns true if it equals another.
     * @public
     * @param {Vec4} v - Vector to compare.
     * @returns {boolean}
     */
    equal(v) {
        return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
    }
    /**
     * Copy input vector's values.
     * @param {Vec4} v - Vector to copy.
     * @returns {Vec4}
     */
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w;
        return this;
    }
    /**
     * Converts vector to a number array.
     * @public
     * @returns {Array.<number>} - (exactly 4 entries)
     */
    toArray() {
        return [this.x, this.y, this.z, this.w];
    }
    /**
     * Converts vector to a number array.
     * @public
     * @returns {Array.<number>} - (exactly 4 entries)
     */
    toArray3() {
        return [this.x, this.y, this.z];
    }
    /**
     * Sets vector's values.
     * @public
     * @param {number} x - Value X.
     * @param {number} y - Value Y.
     * @param {number} z - Value Z.
     * @param {number} w - Value W.
     * @returns {Vec4}
     */
    set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    }
    /**
     * Adds vector to the current.
     * @public
     * @param {Vec4} v - Vector to add.
     * @returns {Vec4}
     */
    addA(v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
    }
    /**
     * Subtract vector from the current.
     * @public
     * @param {Vec4} v - Subtract vector.
     * @returns {Vec4}
     */
    subA(v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
    }
    /**
     * Scale current vector.
     * @public
     * @param {number} scale - Scale value.
     * @returns {Vec4}
     */
    scale(scale) {
        this.x *= scale;
        this.y *= scale;
        this.z *= scale;
        this.w *= scale;
        return this;
    }
    /**
     * Makes vector affinity. Thereby fourth component becomes to 1.0.
     * @public
     * @returns {Vec4}
     */
    affinity() {
        let iw = 1.0 / this.w;
        this.x *= iw;
        this.y *= iw;
        this.z *= iw;
        this.w = 1.0;
        return this;
    }
    /**
     * Scale current vector to another instance.
     * @public
     * @param {number} scale - Scale value.
     * @returns {Vec3}
     */
    scaleTo(scale) {
        return new Vec4(this.x * scale, this.y * scale, this.z * scale, this.w * scale);
    }
    /**
     * Vector's edge function that returns vector where each component is 0.0 if it's smaller than edge and otherwise 1.0.
     * @public
     * @returns {Vec4}
     */
    getStep(edge) {
        return new Vec4(this.x < edge ? 0.0 : 1.0, this.y < edge ? 0.0 : 1.0, this.z < edge ? 0.0 : 1.0, this.w < edge ? 0.0 : 1.0);
    }
    /**
     * The vector frac function returns the vector of fractional parts of each value, i.e. x minus floor(x).
     * @public
     * @param {Vec4} v - Input vector
     * @returns {Vec4}
     */
    getFrac(v) {
        return new Vec4(frac(v.x), frac(v.y), frac(v.z), frac(v.w));
    }
    /**
     * Gets vectors dot production.
     * @public
     * @param {Vec4} v - Another vector.
     * @returns {number} - Dot product.
     */
    dot(v) {
        return v.x * this.x + v.y * this.y + v.z * this.z + v.w * this.w;
    }
    /**
     * Returns true if vector's values are zero.
     * @public
     * @returns {boolean} -
     */
    isZero() {
        return !(this.x || this.y || this.z || this.w);
    }
}

/**
 * Class represents a 4x4 matrix.
 * @class
 */
class Mat4 {
    constructor() {
        /**
         * A 4x4 matrix, index-able as a column-major order array.
         * @public
         * @type {Array.<number>}
         */
        this._m = [
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0
        ];
    }
    /**
     * Returns identity matrix instance.
     * @static
     * @returns {Mat4} -
     */
    static identity() {
        let res = new Mat4();
        res._m[0] = 1;
        res._m[1] = 0;
        res._m[2] = 0;
        res._m[3] = 0;
        res._m[4] = 0;
        res._m[5] = 1;
        res._m[6] = 0;
        res._m[7] = 0;
        res._m[8] = 0;
        res._m[9] = 0;
        res._m[10] = 1;
        res._m[11] = 0;
        res._m[12] = 0;
        res._m[13] = 0;
        res._m[14] = 0;
        res._m[15] = 1;
        return res;
    }
    /**
     * Sets column-major order array matrix.
     * @public
     * @param {Array.<number>} m - Matrix array.
     * @returns {Mat4} -
     */
    set(m) {
        this._m[0] = m[0];
        this._m[1] = m[1];
        this._m[2] = m[2];
        this._m[3] = m[3];
        this._m[4] = m[4];
        this._m[5] = m[5];
        this._m[6] = m[6];
        this._m[7] = m[7];
        this._m[8] = m[8];
        this._m[9] = m[9];
        this._m[10] = m[10];
        this._m[11] = m[11];
        this._m[12] = m[12];
        this._m[13] = m[13];
        this._m[14] = m[14];
        this._m[15] = m[15];
        return this;
    }
    /**
     * Duplicates a Matrix3 instance.
     * @public
     * @returns {Mat4} -
     */
    clone() {
        let res = new Mat4();
        res.set(this._m);
        return res;
    }
    /**
     * Copy matrix.
     * @public
     * @param {Mat4} a - Matrix to copy.
     * @return {Mat4}
     */
    copy(a) {
        return this.set(a._m);
    }
    /**
     * Converts to 3x3 matrix.
     * @public
     * @returns {Mat3} -
     */
    toMatrix3() {
        let res = new Mat3();
        let a = this._m, b = res._m;
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[4];
        b[4] = a[5];
        b[5] = a[6];
        b[6] = a[8];
        b[7] = a[9];
        b[8] = a[10];
        return res;
    }
    /**
     * Multiply to 3d vector.
     * @public
     * @param {Vec3} p - 3d vector.
     * @returns {Vec3} -
     */
    mulVec3(p) {
        let d = p.x, e = p.y, g = p.z;
        return new Vec3(this._m[0] * d + this._m[4] * e + this._m[8] * g + this._m[12], this._m[1] * d + this._m[5] * e + this._m[9] * g + this._m[13], this._m[2] * d + this._m[6] * e + this._m[10] * g + this._m[14]);
    }
    /**
     * Multiply to 4d vector.
     * @public
     * @param {Vec4} p - 4d vector.
     * @returns {Vec4} -
     */
    mulVec4(p) {
        let d = p.x, e = p.y, g = p.z, f = p.w;
        return new Vec4(this._m[0] * d + this._m[4] * e + this._m[8] * g + this._m[12] * f, this._m[1] * d + this._m[5] * e + this._m[9] * g + this._m[13] * f, this._m[2] * d + this._m[6] * e + this._m[10] * g + this._m[14] * f, this._m[3] * d + this._m[7] * e + this._m[11] * g + this._m[15] * f);
    }
    /**
     * Creates an inverse 3x3 matrix of the current.
     * @public
     * @returns {Mat3} -
     */
    toInverseMatrix3() {
        let a = this._m;
        let c = a[0], d = a[1], e = a[2], g = a[4], f = a[5], h = a[6], i = a[8], j = a[9], k = a[10], l = k * f - h * j, o = -k * g + h * i, m = j * g - f * i, n = c * l + d * o + e * m;
        if (!n) {
            return;
        }
        n = 1.0 / n;
        let res = new Mat3();
        res._m[0] = l * n;
        res._m[1] = (-k * d + e * j) * n;
        res._m[2] = (h * d - e * f) * n;
        res._m[3] = o * n;
        res._m[4] = (k * c - e * i) * n;
        res._m[5] = (-h * c + e * g) * n;
        res._m[6] = m * n;
        res._m[7] = (-j * c + d * i) * n;
        res._m[8] = (f * c - d * g) * n;
        return res;
    }
    /**
     * Creates an inverse matrix of the current.
     * @public
     * @returns {Mat4} -
     */
    inverseTo(res = new Mat4()) {
        let c = this._m[0], d = this._m[1], e = this._m[2], g = this._m[3], f = this._m[4], h = this._m[5], i = this._m[6], j = this._m[7], k = this._m[8], l = this._m[9], o = this._m[10], m = this._m[11], n = this._m[12], p = this._m[13], r = this._m[14], s = this._m[15], A = c * h - d * f, B = c * i - e * f, t = c * j - g * f, u = d * i - e * h, v = d * j - g * h, w = e * j - g * i, x = k * p - l * n, y = k * r - o * n, z = k * s - m * n, C = l * r - o * p, D = l * s - m * p, E = o * s - m * r, q = 1 / (A * E - B * D + t * C + u * z - v * y + w * x);
        res._m[0] = (h * E - i * D + j * C) * q;
        res._m[1] = (-d * E + e * D - g * C) * q;
        res._m[2] = (p * w - r * v + s * u) * q;
        res._m[3] = (-l * w + o * v - m * u) * q;
        res._m[4] = (-f * E + i * z - j * y) * q;
        res._m[5] = (c * E - e * z + g * y) * q;
        res._m[6] = (-n * w + r * t - s * B) * q;
        res._m[7] = (k * w - o * t + m * B) * q;
        res._m[8] = (f * D - h * z + j * x) * q;
        res._m[9] = (-c * D + d * z - g * x) * q;
        res._m[10] = (n * v - p * t + s * A) * q;
        res._m[11] = (-k * v + l * t - m * A) * q;
        res._m[12] = (-f * C + h * y - i * x) * q;
        res._m[13] = (c * C - d * y + e * x) * q;
        res._m[14] = (-n * u + p * B - r * A) * q;
        res._m[15] = (k * u - l * B + o * A) * q;
        return res;
    }
    /**
     * Creates a transposed matrix of the current.
     * @public
     * @returns {Mat4} -
     */
    transposeTo() {
        let res = new Mat4();
        res._m[0] = this._m[0];
        res._m[1] = this._m[4];
        res._m[2] = this._m[8];
        res._m[3] = this._m[12];
        res._m[4] = this._m[1];
        res._m[5] = this._m[5];
        res._m[6] = this._m[9];
        res._m[7] = this._m[13];
        res._m[8] = this._m[2];
        res._m[9] = this._m[6];
        res._m[10] = this._m[10];
        res._m[11] = this._m[14];
        res._m[12] = this._m[3];
        res._m[13] = this._m[7];
        res._m[14] = this._m[11];
        res._m[15] = this._m[15];
        return res;
    }
    /**
     * Sets matrix to identity.
     * @public
     * @returns {Mat4} -
     */
    setIdentity() {
        this._m[0] = 1;
        this._m[1] = 0;
        this._m[2] = 0;
        this._m[3] = 0;
        this._m[4] = 0;
        this._m[5] = 1;
        this._m[6] = 0;
        this._m[7] = 0;
        this._m[8] = 0;
        this._m[9] = 0;
        this._m[10] = 1;
        this._m[11] = 0;
        this._m[12] = 0;
        this._m[13] = 0;
        this._m[14] = 0;
        this._m[15] = 1;
        return this;
    }
    /**
     * Computes the product of two matrices.
     * @public
     * @param {Mat4} mx - Matrix to multiply.
     * @returns {Mat4} -
     */
    mul(mx) {
        let d = this._m[0], e = this._m[1], g = this._m[2], f = this._m[3], h = this._m[4], i = this._m[5], j = this._m[6], k = this._m[7], l = this._m[8], o = this._m[9], m = this._m[10], n = this._m[11], p = this._m[12], r = this._m[13], s = this._m[14], a = this._m[15];
        let A = mx._m[0], B = mx._m[1], t = mx._m[2], u = mx._m[3], v = mx._m[4], w = mx._m[5], x = mx._m[6], y = mx._m[7], z = mx._m[8], C = mx._m[9], D = mx._m[10], E = mx._m[11], q = mx._m[12], F = mx._m[13], G = mx._m[14], b = mx._m[15];
        let res = new Mat4();
        res._m[0] = A * d + B * h + t * l + u * p;
        res._m[1] = A * e + B * i + t * o + u * r;
        res._m[2] = A * g + B * j + t * m + u * s;
        res._m[3] = A * f + B * k + t * n + u * a;
        res._m[4] = v * d + w * h + x * l + y * p;
        res._m[5] = v * e + w * i + x * o + y * r;
        res._m[6] = v * g + w * j + x * m + y * s;
        res._m[7] = v * f + w * k + x * n + y * a;
        res._m[8] = z * d + C * h + D * l + E * p;
        res._m[9] = z * e + C * i + D * o + E * r;
        res._m[10] = z * g + C * j + D * m + E * s;
        res._m[11] = z * f + C * k + D * n + E * a;
        res._m[12] = q * d + F * h + G * l + b * p;
        res._m[13] = q * e + F * i + G * o + b * r;
        res._m[14] = q * g + F * j + G * m + b * s;
        res._m[15] = q * f + F * k + G * n + b * a;
        return res;
    }
    /**
     * Add translation vector to the current matrix.
     * @public
     * @param {Vec3} v - Translate vector.
     * @returns {Mat4} -
     */
    translate(v) {
        let d = v.x, e = v.y, b = v.z;
        let a = this._m;
        a[12] = a[0] * d + a[4] * e + a[8] * b + a[12];
        a[13] = a[1] * d + a[5] * e + a[9] * b + a[13];
        a[14] = a[2] * d + a[6] * e + a[10] * b + a[14];
        a[15] = a[3] * d + a[7] * e + a[11] * b + a[15];
        return this;
    }
    /**
     * Sets translation matrix to the position.
     * @public
     * @param {Vec3} v - Translate to position.
     * @returns {Mat4} -
     */
    translateToPosition(v) {
        let a = this._m;
        a[12] = v.x;
        a[13] = v.y;
        a[14] = v.z;
        return this;
    }
    /**
     * Rotate current matrix around the aligned axis and angle.
     * @public
     * @param {Vec3} u - Aligned axis.
     * @param {number} angle - Aligned axis angle in radians.
     * @returns {Mat4} -
     */
    rotate(u, angle) {
        let c = Math.cos(angle), s = Math.sin(angle);
        let rot = new Mat4();
        let mx = rot._m;
        mx[0] = c + (1 - c) * u.x * u.x;
        mx[1] = (1 - c) * u.y * u.x - s * u.z;
        mx[2] = (1 - c) * u.z * u.x + s * u.y;
        mx[3] = 0;
        mx[4] = (1 - c) * u.x * u.y + s * u.z;
        mx[5] = c + (1 - c) * u.y * u.y;
        mx[6] = (1 - c) * u.z * u.y - s * u.x;
        mx[7] = 0;
        mx[8] = (1 - c) * u.x * u.z - s * u.y;
        mx[9] = (1 - c) * u.y * u.z + s * u.x;
        mx[10] = c + (1 - c) * u.z * u.z;
        mx[11] = 0;
        mx[12] = 0;
        mx[13] = 0;
        mx[14] = 0;
        mx[15] = 1;
        return this.mul(rot);
    }
    /**
     * Sets current rotation matrix around the aligned axis and angle.
     * @public
     * @param {Vec3} u - Aligned axis.
     * @param {number} angle - Aligned axis angle in radians.
     * @returns {Mat4} -
     */
    setRotation(u, angle) {
        let c = Math.cos(angle), s = Math.sin(angle);
        let mx = this._m;
        mx[0] = c + (1 - c) * u.x * u.x;
        mx[1] = (1 - c) * u.y * u.x - s * u.z;
        mx[2] = (1 - c) * u.z * u.x + s * u.y;
        mx[3] = 0;
        mx[4] = (1 - c) * u.x * u.y + s * u.z;
        mx[5] = c + (1 - c) * u.y * u.y;
        mx[6] = (1 - c) * u.z * u.y - s * u.x;
        mx[7] = 0;
        mx[8] = (1 - c) * u.x * u.z - s * u.y;
        mx[9] = (1 - c) * u.y * u.z + s * u.x;
        mx[10] = c + (1 - c) * u.z * u.z;
        mx[11] = 0;
        mx[12] = 0;
        mx[13] = 0;
        mx[14] = 0;
        mx[15] = 1;
        return this;
    }
    /**
     * Gets the rotation matrix from one vector to another.
     * @public
     * @param {Vec3} a - First vector.
     * @param {Vec3} b - Second vector.
     * @returns {Mat4} -
     */
    rotateBetweenVectors(a, b) {
        let q = Quat.getRotationBetweenVectors(a, b);
        return q.getMat4();
    }
    /**
     * Scale current matrix to the vector values.
     * @public
     * @param {Vec3} v - Scale vector.
     * @returns {Mat4} -
     */
    scale(v) {
        let mx = this._m;
        mx[0] = mx[0] * v.x;
        mx[1] = mx[1] * v.x;
        mx[2] = mx[2] * v.x;
        mx[3] = mx[3] * v.x;
        mx[4] = mx[4] * v.y;
        mx[5] = mx[5] * v.y;
        mx[6] = mx[6] * v.y;
        mx[7] = mx[7] * v.y;
        mx[8] = mx[8] * v.z;
        mx[9] = mx[9] * v.z;
        mx[10] = mx[10] * v.z;
        mx[11] = mx[11] * v.z;
        return this;
    }
    /**
     * Sets perspective projection matrix frustum values.
     * @public
     * @param {number} left -
     * @param {number} right -
     * @param {number} bottom -
     * @param {number} top -
     * @param {number} near -
     * @param {number} far -
     * @returns {Mat4} -
     */
    setPerspective(left, right, bottom, top, near, far) {
        let h = right - left, i = top - bottom, j = near - far, n2 = 2 * near;
        let mm = this._m;
        mm[0] = n2 / h;
        mm[1] = 0;
        mm[2] = 0;
        mm[3] = 0;
        mm[4] = 0;
        mm[5] = n2 / i;
        mm[6] = 0;
        mm[7] = 0;
        mm[8] = (right + left) / h;
        mm[9] = (top + bottom) / i;
        mm[10] = (far + near) / j;
        mm[11] = -1;
        mm[12] = 0;
        mm[13] = 0;
        mm[14] = (n2 * far) / j;
        mm[15] = 0;
        return this;
    }
    /**
     * Creates current orthographic projection matrix.
     * @public
     * @param {number} left -
     * @param {number} right -
     * @param {number} bottom -
     * @param {number} top -
     * @param {number} near -
     * @param {number} far -
     * @return {Mat4} -
     */
    setOrtho(left, right, bottom, top, near, far) {
        let lr = 1.0 / (left - right), bt = 1.0 / (bottom - top), nf = 1.0 / (near - far), m = this._m;
        m[0] = -2.0 * lr;
        m[1] = 0;
        m[2] = 0;
        m[3] = 0;
        m[4] = 0;
        m[5] = -2.0 * bt;
        m[6] = 0;
        m[7] = 0;
        m[8] = 0;
        m[9] = 0;
        m[10] = 2.0 * nf;
        m[11] = 0;
        m[12] = (left + right) * lr;
        m[13] = (top + bottom) * bt;
        m[14] = (far + near) * nf;
        m[15] = 1.0;
        return this;
    }
    /**
     * Sets current rotation matrix by euler's angles.
     * @public
     * @param {number} ax - Rotation angle in radians around X axis.
     * @param {number} ay - Rotation angle in radians around Y axis.
     * @param {number} az - Rotation angle in radians around Z axis.
     * @returns {Mat4} -
     */
    eulerToMatrix(ax, ay, az) {
        let a = Math.cos(ax), b = Math.sin(ax), c = Math.cos(ay), d = Math.sin(ay), e = Math.cos(az), f = Math.sin(az);
        let ad = a * d, bd = b * d;
        let mat = this._m;
        mat[0] = c * e;
        mat[1] = -c * f;
        mat[2] = -d;
        mat[4] = -bd * e + a * f;
        mat[5] = bd * f + a * e;
        mat[6] = -b * c;
        mat[8] = ad * e + b * f;
        mat[9] = -ad * f + b * e;
        mat[10] = a * c;
        mat[3] = mat[7] = mat[11] = mat[12] = mat[13] = mat[14] = 0;
        mat[15] = 1;
        return this;
    }
}

/**
 * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.
 * @constructor
 * @param {Number} [x=0.0] The X component.
 * @param {Number} [y=0.0] The Y component.
 * @param {Number} [z=0.0] The Z component.
 * @param {Number} [w=0.0] The W component.
 */
class Quat {
    constructor(x = 0.0, y = 0.0, z = 0.0, w = 0.0) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    /**
     * Identity Quat.
     * @const
     * @type {Quat}
     */
    static get IDENTITY() {
        return new Quat(0.0, 0.0, 0.0, 1.0);
    }
    /**
     * Returns a Quat represents rotation around X axis.
     * @static
     * @param {number} a - The angle in radians to rotate around the axis.
     * @returns {Quat} -
     */
    static xRotation(a) {
        a *= 0.5;
        return new Quat(Math.sin(a), 0.0, 0.0, Math.cos(a));
    }
    /**
     * Returns a Quat represents rotation around Y axis.
     * @static
     * @param {number} a - The angle in radians to rotate around the axis.
     * @returns {Quat} -
     */
    static yRotation(a) {
        a *= 0.5;
        return new Quat(0.0, Math.sin(a), 0.0, Math.cos(a));
    }
    /**
     * Returns a Quat represents rotation around Z axis.
     * @static
     * @param {number} a - The angle in radians to rotate around the axis.
     * @returns {Quat} -
     */
    static zRotation(a) {
        a *= 0.5;
        return new Quat(0.0, 0.0, Math.sin(a), Math.cos(a));
    }
    /**
     * Computes a Quat representing a rotation around an axis.
     * @static
     * @param {Vec3} axis - The axis of rotation.
     * @param {number} [angle=0.0] The angle in radians to rotate around the axis.
     * @returns {Quat} -
     */
    static axisAngleToQuat(axis, angle = 0) {
        let v = axis.getNormal();
        let half_angle = angle * 0.5;
        let sin_a = Math.sin(half_angle);
        return new Quat(v.x * sin_a, v.y * sin_a, v.z * sin_a, Math.cos(half_angle));
    }
    /**
     * Computes a rotation from the given heading and up vector.
     * @static
     * @param {Vec3} forward - Heading target coordinates.
     * @param {Vec3} up - Up vector.
     * @returns {Quat} -
     */
    static getLookRotation(forward, up) {
        let f = forward.getNormal().negate();
        let s = up.cross(f).normalize();
        let u = f.cross(s);
        let z = 1.0 + s.x + u.y + f.z;
        if (z > 0.000001) {
            let fd = 1.0 / (2.0 * Math.sqrt(z));
            return new Quat((f.y - u.z) * fd, (s.z - f.x) * fd, (u.x - s.y) * fd, 0.25 / fd);
        }
        if (s.x > u.y && s.x > f.z) {
            let fd = 1.0 / (2.0 * Math.sqrt(1.0 + s.x - u.y - f.z));
            return new Quat(0.25 / fd, (u.x + s.y) * fd, (s.z + f.x) * fd, (f.y - u.z) * fd);
        }
        if (u.y > f.z) {
            let fd = 1.0 / (2.0 * Math.sqrt(1.0 + u.y - s.x - f.z));
            return new Quat((u.x + s.y) * fd, 0.25 / fd, (f.y + u.z) * fd, (s.z - f.x) * fd);
        }
        let fd = 1.0 / (2.0 * Math.sqrt(1.0 + f.z - s.x - u.y));
        return new Quat((s.z + f.x) * fd, (f.y + u.z) * fd, 0.25 / fd, (u.x - s.y) * fd);
    }
    /**
     * Computes a Quat from source point heading to the destination point.
     * @static
     * @param {Vec3} sourcePoint - Source coordinate.
     * @param {Vec3} destPoint - Destination coordinate.
     * @returns {Quat} -
     */
    static getLookAtSourceDest(sourcePoint, destPoint) {
        let forwardVector = destPoint.subA(sourcePoint).normalize();
        let dot = Vec3.FORWARD.dot(forwardVector);
        if (Math.abs(dot - -1.0) < 0.000001) {
            return Quat.axisAngleToQuat(Vec3.UP, Math.PI);
        }
        if (Math.abs(dot - 1.0) < 0.000001) {
            return new Quat(0.0, 0.0, 0.0, 1.0);
        }
        let rotAngle = Math.acos(dot);
        let rotAxis = Vec3.FORWARD.cross(forwardVector).normalize();
        return Quat.axisAngleToQuat(rotAxis, rotAngle);
    }
    /**
     * Compute rotation between two vectors.
     * @static
     * @param {Vec3} u - First vector.
     * @param {Vec3} v - Second vector.
     * @returns {Quat} -
     */
    static getRotationBetweenVectors(u, v) {
        let w = u.cross(v);
        let q = new Quat(w.x, w.y, w.z, 1.0 + u.dot(v));
        return q.normalize();
    }
    /**
     * Compute rotation between two vectors.
     * @static
     * @param {Vec3} u - First vector.
     * @param {Vec3} v - Second vector.
     * @param {Quat} res
     * @returns {Quat} -
     */
    static getRotationBetweenVectorsRes(u, v, res) {
        let w = u.cross(v);
        res.set(w.x, w.y, w.z, 1.0 + u.dot(v));
        return res.normalize();
    }
    /**
     * Compute rotation between two vectors with around vector up
     * for exactly opposite vectors. If vectors exactly in the same
     * direction as returns identity Quat.
     * @static
     * @param {Vec3} source - First vector.
     * @param {Vec3} dest - Second vector.
     * @param {Vec3} up - Up vector.
     * @returns {Quat} -
     */
    static getRotationBetweenVectorsUp(source, dest, up) {
        let dot = source.dot(dest);
        if (Math.abs(dot + 1.0) < 0.000001) {
            // vector source and dest point exactly in the opposite direction,
            // so it is a 180 degrees turn around the up-axis
            return Quat.axisAngleToQuat(up, Math.PI);
        }
        if (Math.abs(dot - 1.0) < 0.000001) {
            // vector source and dest point exactly in the same direction,
            // so we return the identity Quat
            return new Quat(0, 0, 0, 1);
        }
        let rotAngle = Math.acos(dot);
        let rotAxis = source.cross(dest).normalize();
        return Quat.axisAngleToQuat(rotAxis, rotAngle);
    }
    static setFromEulerAngles(pitch, yaw, roll) {
        let res = new Quat();
        return res.setFromEulerAngles(pitch, yaw, roll);
    }
    /**
     * Returns true if the components are zero.
     * @public
     * @returns {boolean} -
     */
    isZero() {
        return this.x === 0.0 && this.y === 0.0 && this.z === 0.0 && this.w === 0.0;
    }
    /**
     * Clear Quat. Sets zeroes.
     * @public
     * @returns {Quat} -
     */
    clear() {
        this.x = this.y = this.z = this.w = 0;
        return this;
    }
    /**
     * Sets Quat values.
     * @public
     * @param {Number} [x=0.0] The X component.
     * @param {Number} [y=0.0] The Y component.
     * @param {Number} [z=0.0] The Z component.
     * @param {Number} [w=0.0] The W component.
     * @returns {Quat} -
     */
    set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    }
    /**
     * Copy Quat values.
     * @public
     * @param {Quat} q - Copy Quat.
     * @returns {Quat} -
     */
    copy(q) {
        this.x = q.x;
        this.y = q.y;
        this.z = q.z;
        this.w = q.w;
        return this;
    }
    /**
     * Set current Quat instance to identity Quat.
     * @public
     * @returns {Quat} -
     */
    setIdentity() {
        this.x = 0.0;
        this.y = 0.0;
        this.z = 0.0;
        this.w = 1.0;
        return this;
    }
    /**
     * Duplicates a Quat instance.
     * @public
     * @returns {Quat} -
     */
    clone() {
        return new Quat(this.x, this.y, this.z, this.w);
    }
    /**
     * Computes the componentwise sum of two Quats.
     * @public
     * @param {Quat} q - Quat to add.
     * @returns {Quat} -
     */
    add(q) {
        return new Quat(this.x + q.x, this.y + q.y, this.z + q.z, this.w + q.w);
    }
    /**
     * Computes the componentwise difference of two Quats.
     * @public
     * @param {Quat} q - Quat to subtract.
     * @returns {Quat} -
     */
    sub(q) {
        return new Quat(this.x - q.x, this.y - q.y, this.z - q.z, this.w - q.w);
    }
    /**
     * Multiplies the provided Quat componentwise by the provided scalar.
     * @public
     * @param {Number} scale - The scalar to multiply with.
     * @returns {Quat} -
     */
    scaleTo(scale) {
        return new Quat(this.x * scale, this.y * scale, this.z * scale, this.w * scale);
    }
    /**
     * Multiplies the provided Quat componentwise.
     * @public
     * @param {Number} scale - The scalar to multiply with.
     * @returns {Quat} -
     */
    scale(scale) {
        this.x *= scale;
        this.y *= scale;
        this.z *= scale;
        this.w *= scale;
        return this;
    }
    /**
     * Converts Quat values to array.
     * @public
     * @returns {Array.<number>} - (exactly 4 entries)
     */
    toVec() {
        return [this.x, this.y, this.z, this.w];
    }
    /**
     * Sets current quaternion by spherical coordinates.
     * @public
     * @param {number} lat - Latitude.
     * @param {number} lon - Longitude.
     * @param {number} angle - Angle in radians.
     * @returns {Quat} -
     */
    setFromSphericalCoords(lat, lon, angle) {
        let sin_a = Math.sin(angle / 2);
        let cos_a = Math.cos(angle / 2);
        let sin_lat = Math.sin(lat);
        let cos_lat = Math.cos(lat);
        let sin_long = Math.sin(lon);
        let cos_long = Math.cos(lon);
        this.x = sin_a * cos_lat * sin_long;
        this.y = sin_a * sin_lat;
        this.z = sin_a * sin_lat * cos_long;
        this.w = cos_a;
        return this;
    }
    /**
     * Sets rotation with the given heading and up vectors.
     * @static
     * @param {Vec3} forward - Heading target coordinates.
     * @param {Vec3} up - Up vector.
     * @returns {Quat} -
     */
    setLookRotation(forward, up) {
        let f = forward.getNormal().negate();
        let s = up.cross(f).normalize();
        let u = f.cross(s);
        let z = 1.0 + s.x + u.y + f.z;
        if (z > 0.000001) {
            let fd = 1.0 / (2.0 * Math.sqrt(z));
            this.x = (f.y - u.z) * fd;
            this.y = (s.z - f.x) * fd;
            this.z = (u.x - s.y) * fd;
            this.w = 0.25 / fd;
        }
        else if (s.x > u.y && s.x > f.z) {
            let fd = 1.0 / (2.0 * Math.sqrt(1.0 + s.x - u.y - f.z));
            this.x = 0.25 / fd;
            this.y = (u.x + s.y) * fd;
            this.z = (s.z + f.x) * fd;
            this.w = (f.y - u.z) * fd;
        }
        else if (u.y > f.z) {
            let fd = 1.0 / (2.0 * Math.sqrt(1.0 + u.y - s.x - f.z));
            this.x = (u.x + s.y) * fd;
            this.y = 0.25 / fd;
            this.z = (f.y + u.z) * fd;
            this.w = (s.z - f.x) * fd;
        }
        else {
            let fd = 1.0 / (2.0 * Math.sqrt(1.0 + f.z - s.x - u.y));
            this.x = (s.z + f.x) * fd;
            this.y = (f.y + u.z) * fd;
            this.z = 0.25 / fd;
            this.w = (u.x - s.y) * fd;
        }
        return this;
    }
    /**
     * Gets spherical coordinates.
     * @public
     * @returns {Object} Returns object with latitude, longitude and alpha.
     */
    toSphericalCoords() {
        let cos_a = this.w;
        let sin_a = Math.sqrt(1.0 - cos_a * cos_a);
        // var angle = Math.acos(cos_a) * 2;
        if (Math.abs(sin_a) < 0.0005) {
            sin_a = 1;
        }
        let tx = this.x / sin_a;
        let ty = this.y / sin_a;
        let tz = this.z / sin_a;
        let lon, lat = -Math.asin(ty);
        if (tx * tx + tz * tz < 0.0005) {
            lon = 0;
        }
        else {
            lon = Math.atan2(tx, tz);
        }
        if (lon < 0) {
            lon += 360.0;
        }
        return {
            lat: lat,
            lon: lon,
            alpha: Math.acos(cos_a)
        };
    }
    /**
     * Sets current Quat representing a rotation around an axis.
     * @public
     * @param {Vec3} axis - The axis of rotation.
     * @param {number} angle The angle in radians to rotate around the axis.
     * @returns {Quat} -
     */
    setFromAxisAngle(axis, angle) {
        let v = axis.getNormal();
        let half_angle = angle * 0.5;
        let sin_a = Math.sin(half_angle);
        this.set(v.x * sin_a, v.y * sin_a, v.z * sin_a, Math.cos(half_angle));
        return this;
    }
    /**
     * Returns axis and angle of the current Quat.
     * @public
     * @returns {Object} -
     */
    getAxisAngle() {
        let x = this.x, y = this.y, z = this.z, w = this.w;
        let vl = Math.sqrt(x * x + y * y + z * z);
        let axis, angle;
        if (vl > 0.0000001) {
            let ivl = 1.0 / vl;
            axis = new Vec3(x * ivl, y * ivl, z * ivl);
            if (w < 0) {
                angle = 2.0 * Math.atan2(-vl, -w); // -PI,0
            }
            else {
                angle = 2.0 * Math.atan2(vl, w); // 0,PI
            }
        }
        else {
            axis = new Vec3(0, 0, 0);
            angle = 0;
        }
        return {
            axis: axis,
            angle: angle
        };
    }
    /**
     * Sets current Quat by Euler's angles.
     * @public
     * @param {number} pitch - Pitch angle in degrees.
     * @param {number} yaw - Yaw angle in degrees.
     * @param {number} roll - Roll angle in degrees.
     * @returns {Quat} -
     */
    setFromEulerAngles(pitch, yaw, roll) {
        let ex = pitch * RADIANS_HALF, ey = yaw * RADIANS_HALF, ez = roll * RADIANS_HALF;
        let cr = Math.cos(ex), cp = Math.cos(ey), cy = Math.cos(ez);
        let sr = Math.sin(ex), sp = Math.sin(ey), sy = Math.sin(ez);
        let cpcy = cp * cy, spsy = sp * sy;
        this.w = cr * cpcy + sr * spsy;
        this.x = sr * cpcy - cr * spsy;
        this.y = cr * sp * cy + sr * cp * sy;
        this.z = cr * cp * sy - sr * sp * cy;
        return this.normalize();
    }
    /**
     * Returns Euler's angles of the current Quat.
     * @public
     * @returns {Object} -
     */
    getEulerAngles() {
        let x = this.x, y = this.y, z = this.z, w = this.w;
        let sqy = y * y;
        let roll = Math.atan2(2.0 * (w * x + y * z), 1.0 - 2.0 * (x * x + sqy));
        let a = w * y - z * x;
        if (a < -1.0) {
            a = -1.0;
        }
        else if (a > 1.0) {
            a = 1.0;
        }
        let pitch = Math.asin(2.0 * a);
        let yaw = Math.atan2(2.0 * (w * z + x * y), 1.0 - 2.0 * (sqy + z * z));
        return {
            roll,
            pitch,
            yaw
        };
    }
    /**
     * Computes a Quat from the provided 4x4 matrix instance.
     * @public
     * @param {Mat4} mx - The rotation matrix.
     * @returns {Quat} -
     */
    setFromMatrix4(mx) {
        let tr, s, q = [];
        let i, j, k;
        let m = mx._m;
        let nxt = [1, 2, 0];
        tr = m[0] + m[5] + m[10];
        if (tr > 0.0) {
            s = Math.sqrt(tr + 1.0);
            this.w = s / 2.0;
            s = 0.5 / s;
            this.x = (m[6] - m[9]) * s;
            this.y = (m[8] - m[2]) * s;
            this.z = (m[1] - m[4]) * s;
        }
        else {
            i = 0;
            if (m[5] > m[0])
                i = 1;
            if (m[10] > m[i * 5])
                i = 2;
            j = nxt[i];
            k = nxt[j];
            s = Math.sqrt(m[i * 5] - (m[j * 5] + m[k * 5]) + 1.0);
            q[i] = s * 0.5;
            if (s !== 0.0)
                s = 0.5 / s;
            q[3] = (m[j * 4 + k] - m[k * 4 + j]) * s;
            q[j] = (m[i * 4 + j] + m[j * 4 + i]) * s;
            q[k] = (m[i * 4 + k] + m[k * 4 + i]) * s;
            this.x = q[0];
            this.y = q[1];
            this.z = q[2];
            this.w = q[3];
        }
        return this;
    }
    /**
     * Converts current Quat to the rotation 4x4 matrix.
     * @public
     * @params {Mat4} [out] - Output matrix
     * @returns {Mat4} -
     */
    getMat4(out = new Mat4()) {
        let xs = this.x + this.x;
        let ys = this.y + this.y;
        let zs = this.z + this.z;
        let wx = this.w * xs;
        let wy = this.w * ys;
        let wz = this.w * zs;
        let xx = this.x * xs;
        let xy = this.x * ys;
        let xz = this.x * zs;
        let yy = this.y * ys;
        let yz = this.y * zs;
        let zz = this.z * zs;
        return out.set([
            1 - (yy + zz), xy - wz, xz + wy, 0,
            xy + wz, 1 - (xx + zz), yz - wx, 0,
            xz - wy, yz + wx, 1 - (xx + yy), 0,
            0, 0, 0, 1
        ]);
    }
    /**
     * Converts current Quat to the rotation 3x3 matrix.
     * @public
     * @returns {Mat3} -
     * @todo NOT TESTED
     */
    getMat3() {
        let m = new Mat3();
        let mx = m._m;
        let c = this.x, d = this.y, e = this.z, g = this.w, f = c + c, h = d + d, i = e + e, j = c * f, k = c * h;
        c = c * i;
        let l = d * h;
        d = d * i;
        e = e * i;
        f = g * f;
        h = g * h;
        g = g * i;
        mx[0] = 1 - (l + e);
        mx[1] = k - g;
        mx[2] = c + h;
        mx[3] = k + g;
        mx[4] = 1 - (j + e);
        mx[5] = d - f;
        mx[6] = c - h;
        mx[7] = d + f;
        mx[8] = 1 - (j + l);
        return m;
    }
    /**
     * Returns quaternion and vector production.
     * @public
     * @param {Vec3} v - 3d Vector.
     * @returns {Vec3} -
     */
    mulVec3(v) {
        // t = 2 * cross(q.xyz, v)
        // v' = v + q.w * t + cross(q.xyz, t)
        let d = v.x, e = v.y, g = v.z;
        let b = this.x, f = this.y, h = this.z, a = this.w;
        let i = a * d + f * g - h * e, j = a * e + h * d - b * g, k = a * g + b * e - f * d;
        d = -b * d - f * e - h * g;
        return new Vec3(i * a + d * -b + j * -h - k * -f, j * a + d * -f + k * -b - i * -h, k * a + d * -h + i * -f - j * -b);
    }
    /**
     * Computes the product of two Quats.
     * @public
     * @param {Quat} q - Quat to multiply.
     * @returns {Quat} -
     */
    mul(q) {
        let d = this.x, e = this.y, g = this.z, a = this.w;
        let f = q.x, h = q.y, i = q.z, b = q.w;
        return new Quat(d * b + a * f + e * i - g * h, e * b + a * h + g * f - d * i, g * b + a * i + d * h - e * f, a * b - d * f - e * h - g * i);
    }
    /**
     * Computes the product of two Quats.
     * @public
     * @param {Quat} q - Quat to multiply.
     * @returns {Quat} -
     */
    mulA(q) {
        let d = this.x, e = this.y, g = this.z, a = this.w;
        let f = q.x, h = q.y, i = q.z, b = q.w;
        this.x = d * b + a * f + e * i - g * h;
        this.y = e * b + a * h + g * f - d * i;
        this.z = g * b + a * i + d * h - e * f;
        this.w = a * b - d * f - e * h - g * i;
        return this;
    }
    /**
     * Gets the conjugate of the Quat.
     * @public
     * @returns {Quat} -
     */
    conjugate() {
        return new Quat(-this.x, -this.y, -this.z, this.w);
    }
    /**
     * Computes the inverse of the Quat.
     * @public
     * @returns {Quat} -
     */
    inverse() {
        let n = 1.0 / this.magnitude2();
        return new Quat(-this.x * n, -this.y * n, -this.z * n, this.w * n);
    }
    /**
     * Computes a magnitude of the Quat.
     * @public
     * @returns {number} -
     */
    magnitude() {
        let b = this.x, c = this.y, d = this.z, a = this.w;
        return Math.sqrt(b * b + c * c + d * d + a * a);
    }
    /**
     * Computes a squared magnitude of the Quat.
     * @public
     * @returns {number} -
     */
    magnitude2() {
        let b = this.x, c = this.y, d = this.z, a = this.w;
        return b * b + c * c + d * d + a * a;
    }
    /**
     * Computes the dot (scalar) product of two Quats.
     * @public
     * @param {Quat} q - Second quaternion.
     * @returns {number} -
     */
    dot(q) {
        return this.x * q.x + this.y * q.y + this.z * q.z;
    }
    /**
     * Current Quat normalization.
     * @public
     * @returns {Quat} -
     */
    normalize() {
        let c = this.x, d = this.y, e = this.z, g = this.w, f = Math.sqrt(c * c + d * d + e * e + g * g);
        if (f === 0.0) {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 0;
            return this;
        }
        f = 1 / f;
        this.x = c * f;
        this.y = d * f;
        this.z = e * f;
        this.w = g * f;
        return this;
    }
    /**
     * Compares two Quats.
     * @public
     * @param {Quat} q - Second quaternion.
     * @returns {Boolean} -
     */
    isEqual(q) {
        let matching = this.dot(q);
        if (Math.abs(matching - 1.0) < 0.001) {
            return true;
        }
        return false;
    }
    /**
     * Performs a spherical linear interpolation between two Quats.
     * @public
     * @param {Quat} b - The end rotation Quat.
     * @param {number} t - interpolation amount between the two Quats.
     * @returns {Quat} -
     */
    slerp(b, t) {
        let ax = this.x, ay = this.y, az = this.z, aw = this.w, bx = b.x, by = b.y, bz = b.z, bw = b.w;
        let omega, cosom, sinom, scale0, scale1;
        cosom = ax * bx + ay * by + az * bz + aw * bw;
        if (cosom < 0.0) {
            cosom = -cosom;
            bx = -bx;
            by = -by;
            bz = -bz;
            bw = -bw;
        }
        if (1.0 - cosom > 0.000001) {
            omega = Math.acos(cosom);
            sinom = Math.sin(omega);
            scale0 = Math.sin((1.0 - t) * omega) / sinom;
            scale1 = Math.sin(t * omega) / sinom;
        }
        else {
            scale0 = 1.0 - t;
            scale1 = t;
        }
        return new Quat(scale0 * ax + scale1 * bx, scale0 * ay + scale1 * by, scale0 * az + scale1 * bz, scale0 * aw + scale1 * bw);
    }
    /**
     * Returns a roll angle in radians.
     * @public
     * @param {Boolean} [reprojectAxis] -
     * @returns {Number} -
     */
    getRoll(reprojectAxis = false) {
        let x = this.x, y = this.y, z = this.z, w = this.w;
        if (reprojectAxis) {
            let fTy = 2.0 * y;
            let fTz = 2.0 * z;
            let fTwz = fTz * w;
            let fTxy = fTy * x;
            let fTyy = fTy * y;
            let fTzz = fTz * z;
            return Math.atan2(fTxy + fTwz, 1.0 - (fTyy + fTzz));
        }
        else {
            return Math.atan2(2 * (x * y + w * z), w * w + x * x - y * y - z * z);
        }
    }
    /**
     * Returns a pitch angle in radians.
     * @public
     * @param {Boolean} [reprojectAxis] -
     * @returns {number} -
     */
    getPitch(reprojectAxis = false) {
        let x = this.x, y = this.y, z = this.z, w = this.w;
        if (reprojectAxis) {
            let fTx = 2.0 * x;
            let fTz = 2.0 * z;
            let fTwx = fTx * w;
            let fTxx = fTx * x;
            let fTyz = fTz * y;
            let fTzz = fTz * z;
            return Math.atan2(fTyz + fTwx, 1.0 - (fTxx + fTzz));
        }
        else {
            return Math.atan2(2 * (y * z + w * x), w * w - x * x - y * y + z * z);
        }
    }
    /**
     * Returns a yaw angle in radians.
     * @public
     * @param {Boolean} [reprojectAxis] -
     * @returns {number} -
     */
    getYaw(reprojectAxis = false) {
        let x = this.x, y = this.y, z = this.z, w = this.w;
        if (reprojectAxis) {
            let fTx = 2.0 * x;
            let fTy = 2.0 * y;
            let fTz = 2.0 * z;
            let fTwy = fTy * w;
            let fTxx = fTx * x;
            let fTxz = fTz * x;
            let fTyy = fTy * y;
            return Math.atan2(fTxz + fTwy, 1.0 - (fTxx + fTyy));
        }
        else {
            return Math.asin(-2 * (x * z - w * y));
        }
    }
}

/**
 * Class represents a 3d vector.
 * @class
 * @param {number} [x] - First value.
 * @param {number} [y] - Second value.
 * @param {number} [z] - Third value.
 */
class Vec3 {
    constructor(x = 0.0, y = 0.0, z = 0.0) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    /** @const */
    static get UP() {
        return new Vec3(0, 1, 0);
    }
    /** @const */
    static get DOWN() {
        return new Vec3(0, -1, 0);
    }
    /** @const */
    static get RIGHT() {
        return new Vec3(1, 0, 0);
    }
    /** @const */
    static get LEFT() {
        return new Vec3(-1, 0, 0);
    }
    /** @const */
    static get FORWARD() {
        return new Vec3(0, 0, -1);
    }
    /** @const */
    static get BACKWARD() {
        return new Vec3(0, 0, 1);
    }
    /** @const */
    static get ZERO() {
        return new Vec3();
    }
    /** @const */
    static get UNIT_X() {
        return new Vec3(1, 0, 0);
    }
    /** @const */
    static get UNIT_Y() {
        return new Vec3(0, 1, 0);
    }
    /** @const */
    static get UNIT_Z() {
        return new Vec3(0, 0, 1);
    }
    /** @const */
    static get NORTH() {
        return Vec3.UNIT_Z;
    }
    /**
     * Separate 63 bit Vec3 to two Vec3 32-bit float values.
     * @function
     * @param {Vec3} v - Double type value.
     * @param {Vec3} high - Out vector high values.
     * @param {Vec3} low - Out vector low values.
     */
    static doubleToTwoFloats(v, high, low) {
        let x = v.x, y = v.y, z = v.z;
        if (x >= 0.0) {
            let doubleHigh = Math.floor(x / 65536.0) * 65536.0;
            high.x = Math.fround(doubleHigh);
            low.x = Math.fround(x - doubleHigh);
        }
        else {
            let doubleHigh = Math.floor(-x / 65536.0) * 65536.0;
            high.x = Math.fround(-doubleHigh);
            low.x = Math.fround(x + doubleHigh);
        }
        if (y >= 0.0) {
            let doubleHigh = Math.floor(y / 65536.0) * 65536.0;
            high.y = Math.fround(doubleHigh);
            low.y = Math.fround(y - doubleHigh);
        }
        else {
            let doubleHigh = Math.floor(-y / 65536.0) * 65536.0;
            high.y = Math.fround(-doubleHigh);
            low.y = Math.fround(y + doubleHigh);
        }
        if (z >= 0.0) {
            let doubleHigh = Math.floor(z / 65536.0) * 65536.0;
            high.z = Math.fround(doubleHigh);
            low.z = Math.fround(z - doubleHigh);
        }
        else {
            let doubleHigh = Math.floor(-z / 65536.0) * 65536.0;
            high.z = Math.fround(-doubleHigh);
            low.z = Math.fround(z + doubleHigh);
        }
    }
    /**
     * Separate 63 bit Vec3 to two Vec3 32-bit float values.
     * @function
     * @param {Vec3} v - Double type value.
     * @param {Float32Array} high - Out vector high values.
     * @param {Float32Array} low - Out vector low values.
     * @returns {Array.<number>} Encoded array. (exactly 2 entries)
     */
    static doubleToTwoFloat32Array(v, high, low) {
        let x = v.x, y = v.y, z = v.z;
        if (x >= 0.0) {
            let doubleHigh = Math.floor(x / 65536.0) * 65536.0;
            high[0] = Math.fround(doubleHigh);
            low[0] = Math.fround(x - doubleHigh);
        }
        else {
            let doubleHigh = Math.floor(-x / 65536.0) * 65536.0;
            high[0] = Math.fround(-doubleHigh);
            low[0] = Math.fround(x + doubleHigh);
        }
        if (y >= 0.0) {
            let doubleHigh = Math.floor(y / 65536.0) * 65536.0;
            high[1] = Math.fround(doubleHigh);
            low[1] = Math.fround(y - doubleHigh);
        }
        else {
            let doubleHigh = Math.floor(-y / 65536.0) * 65536.0;
            high[1] = Math.fround(-doubleHigh);
            low[1] = Math.fround(y + doubleHigh);
        }
        if (z >= 0.0) {
            let doubleHigh = Math.floor(z / 65536.0) * 65536.0;
            high[2] = Math.fround(doubleHigh);
            low[2] = Math.fround(z - doubleHigh);
        }
        else {
            let doubleHigh = Math.floor(-z / 65536.0) * 65536.0;
            high[2] = Math.fround(-doubleHigh);
            low[2] = Math.fround(z + doubleHigh);
        }
    }
    /**
     * Creates 3d vector from array.
     * @function
     * @param {NumberArray2 | NumberArray3 | NumberArray4} arr - Input array (exactly 3 entries)
     * @returns {Vec3} -
     */
    static fromVec(arr) {
        return new Vec3(arr[0], arr[1], arr[2]);
    }
    /**
     * Gets angle between two vectors.
     * @static
     * @param {Vec3} a - First vector.
     * @param {Vec3} b - Second vector.
     * @returns {number} -
     */
    static angle(a, b) {
        return Math.acos(a.dot(b) / Math.sqrt(a.length2() * b.length2()));
    }
    /**
     * Returns two vectors linear interpolation.
     * @static
     * @param {Vec3} v1 - Start vector.
     * @param {Vec3} v2 - End vector.
     * @param {number} l - Interpolate value.
     * @returns {Vec3} -
     */
    static lerp(v1, v2, l) {
        return new Vec3(v1.x + (v2.x - v1.x) * l, v1.y + (v2.y - v1.y) * l, v1.z + (v2.z - v1.z) * l);
    }
    /**
     * Returns summary vector.
     * @static
     * @param {Vec3} a - First vector.
     * @param {Vec3} b - Second vector.
     * @returns {Vec3} - Summary vector.
     */
    static add(a, b) {
        let res = new Vec3(a.x, a.y, a.z);
        res.addA(b);
        return res;
    }
    /**
     * Returns two vectors subtraction.
     * @static
     * @param {Vec3} a - First vector.
     * @param {Vec3} b - Second vector.
     * @returns {Vec3} - Vectors subtraction.
     */
    static sub(a, b) {
        let res = new Vec3(a.x, a.y, a.z);
        res.subA(b);
        return res;
    }
    /**
     * Returns scaled vector.
     * @static
     * @param {Vec3} a - Input vector.
     * @param {number} scale - Scale value.
     * @returns {Vec3} -
     */
    static scale(a, scale) {
        return a.scaleTo(scale);
    }
    /**
     * Returns two vectors production.
     * @static
     * @param {Vec3} a - First vector.
     * @param {Vec3} b - Second vector.
     * @returns {Vec3} -
     */
    static mul(a, b) {
        let res = new Vec3(a.x, a.y, a.z);
        res.mulA(b);
        return res;
    }
    /**
     * Returns true if two vectors are non-collinear.
     * @public
     * @param {Vec3} a - First vector.
     * @param {Vec3} b - Second vector.
     * @returns {Vec3} -
     */
    static noncollinear(a, b) {
        return Boolean(a.y * b.z - a.z * b.y || a.z * b.x - a.x * b.z || a.x * b.y - a.y * b.z);
    }
    /**
     * Get projection of the vector to plane where n - normal to the plane.
     * @static
     * @param {Vec3} b - Vector to project.
     * @param {Vec3} n - Plane normal.
     * @param {Vec3} [def] - Default value for non existed result.
     * @returns {Vec3} -
     */
    static proj_b_to_plane(b, n, def) {
        let res = b.sub(n.scaleTo(n.dot(b) / n.dot(n)));
        if (def && res.isZero()) {
            return new Vec3(def.x, def.y, def.z);
        }
        return res;
    }
    /**
     * Get projection of the first vector to the second.
     * @static
     * @param {Vec3} b - First vector.
     * @param {Vec3} a - Second vector.
     * @returns {Vec3} -
     */
    static proj_b_to_a(b, a) {
        return a.scaleTo(a.dot(b) / a.dot(a));
    }
    /**
     * Makes vectors normalized and orthogonal to each other.
     * Normalizes normal. Normalizes tangent and makes sure it is orthogonal to normal (that is, angle between them is 90 degrees).
     * @static
     * @param {Vec3} normal - Normal vector.
     * @param {Vec3} tangent - Tangent vector.
     * @returns {Vec3} -
     */
    static orthoNormalize(normal, tangent) {
        normal = normal.getNormal();
        normal.scale(tangent.dot(normal));
        return tangent.subA(normal).normalize();
    }
    /**
     * Returns vector components division product one to another.
     * @static
     * @param {Vec3} a - First vector.
     * @param {Vec3} b - Second vector.
     * @returns {Vec3} -
     */
    static div(a, b) {
        let res = new Vec3(a.x, a.y, a.z);
        res.divA(b);
        return res;
    }
    static length2(a) {
        return a.length2();
    }
    // static length(a: Vec3): number {
    //     return a.length();
    // }
    static dot(a, b) {
        return a.dot(b);
    }
    /**
     * Converts to 4d vector, Fourth value is 1.0.
     * @public
     * @returns {Vec4} -
     */
    toVec4() {
        return new Vec4(this.x, this.y, this.z, 1.0);
    }
    /**
     * Returns clone vector.
     * @public
     * @returns {Vec3} -
     */
    clone() {
        return new Vec3(this.x, this.y, this.z);
    }
    /**
     * Converts vector to text string.
     * @public
     * @returns {string} -
     */
    toString() {
        return `(${this.x},${this.y},${this.z})`;
    }
    /**
     * Returns true if vector's values are zero.
     * @public
     * @returns {boolean} -
     */
    isZero() {
        return !(this.x || this.y || this.z);
    }
    /**
     * Get projection of the first vector to the second.
     * @static
     * @param {Vec3} a - Project vector.
     * @returns {Vec3} -
     */
    projToVec(a) {
        return a.scaleTo(a.dot(this) / a.dot(a));
    }
    /**
     * Compares with vector. Returns true if it equals another.
     * @public
     * @param {Vec3} p - Vector to compare.
     * @returns {boolean} -
     */
    equal(p) {
        return this.x === p.x && this.y === p.y && this.z === p.z;
    }
    /**
     * Copy input vector's values.
     * @param {Vec3} p - Vector to copy.
     * @returns {Vec3} -
     */
    copy(p) {
        this.x = p.x;
        this.y = p.y;
        this.z = p.z;
        return this;
    }
    /**
     * Gets vector's length.
     * @public
     * @returns {number} -
     */
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    /**
     * Returns squared vector's length.
     * @public
     * @returns {number} -
     */
    length2() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    /**
     * Converts vector's values to a quaternion object.
     * @public
     * @returns {Quat} -
     */
    getQuat() {
        return new Quat(this.x, this.y, this.z);
    }
    /**
     * Adds vector to the current.
     * @public
     * @param {Vec3} p - Point to add.
     * @returns {Vec3} -
     */
    addA(p) {
        this.x += p.x;
        this.y += p.y;
        this.z += p.z;
        return this;
    }
    /**
     * Gets two vectors summarization.
     * @public
     * @param {Vec3} p - Vector to add.
     * @returns {Vec3} Returns a sum vector.
     */
    add(p) {
        return new Vec3(this.x + p.x, this.y + p.y, this.z + p.z);
    }
    /**
     * Subtract vector from the current.
     * @public
     * @param {Vec3} p - Subtract vector.
     * @returns {Vec3} -
     */
    subA(p) {
        this.x -= p.x;
        this.y -= p.y;
        this.z -= p.z;
        return this;
    }
    /**
     * Gets vector subtraction.
     * @public
     * @param {Vec3} p - Subtract vector.
     * @return {Vec3} Returns new instance of a subtraction
     */
    sub(p) {
        return new Vec3(this.x - p.x, this.y - p.y, this.z - p.z);
    }
    /**
     * Scale current vector.
     * @public
     * @param {number} scale - Scale value.
     * @returns {Vec3} -
     */
    scale(scale) {
        this.x *= scale;
        this.y *= scale;
        this.z *= scale;
        return this;
    }
    /**
     * Scale current vector to another instance.
     * @public
     * @param {number} scale - Scale value.
     * @returns {Vec3} -
     */
    scaleTo(scale) {
        return new Vec3(this.x * scale, this.y * scale, this.z * scale);
    }
    /**
     * Multiply current vector object to another and store result in the current instance.
     * @public
     * @param {Vec3} vec - Multiply vector.
     * @returns {Vec3} -
     */
    mulA(vec) {
        this.x *= vec.x;
        this.y *= vec.y;
        this.z *= vec.z;
        return this;
    }
    /**
     * Multiply current vector object to another and returns new vector instance.
     * @public
     * @param {Vec3} vec - Multiply vector.
     * @returns {Vec3} -
     */
    mul(vec) {
        return new Vec3(this.x * vec.x, this.y * vec.y, this.z * vec.z);
    }
    /**
     * Divide current vector's components to another. Results stores in the current vector object.
     * @public
     * @param {Vec3} vec - Div vector.
     * @returns {Vec3} -
     */
    divA(vec) {
        this.x /= vec.x;
        this.y /= vec.y;
        this.z /= vec.z;
        return this;
    }
    /**
     * Divide current vector's components to another and returns new vector instance.
     * @public
     * @param {Vec3} vec - Div vector.
     * @returns {Vec3} -
     */
    div(vec) {
        return new Vec3(this.x / vec.x, this.y / vec.y, this.z / vec.z);
    }
    /**
     * Gets vectors dot production.
     * @public
     * @param {Vec3} a - Another vector.
     * @returns {number} -
     */
    dot(a) {
        return a.x * this.x + a.y * this.y + a.z * this.z;
    }
    /**
     * Gets vectors dot production.
     * @public
     * @param {Array.<number>} arr - Array vector. (exactly 3 entries)
     * @returns {number} -
     */
    dotArr(arr) {
        return arr[0] * this.x + arr[1] * this.y + arr[2] * this.z;
    }
    /**
     * Gets vectors cross production.
     * @public
     * @param {Vec3} point3 - Another vector.
     * @returns {Vec3} -
     */
    cross(point3) {
        return new Vec3(this.y * point3.z - this.z * point3.y, this.z * point3.x - this.x * point3.z, this.x * point3.y - this.y * point3.x);
    }
    /**
     * Sets vector to zero.
     * @public
     * @returns {Vec3} -
     */
    clear() {
        this.x = this.y = this.z = 0;
        return this;
    }
    /**
     * Returns normalized vector.
     * @public
     * @returns {Vec3} -
     */
    getNormal() {
        let res = new Vec3();
        res.copy(this);
        let length = 1.0 / res.length();
        res.x *= length;
        res.y *= length;
        res.z *= length;
        return res;
    }
    /**
     * Returns normalized vector.
     * @deprecated
     * @public
     * @returns {Vec3} -
     */
    normal() {
        let res = new Vec3();
        res.copy(this);
        let length = 1.0 / res.length();
        res.x *= length;
        res.y *= length;
        res.z *= length;
        return res;
    }
    /**
     * Returns normalized negate vector.
     * @public
     * @returns {Vec3} -
     */
    normalNegate() {
        let res = new Vec3();
        res.copy(this);
        let length = -1.0 / res.length();
        res.x *= length;
        res.y *= length;
        res.z *= length;
        return res;
    }
    /**
     * Returns normalized negate scale vector.
     * @public
     * @returns {Vec3} -
     */
    normalNegateScale(scale) {
        let res = new Vec3();
        res.copy(this);
        let length = -scale / res.length();
        res.x *= length;
        res.y *= length;
        res.z *= length;
        return res;
    }
    /**
     * Returns normalized scale vector.
     * @public
     * @returns {Vec3} -
     */
    normalScale(scale) {
        let res = new Vec3();
        res.copy(this);
        let length = scale / res.length();
        res.x *= length;
        res.y *= length;
        res.z *= length;
        return res;
    }
    /**
     * Normalize current vector.
     * @public
     * @returns {Vec3} -
     */
    normalize() {
        let length = 1.0 / this.length();
        this.x *= length;
        this.y *= length;
        this.z *= length;
        return this;
    }
    /**
     * Converts vector to a number array.
     * @public
     * @returns {Array.<number>} - (exactly 3 entries)
     * @deprecated
     */
    toVec() {
        return [this.x, this.y, this.z];
    }
    /**
     * Converts vector to a number array.
     * @public
     * @returns {Array.<number>} - (exactly 3 entries)
     */
    toArray() {
        return [this.x, this.y, this.z];
    }
    /**
     * Gets distance to point.
     * @public
     * @param {Vec3} p - Distant point.
     * @returns {number} -
     */
    distance(p) {
        let dx = this.x - p.x, dy = this.y - p.y, dz = this.z - p.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    /**
     * Gets square distance to point.
     * @public
     * @param {Vec3} p - Distant point.
     * @returns {number} -
     */
    distance2(p) {
        let dx = this.x - p.x, dy = this.y - p.y, dz = this.z - p.z;
        return dx * dx + dy * dy + dz * dz;
    }
    /**
     * Sets vector's values.
     * @public
     * @param {number} x - Value X.
     * @param {number} y - Value Y.
     * @param {number} z - Value Z.
     * @returns {Vec3} -
     */
    set(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }
    /**
     * Negate current vector.
     * @public
     * @returns {Vec3} -
     */
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    }
    /**
     * Negate current vector to another instance.
     * @public
     * @returns {Vec3} -
     */
    negateTo() {
        return new Vec3(-this.x, -this.y, -this.z);
    }
    /**
     * Gets projected point coordinates of the current vector on the ray.
     * @public
     * @param {Vec3} pos - Ray position.
     * @param {Vec3} direction - Ray direction.
     * @returns {Vec3} -
     */
    projToRay(pos, direction) {
        let v = Vec3.proj_b_to_a(Vec3.sub(this, pos), direction);
        v.addA(pos);
        return v;
    }
    /**
     * Gets angle between two vectors.
     * @public
     * @param {Vec3} a - Another vector.
     * @returns {number} -
     */
    angle(a) {
        return Vec3.angle(this, a);
    }
    /**
     * Returns two vectors linear interpolation.
     * @public
     * @param {Vec3} v2 - End vector.
     * @param {number} l - Interpolate value.
     * @returns {Vec3} -
     */
    lerp(v2, l) {
        return new Vec3(this.x + (v2.x - this.x) * l, this.y + (v2.y - this.y) * l, this.z + (v2.z - this.z) * l);
    }
    /**
     * Returns vector interpolation by v(t) = v1 * t + v2 * (1 - t)
     * @public
     * @param {Vec3} v2 - End vector.
     * @param {number} t - Interpolate value.
     * @returns {Vec3} -
     */
    smerp(v2, t) {
        let one_d = 1 - t;
        return new Vec3(this.x * t + v2.x * one_d, this.y * t + v2.y * one_d, this.z * t + v2.z * one_d);
    }
    static get LERP_DELTA() {
        return 1e-6;
    }
    /**
     * Spherically interpolates between two vectors.
     * Interpolates between current and v2 vector by amount t. The difference between this and linear interpolation (aka, "lerp") is that
     * the vectors are treated as directions rather than points in space. The direction of the returned vector is interpolated
     * by the angle and its magnitude is interpolated between the magnitudes of from and to.
     * @public
     * @param {Vec3} v2 -
     * @param {number} t - The parameter t is clamped to the range [0, 1].
     * @returns {Vec3} -
     */
    slerp(v2, t) {
        let res = new Vec3();
        if (t <= 0.0) {
            res.copy(this);
            return res;
        }
        else if (t >= 1.0) {
            res.copy(v2);
            return res;
        }
        let omega, sinom, scale0, scale1;
        let cosom = this.dot(v2);
        if (1.0 - cosom > Vec3.LERP_DELTA) {
            omega = Math.acos(cosom);
            sinom = Math.sin(omega);
            scale0 = Math.sin((1.0 - t) * omega) / sinom;
            scale1 = Math.sin(t * omega) / sinom;
        }
        else {
            scale0 = 1.0 - t;
            scale1 = t;
        }
        return Vec3.add(this.scaleTo(scale0), v2.scale(scale1));
    }
    /**
     * Gets the shortest arc quaternion to rotate this vector to the destination vector.
     * @param {Vec3} dest -
     * @param {Vec3} fallbackAxis -
     * @returns {Quat} -
     * @todo: TEST IT!
     */
    getRotationTo(dest, fallbackAxis) {
        // Based on Stan Melax's article in Game Programming Gems
        // Copy, since cannot modify local
        let v0 = this.clone();
        let v1 = dest.clone();
        v0.normalize();
        v1.normalize();
        let d = v0.dot(v1);
        // If dot == 1, vectors are the same
        if (d >= 1.0) {
            return Quat.IDENTITY.clone();
        }
        if (d < 1e-6 - 1.0) {
            if (!fallbackAxis.equal(Vec3.ZERO)) {
                // rotate 180 degrees about the fallback axis
                return Quat.axisAngleToQuat(fallbackAxis, Math.PI);
            }
            else {
                // Generate an axis
                let axis = Vec3.UNIT_X.cross(v0);
                if (axis.isZero()) {
                    // pick another if colinear
                    axis = Vec3.UNIT_Y.cross(v0);
                }
                axis.normalize();
                return Quat.axisAngleToQuat(axis, Math.PI);
            }
        }
        else {
            let s = Math.sqrt((1 + d) * 2);
            let invs = 1.0 / s;
            let c = v0.cross(v1);
            let q = new Quat(c.x * invs, c.y * invs, c.z * invs, s * 0.5);
            q.normalize();
            return q;
        }
    }
}

/**
 * Class represents a 3d vector.
 * @class
 * @param {number} [x] - First value.
 * @param {number} [y] - Second value.
 */
class Vec2 {
    constructor(x = 0.0, y = 0.0) {
        this.x = x;
        this.y = y;
    }
    /** @const */
    static get UP() {
        return new Vec2(0, 1);
    }
    /** @const */
    static get DOWN() {
        return new Vec2(0, -1);
    }
    /** @const */
    static get RIGHT() {
        return new Vec2(1, 0);
    }
    /** @const */
    static get LEFT() {
        return new Vec2(-1, 0);
    }
    /** @const */
    static get ZERO() {
        return new Vec2();
    }
    /**
     * Returns summary vector.
     * @static
     * @param {Vec2} a - First vector.
     * @param {Vec2} b - Second vector.
     * @returns {Vec2} - Summary vector.
     */
    static add(a, b) {
        const res = new Vec2(a.x, a.y);
        res.addA(b);
        return res;
    }
    /**
     * Returns two vectors subtraction.
     * @static
     * @param {Vec2} a - First vector.
     * @param {Vec2} b - Second vector.
     * @returns {Vec2} - Vectors subtraction.
     */
    static sub(a, b) {
        var res = new Vec2(a.x, a.y);
        res.subA(b);
        return res;
    }
    /**
     * Returns scaled vector.
     * @static
     * @param {Vec2} a - Input vector.
     * @param {number} scale - Scale value.
     * @returns {Vec2}
     */
    static scale(a, scale) {
        let res = new Vec2(a.x, a.y);
        res.scale(scale);
        return res;
    }
    /**
     * Returns two vectors production.
     * @static
     * @param {Vec2} a - First vector.
     * @param {Vec2} b - Second vector.
     * @returns {Vec2}
     */
    static mul(a, b) {
        let res = new Vec2(a.x, a.y);
        res.mulA(b);
        return res;
    }
    /**
     * Returns vector components division product one to another.
     * @static
     * @param {Vec2} a - First vector.
     * @param {Vec2} b - Second vector.
     * @returns {Vec2}
     */
    static div(a, b) {
        let res = new Vec2(a.x, a.y);
        res.divA(b);
        return res;
    }
    /**
     * Get projection of the first vector to the second.
     * @static
     * @param {Vec2} b - First vector.
     * @param {Vec2} a - Second vector.
     * @returns {Vec2}
     */
    static proj_b_to_a(b, a) {
        return a.scaleTo(a.dot(b) / a.dot(a));
    }
    /**
     * Gets angle between two vectors.
     * @static
     * @param {Vec2} a - First vector.
     * @param {Vec2} b - Second vector.
     * @returns {number}
     */
    static angle(a, b) {
        return Math.acos(a.dot(b) / Math.sqrt(a.length2() * b.length2()));
    }
    /**
     * Makes vectors normalized and orthogonal to each other.
     * @static
     * @param {Vec2} normal - Normal vector.
     * @param {Vec2} tangent - Tangent vector.
     * @returns {Vec2}
     */
    static orthoNormalize(normal, tangent) {
        normal = normal.normal();
        normal.scale(tangent.dot(normal));
        return tangent.sub(normal).normalize();
    }
    /**
     * Converts to 3d vector, third value is 0.0.
     * @public
     * @returns {Vec3}
     */
    toVector3() {
        return new Vec3(this.x, this.y, 0);
    }
    /**
     * Returns clone vector.
     * @public
     * @returns {Vec2}
     */
    clone() {
        return new Vec2(this.x, this.y);
    }
    /**
     * Compares with vector. Returns true if it equals another.
     * @public
     * @param {Vec2} p - Vector to compare.
     * @returns {boolean}
     */
    equal(p) {
        return this.x === p.x && this.y === p.y;
    }
    /**
     * Copy input vector's values.
     * @param {Vec2} point2 - Vector to copy.
     * @returns {Vec2}
     */
    copy(point2) {
        this.x = point2.x;
        this.y = point2.y;
        return this;
    }
    /**
     * Gets vector's length.
     * @public
     * @returns {number}
     */
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    /**
     * Returns squared vector's length.
     * @public
     * @returns {number}
     */
    length2() {
        return this.x * this.x + this.y * this.y;
    }
    /**
     * Adds vector to the current.
     * @public
     * @param {Vec2}
     * @returns {Vec2}
     */
    addA(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    /**
     * Summarize two vectors.
     * @public
     * @param {Vec2}
     * @returns {Vec2}
     */
    add(v) {
        return new Vec2(this.x + v.x, this.y + v.y);
    }
    /**
     * Subtract vector from the current where results saved on the current instance.
     * @public
     * @param {Vec2} v - Subtract vector.
     * @returns {Vec2}
     */
    subA(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
    /**
     * Subtract vector from the current.
     * @public
     * @param {Vec2} v - Subtract vector.
     * @returns {Vec2}
     */
    sub(v) {
        return new Vec2(this.x - v.x, this.y - v.y);
    }
    /**
     * Scale current vector.
     * @public
     * @param {number} scale - Scale value.
     * @returns {Vec2}
     */
    scale(scale) {
        this.x *= scale;
        this.y *= scale;
        return this;
    }
    /**
     * Scale current vector to another instance.
     * @public
     * @param {number} scale - Scale value.
     * @returns {Vec2}
     */
    scaleTo(scale) {
        return new Vec2(this.x * scale, this.y * scale);
    }
    /**
     * Multiply current vector object to another and store result in the current instance.
     * @public
     * @param {Vec2} vec - Multiply vector.
     * @returns {Vec2}
     */
    mulA(vec) {
        this.x *= vec.x;
        this.y *= vec.y;
        return this;
    }
    /**
     * Multiply current vector object to another and returns new vector instance.
     * @public
     * @param {Vec2} vec - Multiply vector.
     * @returns {Vec2}
     */
    mul(vec) {
        return new Vec2(this.x * vec.x, this.y * vec.y);
    }
    /**
     * Divide current vector's components to another. Results stores in the current vector object.
     * @public
     * @param {Vec2}
     * @returns {Vec2}
     */
    divA(vec) {
        this.x /= vec.x;
        this.y /= vec.y;
        return this;
    }
    /**
     * Gets vectors dot production.
     * @public
     * @param {Vec2} v - Another vector.
     * @returns {number}
     */
    dot(v) {
        return v.x * this.x + v.y * this.y;
    }
    /**
     * Gets vectors dot production.
     * @public
     * @param {Array.<number>} arr - Array vector. (exactly 2 entries)
     * @returns {number}
     */
    dotArr(arr) {
        return arr[0] * this.x + arr[1] * this.y;
    }
    /**
     * Gets vectors cross production.
     * @public
     * @param {Vec2} v - Another vector.
     * @returns {number}
     */
    cross(v) {
        return this.x * v.y - this.y * v.x;
    }
    /**
     * Sets vector to zero.
     * @public
     * @returns {Vec2}
     */
    clear() {
        this.x = this.y = 0;
        return this;
    }
    /**
     * Returns normalized vector.
     * @public
     * @returns {Vec2}
     */
    normal() {
        let res = new Vec2();
        res.copy(this);
        let length = 1.0 / res.length();
        res.x *= length;
        res.y *= length;
        return res;
    }
    /**
     * Normalize current vector.
     * @public
     * @returns {Vec2}
     */
    normalize() {
        let length = 1.0 / this.length();
        this.x *= length;
        this.y *= length;
        return this;
    }
    /**
     * Converts vector to a number array.
     * @public
     * @returns {Array.<number>} - (exactly 2 entries)
     */
    toVec() {
        return [this.x, this.y];
    }
    /**
     * Gets distance to point.
     * @public
     * @param {Vec2} p - Distant point.
     * @returns {number}
     */
    distance(p) {
        let vec = Vec2.sub(this, p);
        return vec.length();
    }
    /**
     * Sets vector's values.
     * @public
     * @param {number} x - Value X.
     * @param {number} y - Value Y.
     * @returns {Vec2}
     */
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    /**
     * Negate current vector.
     * @public
     * @returns {Vec2}
     */
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    }
    /**
     * Negate current vector to another instance.
     * @public
     * @returns {Vec2}
     */
    negateTo() {
        return new Vec2(-this.x, -this.y);
    }
    /**
     * Gets projected point coordinates of the current vector on the ray.
     * @public
     * @param {Vec2} pos - Ray position.
     * @param {Vec2} direction - Ray direction.
     * @returns {Vec2}
     */
    projToRay(pos, direction) {
        let v = Vec2.proj_b_to_a(Vec2.sub(this, pos), direction);
        v.add(pos);
        return v;
    }
    /**
     * Gets angle between two vectors.
     * @public
     * @param {Vec2} a - Another vector.
     * @returns {number}
     */
    angle(a) {
        return Vec2.angle(this, a);
    }
    /**
     * Returns two vectors linear interpolation.
     * @public
     * @param {Vec2} v2 - End vector.
     * @param {number} l - Interpolate value.
     * @returns {Vec2}
     */
    lerp(v1, v2, l) {
        let res = this.clone();
        if (l <= 0.0) {
            res.copy(v1);
        }
        else if (l >= 1.0) {
            res.copy(v2);
        }
        else {
            res = Vec2.add(v1, Vec2.sub(v2, v1).scale(l));
        }
        return res;
    }
    static get LERP_DELTA() {
        return 1e-6;
    }
    /**
     * Spherically interpolates between two vectors.
     * Interpolates between current and v2 vector by amount t. The difference between this and linear interpolation (aka, "lerp") is that
     * the vectors are treated as directions rather than points in space. The direction of the returned vector is interpolated
     * by the angle and its magnitude is interpolated between the magnitudes of from and to.
     * @public
     * @param {Vec2} v2
     * @param {number} t - The parameter t is clamped to the range [0, 1].
     * @returns {Vec2}
     */
    slerp(v2, t) {
        let res = new Vec2();
        if (t <= 0.0) {
            res.copy(this);
            return res;
        }
        else if (t >= 1.0) {
            res.copy(v2);
            return res;
        }
        let omega, sinom, scale0, scale1;
        let cosom = this.dot(v2);
        if (1.0 - cosom > Vec2.LERP_DELTA) {
            omega = Math.acos(cosom);
            sinom = Math.sin(omega);
            scale0 = Math.sin((1.0 - t) * omega) / sinom;
            scale1 = Math.sin(t * omega) / sinom;
        }
        else {
            scale0 = 1.0 - t;
            scale1 = t;
        }
        return Vec2.add(this.scale(scale0), v2.scale(scale1));
    }
}

const colorTable = {
    "aliceblue": "#f0f8ff",
    "antiquewhite": "#faebd7",
    "aqua": "#00ffff",
    "aquamarine": "#7fffd4",
    "azure": "#f0ffff",
    "beige": "#f5f5dc",
    "bisque": "#ffe4c4",
    "black": "#000000",
    "blanchedalmond": "#ffebcd",
    "blue": "#0000ff",
    "blueviolet": "#8a2be2",
    "brown": "#a52a2a",
    "burlywood": "#deb887",
    "cadetblue": "#5f9ea0",
    "chartreuse": "#7fff00",
    "chocolate": "#d2691e",
    "coral": "#ff7f50",
    "cornflowerblue": "#6495ed",
    "cornsilk": "#fff8dc",
    "crimson": "#dc143c",
    "cyan": "#00ffff",
    "darkblue": "#00008b",
    "darkcyan": "#008b8b",
    "darkgoldenrod": "#b8860b",
    "darkgray": "#a9a9a9",
    "darkgreen": "#006400",
    "darkkhaki": "#bdb76b",
    "darkmagenta": "#8b008b",
    "darkolivegreen": "#556b2f",
    "darkorange": "#ff8c00",
    "darkorchid": "#9932cc",
    "darkred": "#8b0000",
    "darksalmon": "#e9967a",
    "darkseagreen": "#8fbc8f",
    "darkslateblue": "#483d8b",
    "darkslategray": "#2f4f4f",
    "darkturquoise": "#00ced1",
    "darkviolet": "#9400d3",
    "deeppink": "#ff1493",
    "deepskyblue": "#00bfff",
    "dimgray": "#696969",
    "dodgerblue": "#1e90ff",
    "firebrick": "#b22222",
    "floralwhite": "#fffaf0",
    "forestgreen": "#228b22",
    "fuchsia": "#ff00ff",
    "gainsboro": "#dcdcdc",
    "ghostwhite": "#f8f8ff",
    "gold": "#ffd700",
    "goldenrod": "#daa520",
    "gray": "#808080",
    "green": "#008000",
    "greenyellow": "#adff2f",
    "honeydew": "#f0fff0",
    "hotpink": "#ff69b4",
    "indianred ": "#cd5c5c",
    "indigo": "#4b0082",
    "ivory": "#fffff0",
    "khaki": "#f0e68c",
    "lavender": "#e6e6fa",
    "lavenderblush": "#fff0f5",
    "lawngreen": "#7cfc00",
    "lemonchiffon": "#fffacd",
    "lightblue": "#add8e6",
    "lightcoral": "#f08080",
    "lightcyan": "#e0ffff",
    "lightgoldenrodyellow": "#fafad2",
    "lightgrey": "#d3d3d3",
    "lightgreen": "#90ee90",
    "lightpink": "#ffb6c1",
    "lightsalmon": "#ffa07a",
    "lightseagreen": "#20b2aa",
    "lightskyblue": "#87cefa",
    "lightslategray": "#778899",
    "lightsteelblue": "#b0c4de",
    "lightyellow": "#ffffe0",
    "lime": "#00ff00",
    "limegreen": "#32cd32",
    "linen": "#faf0e6",
    "magenta": "#ff00ff",
    "maroon": "#800000",
    "mediumaquamarine": "#66cdaa",
    "mediumblue": "#0000cd",
    "mediumorchid": "#ba55d3",
    "mediumpurple": "#9370d8",
    "mediumseagreen": "#3cb371",
    "mediumslateblue": "#7b68ee",
    "mediumspringgreen": "#00fa9a",
    "mediumturquoise": "#48d1cc",
    "mediumvioletred": "#c71585",
    "midnightblue": "#191970",
    "mintcream": "#f5fffa",
    "mistyrose": "#ffe4e1",
    "moccasin": "#ffe4b5",
    "navajowhite": "#ffdead",
    "navy": "#000080",
    "oldlace": "#fdf5e6",
    "olive": "#808000",
    "olivedrab": "#6b8e23",
    "orange": "#ffa500",
    "orangered": "#ff4500",
    "orchid": "#da70d6",
    "palegoldenrod": "#eee8aa",
    "palegreen": "#98fb98",
    "paleturquoise": "#afeeee",
    "palevioletred": "#d87093",
    "papayawhip": "#ffefd5",
    "peachpuff": "#ffdab9",
    "peru": "#cd853f",
    "pink": "#ffc0cb",
    "plum": "#dda0dd",
    "powderblue": "#b0e0e6",
    "purple": "#800080",
    "rebeccapurple": "#663399",
    "red": "#ff0000",
    "rosybrown": "#bc8f8f",
    "royalblue": "#4169e1",
    "saddlebrown": "#8b4513",
    "salmon": "#fa8072",
    "sandybrown": "#f4a460",
    "seagreen": "#2e8b57",
    "seashell": "#fff5ee",
    "sienna": "#a0522d",
    "silver": "#c0c0c0",
    "skyblue": "#87ceeb",
    "slateblue": "#6a5acd",
    "slategray": "#708090",
    "snow": "#fffafa",
    "springgreen": "#00ff7f",
    "steelblue": "#4682b4",
    "tan": "#d2b48c",
    "teal": "#008080",
    "thistle": "#d8bfd8",
    "tomato": "#ff6347",
    "turquoise": "#40e0d0",
    "violet": "#ee82ee",
    "wheat": "#f5deb3",
    "white": "#ffffff",
    "whitesmoke": "#f5f5f5",
    "yellow": "#ffff00",
    "yellowgreen": "#9acd32"
};

/**
 * @module og/utils/shared
 */
function getDefault(param, def) {
    return param != undefined ? param : def;
}
function isEmpty(v) {
    return v == null;
}
/**
 * Returns true if the object pointer is undefined.
 * @function
 * @param {Object} obj - Object pointer.
 * @returns {boolean} Returns true if object is undefined.
 */
function isUndef(obj) {
    return obj === void 0;
}
function isUndefExt(obj, defVal) {
    return isUndef(obj) ? defVal : obj;
}
let _stampCounter = 0;
function stamp(obj) {
    let stamp = obj._openglobus_id;
    if (!stamp) {
        stamp = obj._openglobus_id = ++_stampCounter;
    }
    return stamp;
}
function isString(s) {
    return typeof s === "string" || s instanceof String;
}
function d2h(val) {
    return val.toString(16).padStart(2, '0');
}
function rgbToStringHTML(rgb) {
    let r, g, b;
    if (rgb instanceof Array) {
        r = d2h(rgb[0]);
        g = d2h(rgb[1]);
        b = d2h(rgb[2]);
    }
    else {
        r = d2h(rgb.x);
        g = d2h(rgb.y);
        b = d2h(rgb.z);
    }
    return `#${r}${g}${b}`;
}
/**
 * Convert html color string to the RGBA number vector.
 * @param {string} htmlColor - HTML string("#C6C6C6" or "#EF5" or "rgb(8,8,8)" or "rgba(8,8,8)") color.
 * @param {number} [opacity] - Opacity for the output vector.
 * @returns {Vec4} -
 */
function htmlColorToRgba(htmlColor, opacity) {
    let hColor = colorTable[htmlColor];
    if (hColor) {
        htmlColor = hColor;
    }
    if (htmlColor[0] === "#") {
        let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        let hex = htmlColor.replace(shorthandRegex, function (m, r, g, b) {
            return r + r + g + g + b + b;
        });
        let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (result) {
            return new Vec4(parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255, isEmpty(opacity) ? 1.0 : opacity);
        }
        else {
            return new Vec4();
        }
    }
    else {
        if (isEmpty(opacity)) {
            opacity = 1.0;
        }
        let m = htmlColor.split(",");
        return new Vec4(parseInt(m[0].split("(")[1]) / 255, parseInt(m[1]) / 255, parseInt(m[2]) / 255, !isEmpty(m[3]) ? parseFloat(m[3]) : opacity);
    }
}
function htmlColorToFloat32Array(htmlColor, opacity) {
    let c = htmlColorToRgba(htmlColor, opacity);
    return new Float32Array([c.x, c.y, c.z, c.w]);
}
/**
 * Convert html color string to the RGB number vector.
 * @param {string} htmlColor - HTML string("#C6C6C6" or "#EF5" or "rgb(8,8,8)" or "rgba(8,8,8)") color.
 * @returns {Vec3} -
 */
function htmlColorToRgb(htmlColor) {
    let hColor = colorTable[htmlColor];
    if (hColor) {
        htmlColor = hColor;
    }
    if (htmlColor[0] === "#") {
        let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        let hex = htmlColor.replace(shorthandRegex, function (m, r, g, b) {
            return r + r + g + g + b + b;
        });
        let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (result) {
            return new Vec3(parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255);
        }
        else {
            return new Vec3();
        }
    }
    else {
        let m = htmlColor.split(",");
        return new Vec3(parseInt(m[0].split("(")[1]) / 255, parseInt(m[1]) / 255, parseInt(m[2]) / 255);
    }
}
/**
 * Replace template substrings between '{' and '}' tokens.
 * @param {string} template - String with templates in "{" and "}"
 * @param {Object} params - Template named object with subsrtings.
 * @returns {string} -
 *
 * @example <caption>Example from og.terrain that replaces tile indexes in url:</caption>
 * var substrings = {
 *       "x": 12,
 *       "y": 15,
 *       "z": 8
 * }
 * og.utils.stringTemplate("http://earth3.openglobus.org/{z}/{y}/{x}.ddm", substrings);
 * //returns http://earth3.openglobus.org/8/15/12.ddm
 */
function stringTemplate(template, params) {
    return template.replace(/{[^{}]+}/g, function (key) {
        return params[key.replace(/[{}]+/g, "")] || "";
    });
}
function getHTML(template, params) {
    return stringTemplate(template, params);
}
function parseHTML(htmlStr) {
    let p = document.createElement("div");
    p.innerHTML = htmlStr;
    let domArr = [];
    for (let i = 0; i < p.childNodes.length; i++) {
        domArr.push(p.childNodes[i]);
        p.removeChild(p.childNodes[i]);
    }
    return domArr;
}
function print2d(id, text, x, y) {
    let el = document.getElementById(id);
    if (!el) {
        el = document.createElement("div");
        el.id = id;
        el.classList.add("defaultText");
        document.body.appendChild(el);
    }
    el.innerHTML = text;
    el.style.left = `${x}px`;
    el.style.top = `${y}px`;
}
function isNumber(value) {
    return typeof value === 'number';
}
function defaultString(str, def = "") {
    return str ? str.trim() : def;
}
function createVector3(v, def) {
    if (v) {
        if (isNumber(v)) {
            return new Vec3(v, v, v);
        }
        else if (v instanceof Vec3) {
            return v.clone();
        }
        else if (v instanceof Array) {
            return Vec3.fromVec(v);
        }
        else if (v instanceof Vec2) {
            return new Vec3(v.x, v.y, 0.0);
        }
    }
    else if (def) {
        return def;
    }
    return new Vec3();
}
function createVector4(v, def) {
    if (v) {
        if (v instanceof Vec4) {
            return v.clone();
        }
        else if (v instanceof Array) {
            return Vec4.fromVec(v);
        }
    }
    else if (def) {
        return def;
    }
    return new Vec4();
}
function createColorRGBA(c, def) {
    if (c) {
        if (isString(c)) {
            return htmlColorToRgba(c);
        }
        else if (c instanceof Array) {
            return Vec4.fromVec(c);
        }
        else if (c instanceof Vec4) {
            return c.clone();
        }
    }
    else if (def) {
        return def;
    }
    return new Vec4(1.0, 1.0, 1.0, 1.0);
}
function createColorRGB(c, def) {
    if (c) {
        if (isString(c)) {
            return htmlColorToRgb(c);
        }
        else if (c instanceof Array) {
            return Vec3.fromVec(c);
        }
        else if (c instanceof Vec3) {
            return c.clone();
        }
    }
    else if (def) {
        return def;
    }
    return new Vec3(1.0, 1.0, 1.0);
}
function createExtent(e, def) {
    if (e) {
        if (e instanceof Array) {
            return new Extent(createLonLat(e[0]), createLonLat(e[1]));
        }
        else if (e instanceof Extent) {
            return e.clone();
        }
    }
    else if (def) {
        return def;
    }
    return new Extent();
}
function createLonLat(l, def) {
    if (l) {
        if (l instanceof Array) {
            return new LonLat(l[0], l[1], l[2]);
        }
        else if (l instanceof LonLat) {
            return l.clone();
        }
    }
    else if (def) {
        return def;
    }
    return new LonLat();
}
function binarySearchFast(arr, x) {
    let start = 0, end = arr.length - 1;
    while (start <= end) {
        let k = Math.floor((start + end) * 0.5);
        if (Math.abs(arr[k] - x) < 1e-3) {
            return k;
        }
        else if (arr[k] < x) {
            start = k + 1;
        }
        else {
            end = k - 1;
        }
    }
    return -1;
}
/**
 * Finds an item in a sorted array.
 * @param {any[]} ar The sorted array to search.
 * @param {any} el The item to find in the array.
 * @param {Function} compare_fn comparator The function to use to compare the item to
 *        elements in the array.
 * @returns {number} a negative number  if 'a' is less than 'b'; 0 if 'a' is equal to 'b'; 'a' positive number of 'a' is greater than 'b'.
 *
 * @example
 * // Create a comparator function to search through an array of numbers.
 * function comparator(a, b) {
 *     return a - b;
 * };
 * var numbers = [0, 2, 4, 6, 8];
 * var index = og.utils.binarySearch(numbers, 6, comparator); // 3
 */
function binarySearch(ar, el, compare_fn) {
    let m = 0;
    let n = ar.length - 1;
    while (m <= n) {
        let k = (n + m) >> 1;
        let cmp = compare_fn(el, ar[k], k);
        if (cmp > 0) {
            m = k + 1;
        }
        else if (cmp < 0) {
            n = k - 1;
        }
        else {
            return k;
        }
    }
    return -m - 1;
}
/**
 * @todo: replace any with generic
 * Binary insertion that uses binarySearch algorithm.
 * @param {any[]} ar - The sorted array to insert.
 * @param {any} el - The item to insert.
 * @param {Function} compare_fn - comparator The function to use to compare the item to
 *        elements in the array.
 * @returns {number} Array index position in which item inserted in.
 */
function binaryInsert(ar, el, compare_fn) {
    let i = binarySearch(ar, el, compare_fn);
    if (i < 0) {
        i = ~i;
    }
    ar.splice(i, 0, el);
    return i;
}
/**
 * Returns two segment lines intersection coordinate.
 * @static
 * @param {Vec2} start1 - First line first coordinate.
 * @param {Vec2} end1 - First line second coordinate.
 * @param {Vec2} start2 - Second line first coordinate.
 * @param {Vec2} end2 - Second line second coordinate.
 * @param {boolean} [isSegment] - Lines are segments.
 * @return {Vec2} - Intersection coordinate.
 */
function getLinesIntersection2v(start1, end1, start2, end2, isSegment) {
    let dir1 = end1.sub(start1);
    let dir2 = end2.sub(start2);
    let a1 = -dir1.y;
    let b1 = +dir1.x;
    let d1 = -(a1 * start1.x + b1 * start1.y);
    let a2 = -dir2.y;
    let b2 = +dir2.x;
    let d2 = -(a2 * start2.x + b2 * start2.y);
    let seg1_line2_start = a2 * start1.x + b2 * start1.y + d2;
    let seg1_line2_end = a2 * end1.x + b2 * end1.y + d2;
    let seg2_line1_start = a1 * start2.x + b1 * start2.y + d1;
    let seg2_line1_end = a1 * end2.x + b1 * end2.y + d1;
    if (isSegment &&
        (seg1_line2_start * seg1_line2_end > 0 || seg2_line1_start * seg2_line1_end > 0)) {
        return undefined;
    }
    let u = seg1_line2_start / (seg1_line2_start - seg1_line2_end);
    return new Vec2(start1.x + u * dir1.x, start1.y + u * dir1.y);
}
/**
 * Returns two segment lines intersection coordinate.
 * @static
 * @param {Vec2} start1 - First line first coordinate.
 * @param {Vec2} end1 - First line second coordinate.
 * @param {Vec2} start2 - Second line first coordinate.
 * @param {Vec2} end2 - Second line second coordinate.
 * @param {boolean} [isSegment=false] - Lines are segments.
 * @return {Vec2} - Intersection coordinate.
 */
function getLinesIntersectionLonLat(start1, end1, start2, end2, isSegment = false) {
    let dir1 = new LonLat(end1.lon - start1.lon, end1.lat - start1.lat);
    let dir2 = new LonLat(end2.lon - start2.lon, end2.lat - start2.lat);
    let a1 = -dir1.lat;
    let b1 = +dir1.lon;
    let d1 = -(a1 * start1.lon + b1 * start1.lat);
    let a2 = -dir2.lat;
    let b2 = +dir2.lon;
    let d2 = -(a2 * start2.lon + b2 * start2.lat);
    let seg1_line2_start = a2 * start1.lon + b2 * start1.lat + d2;
    let seg1_line2_end = a2 * end1.lon + b2 * end1.lat + d2;
    let seg2_line1_start = a1 * start2.lon + b1 * start2.lat + d1;
    let seg2_line1_end = a1 * end2.lon + b1 * end2.lat + d1;
    if (isSegment &&
        (seg1_line2_start * seg1_line2_end > 0 || seg2_line1_start * seg2_line1_end > 0)) {
        return undefined;
    }
    let u = seg1_line2_start / (seg1_line2_start - seg1_line2_end);
    return new LonLat(start1.lon + u * dir1.lon, start1.lat + u * dir1.lat);
}
/**
 * Converts XML to JSON
 * @static
 * @param {Object} xml - Xml object
 * @return {Object} - Json converted object.
 */
function xmlToJson(xml) {
    // Create the return object
    let obj = {};
    if (xml.nodeType === 1) {
        // element
        // do attributes
        if (xml.attributes.length > 0) {
            obj["@attributes"] = {};
            for (let j = 0; j < xml.attributes.length; j++) {
                let attribute = xml.attributes.item(j);
                obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
            }
        }
    }
    else if (xml.nodeType === 3) {
        // text
        obj = xml.nodeValue;
    }
    // do children
    if (xml.hasChildNodes()) {
        for (let i = 0; i < xml.childNodes.length; i++) {
            let item = xml.childNodes.item(i);
            let nodeName = item.nodeName;
            if (typeof obj[nodeName] === "undefined") {
                obj[nodeName] = xmlToJson(item);
            }
            else {
                if (typeof obj[nodeName].push === "undefined") {
                    let old = obj[nodeName];
                    obj[nodeName] = [];
                    obj[nodeName].push(old);
                }
                obj[nodeName].push(xmlToJson(item));
            }
        }
    }
    return obj;
}
const castType = {
    string: function (v) {
        return isEmpty(v) ? v : v.toString();
    },
    date: function (v) {
        return isEmpty(v) ? v : new Date(v * 1000);
    },
    datetime: function (v) {
        return isEmpty(v) ? v : new Date(v * 1000);
    },
    time: function (v) {
        return isEmpty(v) ? v : parseInt(v);
    },
    integer: function (v) {
        return isEmpty(v) ? v : parseInt(v);
    },
    float: function (v) {
        return isEmpty(v) ? v : parseFloat(v);
    },
    boolean: function (str) {
        if (str === null) {
            return str;
        }
        if (typeof str === "boolean") {
            if (str === true) {
                return true;
            }
            return false;
        }
        if (typeof str === "string") {
            if (str === "") {
                return false;
            }
            str = str.replace(/^\s+|\s+$/g, "");
            if (str.toLowerCase() === "true" || str.toLowerCase() === "yes") {
                return true;
            }
            str = str.replace(/,/g, ".");
            str = str.replace(/^\s*\-\s*/g, "-");
        }
        if (!isNaN(str)) {
            return parseFloat(str) !== 0;
        }
        return false;
    }
};
function base64toBlob(base64Data, contentType = "") {
    let sliceSize = 1024;
    let byteCharacters = atob(base64Data);
    let bytesLength = byteCharacters.length;
    let slicesCount = Math.ceil(bytesLength / sliceSize);
    let byteArrays = new Array(slicesCount);
    for (let sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
        let begin = sliceIndex * sliceSize;
        let end = Math.min(begin + sliceSize, bytesLength);
        let bytes = new Array(end - begin);
        for (let offset = begin, i = 0; offset < end; ++i, ++offset) {
            bytes[i] = byteCharacters[offset].charCodeAt(0);
        }
        byteArrays[sliceIndex] = new Uint8Array(bytes);
    }
    return new Blob(byteArrays, { type: contentType });
}
function base64StringToBlog(string) {
    let block = string.split(";");
    let contentType = block[0].split(":")[1];
    let data = block[1].split(",")[1];
    return base64toBlob(data, contentType);
}
///**
// *
// * @param {LonLat} p
// * @param {LonLat} v1
// * @param {LonLat} v2
// * @param {LonLat} v3
// * @param {Array<Number>} res
// */
//export function cartesianToBarycentricLonLat(p, v1, v2, v3, res) {
//    const y2y3 = v2.lat - v3.lat,
//        x3x2 = v3.lon - v2.lon,
//        x1x3 = v1.lon - v3.lon,
//        y1y3 = v1.lat - v3.lat,
//        y3y1 = v3.lat - v1.lat,
//        xx3 = p.lon - v3.lon,
//        yy3 = p.lat - v3.lat;
//    const d = y2y3 * x1x3 + x3x2 * y1y3,
//        lambda1 = (y2y3 * xx3 + x3x2 * yy3) / d,
//        lambda2 = (y3y1 * xx3 + x1x3 * yy3) / d;
//    res[0] = lambda1;
//    res[1] = lambda2;
//    res[2] = 1 - lambda1 - lambda2;
//    return 0 <= res[0] && res[0] <= 1 && 0 <= lambda1 && lambda1 <= 1 && 0 <= lambda2 && lambda2 <= 1;
//};
/**
 * Callback throttling
 * @param {any} func
 * @param {Number} limit
 * @param {boolean} [skip]
 */
function throttle(func, limit, skip = false) {
    let lastFunc;
    let lastRan = 0;
    return function () {
        const args = arguments;
        if (!lastRan) {
            func.apply(null, args);
            lastRan = Date.now();
        }
        else {
            if (skip) {
                clearTimeout(lastFunc);
            }
            lastFunc = setTimeout(() => {
                if (Date.now() - lastRan >= limit) {
                    func.apply(null, args);
                    lastRan = Date.now();
                }
            }, limit - (Date.now() - lastRan));
        }
    };
}
/**
 *
 * y2-----Q12--------------Q22---
 * |       |     |          |
 * |       |     |          |
 * y-------|-----P----------|----
 * |       |     |          |
 * |       |     |          |
 * |       |     |          |
 * |       |     |          |
 * |       |     |          |
 * y1-----Q11----|---------Q21---
 *         |     |          |
 *         |     |          |
 *         x1    x          x2
 *
 *
 * @param {Number} x -
 * @param {Number} y -
 * @param {Number} fQ11 -
 * @param {Number} fQ21 -
 * @param {Number} fQ12 -
 * @param {Number} fQ22 -
 * @param {Number} [x1=0.0] -
 * @param {Number} [x2=1.0] -
 * @param {Number} [y1=0.0] -
 * @param {Number} [y2=1.0] -
 */
function blerp(x, y, fQ11, fQ21, fQ12, fQ22, x1 = 0.0, x2 = 1.0, y1 = 0.0, y2 = 1.0) {
    return ((fQ11 * (x2 - x) * (y2 - y) +
        fQ21 * (x - x1) * (y2 - y) +
        fQ12 * (x2 - x) * (y - y1) +
        fQ22 * (x - x1) * (y - y1)) /
        ((x2 - x1) * (y2 - y1)));
}
function blerp2(x, y, fQ11, fQ21, fQ12, fQ22) {
    return (fQ11 * (1.0 - x) * (1.0 - y) + fQ21 * x * (1.0 - y) + fQ12 * (1.0 - x) * y + fQ22 * x * y);
}
function extractElevationTiles$1(rgbaData, outCurrenElevations, outChildrenElevations) {
    let destSize = Math.sqrt(outCurrenElevations.length) - 1;
    let destSizeOne = destSize + 1;
    let sourceSize = Math.sqrt(rgbaData.length / 4);
    let dt = sourceSize / destSize;
    let rightHeigh = 0, bottomHeigh = 0;
    for (let k = 0, currIndex = 0, sourceDataLength = rgbaData.length / 4; k < sourceDataLength; k++) {
        let height = rgbaData[k * 4];
        let i = Math.floor(k / sourceSize), j = k % sourceSize;
        let tileX = Math.floor(j / destSize), tileY = Math.floor(i / destSize);
        let destArr = outChildrenElevations[tileY][tileX];
        let ii = i % destSize, jj = j % destSize;
        let destIndex = (ii + tileY) * destSizeOne + jj + tileX;
        destArr[destIndex] = height;
        if ((i + tileY) % dt === 0 && (j + tileX) % dt === 0) {
            outCurrenElevations[currIndex++] = height;
        }
        if ((j + 1) % destSize === 0 && j !== sourceSize - 1) {
            //current tile
            rightHeigh = rgbaData[(k + 1) * 4];
            let middleHeight = (height + rightHeigh) * 0.5;
            destIndex = (ii + tileY) * destSizeOne + jj + 1;
            destArr[destIndex] = middleHeight;
            if ((i + tileY) % dt === 0) {
                outCurrenElevations[currIndex++] = middleHeight;
            }
            //next right tile
            let rightindex = (ii + tileY) * destSizeOne + ((jj + 1) % destSize);
            outChildrenElevations[tileY][tileX + 1][rightindex] = middleHeight;
        }
        if ((i + 1) % destSize === 0 && i !== sourceSize - 1) {
            //current tile
            bottomHeigh = rgbaData[(k + sourceSize) * 4];
            let middleHeight = (height + bottomHeigh) * 0.5;
            destIndex = (ii + 1) * destSizeOne + jj + tileX;
            destArr[destIndex] = middleHeight;
            if ((j + tileX) % dt === 0) {
                outCurrenElevations[currIndex++] = middleHeight;
            }
            //next bottom tile
            let bottomindex = ((ii + 1) % destSize) * destSizeOne + jj + tileX;
            outChildrenElevations[tileY + 1][tileX][bottomindex] = middleHeight;
        }
        if ((j + 1) % destSize === 0 &&
            j !== sourceSize - 1 &&
            (i + 1) % destSize === 0 &&
            i !== sourceSize - 1) {
            //current tile
            let rightBottomHeight = rgbaData[(k + sourceSize + 1) * 4];
            let middleHeight = (height + rightHeigh + bottomHeigh + rightBottomHeight) * 0.25;
            destIndex = (ii + 1) * destSizeOne + (jj + 1);
            destArr[destIndex] = middleHeight;
            outCurrenElevations[currIndex++] = middleHeight;
            //next right tile
            let rightindex = (ii + 1) * destSizeOne;
            outChildrenElevations[tileY][tileX + 1][rightindex] = middleHeight;
            //next bottom tile
            let bottomindex = destSize;
            outChildrenElevations[tileY + 1][tileX][bottomindex] = middleHeight;
            //next right bottom tile
            let rightBottomindex = 0;
            outChildrenElevations[tileY + 1][tileX + 1][rightBottomindex] = middleHeight;
        }
    }
}
/**
 * Concatenates two the same type arrays
 * @param {TypedArray} a
 * @param {TypedArray | number[]} b
 */
function concatTypedArrays(a, b) {
    let c = new a.constructor(a.length + b.length); //hacky
    c.set(a, 0);
    c.set(b, a.length);
    return c;
}
/**
 * Concatenates two the same  arrays
 * @param {TypedArray | number[]} [a=[]] - First array
 * @param {TypedArray | number[]} [b=[]] - Second array
 * @return {TypedArray | number[]} -
 */
function concatArrays(a = [], b = []) {
    if (ArrayBuffer.isView(a)) {
        return concatTypedArrays(a, b);
    }
    else {
        for (let i = 0; i < b.length; i++) {
            a.push(b[i]);
        }
        return a;
    }
}
/**
 * Convert simple array to typed
 * @param arr {number[]}
 * @param ctor {Float32Array}
 * @returns {TypedArray}
 */
function makeArrayTyped(arr, ctor = Float32Array) {
    if (!ArrayBuffer.isView(arr)) {
        const typedArr = new ctor(arr.length); //hacky
        typedArr.set(arr, 0);
        return typedArr;
    }
    else {
        return arr;
    }
}
/**
 * Convert typed array to array
 * @param arr {TypedArray | number[]}
 * @returns {number[]}
 */
function makeArray(arr) {
    if (ArrayBuffer.isView(arr)) {
        return Array.from(arr);
    }
    else {
        return arr;
    }
}
/**
 *
 * @param {TypedArray | Array} arr
 * @param {Number} starting
 * @param {Number} deleteCount
 * @param {{ result: number[] }} [out]
 */
function spliceArray(arr, starting, deleteCount, out) {
    if (ArrayBuffer.isView(arr)) {
        if (starting < 0) {
            deleteCount = Math.abs(starting);
            starting += arr.length;
        }
        return spliceTypedArray(arr, starting, deleteCount, out);
    }
    else {
        let res;
        if (starting < 0) {
            res = arr.splice(starting);
        }
        else {
            res = arr.splice(starting, deleteCount);
        }
        if (out) {
            out.result = res;
        }
        return arr;
    }
}
/**
 *
 * @param {TypedArray} arr
 * @param {Number} starting
 * @param {Number} deleteCount
 * @param {{ result: TypedArray }} [out]
 */
function spliceTypedArray(arr, starting, deleteCount, out) {
    if (arr.length === 0) {
        return arr;
    }
    const newSize = arr.length - deleteCount;
    const splicedArray = new arr.constructor(newSize); //hacky
    splicedArray.set(arr.subarray(0, starting));
    splicedArray.set(arr.subarray(starting + deleteCount), starting);
    if (out) {
        out.result = arr.subarray(starting, starting + deleteCount);
    }
    return splicedArray;
}
/**
 * Returns 64-bit triangle coordinate array from inside of the source triangle array.
 * @static
 * @param {TypedArray | number[]} sourceArr - Source array
 * @param {number} gridSize - Source array square matrix size
 * @param {number} i0 - First row index source array matrix
 * @param {number} j0 - First column index
 * @param {number} size - Square matrix result size.
 * @return {Float64Array} Triangle coordinates array from the source array.
 * @TODO: optimization
 */
function getMatrixSubArray64(sourceArr, gridSize, i0, j0, size) {
    const size_1 = size + 1;
    const i0size = i0 + size_1;
    const j0size = j0 + size_1;
    let res = new Float64Array(size_1 * size_1 * 3);
    let vInd = 0;
    for (let i = i0; i < i0size; i++) {
        for (let j = j0; j < j0size; j++) {
            let ind = 3 * (i * (gridSize + 1) + j);
            res[vInd++] = sourceArr[ind];
            res[vInd++] = sourceArr[ind + 1];
            res[vInd++] = sourceArr[ind + 2];
        }
    }
    return res;
}
/**
 * Returns 32-bit triangle coordinate array from inside of the source triangle array.
 * @static
 * @param {TypedArray | number[]} sourceArr - Source array
 * @param {number} gridSize - Source array square matrix size
 * @param {number} i0 - First row index source array matrix
 * @param {number} j0 - First column index
 * @param {number} size - Square matrix result size.
 * @return {Float32Array} Triangle coordinates array from the source array.
 */
function getMatrixSubArray32(sourceArr, gridSize, i0, j0, size) {
    const size_1 = size + 1;
    const i0size = i0 + size_1;
    const j0size = j0 + size_1;
    let res = new Float32Array(size_1 * size_1 * 3);
    let vInd = 0;
    for (let i = i0; i < i0size; i++) {
        for (let j = j0; j < j0size; j++) {
            let ind = 3 * (i * (gridSize + 1) + j);
            res[vInd++] = sourceArr[ind];
            res[vInd++] = sourceArr[ind + 1];
            res[vInd++] = sourceArr[ind + 2];
        }
    }
    return res;
}
/**
 * Returns two float32 triangle coordinate arrays from inside of the source triangle array.
 * @TODO: optimization
 */
function getMatrixSubArrayBoundsExt(sourceArr, sourceArrHigh, sourceArrLow, noDataVertices, gridSize, i0, j0, size, outArr, outArrHigh, outArrLow, outBounds, outNoDataVertices) {
    const i0size = i0 + size + 1;
    const j0size = j0 + size + 1;
    gridSize += 1;
    let vInd = 0, nInd = 0;
    for (let i = i0; i < i0size; i++) {
        for (let j = j0; j < j0size; j++) {
            let indBy3 = i * gridSize + j, ind = 3 * indBy3;
            let x = sourceArr[ind], y = sourceArr[ind + 1], z = sourceArr[ind + 2];
            if (!noDataVertices || noDataVertices[indBy3] === 0) {
                if (x < outBounds.xmin)
                    outBounds.xmin = x;
                if (x > outBounds.xmax)
                    outBounds.xmax = x;
                if (y < outBounds.ymin)
                    outBounds.ymin = y;
                if (y > outBounds.ymax)
                    outBounds.ymax = y;
                if (z < outBounds.zmin)
                    outBounds.zmin = z;
                if (z > outBounds.zmax)
                    outBounds.zmax = z;
            }
            else {
                outNoDataVertices[nInd] = 1;
            }
            nInd++;
            outArr[vInd] = x;
            outArrLow[vInd] = sourceArrLow[ind];
            outArrHigh[vInd++] = sourceArrHigh[ind];
            outArr[vInd] = y;
            outArrLow[vInd] = sourceArrLow[ind + 1];
            outArrHigh[vInd++] = sourceArrHigh[ind + 1];
            outArr[vInd] = z;
            outArrLow[vInd] = sourceArrLow[ind + 2];
            outArrHigh[vInd++] = sourceArrHigh[ind + 2];
        }
    }
}
function cloneArray(items) {
    return items.map((item) => (Array.isArray(item) ? cloneArray(item) : item));
}
/**
 * Promise for load images
 * @function
 * @param {string} url - link to image.
 * @returns {Promise<Image>} Returns promise.
 */
async function loadImage(url) {
    return new Promise(resolve => {
        const image = new Image();
        image.addEventListener('load', () => {
            resolve(image);
        });
        image.src = url;
        image.crossOrigin = "";
        return image;
    });
}
/**
 * Gets image is loaded
 * @param {HTMLImageElement} image
 * @returns {boolean} Returns true is the image is loaded
 */
function isImageLoaded(image) {
    return image.complete && image.naturalHeight !== 0;
}
function distanceFormat$2(v) {
    if (v > 1000) {
        return `${(v / 1000).toFixed(2)} km`;
    }
    else if (v > 9) {
        return `${Math.round(v)} m`;
    }
    else {
        return `${v.toFixed(1)} m`;
    }
}
function distanceFormatExt(v) {
    if (v > 1000) {
        let d = v - Math.floor(v);
        if (d !== 0) {
            return [(v / 1000).toFixed(2), "km"];
        }
        return [(v / 1000).toFixed(0), "km"];
    }
    else if (v > 9) {
        return [Math.round(v).toString(), "m"];
    }
    else {
        if (v <= 0.01) {
            return ["0", "m"];
        }
        return [v.toFixed(1), "m"];
    }
}
function getUrlParam(paramName) {
    let urlParams = new URLSearchParams(location.search);
    let param = urlParams.get(paramName);
    if (param) {
        return Number(param);
    }
}

var shared = /*#__PURE__*/Object.freeze({
    __proto__: null,
    base64StringToBlog: base64StringToBlog,
    base64toBlob: base64toBlob,
    binaryInsert: binaryInsert,
    binarySearch: binarySearch,
    binarySearchFast: binarySearchFast,
    blerp: blerp,
    blerp2: blerp2,
    castType: castType,
    cloneArray: cloneArray,
    concatArrays: concatArrays,
    concatTypedArrays: concatTypedArrays,
    createColorRGB: createColorRGB,
    createColorRGBA: createColorRGBA,
    createExtent: createExtent,
    createLonLat: createLonLat,
    createVector3: createVector3,
    createVector4: createVector4,
    defaultString: defaultString,
    distanceFormat: distanceFormat$2,
    distanceFormatExt: distanceFormatExt,
    extractElevationTiles: extractElevationTiles$1,
    getDefault: getDefault,
    getHTML: getHTML,
    getLinesIntersection2v: getLinesIntersection2v,
    getLinesIntersectionLonLat: getLinesIntersectionLonLat,
    getMatrixSubArray32: getMatrixSubArray32,
    getMatrixSubArray64: getMatrixSubArray64,
    getMatrixSubArrayBoundsExt: getMatrixSubArrayBoundsExt,
    getUrlParam: getUrlParam,
    htmlColorToFloat32Array: htmlColorToFloat32Array,
    htmlColorToRgb: htmlColorToRgb,
    htmlColorToRgba: htmlColorToRgba,
    isEmpty: isEmpty,
    isImageLoaded: isImageLoaded,
    isNumber: isNumber,
    isString: isString,
    isUndef: isUndef,
    isUndefExt: isUndefExt,
    loadImage: loadImage,
    makeArray: makeArray,
    makeArrayTyped: makeArrayTyped,
    parseHTML: parseHTML,
    print2d: print2d,
    rgbToStringHTML: rgbToStringHTML,
    spliceArray: spliceArray,
    spliceTypedArray: spliceTypedArray,
    stamp: stamp,
    stringTemplate: stringTemplate,
    throttle: throttle,
    xmlToJson: xmlToJson
});

/**
 * Seconds in millisecond.
 * @const
 */
const SECONDS_PER_MILLISECOND = 0.001;
/**
 * Milliseconds in second.
 * @const
 */
const MILLISECONDS_PER_SECOND = 1000.0;
/**
 * Seconds in minute.
 * @const
 */
const SECONDS_PER_MINUTE = 60.0;
/**
 * One by seconds in minute.
 * @const
 */
const ONE_BY_SECONDS_PER_MINUTE = 1.0 / SECONDS_PER_MINUTE;
/**
 * Minutes in hour.
 * @const
 */
const MINUTES_PER_HOUR = 60.0;
/**
 * Hours in day.
 * @const
 */
const HOURS_PER_DAY = 24.0;
/**
 * One by hours in day.
 * @const
 */
const ONE_BY_HOURS_PER_DAY = 1.0 / HOURS_PER_DAY;
/**
 * Seconds in hour.
 * @const
 */
const SECONDS_PER_HOUR = 3600.0;
/**
 * One by seconds in hour.
 * @const
 */
const ONE_BY_SECONDS_PER_HOUR = 1.0 / SECONDS_PER_HOUR;
/**
 * Seconds in 12 hours.
 * @const
 */
const SECONDS_PER_12_HOURS = 12.0 * SECONDS_PER_HOUR;
/**
 * Minutes in day.
 * @const
 */
const MINUTES_PER_DAY = 1440.0;
/**
 * One by minutes in day.
 * @const
 */
const ONE_BY_MINUTES_PER_DAY = 1.0 / MINUTES_PER_DAY;
/**
 * Seconds in day.
 * @const
 */
const SECONDS_PER_DAY = 86400.0;
/**
 * Milliseconds in day.
 * @const
 */
const MILLISECONDS_PER_DAY = 86400000.0;
/**
 * One by milliseconds in day.
 * @const
 */
const ONE_BY_MILLISECONDS_PER_DAY = 1.0 / MILLISECONDS_PER_DAY;
/**
 * One by seconds in day.
 * @const
 */
const ONE_BY_SECONDS_PER_DAY = 1.0 / SECONDS_PER_DAY;
/**
 * Days in julian century.
 * @const
 */
const DAYS_PER_JULIAN_CENTURY = 36525.0;
/**
 * Days in julian year.
 * @const
 */
const DAYS_PER_JULIAN_YEAR = 365.25;
/**
 * Seconds in picoseconds.
 * @const
 */
const PICOSECOND = 0.000000001;
/**
 * Modified julian date difference.
 * @const
 */
const MODIFIED_JULIAN_DATE_DIFFERENCE = 2400000.5;
/**
 * Julian date of 2000 year. Epoch.
 * @const
 */
const J2000 = 2451545.0;
/**
 * Returns julian days from Epoch.
 * @param {JulianDate} jd - Julian date.
 * @returns {number} Days from epoch
 */
function T(jd) {
    return (jd - J2000) / DAYS_PER_JULIAN_CENTURY;
}
/**
 * Gets the date's julian day.
 * @param {number} year - Year.
 * @param {number} month - Month.
 * @param {number} day - Day.
 * @returns {number} Day number
 */
function getDayNumber(year, month, day) {
    let a = ((month - 14) / 12) | 0;
    let b = year + 4800 + a;
    return ((((1461 * b) / 4) | 0) +
        (((367 * (month - 2 - 12 * a)) / 12) | 0) -
        (((3 * (((b + 100) / 100) | 0)) / 4) | 0) +
        day -
        32075);
}
/**
 * Converts javascript date to the universal(UTC) julian date.
 * @param {Date} date - Date.
 * @returns {JulianDate} UTC julian date
 */
function DateToUTC(date) {
    let dayNumber = getDayNumber(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate());
    let hour = date.getUTCHours() - 12;
    if (hour < 0) {
        hour += 24;
    }
    let secondsOfDay = date.getUTCSeconds() +
        hour * SECONDS_PER_HOUR +
        date.getUTCMinutes() * SECONDS_PER_MINUTE +
        date.getUTCMilliseconds() * SECONDS_PER_MILLISECOND;
    if (secondsOfDay >= SECONDS_PER_12_HOURS) {
        dayNumber--;
    }
    let extraDays = (secondsOfDay * ONE_BY_SECONDS_PER_DAY) | 0;
    dayNumber += extraDays;
    secondsOfDay -= SECONDS_PER_DAY * extraDays;
    if (secondsOfDay < 0) {
        dayNumber--;
        secondsOfDay += SECONDS_PER_DAY;
    }
    return dayNumber + secondsOfDay * ONE_BY_SECONDS_PER_DAY;
}
/**
 * Converts javascript date to the atomic(TAI) julian date.
 * @param {Date} date - Date.
 * @returns {JulianDate} TAI julian date
 */
function DateToTAI(date) {
    return UTCtoTAI(DateToUTC(date));
}
/**
 * Converts coordinated universal(UTC) julian date to atomic(TAI) julian date.
 * @param {JulianDate} jd - UTC julian date.
 * @returns {JulianDate} TAI julian date
 */
function UTCtoTAI(jd) {
    let leapSeconds = leapSecondsTable;
    let index = binarySearch(leapSeconds, jd, function (a, b) {
        return a - b.jd;
    });
    if (index < 0) {
        index = ~index;
    }
    if (index >= leapSeconds.length) {
        index = leapSeconds.length - 1;
    }
    let offset = leapSeconds[index].leapSeconds;
    if (index !== 0) {
        if ((leapSeconds[index].jd - jd) * SECONDS_PER_DAY > offset) {
            offset = leapSeconds[index - 1].leapSeconds;
        }
    }
    return jd + offset * ONE_BY_SECONDS_PER_DAY;
}
/**
 * Converts atomic julian date(TAI) to the coordinated universal(UTC) julian date.
 * @param {JulianDate} tai - TAI julian date.
 * @returns {JulianDate | undefined} UTC julian date
 */
function TAItoUTC(tai) {
    let leapSeconds = leapSecondsTable;
    let index = binarySearch(leapSeconds, tai, function (a, b) {
        return a - b.jd;
    });
    if (index < 0) {
        index = ~index;
    }
    if (index >= leapSeconds.length) {
        return tai - leapSeconds[index - 1].leapSeconds * ONE_BY_SECONDS_PER_DAY;
    }
    if (index === 0) {
        return tai - leapSeconds[0].leapSeconds * ONE_BY_SECONDS_PER_DAY;
    }
    let diff = (leapSeconds[index].jd - tai) * SECONDS_PER_DAY;
    if (diff === 0) {
        return tai - leapSeconds[index].leapSeconds * ONE_BY_SECONDS_PER_DAY;
    }
    if (diff <= 1.0) {
        return;
    }
    return tai - leapSeconds[index - 1].leapSeconds * ONE_BY_SECONDS_PER_DAY;
}
/**
 * Converts UTC julian date to the javascript date object.
 * @param {JulianDate} utc - UTC julian date.
 * @returns {Date} JavaScript Date object
 */
function UTCtoDate(utc) {
    let julianDayNumber = utc | 0;
    let secondsOfDay = (utc - julianDayNumber) * SECONDS_PER_DAY;
    if (secondsOfDay >= SECONDS_PER_12_HOURS) {
        julianDayNumber++;
    }
    let L = (julianDayNumber + 68569) | 0;
    let N = ((4 * L) / 146097) | 0;
    L = (L - (((146097 * N + 3) / 4) | 0)) | 0;
    let I = ((4000 * (L + 1)) / 1461001) | 0;
    L = (L - (((1461 * I) / 4) | 0) + 31) | 0;
    let J = ((80 * L) / 2447) | 0;
    let day = (L - (((2447 * J) / 80) | 0)) | 0;
    L = (J / 11) | 0;
    let month = (J + 2 - 12 * L) | 0;
    let year = (100 * (N - 49) + I + L) | 0;
    let hour = (secondsOfDay * ONE_BY_SECONDS_PER_HOUR) | 0;
    let remainingSeconds = secondsOfDay - hour * SECONDS_PER_HOUR;
    let minute = (remainingSeconds * ONE_BY_SECONDS_PER_MINUTE) | 0;
    remainingSeconds = remainingSeconds - minute * SECONDS_PER_MINUTE;
    let second = remainingSeconds | 0;
    let millisecond = ((remainingSeconds - second) * MILLISECONDS_PER_SECOND) | 0;
    hour += 12;
    if (hour > 23) {
        hour -= 24;
    }
    return new Date(Date.UTC(year, month - 1, day, hour, minute, second, millisecond));
}
/**
 * Converts TAI julian date to the javascript date object.
 * @param {JulianDate} tai - TAI julian date.
 * @returns {Date} JavaScript Date object
 */
function TAItoDate(tai) {
    let utc = TAItoUTC(tai);
    if (!utc) {
        utc = TAItoUTC(addSeconds$1(tai, -1));
        console.trace(`TAItoDate - can't convert ${tai.toString()} to utc.`);
    }
    return UTCtoDate(utc);
}
/**
 * Adds milliseconds to the julian date.
 * @param {JulianDate} jd - Julian date.
 * @param {number} milliseconds - Milliseconds to add.
 * @returns {JulianDate} Julian date
 */
function addMilliseconds(jd, milliseconds) {
    return jd + milliseconds * ONE_BY_MILLISECONDS_PER_DAY;
}
/**
 * Adds seconds to the julian date.
 * @param {JulianDate} jd - Julian date.
 * @param {number} seconds - Seconds to add.
 * @returns {JulianDate} Julian date
 */
function addSeconds$1(jd, seconds) {
    return jd + seconds * ONE_BY_SECONDS_PER_DAY;
}
/**
 * Adds hours to the julian date.
 * @param {JulianDate} jd - Julian date.
 * @param {number} hours - Hours to add.
 * @returns {JulianDate} Julian date
 */
function addHours$1(jd, hours) {
    return jd + hours * ONE_BY_HOURS_PER_DAY;
}
/**
 * Adds minutes to the julian date.
 * @param {JulianDate} jd - Julian date.
 * @param {number} minutes - Minutes to add.
 * @returns {JulianDate} Julian date
 */
function addMinutes(jd, minutes) {
    return jd + minutes * MINUTES_PER_DAY;
}
/**
 * Adds days to the julian date.
 * @param {JulianDate} jd - Julian date.
 * @param {number} days - Days to add.
 * @returns {JulianDate} Julian date
 */
function addDays(jd, days) {
    return jd + days;
}
/**
 * Gets milliseconds of a julian date.
 * @param {JulianDate} jd - julian date.
 * @returns {number} Milliseconds
 */
function getMilliseconds(jd) {
    let s = jd - (jd | 0);
    s *= SECONDS_PER_DAY;
    return ((s - (s | 0)) * MILLISECONDS_PER_SECOND) | 0;
}
/**
 * Gets seconds of a julian date.
 * @param {JulianDate} jd - julian date.
 * @returns {number} Seconds
 */
function getSeconds(jd) {
    let s = jd - (jd | 0);
    return s * SECONDS_PER_DAY;
}
/**
 * Gets hours of a julian date.
 * @param {JulianDate} jd - julian date.
 * @returns {number} Hours
 */
function getHours(jd) {
    let julianDayNumber = jd | 0;
    let secondsOfDay = (jd - julianDayNumber) * SECONDS_PER_DAY;
    let hour = (secondsOfDay * ONE_BY_SECONDS_PER_HOUR) | 0;
    let remainingSeconds = secondsOfDay - hour * SECONDS_PER_HOUR;
    let minute = (remainingSeconds * ONE_BY_SECONDS_PER_MINUTE) | 0;
    remainingSeconds = remainingSeconds - minute * SECONDS_PER_MINUTE;
    let second = remainingSeconds | 0;
    let millisecond = ((remainingSeconds - second) * MILLISECONDS_PER_SECOND) | 0;
    hour += 12 + minute / 60 + second / 3600 + millisecond / 1000;
    if (hour > 23) {
        hour -= 24;
    }
    return hour;
}
/**
 * Gets minutes of a julian date.
 * @param {JulianDate} jd - julian date.
 * @returns {number} Minutes
 */
function getMinutes(jd) {
    let s = jd - (jd | 0);
    return (s * MINUTES_PER_DAY) | 0;
}
/**
 * Gets days of a julian date.
 * @param {JulianDate} jd - julian date.
 * @returns {number} Days
 */
function getDays(jd) {
    return jd | 0;
}
/**
 * Returns days in seconds.
 * @param {number} s - Seconds.
 * @returns {number} Days
 */
function secondsToDays(s) {
    return s * ONE_BY_SECONDS_PER_DAY;
}
/**
 * Returns seconds in days.
 * @param {number} d - Days.
 * @returns {number} Seconds
 */
function daysToSeconds(d) {
    return d * SECONDS_PER_DAY;
}
function __ls(jd, leapSeconds) {
    return {
        jd: jd,
        leapSeconds: leapSeconds
    };
}
const leapSecondsTable = [
    __ls(2441317.5, 10.0), // 1972-01-01T00:00:00.000Z
    __ls(2441499.5, 11.0), // 1972-07-01T00:00:00.000Z
    __ls(2441683.5, 12.0), // 1973-01-01T00:00:00.000Z
    __ls(2442048.5, 13.0), // 1974-01-01T00:00:00.000Z
    __ls(2442413.5, 14.0), // 1975-01-01T00:00:00.000Z
    __ls(2442778.5, 15.0), // 1976-01-01T00:00:00.000Z
    __ls(2443144.5, 16.0), // 1977-01-01T00:00:00.000Z
    __ls(2443509.5, 17.0), // 1978-01-01T00:00:00.000Z
    __ls(2443874.5, 18.0), // 1979-01-01T00:00:00.000Z
    __ls(2444239.5, 19.0), // 1980-01-01T00:00:00.000Z
    __ls(2444786.5, 20.0), // 1981-07-01T00:00:00.000Z
    __ls(2445151.5, 21.0), // 1982-07-01T00:00:00.000Z
    __ls(2445516.5, 22.0), // 1983-01-01T00:00:00.000Z
    __ls(2446247.5, 23.0), // 1985-07-01T00:00:00.000Z
    __ls(2447161.5, 24.0), // 1988-01-01T00:00:00.000Z
    __ls(2447892.5, 25.0), // 1990-01-01T00:00:00.000Z
    __ls(2448257.5, 26.0), // 1991-01-01T00:00:00.000Z
    __ls(2448804.5, 27.0), // 1992-07-01T00:00:00.000Z
    __ls(2449169.5, 28.0), // 1993-07-01T00:00:00.000Z
    __ls(2449534.5, 29.0), // 1994-07-01T00:00:00.000Z
    __ls(2450083.5, 30.0), // 1996-01-01T00:00:00.000Z
    __ls(2450630.5, 31.0), // 1997-07-01T00:00:00.000Z
    __ls(2451179.5, 32.0), // 1999-01-01T00:00:00.000Z
    __ls(2453736.5, 33.0), // 2006-01-01T00:00:00.000Z
    __ls(2454832.5, 34.0), // 2009-01-01T00:00:00.000Z
    __ls(2456109.5, 35.0), // 2012-07-01T00:00:00.000Z
    __ls(2457204.5, 36.0) // 2015-07-01T00:00:00.000Z
];
const J2000TAI = UTCtoTAI(J2000);

var jd = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DAYS_PER_JULIAN_CENTURY: DAYS_PER_JULIAN_CENTURY,
    DAYS_PER_JULIAN_YEAR: DAYS_PER_JULIAN_YEAR,
    DateToTAI: DateToTAI,
    DateToUTC: DateToUTC,
    HOURS_PER_DAY: HOURS_PER_DAY,
    J2000: J2000,
    J2000TAI: J2000TAI,
    MILLISECONDS_PER_DAY: MILLISECONDS_PER_DAY,
    MILLISECONDS_PER_SECOND: MILLISECONDS_PER_SECOND,
    MINUTES_PER_DAY: MINUTES_PER_DAY,
    MINUTES_PER_HOUR: MINUTES_PER_HOUR,
    MODIFIED_JULIAN_DATE_DIFFERENCE: MODIFIED_JULIAN_DATE_DIFFERENCE,
    ONE_BY_HOURS_PER_DAY: ONE_BY_HOURS_PER_DAY,
    ONE_BY_MILLISECONDS_PER_DAY: ONE_BY_MILLISECONDS_PER_DAY,
    ONE_BY_MINUTES_PER_DAY: ONE_BY_MINUTES_PER_DAY,
    ONE_BY_SECONDS_PER_DAY: ONE_BY_SECONDS_PER_DAY,
    ONE_BY_SECONDS_PER_HOUR: ONE_BY_SECONDS_PER_HOUR,
    ONE_BY_SECONDS_PER_MINUTE: ONE_BY_SECONDS_PER_MINUTE,
    PICOSECOND: PICOSECOND,
    SECONDS_PER_12_HOURS: SECONDS_PER_12_HOURS,
    SECONDS_PER_DAY: SECONDS_PER_DAY,
    SECONDS_PER_HOUR: SECONDS_PER_HOUR,
    SECONDS_PER_MILLISECOND: SECONDS_PER_MILLISECOND,
    SECONDS_PER_MINUTE: SECONDS_PER_MINUTE,
    T: T,
    TAItoDate: TAItoDate,
    TAItoUTC: TAItoUTC,
    UTCtoDate: UTCtoDate,
    UTCtoTAI: UTCtoTAI,
    addDays: addDays,
    addHours: addHours$1,
    addMilliseconds: addMilliseconds,
    addMinutes: addMinutes,
    addSeconds: addSeconds$1,
    daysToSeconds: daysToSeconds,
    getDayNumber: getDayNumber,
    getDays: getDays,
    getHours: getHours,
    getMilliseconds: getMilliseconds,
    getMinutes: getMinutes,
    getSeconds: getSeconds,
    secondsToDays: secondsToDays
});

/**
 * Bounding box class.
 * @class
 * @param {NumberArray6} [boundsArr]
 */
class Box {
    constructor(boundsArr) {
        this.vertices = [
            new Vec3(),
            new Vec3(),
            new Vec3(),
            new Vec3(),
            new Vec3(),
            new Vec3(),
            new Vec3(),
            new Vec3()
        ];
        if (boundsArr) {
            this.setFromBoundsArr(boundsArr);
        }
    }
    copy(bbox) {
        for (let i = 0, len = this.vertices.length; i < len; i++) {
            this.vertices[i].copy(bbox.vertices[i]);
        }
    }
    /**
     * Sets bounding box coordinates by the bounds array.
     * @param {NumberArray6} bounds - Bounds is an array where [minX, minY, minZ, maxX, maxY, maxZ]
     */
    setFromBoundsArr(bounds) {
        let xmin = bounds[0], xmax = bounds[3], ymin = bounds[1], ymax = bounds[4], zmin = bounds[2], zmax = bounds[5];
        let v = this.vertices;
        v[0].set(xmin, ymin, zmin);
        v[1].set(xmax, ymin, zmin);
        v[2].set(xmax, ymin, zmax);
        v[3].set(xmin, ymin, zmax);
        v[4].set(xmin, ymax, zmin);
        v[5].set(xmax, ymax, zmin);
        v[6].set(xmax, ymax, zmax);
        v[7].set(xmin, ymax, zmax);
    }
    /**
     * Sets bounding box coordinates by ellipsoid geodetic extend.
     * @param {Ellipsoid} ellipsoid - Ellipsoid.
     * @param {Extent} extent - Geodetic extent.
     */
    setFromExtent(ellipsoid, extent) {
        this.setFromBoundsArr(extent.getCartesianBounds(ellipsoid));
    }
}

/**
 * Bounding sphere class.
 * @class
 * @param {Number} [radius] - Bounding sphere radius.
 * @param {Vec3} [center] - Bounding sphere coordinates.
 */
class Sphere {
    constructor(radius = 0, center) {
        this.radius = radius;
        this.center = center ? center.clone() : new Vec3();
    }
    /**
     * Sets bounding sphere coordinates by the bounds array.
     * @param {Array.<number>} bounds - Bounds is an array where [minX, minY, minZ, maxX, maxY, maxZ]
     */
    setFromBounds(bounds) {
        let m = new Vec3(bounds[0], bounds[1], bounds[2]);
        this.center.set(m.x + (bounds[3] - m.x) * 0.5, m.y + (bounds[3] - m.y) * 0.5, m.z + (bounds[5] - m.z) * 0.5);
        this.radius = this.center.distance(m);
    }
    /**
     * Sets bounding sphere coordinates by ellipsoid geodetic extend.
     * @param {Ellipsoid} ellipsoid - Ellipsoid.
     * @param {Extent} extent - Geodetic extent.
     */
    setFromExtent(ellipsoid, extent) {
        this.setFromBounds(extent.getCartesianBounds(ellipsoid));
    }
}

var index$5 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Box: Box,
    Sphere: Sphere
});

function createEvents(methodNames, sender) {
    return new Events(methodNames, sender);
}
/**
 * Base events class to handle custom events.
 * @class
 * @param {Array.<string>} [eventNames] - Event names that could be dispatched.
 * @param {*} [sender]
 */
class Events {
    constructor(eventNames, sender) {
        this.__id = Events.__counter__++;
        this._eventNames = [];
        eventNames && this.registerNames(eventNames);
        this._sender = sender || this;
        this._stopPropagation = false;
        this._stampCache = {};
    }
    bindSender(sender) {
        this._sender = sender || this;
    }
    /**
     * Function that creates event object properties that would be dispatched.
     * @public
     * @param {Array.<string>} eventNames - Specified event names list.
     */
    registerNames(eventNames) {
        for (let i = 0; i < eventNames.length; i++) {
            this[eventNames[i]] = {
                active: true,
                handlers: []
            };
            this._eventNames.push(eventNames[i]);
        }
        return this;
    }
    _getStamp(name, id, ogid) {
        return `${name}_${id}_${ogid}`;
    }
    /**
     * Returns true if event callback has stamped.
     * @protected
     * @param {Object} name - Event identifier.
     * @param {Object} obj - Event callback.
     * @return {boolean} -
     */
    _stamp(name, obj) {
        let ogid = stamp(obj);
        let st = this._getStamp(name, this.__id, ogid);
        if (!this._stampCache[st]) {
            this._stampCache[st] = ogid;
            return true;
        }
        return false;
    }
    /**
     * Attach listener.
     * @public
     * @param {string} name - Event name to listen.
     * @param {EventCallback} callback - Event callback function.
     * @param {any} [sender] - Event callback function owner.
     * @param {number} [priority] - Priority of event callback.
     */
    on(name, callback, sender, priority = 0) {
        if (this._stamp(name, callback)) {
            if (this[name]) {
                let c = callback.bind(sender || this._sender);
                c._openglobus_id = callback._openglobus_id;
                c._openglobus_priority = priority;
                binaryInsert(this[name].handlers, c, (a, b) => {
                    return (b._openglobus_priority || 0) - (a._openglobus_priority || 0);
                });
            }
        }
    }
    /**
     * Stop listening event name with specified callback function.
     * @public
     * @param {string} name - Event name.
     * @param {EventCallback | null} callback - Attached  event callback.
     */
    off(name, callback) {
        if (callback) {
            let st = this._getStamp(name, this.__id, callback._openglobus_id);
            if (callback._openglobus_id && this._stampCache[st]) {
                let h = this[name].handlers;
                let i = h.length;
                let indexToRemove = -1;
                while (i--) {
                    let hi = h[i];
                    if (hi._openglobus_id === callback._openglobus_id) {
                        indexToRemove = i;
                        break;
                    }
                }
                if (indexToRemove !== -1) {
                    h.splice(indexToRemove, 1);
                    this._stampCache[st] = undefined;
                    delete this._stampCache[st];
                }
            }
        }
    }
    /**
     * Dispatch event.
     * @public
     * @param {EventCallbackHandler} event - Event instance property that created by event name.
     * @param {Object} [args] - Callback parameters.
     */
    dispatch(event, ...args) {
        let result = true;
        if (event && event.active && !this._stopPropagation) {
            let h = event.handlers.slice(0), i = h.length;
            while (i--) {
                if (h[i](...args) === false) {
                    result = false;
                }
            }
        }
        this._stopPropagation = false;
        return result;
    }
    /**
     * Brakes events propagation.
     * @public
     */
    stopPropagation() {
        this._stopPropagation = true;
    }
    /**
     * Removes all events.
     * @public
     */
    clear() {
        for (let i = 0; i < this._eventNames.length; i++) {
            let e = this[this._eventNames[i]];
            e.handlers.length = 0;
            e.handlers = [];
        }
        this._eventNames.length = 0;
        this._eventNames = [];
    }
}
Events.__counter__ = 0;

const VIEW_EVENTS = ["render"];
class View {
    constructor(options = {}) {
        this.__id = View.__counter__++;
        this.events = createEvents(VIEW_EVENTS);
        this.model = options.model || null;
        this.template = options.template || "";
        this.parent = options.parent || null;
        this._classList = options.classList || [];
        this.el = null;
    }
    static getHTML(template, params) {
        return stringTemplate(template, params);
    }
    static parseHTML(htmlStr) {
        return parseHTML(htmlStr);
    }
    static insertAfter(newNodes, referenceNode) {
        if (!Array.isArray(newNodes)) {
            newNodes = [newNodes];
        }
        for (let i = 0; i < newNodes.length; i++) {
            if (referenceNode.parentNode) {
                referenceNode.parentNode.insertBefore(newNodes[i], referenceNode.nextSibling);
            }
        }
        return newNodes;
    }
    static insertBefore(newNodes, referenceNode) {
        if (!Array.isArray(newNodes)) {
            newNodes = [newNodes];
        }
        for (let i = 0; i < newNodes.length; i++) {
            if (referenceNode.parentNode) {
                referenceNode.parentNode.insertBefore(newNodes[i], referenceNode);
            }
        }
        return newNodes;
    }
    insertBefore(view) {
        if (!this.el) {
            this.render();
        }
        if (this.el) {
            if (view instanceof HTMLElement && view.parentNode) {
                View.insertBefore(this.el, view);
            }
            if (view instanceof View && view.el && view.el.parentNode) {
                View.insertBefore(this.el, view.el);
            }
        }
    }
    insertAfter(view) {
        if (!this.el) {
            this.render();
        }
        if (this.el) {
            if (view instanceof HTMLElement && view.parentNode) {
                View.insertAfter(this.el, view);
            }
            if (view instanceof View && view.el && view.el.parentNode) {
                View.insertAfter(this.el, view.el);
            }
        }
    }
    isEqual(view) {
        return view.__id === this.__id;
    }
    appendTo(node, clean = false, firstPosition = false) {
        if (node) {
            if (!this.el) {
                this.beforeRender(node);
                this.render();
            }
            if (this.el && this.el.parentNode) {
                this.el.parentNode.removeChild(this.el);
            }
            if (clean) {
                node.innerHTML = "";
            }
            if (this.el) {
                if (firstPosition) {
                    if (node.childNodes[0]) {
                        View.insertBefore(this.el, node.childNodes[0]);
                    }
                    else {
                        node.appendChild(this.el);
                    }
                }
                else {
                    node.appendChild(this.el);
                }
            }
            this.afterRender(node);
        }
        return this;
    }
    afterRender(parentNode) {
    }
    beforeRender(parentNode) {
    }
    stopPropagation() {
        this.events.stopPropagation();
    }
    renderTemplate(params) {
        return View.parseHTML(View.getHTML(this.template, params || {}))[0];
    }
    render(params) {
        this.el = this.renderTemplate(params);
        for (let i = 0, len = this._classList.length; i < len; i++) {
            this.el.classList.add(this._classList[i]);
        }
        this.events.dispatch(this.events.render, this);
        return this;
    }
    select(queryStr) {
        if (this.el) {
            return this.el.querySelector(queryStr);
        }
        return null;
    }
    selectRemove(queryStr) {
        if (this.el) {
            let r = this.select(queryStr);
            if (r && r.parentNode) {
                r.parentNode.removeChild(r);
                return r;
            }
        }
    }
    selectAll(queryStr, callback) {
        if (this.el) {
            const res = this.el.querySelectorAll(queryStr);
            if (callback) {
                for (let i = 0, len = res.length; i < len; i++) {
                    callback(res[i], i);
                }
            }
            return res;
        }
    }
    remove() {
        if (this.el && this.el.parentNode) {
            this.el.parentNode.removeChild(this.el);
        }
    }
}
View.__counter__ = 0;

const TEMPLATE$d = `<div class="og-button" title="{title}">
       <div class="og-button-icon">{icon}</div>
       <div class="og-button-text">{text}</div>
    </div>`;
const BUTTON_EVENTS = ["click", "mousedown", "mouseup", "touchstart", "touchend", "touchcancel"];
class Button extends View {
    constructor(options = {}) {
        super({
            template: stringTemplate(TEMPLATE$d, {
                icon: options.icon || "",
                text: options.text || "",
                title: options.title || ""
            }),
            ...options
        });
        this._onMouseDown = (e) => {
            e.preventDefault();
            this.events.dispatch(this.events.mousedown, this, e);
        };
        this._onMouseUp = (e) => {
            e.preventDefault();
            this.events.dispatch(this.events.mouseup, this, e);
        };
        this._onTouchStart = (e) => {
            e.preventDefault();
            this.events.dispatch(this.events.touchstart, this, e);
        };
        this._onTouchEnd = (e) => {
            e.preventDefault();
            this.events.dispatch(this.events.touchend, this, e);
        };
        this._onTouchCancel = (e) => {
            e.preventDefault();
            this.events.dispatch(this.events.touchcancel, this, e);
        };
        this._onMouseClick = (e) => {
            this._mouseClickHandler(e);
        };
        //@ts-ignore
        this.events = this.events.registerNames(BUTTON_EVENTS);
        this.el = null;
        this.name = options.name || "";
        this.$icon = null;
        this.$text = null;
    }
    render(params) {
        super.render(params);
        this.$icon = this.select(".og-button-icon");
        this.$text = this.select(".og-button-text");
        this.el.__og_button__ = this;
        this._initEvents();
        return this;
    }
    _initEvents() {
        if (this.el) {
            this.el.addEventListener("click", this._onMouseClick);
            this.el.addEventListener("mousedown", this._onMouseDown);
            this.el.addEventListener("mouseup", this._onMouseUp);
            this.el.addEventListener("touchstart", this._onTouchStart);
            this.el.addEventListener("touchend", this._onTouchEnd);
            this.el.addEventListener("touchcancel", this._onTouchCancel);
        }
    }
    _mouseClickHandler(e) {
        e.preventDefault();
        this.events.dispatch(this.events.click, this, e);
    }
    remove() {
        this._clearEvents();
        super.remove();
    }
    _clearEvents() {
        this.el && this.el.removeEventListener("click", this._onMouseClick);
    }
}

/**
 * Base control class. All other controls extend from this class.
 * @class Control
 * @param {Boolean} [options.autoActivate=true] - If true - calls initialize function after the renderer assigning.
 */
class Control {
    constructor(options = {}) {
        this.__id = Control.__counter__++;
        this._name = options.name || `_control_${this.__id.toString()}`;
        this.planet = null;
        this._initialized = false;
        this.renderer = null;
        this.autoActivate = options.autoActivate || false;
        this._active = false;
        this._deferredActive = true;
    }
    /**
     * Returns control name.
     * @public
     * @return {string} -
     */
    get name() {
        return this._name;
    }
    /**
     * Control initialization function have to be overridden.
     * @public
     */
    oninit() {
    }
    /**
     * Control renderer assigning function have to be overridden.
     * @public
     */
    onadd() {
    }
    /**
     * Control remove function have to be overridden.
     * @public
     */
    onremove() {
    }
    /**
     * Control activation function have to be overridden.
     * @public
     */
    onactivate() {
    }
    /**
     * Control deactivation function have to be overriden.
     * @public
     */
    ondeactivate() {
    }
    /**
     * Assign renderer to the control.
     * @public
     * @type {Renderer}
     */
    addTo(renderer) {
        if (renderer) {
            this.renderer = renderer;
            renderer.controls[this.name] = this;
            this.onadd && this.onadd();
            if (renderer.isInitialized()) {
                this._initialized = true;
                this.oninit && this.oninit();
                if (this.autoActivate) {
                    this.activate();
                }
            }
        }
    }
    /**
     * Removes control.
     * @public
     */
    remove() {
        this.deactivate();
        this.onremove && this.onremove();
        let r = this.renderer, n = this.name;
        if (!r)
            return;
        let c = r.controls[n];
        if (c) {
            if (this.isEqual(c)) {
                delete r.controls[n];
            }
        }
        this.renderer = null;
        this._active = false;
        this._initialized = false;
    }
    /**
     * Activate control.
     * @public
     */
    activate() {
        if (!this._active) {
            if (!this._initialized) {
                this._initialized = true;
                this.oninit && this.oninit();
            }
            if (this._deferredActive) {
                this._active = true;
                this.onactivate && this.onactivate();
            }
            else {
                this._deferredActive = true;
            }
        }
    }
    /**
     * Deactivate control.
     * @public
     */
    deactivate() {
        if (this._active) {
            this._active = false;
            this.ondeactivate && this.ondeactivate();
        }
        else if (!this._initialized) {
            this._deferredActive = false;
        }
    }
    /**
     * Is control active.
     * @public
     */
    isActive() {
        return this._active;
    }
    isEqual(control) {
        return control.__id === this.__id;
    }
}
Control.__counter__ = 0;

const ICON_BUTTON_SVG$9 = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   viewBox="0 0 110.6 110.3"
   version="1.1"
   id="svg21"
   sodipodi:docname="aaa.svg"
   inkscape:version="0.92.3 (2405546, 2018-03-11)">
  <metadata
     id="metadata11">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <defs
     id="defs25" />
  <sodipodi:namedview
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1"
     objecttolerance="10"
     gridtolerance="10"
     guidetolerance="10"
     inkscape:pageopacity="0"
     inkscape:pageshadow="2"
     inkscape:window-width="1920"
     inkscape:window-height="1001"
     id="namedview23"
     showgrid="false"
     inkscape:zoom="9.4900968"
     inkscape:cx="28.376998"
     inkscape:cy="60.17054"
     inkscape:window-x="-9"
     inkscape:window-y="-9"
     inkscape:window-maximized="1"
     inkscape:current-layer="svg21" />
  <g
     id="Layer_2"
     data-name="Layer 2"
     transform="matrix(1,0,0,-1,0,110.3)">
    <g
       id="–°–ª–æ–π_1"
       data-name="–°–ª–æ–π 1">
      <g
         id="_Group_"
         data-name="&lt;Group&gt;">
        <g
           id="_Group_7"
           data-name="&lt;Group&gt;">
          <polygon
             id="_Path_7"
             data-name="&lt;Path&gt;"
             points="55.2,97.6 55.3,97.4 55.3,97.6 55.3,97.2 65.3,55.1 55.3,55.1 55.2,55.1 45.3,55.1 55.2,97.2 "
             style="fill:#ff2b45" />
          <polygon
             id="_Path_8"
             data-name="&lt;Path&gt;"
             points="55.3,12.7 55.3,12.9 55.2,12.7 55.2,13.1 45.3,55.1 55.2,55.1 55.3,55.1 65.3,55.1 55.3,13.1 "
             style="fill:#cecece;" />
        </g>
      </g>
    </g>
  </g>
</svg>`;
/**
 * Planet compass button
 */
class CompassButton extends Control {
    constructor(options = {}) {
        super(options);
        this._heading = 0;
        this._svg = null;
    }
    oninit() {
        let btn = new Button({
            classList: ["og-map-button", "og-compass-button"],
            icon: ICON_BUTTON_SVG$9
        });
        btn.appendTo(this.renderer.div);
        btn.events.on("click", this._onClick, this);
        this._svg = btn.select("svg");
        this.renderer.events.on("draw", this._draw, this);
    }
    _onClick() {
        const planet = this.planet;
        let c = planet.getCartesianFromPixelTerrain(this.renderer.handler.getCenter());
        if (c) {
            planet.flyCartesian(c.normal().scaleTo(c.length() + c.distance(planet.camera.eye)), null, null, 0, null, null, () => {
                planet.camera.look(c);
            });
        }
        else {
            planet.flyCartesian(planet.camera.eye);
        }
    }
    _draw() {
        this.setHeading(this.planet.camera.getHeading());
    }
    setHeading(heading) {
        if (this._heading !== heading) {
            this._heading = heading;
            this._svg.style.transform = `rotateZ(${-heading}deg)`;
        }
    }
}

const CLOSE_ICON = `<svg className="svg-icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor; overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <path d="M777.856 280.192l-33.92-33.952-231.872 231.872-231.84-231.872-33.984 33.888 231.872 231.904-231.84 231.84 33.888 33.984 231.904-231.904 231.84 231.872 33.952-33.888-231.872-231.904z"/>
</svg>`;

const DIALOG_EVENTS = ["resize", "focus", "visibility", "dragstart", "dragend"];
const TEMPLATE$c = `<div class="og-ddialog" 
        style="display:{display}; resize:{resize}; width: {width}px; {height}; top: {top}px; left: {left}px; min-height: {minHeight}; max-height: {maxHeight}; min-width: {minWidth}; max-width: {maxWidth};">
       <div class="og-ddialog-header">
         <div class="og-ddialog-header__title">{title}</div>      
         <div class="og-ddialog-header__buttons"></div>      
        </div>
       <div class="og-ddialog-container"></div>
    </div>>`;
class Dialog extends View {
    constructor(options = {}) {
        super({
            template: stringTemplate(TEMPLATE$c, {
                title: options.title || "",
                display: getDefault(options.visible, true) ? "flex" : "none",
                resize: getDefault(options.resizable, true) ? "both" : "none",
                width: options.width || 300,
                height: options.height ? `height: ${options.height || 200}px` : "",
                left: options.left || 0,
                top: options.top || 0,
                minHeight: options.minHeight ? `${options.minHeight}px` : 'unset',
                maxHeight: options.maxHeight ? `${options.maxHeight}px` : 'unset',
                minWidth: options.minWidth ? `${options.minWidth}px` : 'unset',
                maxWidth: options.maxWidth ? `${options.maxWidth}px` : 'unset',
            }),
            ...options
        });
        this._onCloseBtnClick = () => {
            this.close();
        };
        this._onMouseDownAll = () => {
            this.bringToFront();
        };
        this._onMouseDown = (e) => {
            e.preventDefault();
            this._startDragging();
            this._startPosX = e.clientX;
            this._startPosY = e.clientY;
            document.addEventListener("mousemove", this._onMouseMove);
            document.addEventListener("mouseup", this._onMouseUp);
        };
        this._onMouseMove = (e) => {
            e.preventDefault();
            let dx = this._startPosX - e.clientX;
            let dy = this._startPosY - e.clientY;
            this._startPosX = e.clientX;
            this._startPosY = e.clientY;
            this.setPosition(this.el.offsetLeft - dx, this.el.offsetTop - dy);
        };
        this._onMouseUp = () => {
            this._clearDragging();
            document.removeEventListener("mouseup", this._onMouseUp);
            document.removeEventListener("mousemove", this._onMouseMove);
        };
        //@ts-ignore
        this.events = this.events.registerNames(DIALOG_EVENTS);
        this._startPosX = 0;
        this._startPosY = 0;
        this.$header = null;
        this.$title = null;
        this.$container = null;
        this.$buttons = null;
        this._closeBtn = new Button({
            icon: CLOSE_ICON,
            classList: ["og-button-size__20"]
        });
        this.useHide = options.useHide || false;
        this._visibility = getDefault(options.visible, true);
    }
    setContainer(htmlStr) {
        this.$container.innerHTML = htmlStr;
    }
    get container() {
        return this.$container;
    }
    get width() {
        return this.el ? parseFloat(this.el.style.width) : 0;
    }
    get height() {
        return this.el ? parseFloat(this.el.style.height) : 0;
    }
    bringToFront() {
        this.el.style.zIndex = String(Dialog.__zIndex__++);
    }
    render(params) {
        super.render(params);
        this.bringToFront();
        this.$header = this.select(".og-ddialog-header");
        this.$title = this.select(".og-ddialog-header__title");
        this.$container = this.select(".og-ddialog-container");
        this.$buttons = this.select(".og-ddialog-header__buttons");
        this._initEvents();
        this._initButtons();
        return this;
    }
    show() {
        if (!this._visibility) {
            this._visibility = true;
            this.el.style.display = "flex";
            this.bringToFront();
            this.events.dispatch(this.events.visibility, true, this);
        }
    }
    hide() {
        if (this._visibility) {
            this._visibility = false;
            this.el.style.display = "none";
            this.events.dispatch(this.events.visibility, false, this);
        }
    }
    close() {
        if (this.useHide) {
            this.hide();
        }
        else {
            this.remove();
        }
    }
    setVisibility(visibility) {
        if (visibility) {
            this.show();
        }
        else {
            this.hide();
        }
    }
    _initButtons() {
        this._closeBtn.events.on("click", this._onCloseBtnClick);
        this._closeBtn.appendTo(this.$buttons);
    }
    _initEvents() {
        this.$header.addEventListener("mousedown", this._onMouseDown);
        this.el.addEventListener("mousedown", this._onMouseDownAll);
    }
    setPosition(x, y) {
        if (x != undefined) {
            this.el.style.left = `${x}px`;
        }
        if (y != undefined) {
            this.el.style.top = `${y}px`;
        }
    }
    _startDragging() {
        if (!this.el.classList.contains("dragging")) {
            this.el.classList.add("dragging");
            this.events.dispatch(this.events.dragstart, this);
        }
    }
    _clearDragging() {
        if (this.el.classList.contains("dragging")) {
            this.events.dispatch(this.events.dragend, this);
            this.el.classList.remove("dragging");
        }
    }
    remove() {
        this._clearDragging();
        this._clearEvents();
        super.remove();
    }
    _clearEvents() {
        this._closeBtn.events.off("click", this._onCloseBtnClick);
        document.removeEventListener("mouseup", this._onMouseUp);
        document.removeEventListener("mousemove", this._onMouseMove);
        this.$header.removeEventListener("mousedown", this._onMouseDown);
        this.el.removeEventListener("mousedown", this._onMouseDownAll);
    }
}
Dialog.__zIndex__ = 0;

const TOGGLEBUTTON_EVENTS = ["change"];
class ToggleButton extends Button {
    constructor(options) {
        super({
            ...options
        });
        this._onMouseClick = (e) => {
            if (!this.preventClick) {
                this._mouseClickHandler(e);
                this.setActive(!this.isActive);
            }
        };
        //@ts-ignore
        this.events = this.events.registerNames(TOGGLEBUTTON_EVENTS);
        this._isActive = options.isActive || false;
        this.preventClick = options.preventClick || false;
    }
    setActive(isActive, stopPropagation = false) {
        if (isActive !== this._isActive) {
            this._isActive = isActive;
            this._toggle();
            if (!stopPropagation) {
                this.events.dispatch(this.events.change, isActive, this);
            }
        }
    }
    _toggle() {
        this.el && this.el.classList.toggle("og-button__active");
    }
    get isActive() {
        return this._isActive;
    }
    render(params) {
        super.render(params);
        if (this._isActive) {
            this._toggle();
        }
        return this;
    }
}

const VISIBLE_DISTANCE = 3570.0;
const MAX_RENDERED_NODES = 1000;
const NW = 0;
const NE = 1;
const SW = 2;
const SE = 3;
const N = 0;
const E = 1;
const S = 2;
const W = 3;
const NOTRENDERING = 0;
const RENDERING = 1;
const WALKTHROUGH = 2;
/**
 * World opposite side table.
 */
const OPSIDE = [S, W, N, E];
/**
 * First index is {N,E,S,W} and second is {NW,NE,SW,SE}
 */
const NEIGHBOUR = [
    [-1, -1, NW, NE],
    [NE, -1, SE, -1],
    [SW, SE, -1, -1],
    [-1, NW, -1, SW]
];
/**
 * Neighbor's oposite part. For example oposite side
 * on the east neighbor side is: [S][SE] = NE
 */
const OPPART = [
    [SW, SE, NW, NE],
    [NE, NW, SE, SW],
    [SW, SE, NW, NE],
    [NE, NW, SE, SW]
];
/**
 * Gets segment part left to right or up to downo ffset against neighbour side.
 * Where 0 - no offset 1 - half segment size offset.
 */
const PARTOFFSET = [
    /*     N  E  S  W */
    /*NW*/ [0, 1, 0, 0],
    /*NE*/ [1, 0, 0, 0],
    /*SW*/ [0, 1, 0, 1],
    /*SE*/ [1, 1, 1, 1]
];

/**
 * @class Material
 * @param {Segment} segment
 * @param {Layer} layer
 */
class Material {
    constructor(segment, layer) {
        this.segment = segment;
        this.layer = layer;
        this.isReady = false;
        this.isLoading = false;
        this.texture = null;
        this.pickingMask = null;
        this.textureExists = false;
        this.appliedNodeId = 0;
        this.appliedNode = null;
        this.texOffset = [0.0, 0.0, 1.0, 1.0];
        this.loadingAttempts = 0;
        this._updateTexture = null;
        this._updatePickingMask = null;
        this.pickingReady = false;
    }
    abortLoading() {
        this.layer.abortMaterialLoading(this);
    }
    _createTexture(img) {
        return this.layer._planet && this.layer.createTexture(img, this.layer._internalFormat, this.isReady ? this.texture : null);
    }
    applyImage(img) {
        if (this.segment.initialized) {
            this._updateTexture = null;
            //this.image = img;
            this.texture = this._createTexture(img);
            this.isReady = true;
            this.pickingReady = true;
            this.textureExists = true;
            this.isLoading = false;
            this.appliedNodeId = this.segment.node.nodeId;
            this.texOffset = [0.0, 0.0, 1.0, 1.0];
        }
    }
    applyTexture(texture, pickingMask) {
        if (this.segment.initialized) {
            this.texture = texture;
            this._updateTexture = null;
            this.pickingMask = pickingMask || null;
            this._updatePickingMask = null;
            this.isReady = true;
            this.pickingReady = true;
            this.textureExists = true;
            this.isLoading = false;
            this.appliedNodeId = this.segment.node.nodeId;
            this.texOffset = [0.0, 0.0, 1.0, 1.0];
        }
    }
    textureNotExists() {
        if (this.segment.initialized) {
            this.pickingReady = true;
            this.isLoading = false;
            this.isReady = true;
            this.textureExists = false;
        }
    }
    clear() {
        this.loadingAttempts = 0;
        this.layer.clearMaterial(this);
    }
}

const FADING_RATIO = 30;
/**
 * @class
 * Base class; normally only used for creating subclasses and not instantiated in apps.
 * A visual representation of raster or vector map data well known as a layer.
 * @class
 * @param {String} [name="noname"] - Layer name.
 * @param {Object} [options] - Layer options:
 * @param {number} [options.opacity=1.0] - Layer opacity.
 * @param {number} [options.minZoom=0] - Minimal visibility zoom level.
 * @param {number} [options.maxZoom=0] - Maximal visibility zoom level.
 * @param {string} [options.attribution] - Layer attribution that displayed in the attribution area on the screen.
 * @param {boolean} [options.isBaseLayer=false] - This is a base layer.
 * @param {boolean} [options.visibility=true] - Layer visibility.
 * @param {boolean} [options.hideInLayerSwitcher=false] - Presence of layer in dialog window of LayerSwitcher control.
 * @param {boolean} [options.isSRGB=false] - Layer image webgl internal format.
 * @param {Extent} [options.extent=[[-180.0, -90.0], [180.0, 90.0]]] - Visible extent.
 * @param {string} [options.textureFilter="anisotropic"] - Image texture filter. Available values: "nearest", "linear", "mipmap" and "anisotropic".
 * @param {string} [options.icon] - Icon for LayerSwitcher
 * @fires EventsHandler<LayerEventsList>#visibilitychange
 * @fires EventsHandler<LayerEventsList>#add
 * @fires EventsHandler<LayerEventsList>#remove
 * @fires EventsHandler<LayerEventsList>#mousemove
 * @fires EventsHandler<LayerEventsList>#mouseenter
 * @fires EventsHandler<LayerEventsList>#mouseleave
 * @fires EventsHandler<LayerEventsList>#lclick
 * @fires EventsHandler<LayerEventsList>#rclick
 * @fires EventsHandler<LayerEventsList>#mclick
 * @fires EventsHandler<LayerEventsList>#ldblclick
 * @fires EventsHandler<LayerEventsList>#rdblclick
 * @fires EventsHandler<LayerEventsList>#mdblclick
 * @fires EventsHandler<LayerEventsList>#lup
 * @fires EventsHandler<LayerEventsList>#rup
 * @fires EventsHandler<LayerEventsList>#mup
 * @fires EventsHandler<LayerEventsList>#ldown
 * @fires EventsHandler<LayerEventsList>#rdown
 * @fires EventsHandler<LayerEventsList>#mdown
 * @fires EventsHandler<LayerEventsList>#lhold
 * @fires EventsHandler<LayerEventsList>#rhold
 * @fires EventsHandler<LayerEventsList>#mhold
 * @fires EventsHandler<LayerEventsList>#mousewheel
 * @fires EventsHandler<LayerEventsList>#touchmove
 * @fires EventsHandler<LayerEventsList>#touchstart
 * @fires EventsHandler<LayerEventsList>#touchend
 * @fires EventsHandler<LayerEventsList>#doubletouch
 */
class Layer {
    constructor(name, options = {}) {
        this.isVector = false;
        this.__id = Layer.__counter__++;
        this._iconSrc = options.iconSrc || null;
        this.events = createEvents(LAYER_EVENTS, this);
        this.name = name || "noname";
        this.properties = options.properties || {};
        this.hideInLayerSwitcher = options.hideInLayerSwitcher || false;
        this._hasImageryTiles = true;
        this._opacity = options.opacity != undefined ? options.opacity : 1.0;
        this.minZoom = options.minZoom || 0;
        this.maxZoom = options.maxZoom != undefined ? options.maxZoom : 50;
        this._planet = null;
        this.isVector = false;
        this._attribution = options.attribution || "";
        this._zIndex = options.zIndex || 0;
        this._isBaseLayer = options.isBaseLayer || false;
        this._defaultTextures = options.defaultTextures || [null, null];
        this._visibility = options.visibility !== undefined ? options.visibility : true;
        this._fading = options.fading || false;
        this._fadingFactor = this._opacity / FADING_RATIO;
        if (this._fading) {
            this._fadingOpacity = 0;
        }
        else {
            this._fadingOpacity = this._opacity;
        }
        this._height = options.height || 0;
        this._extent = new Extent();
        this.createTexture = null;
        this._textureFilter = options.textureFilter ? options.textureFilter.trim().toUpperCase() : "MIPMAP";
        this._isSRGB = options.isSRGB != undefined ? options.isSRGB : false;
        this._internalFormat = null;
        this._extentMerc = new Extent();
        // Setting the extent up
        this.setExtent(createExtent(options.extent, new Extent(new LonLat(-180, -90), new LonLat(180, 90))));
        /**
         * Layer picking color. Assign when added to the planet.
         * @protected
         * @type {Vec3}
         */
        this._pickingColor = new Vec3();
        this._pickingEnabled = options.pickingEnabled !== undefined ? options.pickingEnabled : true;
        this._isPreloadDone = false;
        this._preLoadZoomLevels = options.preLoadZoomLevels || [0, 1];
        this._ambient = null;
        this._diffuse = null;
        this._specular = null;
        if (options.ambient) {
            let a = createColorRGB(options.ambient, new Vec3(0.2, 0.2, 0.2));
            this._ambient = new Float32Array([a.x, a.y, a.z]);
        }
        if (options.diffuse) {
            let d = createColorRGB(options.diffuse, new Vec3(0.8, 0.8, 0.8));
            this._diffuse = new Float32Array([d.x, d.y, d.z]);
        }
        if (options.specular) {
            let s = createColorRGB(options.specular, new Vec3(0.0003, 0.0003, 0.0003));
            let shininess = options.shininess || 20.0;
            this._specular = new Float32Array([s.x, s.y, s.z, shininess]);
        }
        this.nightTextureCoefficient = options.nightTextureCoefficient || 1.0;
    }
    get iconSrc() {
        return this._iconSrc;
    }
    set iconSrc(src) {
        // @todo: add event
        this._iconSrc = src;
    }
    set diffuse(rgb) {
        if (rgb) {
            let vec = createColorRGB(rgb);
            this._diffuse = new Float32Array(vec.toArray());
        }
        else {
            this._diffuse = null;
        }
    }
    set ambient(rgb) {
        if (rgb) {
            let vec = createColorRGB(rgb);
            this._ambient = new Float32Array(vec.toArray());
        }
        else {
            this._ambient = null;
        }
    }
    set specular(rgb) {
        if (rgb) {
            let vec = createColorRGB(rgb);
            this._specular = new Float32Array([vec.x, vec.y, vec.y, this._specular ? this._specular[3] : 0.0]);
        }
        else {
            this._specular = null;
        }
    }
    set shininess(v) {
        if (this._specular) {
            this._specular[3] = v;
        }
    }
    // get normalMapCreator() {
    //     return this._normalMapCreator;
    // }
    static getTMS(x, y, z) {
        return {
            x: x,
            y: (1 << z) - y - 1,
            z: z
        };
    }
    static getTileIndex(x, y, z, tileGroup) {
        return `${tileGroup}::${x}_${y}_${z}`;
    }
    get instanceName() {
        return "Layer";
    }
    get rendererEvents() {
        return this.events;
    }
    set opacity(opacity) {
        if (opacity !== this._opacity) {
            if (this._fading) {
                if (opacity > this._opacity) {
                    this._fadingFactor = (opacity - this._opacity) / FADING_RATIO;
                }
                else if (opacity < this._opacity) {
                    this._fadingFactor = (this._opacity - opacity) / FADING_RATIO;
                }
            }
            else {
                this._fadingOpacity = opacity;
            }
            this._opacity = opacity;
        }
    }
    set pickingEnabled(picking) {
        this._pickingEnabled = picking;
    }
    get pickingEnabled() {
        return this._pickingEnabled;
    }
    /**
     * Returns true if a layer has imagery tiles.
     * @public
     * @virtual
     * @returns {boolean} - Imagery tiles flag.
     */
    hasImageryTiles() {
        return this._hasImageryTiles;
    }
    /**
     * Gets layer identifier.
     * @public
     * @returns {string} - Layer object id.
     */
    getID() {
        return this.__id;
    }
    get id() {
        return this.__id;
    }
    /**
     * @todo: remove after all
     */
    get _id() {
        return this.__id;
    }
    /**
     * Compares layers instances.
     * @public
     * @param {Layer} layer - Layer instance to compare.
     * @returns {boolean} - Returns true if the layers is the same instance of the input.
     */
    isEqual(layer) {
        return layer.__id === this.__id;
    }
    /**
     * Assign the planet.
     * @protected
     * @virtual
     * @param {Planet} planet - Planet render node.
     */
    _assignPlanet(planet) {
        this._planet = planet;
        planet._layers.push(this);
        if (planet.renderer && planet.renderer.isInitialized()) {
            // TODO: webgl1
            if (this._isSRGB) {
                this._internalFormat = planet.renderer.handler.gl.SRGB8_ALPHA8;
            }
            else {
                this._internalFormat = planet.renderer.handler.gl.RGBA8;
            }
            this.createTexture = planet.renderer.handler.createTexture[this._textureFilter];
            this.events.on("visibilitychange", planet._onLayerVisibilityChanged, planet);
            if (this._isBaseLayer && this._visibility) {
                planet.setBaseLayer(this);
            }
            planet.events.dispatch(planet.events.layeradd, this);
            this.events.dispatch(this.events.add, planet);
            planet.updateVisibleLayers();
            this._bindPicking();
            if (this._visibility && this.hasImageryTiles()) {
                this._preLoad();
            }
        }
    }
    get isIdle() {
        return this._planet && this._planet._terrainCompletedActivated || false;
    }
    /**
     * Assign picking color to the layer.
     * @protected
     * @virtual
     */
    _bindPicking() {
        this._planet && this._planet.renderer && this._planet.renderer.assignPickingColor(this);
    }
    /**
     * Adds layer to the planet.
     * @public
     * @param {Planet} planet - Adds layer to the planet.
     */
    addTo(planet) {
        if (!this._planet) {
            this._assignPlanet(planet);
        }
    }
    /**
     * Removes from planet.
     * @public
     * @returns {Layer} -This layer.
     */
    remove() {
        let p = this._planet;
        if (p) {
            //TODO: replace to planet
            for (let i = 0; i < p._layers.length; i++) {
                if (this.isEqual(p._layers[i])) {
                    p.renderer && p.renderer.clearPickingColor(this);
                    p._layers.splice(i, 1);
                    p.updateVisibleLayers();
                    this.clear();
                    p.events.dispatch(p.events.layerremove, this);
                    this.events.dispatch(this.events.remove, p);
                    this._planet = null;
                    this._internalFormat = null;
                    this.createTexture = null;
                    return this;
                }
            }
        }
        return this;
    }
    /**
     * Clears layer material.
     * @virtual
     */
    clear() {
        if (this._planet) {
            this._planet._clearLayerMaterial(this);
        }
    }
    /**
     * Returns planet instance.
     */
    get planet() {
        return this._planet;
    }
    /**
     * Sets layer attribution text.
     * @public
     * @param {string} html - HTML code that represents layer attribution, it could be just a text.
     */
    setAttribution(html) {
        if (this._attribution !== html) {
            this._attribution = html;
            this._planet && this._planet.updateAttributionsList();
        }
    }
    /**
     * Gets layer attribution.
     * @public
     * @returns {string} Layer attribution
     */
    getAttribution() {
        return this._attribution;
    }
    /**
     * Sets height over the ground.
     * @public
     * @param {number} height - Layer height.
     */
    setHeight(height) {
        this._height = height;
        this._planet && this._planet.updateVisibleLayers();
    }
    /**
     * Gets layer height.
     * @public
     * @returns {number} -
     */
    getHeight() {
        return this._height;
    }
    /**
     * Sets z-index.
     * @public
     * @param {number} zIndex - Layer z-index.
     */
    setZIndex(zIndex) {
        this._zIndex = zIndex;
        this._planet && this._planet.updateVisibleLayers();
    }
    /**
     * Gets z-index.
     * @public
     * @returns {number} -
     */
    getZIndex() {
        return this._zIndex;
    }
    /**
     * Set zIndex to the maximal value depend on other layers on the planet.
     * @public
     */
    bringToFront() {
        if (this._planet) {
            let vl = this._planet.visibleTileLayers;
            let l = vl[vl.length - 1];
            if (!l.isEqual(this)) {
                this.setZIndex(l.getZIndex() + 1);
            }
        }
    }
    /**
     * Returns true if the layer is a base.
     * @public
     * @returns {boolean} - Base layer flag.
     */
    isBaseLayer() {
        return this._isBaseLayer;
    }
    /**
     * Sets base layer type true.
     * @public
     * @param {boolean} isBaseLayer -
     */
    setBaseLayer(isBaseLayer) {
        this._isBaseLayer = isBaseLayer;
        if (this._planet) {
            if (!isBaseLayer && this._planet.baseLayer && this.isEqual(this._planet.baseLayer)) {
                this._planet.baseLayer = null;
            }
            this._planet.updateVisibleLayers();
        }
    }
    /**
     * Sets layer visibility.
     * @public
     * @virtual
     * @param {boolean} visibility - Layer visibility.
     */
    setVisibility(visibility) {
        if (visibility !== this._visibility) {
            this._visibility = visibility;
            if (this._planet) {
                if (this._isBaseLayer && visibility) {
                    this._planet.setBaseLayer(this);
                }
                this._planet.updateVisibleLayers();
                if (visibility && !this._isPreloadDone && !this.isVector) {
                    this._isPreloadDone = true;
                    this._preLoad();
                }
            }
            this.events.dispatch(this.events.visibilitychange, this);
        }
    }
    _forceMaterialApply(segment) {
        let pm = segment.materials, m = pm[this.__id];
        if (!m) {
            m = pm[this.__id] = this.createMaterial(segment);
        }
        if (!m.isReady) {
            this._planet._renderCompleted = false;
        }
        this.applyMaterial(m, true);
    }
    clearMaterial(material) {
        //empty
    }
    loadMaterial(material, forceLoading = false) {
        //empty
    }
    applyMaterial(m, isForced = false) {
        return [0, 0, 1, 1];
    }
    _preLoadRecursive(node, maxZoom) {
        if (node.segment.tileZoom > maxZoom) {
            return;
        }
        if (this._preLoadZoomLevels.includes(node.segment.tileZoom)) {
            this._forceMaterialApply(node.segment);
        }
        for (let i = 0, len = node.nodes.length; i < len; i++) {
            if (node.nodes[i]) {
                this._preLoadRecursive(node.nodes[i], maxZoom);
            }
        }
    }
    _preLoad() {
        if (this._planet && this._preLoadZoomLevels.length) {
            let p = this._planet, maxZoom = Math.max(...this._preLoadZoomLevels);
            for (let i = 0, len = p.quadTreeStrategy.quadTreeList.length; i < len; i++) {
                this._preLoadRecursive(p.quadTreeStrategy.quadTreeList[i], maxZoom);
            }
        }
    }
    /**
     * Gets layer visibility.
     * @public
     * @returns {boolean} - Layer visibility.
     */
    getVisibility() {
        return this._visibility;
    }
    /**
     * Sets visible geographical extent.
     * @public
     * @param {Extent} extent - Layer visible geographical extent.
     */
    setExtent(extent) {
        let sw = extent.southWest.clone(), ne = extent.northEast.clone();
        if (sw.lat < MIN_LAT) {
            sw.lat = MIN_LAT;
        }
        if (ne.lat > MAX_LAT) {
            ne.lat = MAX_LAT;
        }
        this._extent = extent.clone();
        this._extentMerc = new Extent(sw.forwardMercator(), ne.forwardMercator());
        this._correctFullExtent();
    }
    /**
     * Gets layer extent.
     * @public
     * @return {Extent} - Layer geodetic extent.
     */
    getExtent() {
        return this._extent;
    }
    /**
     * Gets layer web-mercator extent.
     * @public
     * @return {Extent} - Layer extent.
     */
    getExtentMerc() {
        return this._extentMerc;
    }
    /**
     * Fly extent.
     * @public
     */
    flyExtent() {
        this._planet?.flyExtent(this.getExtent());
    }
    /**
     * View extent.
     * @public
     */
    viewExtent() {
        this._planet?.viewExtent(this.getExtent());
    }
    /**
     * Special correction of the whole globe extent.
     * @protected
     */
    _correctFullExtent() {
        // var e = this._extent,
        //    em = this._extentMerc;
        // var ENLARGE_MERCATOR_LON = og.mercator.POLE + 50000;
        // var ENLARGE_MERCATOR_LAT = og.mercator.POLE + 50000;
        // if (e.northEast.lat === 90.0) {
        //    em.northEast.lat = ENLARGE_MERCATOR_LAT;
        // }
        // if (e.northEast.lon === 180.0) {
        //    em.northEast.lon = ENLARGE_MERCATOR_LON;
        // }
        // if (e.southWest.lat === -90.0) {
        //    em.southWest.lat = -ENLARGE_MERCATOR_LAT;
        // }
        // if (e.southWest.lon === -180.0) {
        //    em.southWest.lon = -ENLARGE_MERCATOR_LON;
        // }
    }
    get opacity() {
        return this._opacity;
    }
    get screenOpacity() {
        return this._fading ? this._fadingOpacity : this._opacity;
    }
    _refreshFadingOpacity() {
        let p = this._planet;
        if (this._visibility && p.getViewExtent().overlaps(this._extent) &&
            p.maxCurrZoom >= this.minZoom &&
            p.minCurrZoom <= this.maxZoom) {
            this._fadingOpacity += this._fadingFactor;
            if ((this._fadingFactor > 0.0 && this._fadingOpacity > this._opacity) ||
                (this._fadingFactor < 0.0 && this._fadingOpacity < this._opacity)) {
                this._fadingOpacity = this._opacity;
            }
            return false;
        }
        else {
            this._fadingOpacity -= this._fadingFactor;
            if (this._fadingOpacity <= 0) {
                this._fadingOpacity = 0.0;
            }
            return false;
        }
    }
    createMaterial(segment) {
        return new Material(segment, this);
    }
    redraw() {
        if (this._planet) {
            this._planet.quadTreeStrategy.clearLayerMaterial(this);
            // this._planet._quadTree.traverseTree((n: Node) => {
            //         if (n.segment.materials[this.__id]) {
            //             n.segment.materials[this.__id].clear();
            //         }
            //     }
            // );
            //
            // this._planet._quadTreeNorth.traverseTree((n: Node) => {
            //         if (n.segment.materials[this.__id]) {
            //             n.segment.materials[this.__id].clear();
            //         }
            //     }
            // );
            //
            // this._planet._quadTreeSouth.traverseTree((n: Node) => {
            //         if (n.segment.materials[this.__id]) {
            //             n.segment.materials[this.__id].clear();
            //         }
            //     }
            // );
        }
    }
    abortMaterialLoading(material) {
    }
    abortLoading() {
    }
}
Layer.__counter__ = 0;
const LAYER_EVENTS = [
    /**
     * Triggered when layer visibility changed.
     * @event og.Layer#visibilitychange
     */
    "visibilitychange",
    /**
     * Triggered when layer has added to the planet.
     * @event og.Layer#add
     */
    "add",
    /**
     * Triggered when layer has removed from the planet.
     * @event og.Layer#remove
     */
    "remove",
    /**
     * Triggered when mouse moves over the layer.
     * @event og.Layer#mousemove
     */
    "mousemove",
    /**
     * Triggered when mouse has entered over the layer.
     * @event og.Layer#mouseenter
     */
    "mouseenter",
    /**
     * Triggered when mouse leaves the layer.
     * @event og.Layer#mouseenter
     */
    "mouseleave",
    /**
     * Mouse left button clicked.
     * @event og.Layer#lclick
     */
    "lclick",
    /**
     * Mouse right button clicked.
     * @event og.Layer#rclick
     */
    "rclick",
    /**
     * Mouse right button clicked.
     * @event og.Layer#mclick
     */
    "mclick",
    /**
     * Mouse left button double click.
     * @event og.Layer#ldblclick
     */
    "ldblclick",
    /**
     * Mouse right button double click.
     * @event og.Layer#rdblclick
     */
    "rdblclick",
    /**
     * Mouse middle button double click.
     * @event og.Layer#mdblclick
     */
    "mdblclick",
    /**
     * Mouse left button up(stop pressing).
     * @event og.Layer#lup
     */
    "lup",
    /**
     * Mouse right button up(stop pressing).
     * @event og.Layer#rup
     */
    "rup",
    /**
     * Mouse middle button up(stop pressing).
     * @event og.Layer#mup
     */
    "mup",
    /**
     * Mouse left button is just pressed down(start pressing).
     * @event og.Layer#ldown
     */
    "ldown",
    /**
     * Mouse right button is just pressed down(start pressing).
     * @event og.Layer#rdown
     */
    "rdown",
    /**
     * Mouse middle button is just pressed down(start pressing).
     * @event og.Layer#mdown
     */
    "mdown",
    /**
     * Mouse left button is pressing.
     * @event og.Layer#lhold
     */
    "lhold",
    /**
     * Mouse right button is pressing.
     * @event og.Layer#rhold
     */
    "rhold",
    /**
     * Mouse middle button is pressing.
     * @event og.Layer#mhold
     */
    "mhold",
    /**
     * Mouse wheel is rotated.
     * @event og.Layer#mousewheel
     */
    "mousewheel",
    /**
     * Triggered when touching moves over the layer.
     * @event og.Layer#touchmove
     */
    "touchmove",
    /**
     * Triggered when layer begins to touch.
     * @event og.Layer#touchstart
     */
    "touchstart",
    /**
     * Triggered when layer has finished touching.
     * @event og.Layer#touchend
     */
    "touchend",
    /**
     * Triggered layer has double touched.
     * @event og.Layer#doubletouch
     */
    "doubletouch",
    /**
     * Triggered when touching leaves layer borders.
     * @event og.Layer#touchleave
     */
    "touchleave",
    /**
     * Triggered when touch enters over the layer.
     * @event og.Layer#touchenter
     */
    "touchenter"
];

const CANVASTILES_EVENTS = [
    /**
     * Triggered when current tile image has loaded before rendering.
     * @event og.layer.CanvasTiles#load
     */
    "load",
    /**
     * Triggered when all tiles have loaded or loading has stopped.
     * @event og.layer.CanvasTiles#loadend
     */
    "loadend"
];
/**
 * Layer used to rendering each tile as a separate canvas object.
 * @class
 * @extends {Layer}
 * @param {String} [name="noname"] - Layer name.
 * @param {ICanvasTilesParams} options:
 * @param {number} [options.opacity=1.0] - Layer opacity.
 * @param {number} [options.minZoom=0] - Minimal visibility zoom level.
 * @param {number} [options.maxZoom=0] - Maximal visibility zoom level.
 * @param {string} [options.attribution] - Layer attribution that displayed in the attribution area on the screen.
 * @param {boolean} [options.isBaseLayer=false] - Base layer flag.
 * @param {boolean} [options.visibility=true] - Layer visibility.
 * @param {DrawTileCallback} options.drawTile - Draw tile callback.
 * @fires EventsHandler<CanvasTilesEventsList>#load
 * @fires EventsHandler<CanvasTilesEventsList>#loadend
 */
class CanvasTiles extends Layer {
    constructor(name, options) {
        super(name, options);
        //@ts-ignore
        this.events = this.events.registerNames(CANVASTILES_EVENTS);
        this.animated = options.animated || false;
        this.minNativeZoom = options.minNativeZoom || 0;
        this.maxNativeZoom = options.maxNativeZoom || 100;
        this._counter = 0;
        this._pendingsQueue = []; // new og.QueueArray();
        this.drawTile = options.drawTile;
        this._onLoadend_ = null;
    }
    addTo(planet) {
        this._onLoadend_ = this._onLoadend.bind(this);
        this.events.on("loadend", this._onLoadend_, this);
        return super.addTo(planet);
    }
    remove() {
        this.events.off("loadend", this._onLoadend_);
        this._onLoadend_ = null;
        return super.remove();
    }
    _onLoadend() {
        if (this._planet && this._planet._terrainCompletedActivated) {
            this._planet.events.dispatch(this._planet.events.layerloadend, this);
        }
    }
    get instanceName() {
        return "CanvasTiles";
    }
    get isIdle() {
        return super.isIdle && this._counter === 0;
    }
    /**
     * Abort loading tiles.
     * @public
     */
    abortLoading() {
        //const q = this._pendingsQueue;
        // for (let i = q._shiftIndex + 1; i < q._popIndex + 1; i++) {
        //     if (q._array[i]) {
        //         this.abortMaterialLoading(q._array[i]);
        //     }
        // }
        // this._pendingsQueue.clear();
        // for (let i = 0; i < q.length; i++) {
        //     this.abortMaterialLoading(q[i]);
        // }
        this._pendingsQueue.forEach((qi) => {
            this.abortMaterialLoading(qi);
        });
        this._pendingsQueue = [];
    }
    /**
     * Sets layer visibility.
     * @public
     * @param {boolean} visibility - Layer visibility.
     */
    setVisibility(visibility) {
        if (visibility !== this._visibility) {
            super.setVisibility(visibility);
            if (!visibility) {
                this.abortLoading();
            }
        }
    }
    /**
     * Start to load tile material.
     * @public
     * @virtual
     * @param {Material} material -
     */
    loadMaterial(material) {
        let seg = material.segment;
        if (this._isBaseLayer) {
            material.texture = seg._isNorth ? seg.planet.solidTextureOne : seg.planet.solidTextureTwo;
        }
        else {
            material.texture = seg.planet.transparentTexture;
        }
        if (this._planet.layerLock.isFree() || material.segment.tileZoom < 2) {
            material.isReady = false;
            material.isLoading = true;
            if (CanvasTiles.__requestsCounter >= CanvasTiles.MAX_REQUESTS && this._counter) {
                this._pendingsQueue.push(material);
            }
            else {
                this._exec(material);
            }
        }
    }
    /**
     * Loads material image and apply it to the planet segment.
     * @protected
     * @param {Material} material - Loads material image.
     */
    _exec(material) {
        CanvasTiles.__requestsCounter++;
        this._counter++;
        const e = this.events.load;
        if (e.handlers.length) {
            this.events.dispatch(e, material);
        }
        requestAnimationFrame(() => {
            this.drawTile(material, (canvas) => {
                this._counter--;
                CanvasTiles.__requestsCounter--;
                this._correctCounter();
                if (material.isLoading) {
                    material.applyImage(canvas);
                }
                this._dequeueRequest();
            });
        });
    }
    _correctCounter() {
        if (this._counter < 0)
            this._counter = 0;
        if (CanvasTiles.__requestsCounter < 0)
            CanvasTiles.__requestsCounter = 0;
    }
    /**
     * Abort exact material loading.
     * @public
     * @param {Material} material - Segment material.
     */
    abortMaterialLoading(material) {
        if (material.isLoading) {
            this._counter--;
            CanvasTiles.__requestsCounter--;
            this._correctCounter();
            this._dequeueRequest();
        }
        material.isLoading = false;
        material.isReady = false;
    }
    _dequeueRequest() {
        if (this._pendingsQueue.length) {
            if (CanvasTiles.__requestsCounter < CanvasTiles.MAX_REQUESTS) {
                const pmat = this._whilePendings();
                if (pmat) {
                    this._exec(pmat);
                }
            }
        }
        else if (this._counter === 0 && this._planet && this._planet._terrainCompletedActivated) {
            this.events.dispatch(this.events.loadend);
        }
    }
    _whilePendings() {
        while (this._pendingsQueue.length) {
            const pmat = this._pendingsQueue.pop();
            if (pmat && pmat.segment && pmat.segment.node) {
                if (pmat.segment.initialized && pmat.segment.node.getState() === RENDERING) {
                    return pmat;
                }
                pmat.isLoading = false;
            }
        }
        return null;
    }
    applyMaterial(material) {
        if (material.isReady) {
            // IMPORTANT!
            // Animated doesn't work withMaxNativeZoom
            // It could be fixed with call drawTile method only for parent
            // material (which is rendered on the current segment material),
            // just for one renderer frame
            if (material.layer.animated) {
                requestAnimationFrame(() => {
                    this.drawTile(material, function (canvas) {
                        material.applyImage(canvas);
                    });
                });
            }
            return material.texOffset;
        }
        else if (material.segment.tileZoom < this.minNativeZoom) {
            material.textureNotExists();
        }
        else {
            let segment = material.segment;
            let pn = segment.node, parentTextureExists = false;
            let maxNativeZoom = material.layer.maxNativeZoom;
            if (segment.passReady && !material.isLoading && segment.tileZoom <= maxNativeZoom) {
                this.loadMaterial(material);
            }
            let mId = this._id;
            let psegm = material;
            while (pn.parentNode) {
                pn = pn.parentNode;
                psegm = pn.segment.materials[mId];
                if (psegm && psegm.textureExists) {
                    parentTextureExists = true;
                    break;
                }
            }
            if (segment.passReady) {
                if (pn.segment.tileZoom === maxNativeZoom) {
                    if (segment.tileZoom > maxNativeZoom) {
                        material.textureNotExists();
                    }
                }
                else if (pn.segment.tileZoom < maxNativeZoom) {
                    let pn = segment.node;
                    while (pn.segment.tileZoom > maxNativeZoom) {
                        pn = pn.parentNode;
                    }
                    let pnm = pn.segment.materials[mId];
                    if (pnm) {
                        !pnm.isLoading && !pnm.isReady && this.loadMaterial(pnm);
                    }
                    else {
                        pnm = pn.segment.materials[material.layer._id] = material.layer.createMaterial(pn.segment);
                        this.loadMaterial(pnm);
                    }
                }
            }
            if (parentTextureExists) {
                //
                // Animated doesn't work withMaxNativeZoom
                //
                if (material.layer.animated) {
                    requestAnimationFrame(() => {
                        this.drawTile(material, function (canvas) {
                            material.applyImage(canvas);
                        });
                    });
                }
                material.appliedNodeId = pn.nodeId;
                material.texture = psegm.texture;
                let dZ2 = 1.0 / (2 << (segment.tileZoom - pn.segment.tileZoom - 1));
                material.texOffset[0] = segment.tileX * dZ2 - pn.segment.tileX;
                material.texOffset[1] = segment.tileY * dZ2 - pn.segment.tileY;
                material.texOffset[2] = dZ2;
                material.texOffset[3] = dZ2;
            }
            else {
                material.texture = segment.planet.transparentTexture;
                material.texOffset[0] = 0.0;
                material.texOffset[1] = 0.0;
                material.texOffset[2] = 1.0;
                material.texOffset[3] = 1.0;
            }
        }
        return material.texOffset;
    }
    clearMaterial(material) {
        if (material.isReady) {
            material.isReady = false;
            if (material.textureExists && material.texture && !material.texture.default) {
                material.segment.handler.gl.deleteTexture(material.texture);
                material.texture = null;
            }
        }
        this.abortMaterialLoading(material);
        material.isLoading = false;
        material.textureExists = false;
        //@ts-ignore
        material.layer = null;
        //@ts-ignore
        material.segment = null;
        // if (material.image) {
        //     material.image.src = "";
        //     material.image = null;
        // }
    }
}
CanvasTiles.MAX_REQUESTS = 20;
CanvasTiles.__requestsCounter = 0;

const ICON_LOCK_BUTTON_SVG = `<?xml version="1.0" encoding="utf-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg fill="#000000" width="800px" height="800px" viewBox="-7.5 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg">
<title>lock</title>
<path d="M14.625 15.156h2.094c0.281 0 0.5 0.25 0.5 0.531v11c0 0.281-0.219 0.5-0.5 0.5h-16.219c-0.281 0-0.5-0.219-0.5-0.5v-11c0-0.281 0.219-0.531 0.5-0.531h2.031v-5.125c0-2.875 1.844-5.25 4.688-5.25h2.688c2.875 0 4.719 2.375 4.719 5.25v5.125zM5.188 15.156h6.813v-4.875c0-1.594-1.313-2.938-2.938-2.938h-0.969c-1.594 0-2.906 1.344-2.906 2.938v4.875zM7.156 24h2.906l-0.719-3.156c0.5-0.25 0.844-0.781 0.844-1.375 0-0.906-0.719-1.594-1.594-1.594s-1.563 0.688-1.563 1.594c0 0.594 0.344 1.125 0.844 1.375z"></path>
</svg>`;
const ICON_BUTTON_SVG$8 = `<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg fill="#000000" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
\t width="800px" height="800px" viewBox="0 0 932.179 932.179"
\t xml:space="preserve">
<g>
\t<path d="M61.2,341.538c4.9,16.8,11.7,33,20.3,48.2l-24.5,30.9c-8,10.1-7.1,24.5,1.9,33.6l42.2,42.2c9.1,9.1,23.5,9.899,33.6,1.899
\t\tl30.7-24.3c15.8,9.101,32.6,16.2,50.1,21.2l4.6,39.5c1.5,12.8,12.3,22.4,25.1,22.4h59.7c12.8,0,23.6-9.601,25.1-22.4l4.4-38.1
\t\tc18.8-4.9,36.8-12.2,53.7-21.7l29.7,23.5c10.1,8,24.5,7.1,33.6-1.9l42.2-42.2c9.1-9.1,9.9-23.5,1.9-33.6l-23.1-29.3
\t\tc9.6-16.601,17.1-34.3,22.1-52.8l35.6-4.1c12.801-1.5,22.4-12.3,22.4-25.1v-59.7c0-12.8-9.6-23.6-22.4-25.1l-35.1-4.1
\t\tc-4.801-18.3-12-35.8-21.199-52.2l21.6-27.3c8-10.1,7.1-24.5-1.9-33.6l-42.1-42.1c-9.1-9.1-23.5-9.9-33.6-1.9l-26.5,21
\t\tc-17.2-10.1-35.601-17.8-54.9-23l-4-34.3c-1.5-12.8-12.3-22.4-25.1-22.4h-59.7c-12.8,0-23.6,9.6-25.1,22.4l-4,34.3
\t\tc-19.8,5.3-38.7,13.3-56.3,23.8l-27.5-21.8c-10.1-8-24.5-7.1-33.6,1.9l-42.2,42.2c-9.1,9.1-9.9,23.5-1.9,33.6l23,29.1
\t\tc-9.2,16.6-16.2,34.3-20.8,52.7l-36.8,4.2c-12.8,1.5-22.4,12.3-22.4,25.1v59.7c0,12.8,9.6,23.6,22.4,25.1L61.2,341.538z
\t\t M277.5,180.038c54.4,0,98.7,44.3,98.7,98.7s-44.3,98.7-98.7,98.7c-54.399,0-98.7-44.3-98.7-98.7S223.1,180.038,277.5,180.038z"/>
\t<path d="M867.699,356.238l-31.5-26.6c-9.699-8.2-24-7.8-33.199,0.9l-17.4,16.3c-14.699-7.1-30.299-12.1-46.4-15l-4.898-24
\t\tc-2.5-12.4-14-21-26.602-20l-41.1,3.5c-12.6,1.1-22.5,11.4-22.9,24.1l-0.799,24.4c-15.801,5.7-30.701,13.5-44.301,23.3
\t\tl-20.799-13.8c-10.602-7-24.701-5-32.9,4.7l-26.6,31.7c-8.201,9.7-7.801,24,0.898,33.2l18.201,19.399
\t\tc-6.301,14.2-10.801,29.101-13.4,44.4l-26,5.3c-12.4,2.5-21,14-20,26.601l3.5,41.1c1.1,12.6,11.4,22.5,24.1,22.9l28.1,0.899
\t\tc5.102,13.4,11.801,26.101,19.9,38l-15.699,23.7c-7,10.6-5,24.7,4.699,32.9l31.5,26.6c9.701,8.2,24,7.8,33.201-0.9l20.6-19.3
\t\tc13.5,6.3,27.699,11,42.299,13.8l5.701,28.2c2.5,12.4,14,21,26.6,20l41.1-3.5c12.6-1.1,22.5-11.399,22.9-24.1l0.9-27.601
\t\tc15-5.3,29.199-12.5,42.299-21.399l22.701,15c10.6,7,24.699,5,32.9-4.7l26.6-31.5c8.199-9.7,7.799-24-0.9-33.2l-18.301-19.399
\t\tc6.701-14.2,11.602-29.2,14.4-44.601l25-5.1c12.4-2.5,21-14,20-26.601l-3.5-41.1c-1.1-12.6-11.4-22.5-24.1-22.9l-25.1-0.8
\t\tc-5.201-14.6-12.201-28.399-20.9-41.2l13.699-20.6C879.4,378.638,877.4,364.438,867.699,356.238z M712.801,593.837
\t\tc-44.4,3.801-83.602-29.3-87.301-73.699c-3.801-44.4,29.301-83.601,73.699-87.301c44.4-3.8,83.602,29.301,87.301,73.7
\t\tC790.301,550.938,757.199,590.138,712.801,593.837z"/>
\t<path d="M205,704.438c-12.6,1.3-22.3,11.899-22.4,24.6l-0.3,25.3c-0.2,12.7,9.2,23.5,21.8,25.101l18.6,2.399
\t\tc3.1,11.301,7.5,22.101,13.2,32.301l-12,14.8c-8,9.899-7.4,24.1,1.5,33.2l17.7,18.1c8.9,9.1,23.1,10.1,33.2,2.3l14.899-11.5
\t\tc10.5,6.2,21.601,11.101,33.2,14.5l2,19.2c1.3,12.6,11.9,22.3,24.6,22.4l25.301,0.3c12.699,0.2,23.5-9.2,25.1-21.8l2.3-18.2
\t\tc12.601-3.101,24.601-7.8,36-14l14,11.3c9.9,8,24.101,7.4,33.201-1.5l18.1-17.7c9.1-8.899,10.1-23.1,2.301-33.2L496.6,818.438
\t\tc6.6-11,11.701-22.7,15.201-35l16.6-1.7c12.6-1.3,22.299-11.9,22.4-24.6l0.299-25.301c0.201-12.699-9.199-23.5-21.799-25.1
\t\tl-16.201-2.1c-3.1-12.2-7.699-24-13.699-35l10.1-12.4c8-9.9,7.4-24.1-1.5-33.2l-17.699-18.1c-8.9-9.101-23.102-10.101-33.201-2.3
\t\tl-12.101,9.3c-11.399-6.9-23.6-12.2-36.399-15.8l-1.601-15.7c-1.3-12.601-11.899-22.3-24.6-22.4l-25.3-0.3
\t\tc-12.7-0.2-23.5,9.2-25.101,21.8l-2,15.601c-13.199,3.399-25.899,8.6-37.699,15.399l-12.5-10.2c-9.9-8-24.101-7.399-33.201,1.5
\t\tl-18.2,17.801c-9.1,8.899-10.1,23.1-2.3,33.199l10.7,13.801c-6.2,11-11.1,22.699-14.3,35L205,704.438z M368.3,675.837
\t\tc36.3,0.4,65.399,30.301,65,66.601c-0.4,36.3-30.301,65.399-66.601,65c-36.3-0.4-65.399-30.3-65-66.601
\t\tC302.1,704.538,332,675.438,368.3,675.837z"/>
</g>
</svg>`;
const ICON_CANVASTILES_SVG = `<?xml version="1.0"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M 4 4 L 4 8 L 8 8 L 8 4 L 4 4 z M 10 4 L 10 8 L 14 8 L 14 4 L 10 4 z M 16 4 L 16 8 L 20 8 L 20 4 L 16 4 z M 4 10 L 4 14 L 8 14 L 8 10 L 4 10 z M 10 10 L 10 14 L 14 14 L 14 10 L 10 10 z M 16 10 L 16 14 L 20 14 L 20 10 L 16 10 z M 4 16 L 4 20 L 8 20 L 8 16 L 4 16 z M 10 16 L 10 20 L 14 20 L 14 16 L 10 16 z M 16 16 L 16 20 L 20 20 L 20 16 L 16 16 z"/>
</svg>`;
class DebugInfo extends Control {
    constructor(options = {}) {
        if (!options.name || options.name === "") {
            options.name = "DebugInfo";
        }
        super(options);
        this.el = null;
        this._watch = options.watch || [];
        this._toggleBtn = new ToggleButton({
            classList: ["og-map-button", "og-debuginfo_button"],
            icon: ICON_BUTTON_SVG$8
        });
        this._dialog = new Dialog({
            title: "Debug Info",
            visible: false,
            useHide: true,
            top: 120,
            left: 60,
            width: 480
        });
        this._dialog.events.on("visibility", (v) => {
            this._toggleBtn.setActive(v);
        });
        this._canvasTiles = new CanvasTiles("Tile grid", {
            visibility: true,
            isBaseLayer: false,
            hideInLayerSwitcher: true,
            drawTile: function (material, applyCanvas) {
                //
                // This is important create canvas here!
                //
                let cnv = document.createElement("canvas");
                let ctx = cnv.getContext("2d");
                cnv.width = 256;
                cnv.height = 256;
                //Clear canvas
                ctx.clearRect(0, 0, cnv.width, cnv.height);
                //Draw border
                ctx.beginPath();
                ctx.rect(0, 0, cnv.width, cnv.height);
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'black';
                ctx.stroke();
                let size;
                // if (material.segment.isPole) {
                //     let ext = material.segment.getExtentLonLat();
                //
                //     ctx.fillStyle = 'black';
                //     ctx.font = 'normal ' + 29 + 'px Verdana';
                //
                //     ctx.textAlign = 'center';
                //     ctx.fillText(`${ext.northEast.lon.toFixed(3)} ${ext.northEast.lat.toFixed(3)}`, cnv.width / 2, cnv.height / 2 + 20);
                //     ctx.fillText(`${ext.southWest.lon.toFixed(3)} ${ext.southWest.lat.toFixed(3)}`, cnv.width / 2, cnv.height / 2 - 20);
                // } else {
                //Draw text
                if (material.segment.tileZoom > 14) {
                    size = "26";
                }
                else {
                    size = "32";
                }
                ctx.fillStyle = 'black';
                ctx.font = 'normal ' + size + 'px Verdana';
                ctx.textAlign = 'center';
                ctx.fillText(material.segment.tileX + "," + material.segment.tileY + "," + material.segment.tileZoom, cnv.width / 2, cnv.height / 2);
                //}
                //Draw canvas tile
                applyCanvas(cnv);
            }
        });
    }
    addWatches(watches) {
        for (let i = 0; i < watches.length; i++) {
            this.addWatch(watches[i]);
        }
    }
    addWatch(watch) {
        this._watch.push(watch);
        let watchEl = document.createElement("div");
        watchEl.classList.add("og-watch-line");
        watchEl.innerHTML = `<div class="og-watch-label">${watch.label}</div><div class="og-watch-value"></div>`;
        watch.valEl = watchEl.querySelector(".og-watch-value");
        this.el.appendChild(watchEl);
    }
    oninit() {
        this._toggleBtn.appendTo(this.renderer.div);
        this._dialog.appendTo(this.renderer.div);
        this._toggleBtn.events.on("change", (isActive) => {
            this._dialog.setVisibility(isActive);
        });
        this.el = document.createElement("div");
        this.el.className = "og-debug-info";
        let $controls = document.createElement("div");
        $controls.classList.add("og-debuginfo_controls");
        this.el.appendChild($controls);
        let temp = this._watch;
        this._watch = [];
        for (let i = 0; i < temp.length; i++) {
            this.addWatch(temp[i]);
        }
        this._dialog.container?.appendChild(this.el);
        this.renderer.events.on("draw", this._frame, this);
        let p = this.planet;
        if (p) {
            this.addWatches([
                {
                    label: "Nodes count",
                    frame: () => p._renderedNodes.length
                },
                {
                    label: "Planet._fadingNodes",
                    frame: () => p._fadingNodes.size
                },
                {
                    label: "createdNodes",
                    frame: () => p._createdNodesCount
                },
                {
                    label: "indexesCache",
                    frame: () => p._indexesCacheToRemoveCounter
                },
                {
                    label: "distBeforeMemClear",
                    frame: () => Math.round(p._distBeforeMemClear)
                },
                {
                    label: "maxZoom/minZoom",
                    frame: () => p.maxCurrZoom + " / " + p?.minCurrZoom
                },
                {
                    label: "viewExtent",
                    frame: () => p.getViewExtent().toString()
                },
                {
                    label: "height/alt (km)",
                    frame: () => `<div style="width:190px">${(p.camera._lonLat.height / 1000.0).toFixed(2) +
                        " / " +
                        (p.camera.getAltitude() / 1000.0).toFixed(2)}</div>`
                },
                {
                    label: "cam.slope",
                    frame: () => p.camera.slope.toFixed(3)
                },
                {
                    label: "lodSize",
                    frame: () => Math.round(p.lodSize)
                },
                {
                    label: "deltaTime/FPS",
                    frame: () => `<div style="width:70px"><div style="width:20px; float: left;">
                        ${Math.round(p.renderer.handler.deltaTime)}
                        </div> <div style="float: left">
                        ${Math.round(1000.0 / p.renderer.handler.deltaTime)}
                        </div></div>`
                },
                {
                    label: "-------------------------"
                },
                {
                    label: "_renderCompleted / renderCompletedActivated",
                    frame: () => `${p._renderCompleted} / ${p._renderCompletedActivated}`
                },
                {
                    label: "_terrainCompleted / terrainCompletedActivated",
                    frame: () => `${p._terrainCompleted} / ${p._terrainCompletedActivated}`
                },
                {
                    label: "PlainWorker",
                    frame: () => p._plainSegmentWorker.pendingQueue.length
                },
                {
                    label: "TileLoader",
                    frame: () => `${p._tileLoader.loading} ${p._tileLoader.queue.length}`
                },
                {
                    label: "TerrainLoader",
                    frame: () => {
                        if (p.terrain && !p.terrain.isEmpty) {
                            return `${p.terrain.loader.loading}  ${p.terrain.loader.queue.length}`;
                        }
                        return "";
                    }
                },
                {
                    label: "TerrainWorker",
                    frame: () => p._terrainWorker.pendingQueue.length
                },
                {
                    label: "NormalMapCreator",
                    frame: () => p._normalMapCreator.queueSize
                },
                {
                    label: "VectorTileCreator",
                    frame: () => p._vectorTileCreator.queueSize
                }
            ]);
        }
        let lockTreeBtn = new ToggleButton({
            classList: ["og-debuginfo_controls-button"],
            icon: ICON_LOCK_BUTTON_SVG,
            title: "Lock/Unlock quad tree"
        });
        lockTreeBtn.appendTo($controls);
        lockTreeBtn.events.on("change", (isActive) => {
            if (isActive) {
                p.lockQuadTree();
            }
            else {
                p.unlockQuadTree();
            }
        });
        let canvasTilesBtn = new ToggleButton({
            classList: ["og-debuginfo_controls-button"],
            icon: ICON_CANVASTILES_SVG,
            title: "Show/Hide grid"
        });
        canvasTilesBtn.appendTo($controls);
        canvasTilesBtn.events.on("change", (isActive) => {
            if (isActive) {
                this.planet.addLayer(this._canvasTiles);
            }
            else {
                this._canvasTiles.remove();
            }
        });
    }
    _frame() {
        this._watch.forEach((w) => {
            if (w.valEl) {
                w.valEl.innerHTML = w.frame ? String(w.frame()) : "";
            }
        });
    }
}

const BUTTONGROUP_EVENTS = ["change"];
class ButtonGroup {
    constructor(options = {}) {
        this._onChange = (isActive, btn) => {
            if (isActive) {
                btn.preventClick = true;
                for (let i = 0; i < this._buttons.length; i++) {
                    let bi = this._buttons[i];
                    if (!bi.isEqual(btn)) {
                        bi.setActive(false);
                        bi.preventClick = false;
                    }
                }
                this.events.dispatch(this.events.change, btn);
            }
        };
        this.events = createEvents(BUTTONGROUP_EVENTS);
        this._buttons = options.buttons || [];
        for (let i = 0; i < this._buttons.length; i++) {
            this._bindButton(this._buttons[i]);
        }
    }
    _bindButton(button) {
        button.events.on("change", this._onChange);
    }
    add(button) {
        this._buttons.push(button);
        this._bindButton(button);
    }
    remove(button) {
        for (let i = 0; i < this._buttons.length; i++) {
            if (this._buttons[i].isEqual(button)) {
                this._buttons.splice(i);
                button.events.off("change", this._onChange);
                return;
            }
        }
    }
}

class BaseWorker {
    constructor(numWorkers = 2, program) {
        this._sourceId = 0;
        this._source = new Map();
        this._pendingQueue = [];
        this._numWorkers = numWorkers;
        this._workerQueue = [];
        if (program) {
            this.setProgram(program);
        }
    }
    check() {
        if (this._pendingQueue.length) {
            this.make(this._pendingQueue.pop());
        }
    }
    setProgram(program) {
        let p = new Blob([program], { type: "application/javascript" });
        for (let i = 0; i < this._numWorkers; i++) {
            let w = new Worker(URL.createObjectURL(p));
            w.onmessage = (e) => {
                this._onMessage(e);
                this._workerQueue && this._workerQueue.unshift(e.target);
                this.check();
            };
            this._workerQueue.push(w);
        }
    }
    make(data) {
    }
    _onMessage(e) {
    }
    destroy() {
        for (let i = 0; i < this._workerQueue.length; i++) {
            const w = this._workerQueue[i];
            w.onmessage = null;
            w.terminate();
        }
        //@ts-ignore
        this._pendingQueue = null;
        //@ts-ignore
        this._workerQueue = null;
    }
    get pendingQueue() {
        return this._pendingQueue;
    }
}

const LOCK_UPDATE = -2;
const LOCK_FREE = -1;
class LabelWorker extends BaseWorker {
    constructor(numWorkers = 4) {
        super(numWorkers, LABEL_PROGRAM);
    }
    _onMessage(e) {
        let s = this._source.get(e.data.id);
        if (s.label._lockId === LOCK_UPDATE) {
            requestAnimationFrame(() => {
                this.make({ handler: s.handler, label: s.label });
            });
        }
        else {
            s.handler.workerCallback(e.data, s.label);
        }
        this._source.delete(e.data.id);
    }
    make(data) {
        let label = data.label, handler = data.handler;
        if (handler._entityCollection) {
            let labelData = label.serializeWorkerData(this._sourceId);
            if (labelData) {
                if (this._workerQueue.length) {
                    let w = this._workerQueue.pop();
                    this._source.set(this._sourceId, data);
                    label._lockId = this._sourceId;
                    this._sourceId++;
                    w.postMessage({
                        labelData: labelData
                    }, [
                        labelData.buffer,
                    ]);
                }
                else {
                    this._pendingQueue.push(data);
                }
            }
        }
    }
}
const LABEL_PROGRAM = `'use strict';

    function concatTypedArrays(dest, index, source) {
        let len = source.length,
            offset = index * len;
        for(let i = 0; i < len; i++) {
            dest[offset + i] = source[i];
        }
    }

    self.onmessage = function (e) {
        var labelData = e.data.labelData,
            id = labelData[0],
            maxLetters = labelData[1],
            isVisible = labelData[2],
            /*3, 4, 5*/_positionHigh_x = labelData[3], _positionHigh_y = labelData[4], _positionHigh_z = labelData[5],
            /*6, 7, 8*/_positionLow_x = labelData[6], _positionLow_y = labelData[7], _positionLow_z = labelData[8],
            /*9*/_size = labelData[9],
            /*10, 11, 12*/_offset_x = labelData[10], _offset_y = labelData[11], _offset_z = labelData[12],
            /*13, 14, 15, 16*/_color_x = labelData[13], _color_y = labelData[14], _color_z = labelData[15], _color_w = labelData[16],
            /*17*/_rotation = labelData[17],
            /*18, 19, 20*/_alignedAxis_x = labelData[18], _alignedAxis_y = labelData[19], _alignedAxis_z = labelData[20],
            /*21*/_fontIndex = labelData[21],
            /*22*/_outline = labelData[22],
            /*23, 24, 25, 26*/_outlineColor_x = labelData[23], _outlineColor_y = labelData[24], _outlineColor_z = labelData[25], _outlineColor_w = labelData[26],
            /*27, 28, 29*/_pickingColor_x = labelData[27], _pickingColor_y = labelData[28], _pickingColor_z = labelData[29]
         

        let _vertexArr = new Float32Array(maxLetters * 12),
            _texCoordArr = new Float32Array(maxLetters * 24),
            _gliphParamArr = new Float32Array(maxLetters * 24),
            _positionHighArr = new Float32Array(maxLetters * 18),
            _positionLowArr = new Float32Array(maxLetters * 18),
            _sizeArr = new Float32Array(maxLetters * 6),
            _offsetArr = new Float32Array(maxLetters * 18),
            _rgbaArr = new Float32Array(maxLetters * 24),
            _rotationArr = new Float32Array(maxLetters * 6),
            _alignedAxisArr = new Float32Array(maxLetters * 18),
            _fontIndexArr = new Float32Array(maxLetters * 6),
            _outlineArr = new Float32Array(maxLetters * 6),
            _outlineColorArr = new Float32Array(maxLetters * 24),
            _pickingColorArr = new Float32Array(maxLetters * 18);
        
        for (let i = 0; i < maxLetters; i++) {
            if (isVisible !== 0) {
                concatTypedArrays(_vertexArr, i, [0, 0, 0, -1, 1, -1, 1, -1, 1, 0, 0, 0]);
            } else {
                concatTypedArrays(_vertexArr, i, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
            }

            concatTypedArrays(_texCoordArr, i, [0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0]);
            concatTypedArrays(_gliphParamArr, i, [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]);

            var x = _positionHigh_x, y = _positionHigh_y, z = _positionHigh_z, w;
            concatTypedArrays(_positionHighArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

            x = _positionLow_x; y = _positionLow_y; z = _positionLow_z;
            concatTypedArrays(_positionLowArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

            x = _size;
            concatTypedArrays(_sizeArr, i, [x, x, x, x, x, x]);

            x = _offset_x; y = _offset_y; z = _offset_z;
            concatTypedArrays(_offsetArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

            x = _color_x; y = _color_y; z = _color_z; w = _color_w;
            concatTypedArrays(_rgbaArr, i, [x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w]);

            x = _rotation;
            concatTypedArrays(_rotationArr, i, [x, x, x, x, x, x]);

            x = _alignedAxis_x; y = _alignedAxis_y; z = _alignedAxis_z;
            concatTypedArrays(_alignedAxisArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

            x = _fontIndex;
            concatTypedArrays(_fontIndexArr, i, [x, x, x, x, x, x]);

            x = _outline;
            concatTypedArrays(_outlineArr, i, [x, x, x, x, x, x]);

            x = _outlineColor_x; y = _outlineColor_y; z = _outlineColor_z; w = _outlineColor_w;
            concatTypedArrays(_outlineColorArr, i, [x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w]);

            x = _pickingColor_x / 255; y = _pickingColor_y / 255; z = _pickingColor_z / 255;
            concatTypedArrays(_pickingColorArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);
        }

        self.postMessage({
                id: id,
                vertexArr: _vertexArr,
                texCoordArr: _texCoordArr,
                gliphParamArr: _gliphParamArr,
                positionHighArr: _positionHighArr,
                positionLowArr: _positionLowArr,
                sizeArr: _sizeArr,
                offsetArr: _offsetArr,
                rgbaArr: _rgbaArr,
                rotationArr: _rotationArr,
                alignedAxisArr: _alignedAxisArr,
                fontIndexArr: _fontIndexArr,
                outlineArr: _outlineArr,
                outlineColorArr: _outlineColorArr,
                pickingColorArr: _pickingColorArr
             }, [
                    _vertexArr.buffer,
                    _texCoordArr.buffer,
                    _gliphParamArr.buffer,
                    _positionHighArr.buffer,
                    _positionLowArr.buffer,
                    _sizeArr.buffer,
                    _offsetArr.buffer,
                    _rgbaArr.buffer,
                    _rotationArr.buffer,
                    _alignedAxisArr.buffer,
                    _fontIndexArr.buffer,
                    _outlineArr.buffer,
                    _outlineColorArr.buffer,
                    _pickingColorArr.buffer
            ]);
    }`;

/**
 * Base prototype for billboard and label classes.
 * @class
 * @param {Object} [options] - Options:
 * @param {Vec3|Array.<number>} [options.position] - Billboard position.
 * @param {number} [options.rotation] - Screen angle rotation.
 * @param {Vec4|string|Array.<number>} [options.color] - Billboard color.
 * @param {Vec3|Array.<number>} [options.alignedAxis] - Billboard aligned vector.
 * @param {Vec3|Array.<number>} [options.offset] - Billboard center screen offset.
 * @param {boolean} [options.visibility] - Visibility.
 */
class BaseBillboard {
    constructor(options = {}) {
        this.__id = BaseBillboard.__counter__++;
        this._position = createVector3(options.position);
        this._positionHigh = new Vec3();
        this._positionLow = new Vec3();
        Vec3.doubleToTwoFloats(this._position, this._positionHigh, this._positionLow);
        this._rotation = options.rotation || 0;
        this._color = createColorRGBA(options.color);
        this._alignedAxis = createVector3(options.alignedAxis);
        this._offset = createVector3(options.offset);
        this._visibility = options.visibility != undefined ? options.visibility : true;
        this._entity = null;
        this._handler = null;
        this._handlerIndex = -1;
        this._isReady = false;
        this._lockId = LOCK_FREE;
    }
    /**
     * Sets billboard position.
     * @public
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} z - Z coordinate.
     */
    setPosition(x, y, z) {
        this._position.x = x;
        this._position.y = y;
        this._position.z = z;
        Vec3.doubleToTwoFloats(this._position, this._positionHigh, this._positionLow);
        if (this._isReady && this._handler) {
            this._handler.setPositionArr(this._handlerIndex, this._positionHigh, this._positionLow);
        }
        else if (this._lockId !== LOCK_FREE) {
            this._lockId = LOCK_UPDATE;
        }
    }
    /**
     * Sets billboard position.
     * @public
     * @param {Vec3} position - Cartesian coordinates.
     */
    setPosition3v(position) {
        this._position.x = position.x;
        this._position.y = position.y;
        this._position.z = position.z;
        Vec3.doubleToTwoFloats(position, this._positionHigh, this._positionLow);
        if (this._isReady && this._handler) {
            this._handler.setPositionArr(this._handlerIndex, this._positionHigh, this._positionLow);
        }
        else if (this._lockId !== LOCK_FREE) {
            this._lockId = LOCK_UPDATE;
        }
    }
    /**
     * Returns billboard position.
     * @public
     * @returns {Vec3}
     */
    getPosition() {
        return this._position;
    }
    /**
     * Sets screen space offset.
     * @public
     * @param {number} x - X offset.
     * @param {number} y - Y offset.
     * @param {number} [z] - Z offset.
     */
    setOffset(x, y, z) {
        this._offset.x = x;
        this._offset.y = y;
        z != undefined && (this._offset.z = z);
        if (this._isReady && this._handler) {
            this._handler.setOffsetArr(this._handlerIndex, this._offset);
        }
        else if (this._lockId !== LOCK_FREE) {
            this._lockId = LOCK_UPDATE;
        }
    }
    /**
     * Sets screen space offset.
     * @public
     * @param {Vec2} offset - Offset size.
     */
    setOffset3v(offset) {
        this.setOffset(offset.x, offset.y, offset.z);
    }
    /**
     * Returns billboard screen space offset size.
     * @public
     * @returns {Vec3}
     */
    getOffset() {
        return this._offset;
    }
    /**
     * Sets billboard screen space rotation in radians.
     * @public
     * @param {number} rotation - Screen space rotation in radians.
     */
    setRotation(rotation) {
        if (rotation !== this._rotation) {
            this._rotation = rotation;
            if (this._isReady && this._handler) {
                this._handler.setRotationArr(this._handlerIndex, rotation);
            }
            else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }
    }
    /**
     * Gets screen space rotation.
     * @public
     * @returns {number}
     */
    getRotation() {
        return this._rotation;
    }
    /**
     * Sets billboard opacity.
     * @public
     * @param {number} a - Billboard opacity.
     */
    setOpacity(a) {
        if (a !== this._color.w) {
            a != undefined && (this._color.w = a);
            if (this._isReady && this._handler) {
                this._handler.setRgbaArr(this._handlerIndex, this._color);
            }
            else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }
    }
    /**
     * Sets RGBA color. Each channel from 0.0 to 1.0.
     * @public
     * @param {number} r - Red.
     * @param {number} g - Green.
     * @param {number} b - Blue.
     * @param {number} a - Alpha.
     */
    setColor(r, g, b, a) {
        if (a !== this._color.w || r !== this._color.x || g !== this._color.y || this._color.z !== b) {
            this._color.x = r;
            this._color.y = g;
            this._color.z = b;
            a != undefined && (this._color.w = a);
            if (this._isReady && this._handler) {
                this._handler.setRgbaArr(this._handlerIndex, this._color);
            }
            else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }
    }
    /**
     * Sets RGBA color. Each channel from 0.0 to 1.0.
     * @public
     * @param {Vec4} color - RGBA vector.
     */
    setColor4v(color) {
        this.setColor(color.x, color.y, color.z, color.w);
    }
    /**
     * Sets billboard color.
     * @public
     * @param {string} color - HTML style color.
     */
    setColorHTML(color) {
        this.setColor4v(htmlColorToRgba(color));
    }
    /**
     * Returns RGBA color.
     * @public
     * @returns {Vec4}
     */
    getColor() {
        return this._color;
    }
    /**
     * Sets billboard visibility.
     * @public
     * @param {boolean} visibility - Visibility flag.
     */
    setVisibility(visibility) {
        if (visibility !== this._visibility) {
            this._visibility = visibility;
            if (this._isReady && this._handler) {
                this._handler.setVisibility(this._handlerIndex, visibility);
            }
            else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }
    }
    /**
     * Returns billboard visibility.
     * @public
     * @returns {boolean}
     */
    getVisibility() {
        return this._visibility;
    }
    /**
     * Sets billboard cartesian aligned vector.
     * @public
     * @param {number} x - Aligned vector X coordinate.
     * @param {number} y - Aligned vector Y coordinate.
     * @param {number} z - Aligned vector Z coordinate.
     */
    setAlignedAxis(x, y, z) {
        this._alignedAxis.x = x;
        this._alignedAxis.y = y;
        this._alignedAxis.z = z;
        if (this._isReady && this._handler) {
            this._handler.setAlignedAxisArr(this._handlerIndex, this._alignedAxis);
        }
        else if (this._lockId !== LOCK_FREE) {
            this._lockId = LOCK_UPDATE;
        }
    }
    /**
     * Sets billboard aligned vector.
     * @public
     * @param {Vec3} alignedAxis - Align direction.
     */
    setAlignedAxis3v(alignedAxis) {
        this.setAlignedAxis(alignedAxis.x, alignedAxis.y, alignedAxis.z);
    }
    /**
     * Returns aligned vector.
     * @public
     * @returns {Vec3}
     */
    getAlignedAxis() {
        return this._alignedAxis;
    }
    /**
     * Removes billboard from handler.
     * @public
     */
    remove() {
        this._entity = null;
        this._handler && this._handler.remove(this);
    }
    /**
     * Sets billboard picking color.
     * @public
     * @param {Vec3} color - Picking color.
     */
    setPickingColor3v(color) {
        if (this._isReady && this._handler) {
            this._handler.setPickingColorArr(this._handlerIndex, color);
        }
        else if (this._lockId !== LOCK_FREE) {
            this._lockId = LOCK_UPDATE;
        }
    }
    serializeWorkerData(workerId) {
        if (this._handler) {
            return new Float32Array([]);
        }
        return null;
    }
}
BaseBillboard.__counter__ = 0;

/**
 * Represents basic quad billboard image.
 * @class
 * @extends {BaseBillboard}
 * @param {Object} [options] - Options:
 * @param {Vec3|Array.<number>} [options.position] - Billboard spatial position.
 * @param {number} [options.rotation] - Screen angle rotation.
 * @param {Vec4|string|Array.<number>} [options.color] - Billboard color.
 * @param {Vec3|Array.<number>} [options.alignedAxis] - Billboard aligned vector.
 * @param {Vec3|Array.<number>} [options.offset] - Billboard center screen offset.
 * @param {boolean} [options.visibility] - Visibility.
 * @param {string} [options.src] - Billboard image url source.
 * @param {Image} [options.image] - Billboard image object.
 * @param {number} [options.width] - Screen width.
 * @param {number} [options.height] - Screen height.
 * @param {number} [options.scale] - Billboard scale.
 */
class Billboard extends BaseBillboard {
    constructor(options = {}) {
        super(options);
        this._handler = null;
        this._src = options.src || null;
        this._image = options.image || null;
        this._scale = 1.0;
        this._width = options.width || (options.size ? options.size[0] : 30);
        this._height = options.height || (options.size ? options.size[1] : 30);
    }
    /**
     * Sets billboard image url source.
     * @public
     * @param {string} src - Image url.
     */
    setSrc(src) {
        this._src = src;
        let bh = this._handler;
        if (bh && src && src.length) {
            let rn = bh._entityCollection.renderNode;
            if (rn && rn.renderer) {
                let ta = rn.renderer.billboardsTextureAtlas;
                let that = this;
                ta.loadImage(src, function (img) {
                    if (img.__nodeIndex != undefined && ta.get(img.__nodeIndex)) {
                        that._image = img;
                        bh.setTexCoordArr(that._handlerIndex, ta.get(that._image.__nodeIndex).texCoords);
                    }
                    else {
                        ta.addImage(img);
                        ta.createTexture();
                        that._image = img;
                        rn.updateBillboardsTexCoords();
                    }
                });
            }
        }
    }
    getSrc() {
        return this._src;
    }
    /**
     * Sets image object.
     * @public
     * @param {Object} image - JavaScript image object.
     */
    setImage(image) {
        this.setSrc(image.src);
    }
    getImage() {
        return this._image;
    }
    /**
     * Sets billboard screen size in pixels.
     * @public
     * @param {number} width - Billboard width.
     * @param {number} height - Billboard height.
     */
    setSize(width, height) {
        this._width = width;
        this._height = height;
        this._handler &&
            this._handler.setSizeArr(this._handlerIndex, width * this._scale, height * this._scale);
    }
    /**
     * Returns billboard screen size.
     * @public
     * @returns {Object}
     */
    getSize() {
        return {
            width: this._width,
            height: this._height
        };
    }
    /**
     * Sets billboard screen width.
     * @public
     * @param {number} width - Width.
     */
    setWidth(width) {
        this.setSize(width, this._height);
    }
    /**
     * Gets billboard screen width.
     * @public
     * @returns {number}
     */
    getWidth() {
        return this._width;
    }
    /**
     * Sets billboard screen heigh.
     * @public
     * @param {number} height - Height.
     */
    setHeight(height) {
        this.setSize(this._width, height);
    }
    /**
     * Gets billboard screen height.
     * @public
     * @returns {number}
     */
    getHeight() {
        return this._height;
    }
}

var GeometryTypeEnum;
(function (GeometryTypeEnum) {
    GeometryTypeEnum[GeometryTypeEnum["POINT"] = 1] = "POINT";
    GeometryTypeEnum[GeometryTypeEnum["LINESTRING"] = 2] = "LINESTRING";
    GeometryTypeEnum[GeometryTypeEnum["POLYGON"] = 3] = "POLYGON";
    GeometryTypeEnum[GeometryTypeEnum["MULTIPOLYGON"] = 4] = "MULTIPOLYGON";
    GeometryTypeEnum[GeometryTypeEnum["MULTILINESTRING"] = 5] = "MULTILINESTRING";
})(GeometryTypeEnum || (GeometryTypeEnum = {}));
const GeometryType = {
    POINT: 1,
    LINESTRING: 2,
    POLYGON: 3,
    MULTIPOLYGON: 4,
    MULTILINESTRING: 5
};
class Geometry {
    constructor(options = {}) {
        this.__id = Geometry.__counter__++;
        this._entity = null;
        this._handler = null;
        this._handlerIndex = -1;
        this._polyVerticesHighMerc = [];
        this._polyVerticesLowMerc = [];
        this._polyVerticesLength = -1;
        this._polyIndexesLength = -1;
        this._polyVerticesHandlerIndex = -1;
        this._polyIndexesHandlerIndex = -1;
        this._lineVerticesHighMerc = [];
        this._lineVerticesLowMerc = [];
        this._lineVerticesLength = -1;
        this._lineOrdersLength = -1;
        this._lineIndexesLength = -1;
        this._lineColorsLength = -1;
        this._lineThicknessLength = -1;
        this._lineVerticesHandlerIndex = -1;
        this._lineOrdersHandlerIndex = -1;
        this._lineIndexesHandlerIndex = -1;
        this._lineThicknessHandlerIndex = -1;
        this._lineColorsHandlerIndex = -1;
        this._type = (options.type && Geometry.getType(options.type)) || GeometryTypeEnum.POINT;
        this._coordinates = options.coordinates || [];
        this._extent = Geometry.getExtent({
            type: options.type || "POINT",
            coordinates: options.coordinates || []
        }, this._coordinates);
        options.style = options.style || {};
        this._style = {
            fillColor: createColorRGBA(options.style.fillColor, new Vec4(0.19, 0.62, 0.85, 0.4)),
            lineColor: createColorRGBA(options.style.lineColor, new Vec4(0.19, 0.62, 0.85, 1)),
            strokeColor: createColorRGBA(options.style.strokeColor, new Vec4(1, 1, 1, 0.95)),
            lineWidth: options.style.lineWidth || 3,
            strokeWidth: options.style.strokeWidth || 0
        };
        this._visibility = options.visibility || true;
        // optimization flag for picking mask rendering pass
        this._pickingReady = false;
    }
    get id() {
        return this.__id;
    }
    get type() {
        return this._type;
    }
    static getType(typeStr) {
        return GeometryType[typeStr.toUpperCase()];
    }
    /**
     * Returns geometry extent.
     @static
     @param {IGeometry} geometryObj - GeoJSON style geometry feature.
     @param {IGeometryCoordinates} outCoordinates - Geometry feature coordinates clone.
     @returns {Extent} -
     */
    static getExtent(geometryObj, outCoordinates) {
        let res = new Extent(new LonLat(180.0, 90.0), new LonLat(-180.0, -90.0));
        let t = Geometry.getType(geometryObj.type);
        if (t === GeometryTypeEnum.POINT) {
            let lon = geometryObj.coordinates[0], lat = geometryObj.coordinates[1];
            res.southWest.lon = lon;
            res.southWest.lat = lat;
            res.northEast.lon = lon;
            res.northEast.lat = lat;
            outCoordinates && (outCoordinates[0] = lon) && (outCoordinates[1] = lat);
        }
        else if (t === GeometryTypeEnum.LINESTRING) {
            let c = geometryObj.coordinates;
            for (let i = 0; i < c.length; i++) {
                let lon = c[i][0], lat = c[i][1];
                if (lon < res.southWest.lon)
                    res.southWest.lon = lon;
                if (lat < res.southWest.lat)
                    res.southWest.lat = lat;
                if (lon > res.northEast.lon)
                    res.northEast.lon = lon;
                if (lat > res.northEast.lat)
                    res.northEast.lat = lat;
                outCoordinates && (outCoordinates[i] = [lon, lat]);
            }
        }
        else if (t === GeometryTypeEnum.POLYGON) {
            let c = geometryObj.coordinates;
            for (let i = 0; i < c.length; i++) {
                let ci = c[i];
                outCoordinates && (outCoordinates[i] = []);
                for (let j = 0; j < ci.length; j++) {
                    let cij = ci[j];
                    let lon = cij[0], lat = cij[1];
                    if (lon < res.southWest.lon)
                        res.southWest.lon = lon;
                    if (lat < res.southWest.lat)
                        res.southWest.lat = lat;
                    if (lon > res.northEast.lon)
                        res.northEast.lon = lon;
                    if (lat > res.northEast.lat)
                        res.northEast.lat = lat;
                    outCoordinates && (outCoordinates[i][j] = [lon, lat]);
                }
            }
        }
        else if (t === GeometryTypeEnum.MULTIPOLYGON) {
            let p = geometryObj.coordinates;
            for (let i = 0; i < p.length; i++) {
                let pi = p[i];
                outCoordinates && (outCoordinates[i] = []);
                for (let j = 0; j < pi.length; j++) {
                    let pij = pi[j];
                    outCoordinates && (outCoordinates[i][j] = []);
                    for (let k = 0; k < pij.length; k++) {
                        let pijk = pij[k];
                        let lon = pijk[0], lat = pijk[1];
                        if (lon < res.southWest.lon)
                            res.southWest.lon = lon;
                        if (lat < res.southWest.lat)
                            res.southWest.lat = lat;
                        if (lon > res.northEast.lon)
                            res.northEast.lon = lon;
                        if (lat > res.northEast.lat)
                            res.northEast.lat = lat;
                        outCoordinates && (outCoordinates[i][j][k] = [lon, lat]);
                    }
                }
            }
        }
        else if (t === GeometryTypeEnum.MULTILINESTRING) {
            let c = geometryObj.coordinates;
            for (let i = 0; i < c.length; i++) {
                let ci = c[i];
                outCoordinates && (outCoordinates[i] = []);
                for (let j = 0; j < ci.length; j++) {
                    let cij = ci[j];
                    let lon = cij[0], lat = cij[1];
                    if (lon < res.southWest.lon)
                        res.southWest.lon = lon;
                    if (lat < res.southWest.lat)
                        res.southWest.lat = lat;
                    if (lon > res.northEast.lon)
                        res.northEast.lon = lon;
                    if (lat > res.northEast.lat)
                        res.northEast.lat = lat;
                    outCoordinates && (outCoordinates[i][j] = [lon, lat]);
                }
            }
        }
        else {
            res.southWest.lon = res.southWest.lat = res.northEast.lon = res.northEast.lat = 0.0;
            outCoordinates && (outCoordinates[0] = 0) && (outCoordinates[1] = 0);
        }
        return res;
    }
    /**
     * @todo ASAP need test for this method
     * @param geoJson
     * @returns {Geometry}
     */
    setGeometry(geoJson) {
        let h = this._handler;
        if (h) {
            this.remove();
            this._type = Geometry.getType(geoJson.type || "Point");
            this._extent = Geometry.getExtent(geoJson, this._coordinates);
            h.add(this);
        }
        return this;
    }
    setFillColor(r, g, b, a = 1.0) {
        let c = this._style.fillColor;
        if ((c.w === 0.0 && a !== 0.0) || (c.w !== 0.0 && a === 0.0)) {
            this._pickingReady = false;
        }
        c.x = r;
        c.y = g;
        c.z = b;
        c.w = a;
        this._handler && this._handler.setPolyColorArr(this, c);
        return this;
    }
    overlaps(extent) {
        return this._extent.overlaps(extent);
    }
    setFillColor4v(rgba) {
        return this.setFillColor(rgba.x, rgba.y, rgba.z, rgba.w);
    }
    setStrokeColor(r, g, b, a = 1.0) {
        let c = this._style.strokeColor;
        if ((c.w === 0.0 && a !== 0.0) || (c.w !== 0.0 && a === 0.0)) {
            this._pickingReady = false;
        }
        c.x = r;
        c.y = g;
        c.z = b;
        c.w = a;
        this._handler && this._handler.setLineStrokeColorArr(this, c);
        return this;
    }
    setLineColor(r, g, b, a = 1.0) {
        let c = this._style.lineColor;
        if ((c.w === 0.0 && a !== 0.0) || (c.w !== 0.0 && a === 0.0)) {
            this._pickingReady = false;
        }
        c.x = r;
        c.y = g;
        c.z = b;
        c.w = a;
        this._handler && this._handler.setLineColorArr(this, c);
        return this;
    }
    setStrokeColor4v(rgba) {
        return this.setStrokeColor(rgba.x, rgba.y, rgba.z, rgba.w);
    }
    setLineColor4v(rgba) {
        return this.setLineColor(rgba.x, rgba.y, rgba.z, rgba.w);
    }
    setStrokeOpacity(opacity) {
        let c = this._style.strokeColor;
        c.w = opacity;
        return this.setStrokeColor(c.x, c.y, c.z, opacity);
    }
    setLineOpacity(opacity) {
        let c = this._style.lineColor;
        c.w = opacity;
        return this.setLineColor(c.x, c.y, c.z, opacity);
    }
    setStrokeWidth(width) {
        this._style.strokeWidth = width;
        this._pickingReady = false;
        this._handler && this._handler.setLineStrokeArr(this, width);
        return this;
    }
    bringToFront() {
        this._handler && this._handler.bringToFront(this);
        return this;
    }
    setLineWidth(width) {
        this._style.lineWidth = width;
        this._pickingReady = false;
        this._handler && this._handler.setLineThicknessArr(this, width);
        return this;
    }
    setFillOpacity(opacity) {
        let c = this._style.fillColor;
        if ((c.w === 0.0 && opacity !== 0.0) || (c.w !== 0.0 && opacity === 0.0)) {
            this._pickingReady = false;
        }
        c.w = opacity;
        this._handler && this._handler.setPolyColorArr(this, c);
        return this;
    }
    setVisibility(visibility) {
        this._visibility = visibility;
        this._handler && this._handler.setGeometryVisibility(this);
        return this;
    }
    getVisibility() {
        return this._visibility;
    }
    remove() {
        this._handler && this._handler.remove(this);
    }
    getExtent() {
        return this._extent.clone();
    }
    getType() {
        return this._type;
    }
}
Geometry.__counter__ = 0;

class Line2 {
    constructor(a = 0, b = 0, c = 0) {
        this.a = a;
        this.b = b;
        this.c = c;
    }
    static get(p0, p1) {
        return new Line2(p1.y - p0.y, p0.x - p1.x, p1.x * p0.y - p0.x * p1.y);
    }
    static getParallel(l, p) {
        return new Line2(l.a, l.b, -l.a * p.x - l.b * p.y);
    }
    static getIntersection(L0, L1) {
        let x = (L1.b * L0.c - L0.b * L1.c) / (L0.b * L1.a - L1.b * L0.a);
        return new Vec2(x, -(L0.c + L0.a * x) / L0.b);
    }
    intersects(l) {
        return Line2.getIntersection(this, l);
    }
}

/**
 * @todo: write tests
 * @class Line3
 * Represents a line segment in 3d space.
 * @param {Vec3} [p0] - First point of the line
 * @param {Vec3} [p1] - Second point of the line
 */
class Line3 {
    constructor(p0, p1) {
        this.p0 = p0 || new Vec3();
        this.p1 = p1 || new Vec3();
    }
    getMagnitude() {
        return this.p0.distance(this.p1);
    }
    getSphereIntersection(sphere) {
        let p0 = this.p0, p1 = this.p1;
        let cx = sphere.center.x, cy = sphere.center.y, cz = sphere.center.z;
        let px = p0.x, py = p0.y, pz = p0.z;
        let vx = p1.x - px, vy = p1.y - py, vz = p1.z - pz;
        let A = vx * vx + vy * vy + vz * vz, B = 2.0 * (px * vx + py * vy + pz * vz - vx * cx - vy * cy - vz * cz), C = px * px - 2 * px * cx + cx * cx + py * py - 2 * py * cy + cy * cy +
            pz * pz - 2 * pz * cz + cz * cz - sphere.radius * sphere.radius;
        let D = B * B - 4 * A * C;
        if (D < 0) {
            // no solutions
            return [];
        }
        let t1 = (-B - Math.sqrt(D)) / (2.0 * A);
        let solution1 = new Vec3(p0.x * (1 - t1) + t1 * p1.x, p0.y * (1 - t1) + t1 * p1.y, p0.z * (1 - t1) + t1 * p1.z);
        if (D == 0) {
            return [solution1];
        }
        let t2 = (-B + Math.sqrt(D)) / (2.0 * A);
        let solution2 = new Vec3(p0.x * (1 - t2) + t2 * p1.x, p0.y * (1 - t2) + t2 * p1.y, p0.z * (1 - t2) + t2 * p1.z);
        // prefer a solution that's on the line segment itself
        if (Math.abs(t1 - 0.5) < Math.abs(t2 - 0.5)) {
            return [solution1, solution2];
        }
        return [solution2, solution1];
    }
    intersects(line, res, res2) {
        let p13 = this.p0.sub(line.p0), p43 = line.p1.sub(line.p0);
        if (Math.abs(p43.x) < EPS10 && Math.abs(p43.y) < EPS10 && Math.abs(p43.z) < EPS10) {
            return false;
        }
        let p21 = this.p1.sub(this.p0);
        if (Math.abs(p21.x) < EPS10 && Math.abs(p21.y) < EPS10 && Math.abs(p21.z) < EPS10) {
            return false;
        }
        let d1343 = p13.x * p43.x + p13.y * p43.y + p13.z * p43.z, d4321 = p43.x * p21.x + p43.y * p21.y + p43.z * p21.z, d1321 = p13.x * p21.x + p13.y * p21.y + p13.z * p21.z, d4343 = p43.x * p43.x + p43.y * p43.y + p43.z * p43.z, d2121 = p21.x * p21.x + p21.y * p21.y + p21.z * p21.z;
        let denom = d2121 * d4343 - d4321 * d4321;
        if (Math.abs(denom) < EPS10) {
            return false;
        }
        let numer = d1343 * d4321 - d1321 * d4343;
        let mua = numer / denom;
        res.x = this.p0.x + mua * p21.x;
        res.y = this.p0.y + mua * p21.y;
        res.z = this.p0.z + mua * p21.z;
        if (res2) {
            let mub = (d1343 + d4321 * mua) / d4343;
            res2.x = line.p0.x + mub * p43.x;
            res2.y = line.p0.y + mub * p43.y;
            res2.z = line.p0.z + mub * p43.z;
        }
        return true;
    }
    getNearestDistancePoint(point, res) {
        let p0 = this.p0, p1 = this.p1;
        let mag = this.getMagnitude();
        let u = (((point.x - p0.x) * (p1.x - p0.x)) +
            ((point.y - p0.y) * (p1.y - p0.y)) +
            ((point.z - p0.z) * (p1.z - p0.z))) /
            (mag * mag);
        res.x = p0.x + u * (p1.x - p0.x);
        res.y = p0.y + u * (p1.y - p0.y);
        res.z = p0.z + u * (p1.z - p0.z);
        if (u < 0.0 || u > 1.0) {
            return false;
        }
        return true;
    }
}

const DISJOINT = 0;
const COINCIDE = 1;
const INTERSECT = 2;
/**
 * Plane class.
 * @constructor
 * @param {Vec3} [p] - Plane point.
 * @param {Vec3} [n] - Planet normal.
 */
class Plane {
    constructor(p, n) {
        this.p = p ? p.clone() : new Vec3();
        this.n = n ? n.clone() : this.p.normal();
    }
    set(p, n) {
        this.p.copy(p);
        this.n.copy(n);
    }
    getNormal() {
        return this.n.clone();
    }
    distance(p) {
        let pp = this.getProjection(p);
        return p.distance(pp);
    }
    getProjection(v, def) {
        return Vec3.proj_b_to_plane(v, this.n, def);
    }
    getProjectionPoint(p, vh) {
        let v = p.sub(this.p), n = this.n, dist = v.dot(n);
        if (vh) {
            vh.copy(n.scale(dist));
        }
        else {
            vh = n.scale(dist);
        }
        return p.sub(vh);
    }
    getIntersection(Pn1, Pn2, L) {
        let u = Pn1.n.cross(Pn2.n);
        let ax = u.x >= 0 ? u.x : -u.x;
        let ay = u.y >= 0 ? u.y : -u.y;
        let az = u.z >= 0 ? u.z : -u.z;
        // test if the two planes are parallel
        if (ax + ay + az < EPS5) {
            // Pn1 and Pn2 are near parallel
            // test if disjoint or coincide
            let v = Pn2.p.sub(Pn1.p);
            if (Pn1.n.dot(v) == 0) {
                // Pn2.V0 lies in Pn1
                return COINCIDE; // Pn1 and Pn2 coincide
            }
            else {
                return DISJOINT; // Pn1 and Pn2 are disjoint
            }
        }
        // Pn1 and Pn2 intersect in a line
        // first determine max abs coordinate of cross product
        let maxc; // max coordinate
        if (ax > ay) {
            if (ax > az) {
                maxc = 1;
            }
            else {
                maxc = 3;
            }
        }
        else {
            if (ay > az) {
                maxc = 2;
            }
            else {
                maxc = 3;
            }
        }
        // next, to get a point on the intersect line
        // zero the max coord, and solve for the other two
        let iP = new Vec3(); // intersect point
        let d1, d2; // the constants in the 2 plane equations
        d1 = -Pn1.n.dot(Pn1.p); // note: could be pre-stored  with plane
        d2 = -Pn2.n.dot(Pn2.p); // ditto
        // select max coordinate
        if (maxc === 1) {
            // intersect with x=0
            iP.x = 0;
            iP.y = (d2 * Pn1.n.z - d1 * Pn2.n.z) / u.x;
            iP.z = (d1 * Pn2.n.y - d2 * Pn1.n.y) / u.x;
        }
        else if (maxc === 2) {
            // intersect with y=0
            iP.x = (d1 * Pn2.n.z - d2 * Pn1.n.z) / u.y;
            iP.y = 0;
            iP.z = (d2 * Pn1.n.x - d1 * Pn2.n.x) / u.y;
        }
        else if (maxc === 3) {
            // intersect with z=0
            iP.x = (d2 * Pn1.n.y - d1 * Pn2.n.y) / u.z;
            iP.y = (d1 * Pn2.n.x - d2 * Pn1.n.x) / u.z;
            iP.z = 0;
        }
        L.p0.copy(iP);
        L.p1.copy(iP.add(u));
        return INTERSECT;
    }
}

/**
 * Represents a ray that extends infinitely from the provided origin in the provided direction.
 * @class
 * @param {Vec3} origin - The origin of the ray.
 * @param {Vec3} direction - The direction of the ray.
 */
let Ray$1 = class Ray {
    constructor(origin = Vec3.ZERO, direction = Vec3.ZERO) {
        this.origin = origin;
        this.direction = direction;
    }
    /** @const */
    static get OUTSIDE() {
        return 0;
    }
    /** @const */
    static get INSIDE() {
        return 1;
    }
    /** @const */
    static get INPLANE() {
        return 2;
    }
    /** @const */
    static get AWAY() {
        return 3;
    }
    /**
     * Sets a ray parameters.
     * @public
     * @param {Vec3} origin - The origin of the ray.
     * @param {Vec3} direction - The direction of the ray.
     * @returns {Ray}
     */
    set(origin, direction) {
        this.origin = origin;
        this.direction = direction;
        return this;
    }
    /**
     * Computes the point along the ray on the distance.
     * @public
     * @param {number} distance - Point distance.
     * @returns {Vec3}
     */
    getPoint(distance) {
        return Vec3.add(this.origin, this.direction.scaleTo(distance));
    }
    /**
     * Returns ray hit a triange result.
     * @public
     * @param {Vec3} v0 - First triangle corner coordinate.
     * @param {Vec3} v1 - Second triangle corner coordinate.
     * @param {Vec3} v2 - Third triangle corner coordinate.
     * @param {Vec3} res - Hit point object pointer that stores hit result.
     * @returns {number} - Hit code, could 0 - og.Ray.OUTSIDE, 1 - og.Ray.INSIDE,
     *      2 - og.Ray.INPLANE and 3 - og.Ray.AWAY(ray goes away from triangle).
     */
    hitTriangle(v0, v1, v2, res) {
        let u = v1.sub(v0);
        let v = v2.sub(v0);
        let n = u.cross(v);
        let w0 = this.origin.sub(v0);
        let a = -n.dot(w0);
        let b = n.dot(this.direction);
        // ray is  parallel to triangle plane
        if (Math.abs(b) < EPS10) {
            if (a === 0) {
                res.copy(this.origin);
                // ray lies in triangle plane
                return Ray.INPLANE;
            }
            else {
                // ray disjoint from plane
                return Ray.OUTSIDE;
            }
        }
        let r = a / b;
        // intersect point of ray and plane
        res.copy(this.origin.add(this.direction.scaleTo(r)));
        // ray goes away from triangle
        if (r < 0.0) {
            return Ray.AWAY;
        }
        // is res point inside the triangle?
        let uu = u.dot(u);
        let uv = u.dot(v);
        let vv = v.dot(v);
        let w = res.sub(v0);
        let wu = w.dot(u);
        let wv = w.dot(v);
        let D = uv * uv - uu * vv;
        let s = (uv * wv - vv * wu) / D;
        if (s < 0.0 || s > 1.0) {
            return Ray.OUTSIDE;
        }
        let t = (uv * wu - uu * wv) / D;
        if (t < 0.0 || s + t > 1.0) {
            return Ray.OUTSIDE;
        }
        return Ray.INSIDE;
    }
    /**
     * Gets a ray hit a plane result. If the ray cross the plane returns 1 - og.Ray.INSIDE otherwise returns 0 - og.Ray.OUTSIDE.
     * @public
     * @param {Vec3} v0 - First plane point.
     * @param {Vec3} v1 - Second plane point.
     * @param {Vec3} v2 - Third plane point.
     * @param {Vec3} res - Hit point object pointer that stores hit result.
     * @returns {number}
     */
    hitPlane(v0, v1, v2, res) {
        let u = Vec3.sub(v1, v0);
        let v = Vec3.sub(v2, v0);
        let n = u.cross(v);
        let w0 = Vec3.sub(this.origin, v0);
        let a = -n.dot(w0);
        let b = n.dot(this.direction);
        // ray is  parallel to the plane
        if (Math.abs(b) < EPS10) {
            if (a === 0) {
                return Ray.OUTSIDE;
            }
        }
        let r = a / b;
        if (r < 0) {
            return Ray.OUTSIDE;
        }
        let d = this.direction.scaleTo(r);
        // intersect point of ray and plane
        res.x = this.origin.x + d.x;
        res.y = this.origin.y + d.y;
        res.z = this.origin.z + d.z;
        return Ray.INSIDE;
    }
    /**
     * Returns a ray hit sphere coordiante. If there isn't hit returns null.
     * @public
     * @param {Sphere} sphere - Sphere object.
     * @returns {Vec3}
     */
    hitSphere(sphere) {
        let r = sphere.radius, c = sphere.center, o = this.origin, d = this.direction;
        let vpc = Vec3.sub(c, o);
        if (vpc.dot(d) < 0) {
            var l = vpc.length();
            if (l > r) {
                return null;
            }
            else if (l === r) {
                return o.clone();
            }
            let pc = c.projToRay(o, vpc);
            var lc = Vec3.sub(pc, c).length();
            let dist = Math.sqrt(r * r - lc * lc);
            let di1 = dist - Vec3.sub(pc, o).length();
            let intersection = Vec3.add(o, d.scaleTo(di1));
            return intersection;
        }
        else {
            let pc = c.projToRay(o, d);
            var cpcl = Vec3.sub(c, pc).length();
            if (cpcl > sphere.radius) {
                return null;
            }
            else {
                let dist = Math.sqrt(r * r - cpcl * cpcl);
                let di1;
                pc.subA(o);
                if (vpc.length() > r) {
                    di1 = pc.length() - dist;
                }
                else {
                    di1 = pc.length() + dist;
                }
                let intersection = Vec3.add(o, d.scaleTo(di1));
                return intersection;
            }
        }
    }
    hitBox(box) {
        //
        // TODO
        //
    }
};

function objParser(text) {
    const objPositions = [[0, 0, 0]];
    const objTexcoords = [[0, 0]];
    const objNormals = [[0, 0, 0]];
    // same order as `f` indices
    const objVertexData = [
        objPositions,
        objTexcoords,
        objNormals,
    ];
    // same order as `f` indices
    let vertexData = [
        [], // positions
        [], // texcoords
        [], // normals
    ];
    const materialLibs = [];
    const geometries = [];
    let geometry;
    let groups = ['default'];
    let material = 'default';
    let object = 'default';
    function newGeometry() {
        // If there is an existing geometry and it's
        // not empty then start a new one.
        if (geometry && geometry.data.vertices.length) {
            geometry = null;
        }
    }
    function setGeometry() {
        if (!geometry) {
            const vertices = [];
            const textures = [];
            const normals = [];
            vertexData = [
                vertices,
                textures,
                normals,
            ];
            geometry = {
                object,
                groups,
                material,
                data: {
                    vertices,
                    textures,
                    normals,
                },
            };
            geometries.push(geometry);
        }
    }
    function addVertex(vert) {
        const ptn = vert.split('/');
        ptn.forEach((objIndexStr, i) => {
            if (!objIndexStr) {
                return;
            }
            const objIndex = parseInt(objIndexStr);
            const index = objIndex + (objIndex >= 0 ? 0 : objVertexData[i].length);
            vertexData[i].push(...objVertexData[i][index]);
        });
    }
    const keywords = {
        v(parts) {
            objPositions.push(parts.map(parseFloat));
        },
        vn(parts) {
            objNormals.push(parts.map(parseFloat));
        },
        vt(parts) {
            // should check for missing v and extra w?
            objTexcoords.push(parts.map(parseFloat));
        },
        f(parts) {
            setGeometry();
            const numTriangles = parts.length - 2;
            for (let tri = 0; tri < numTriangles; ++tri) {
                addVertex(parts[0]);
                addVertex(parts[tri + 1]);
                addVertex(parts[tri + 2]);
            }
        },
        s: () => {
        }, // smoothing group
        mtllib(parts, unparsedArgs) {
            // the spec says there can be multiple filenames here
            // but many exist with spaces in a single filename
            materialLibs.push(unparsedArgs);
        },
        usemtl(parts, unparsedArgs) {
            material = unparsedArgs;
            newGeometry();
        },
        g(parts) {
            groups = parts;
            newGeometry();
        },
        o(parts, unparsedArgs) {
            object = unparsedArgs;
            newGeometry();
        },
    };
    const keywordRE = /(\w*)(?: )*(.*)/;
    const lines = text.split('\n');
    for (let lineNo = 0; lineNo < lines.length; ++lineNo) {
        const line = lines[lineNo].trim();
        if (line === '' || line.startsWith('#')) {
            continue;
        }
        const m = keywordRE.exec(line);
        if (!m) {
            continue;
        }
        const [, keyword, unparsedArgs] = m;
        const parts = line.split(/\s+/).slice(1);
        const handler = keywords[keyword];
        if (!handler) {
            console.warn('unhandled keyword:', keyword); // eslint-disable-line no-console
            continue;
        }
        handler(parts, unparsedArgs);
    }
    // remove any arrays that have no entries.
    for (const geometry of geometries) {
        geometry.data = Object.fromEntries(Object.entries(geometry.data).filter(([key, array]) => array.length > 0));
    }
    return {
        geometries,
        materialLibs,
    };
}
function transformLeftToRightCoordinateSystem(objData) {
    const convertedGeometries = objData.geometries.map(geometry => {
        const vertices = geometry.data.vertices;
        const normals = geometry.data.normals;
        const textures = geometry.data.textures;
        rotateObject(geometry.data, 0);
        let convertedVertices = [];
        let convertedNormals = [];
        let convertedTextures = [];
        // Convert positions
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const y = vertices[i + 1];
            const z = vertices[i + 2];
            convertedVertices.push(x, y, z);
        }
        // Convert normals
        for (let i = 0; i < normals.length; i += 3) {
            const x = normals[i];
            const y = normals[i + 1];
            const z = normals[i + 2];
            convertedNormals.push(x, y, -z);
        }
        // Convert textures
        for (let i = 0; i < textures.length; i += 2) {
            const s = textures[i];
            const t = 1 - textures[i + 1];
            convertedTextures.push(s, t);
        }
        return {
            object: geometry.object,
            groups: geometry.groups,
            material: geometry.material,
            data: {
                vertices: convertedVertices,
                normals: convertedNormals,
                textures: convertedTextures
            }
        };
    });
    return {
        geometries: convertedGeometries,
        materialLibs: objData.materialLibs
    };
}
function rotateObject(obj, angle) {
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    const vertices = obj.vertices;
    const normals = obj.normals;
    for (let i = 0; i < vertices.length; i += 3) {
        const x = vertices[i];
        const y = vertices[i + 1];
        const z = vertices[i + 2];
        vertices[i] = x * cosA + z * sinA;
        vertices[i + 1] = y;
        vertices[i + 2] = -x * sinA + z * cosA;
        const nx = normals[i];
        const ny = normals[i + 1];
        const nz = normals[i + 2];
        normals[i] = nx * cosA + nz * sinA;
        normals[i + 1] = ny;
        normals[i + 2] = -nx * sinA + nz * cosA;
    }
    return {
        vertices: vertices,
        normals: normals
    };
}

function getColor(color) {
    if (color instanceof Array) {
        return new Float32Array(color);
    }
    else if (typeof color === 'string') {
        return htmlColorToFloat32Array(color);
    }
    return new Float32Array([1.0, 1.0, 1.0, 1.0]);
}
class Object3d {
    constructor(data = {}) {
        this._name = data.name || "noname";
        this._vertices = data.vertices || [];
        this._numVertices = this._vertices.length / 3;
        this._texCoords = data.texCoords || new Array(2 * this._numVertices);
        if (data.center) {
            Object3d.centering(this._vertices);
        }
        /**
         * Image src.
         * @protected
         * @type {string}
         */
        this._src = data.src || null;
        this.color = getColor(data.color);
        if (data.scale) {
            let s = data.scale;
            let scale;
            if (typeof s === 'number') {
                scale = new Vec3(s, s, s);
            }
            else {
                scale = s;
            }
            Object3d.scale(this._vertices, scale);
        }
        if (data.indices) {
            this._indices = data.indices;
            this._normals = data.normals || [];
        }
        else {
            this._normals = Object3d.getNormals(this._vertices);
            this._indices = new Array(this._vertices.length / 3);
            for (let i = 0, len = this._indices.length; i < len; i++) {
                this._indices[i] = i;
            }
        }
    }
    static centering(verts) {
        let min_x = MAX, min_y = MAX, min_z = MAX, max_x = MIN, max_y = MIN, max_z = MIN;
        for (let i = 0, len = verts.length; i < len; i += 3) {
            let x = verts[i], y = verts[i + 1], z = verts[i + 2];
            if (x < min_x)
                min_x = x;
            if (y < min_y)
                min_y = y;
            if (z < min_z)
                min_z = z;
            if (x > max_x)
                max_x = x;
            if (y > max_y)
                max_y = y;
            if (z > max_z)
                max_z = z;
        }
        let c_x = min_x + (max_x - min_x) * 0.5;
        let c_y = min_y + (max_y - min_y) * 0.5;
        let c_z = min_z + (max_z - min_z) * 0.5;
        for (let i = 0, len = verts.length; i < len; i += 3) {
            verts[i] -= c_x;
            verts[i + 1] -= c_y;
            verts[i + 2] -= c_z;
        }
    }
    centering() {
        Object3d.centering(this._vertices);
        return this;
    }
    applyMat4(m) {
        for (let i = 0, len = this._vertices.length; i < len; i += 3) {
            let v = new Vec3(this._vertices[i], this._vertices[i + 1], this._vertices[i + 2]), n = new Vec3(this._normals[i], this._normals[i + 1], this._normals[i + 2]);
            v = m.mulVec3(v);
            n = m.mulVec3(n);
            this._vertices[i] = v.x;
            this._vertices[i + 1] = v.y;
            this._vertices[i + 2] = v.z;
            this._normals[i] = n.x;
            this._normals[i + 1] = n.y;
            this._normals[i + 2] = n.z;
        }
        return this;
    }
    scale(s) {
        Object3d.scale(this._vertices, s);
        return this;
    }
    translate(v) {
        for (let i = 0, len = this._vertices.length; i < len; i += 3) {
            this._vertices[i] += v.x;
            this._vertices[i + 1] += v.y;
            this._vertices[i + 2] += v.z;
        }
        return this;
    }
    get src() {
        return this._src;
    }
    set src(src) {
        this._src = src;
    }
    get name() {
        return this._name;
    }
    get vertices() {
        return this._vertices;
    }
    get normals() {
        return this._normals;
    }
    get indices() {
        return this._indices;
    }
    get texCoords() {
        return this._texCoords;
    }
    get numVertices() {
        return this._numVertices;
    }
    static scale(vertices, s) {
        for (let i = 0; i < vertices.length; i += 3) {
            vertices[i] *= s.x;
            vertices[i + 1] *= s.y;
            vertices[i + 2] *= s.z;
        }
    }
    static centroid(vertices) {
        let minX = 1000.0, minY = 1000.0, minZ = 1000.0, maxX = -1000.0, maxY = -1000.0, maxZ = -1000.0;
        for (let i = 0; i < vertices.length; i += 3) {
            let x = vertices[i], y = vertices[i + 1], z = vertices[i + 2];
            if (x < minX)
                minX = x;
            if (y < minY)
                minY = y;
            if (z < minZ)
                minZ = z;
            if (x > maxX)
                maxX = x;
            if (y > maxY)
                maxY = y;
            if (z > maxZ)
                maxZ = z;
        }
        return [minX + (maxX - minX) * 0.5, minY + (maxY - minY) * 0.5, minZ + (maxZ - minZ) * 0.5];
    }
    static translate(vertices, v) {
        for (let i = 0; i < vertices.length; i += 3) {
            vertices[i] += v[0];
            vertices[i + 1] += v[1];
            vertices[i + 2] += v[2];
        }
    }
    static getNormals(vertices) {
        let res = new Array(vertices.length);
        for (let i = 0; i < vertices.length; i += 9) {
            let t03 = i, t13 = i + 3, t23 = i + 6, v0_x = vertices[t03], v0_y = vertices[t03 + 1], v0_z = vertices[t03 + 2], v1_x = vertices[t13], v1_y = vertices[t13 + 1], v1_z = vertices[t13 + 2], v2_x = vertices[t23], v2_y = vertices[t23 + 1], v2_z = vertices[t23 + 2], vv0_x = v1_x - v0_x, vv0_y = v1_y - v0_y, vv0_z = v1_z - v0_z, vv1_x = v2_x - v0_x, vv1_y = v2_y - v0_y, vv1_z = v2_z - v0_z, n_x = vv0_y * vv1_z - vv0_z * vv1_y, n_y = vv0_z * vv1_x - vv0_x * vv1_z, n_z = vv0_x * vv1_y - vv0_y * vv1_x;
            let l = Math.sqrt(n_x * n_x + n_y * n_y + n_z * n_z);
            n_x /= l;
            n_y /= l;
            n_z /= l;
            res[t03] = n_x;
            res[t03 + 1] = n_y;
            res[t03 + 2] = n_z;
            res[t13] = n_x;
            res[t13 + 1] = n_y;
            res[t13 + 2] = n_z;
            res[t23] = n_x;
            res[t23 + 1] = n_y;
            res[t23 + 2] = n_z;
        }
        return res;
    }
    static createSphere(lonBands = 16, latBands = 16, radius = 1.0, offsetX = 0, offsetY = 0, offsetZ = 0) {
        let vertices = [], indices = [], normals = [];
        for (let latNumber = 0; latNumber <= latBands; latNumber++) {
            let theta = latNumber * Math.PI / latBands;
            let sinTheta = Math.sin(theta);
            let cosTheta = Math.cos(theta);
            for (let longNumber = 0; longNumber <= lonBands; longNumber++) {
                let phi = longNumber * 2 * Math.PI / lonBands;
                let sinPhi = Math.sin(phi);
                let cosPhi = Math.cos(phi);
                let x = cosPhi * sinTheta + offsetX;
                let y = cosTheta + offsetY;
                let z = sinPhi * sinTheta + offsetZ;
                //var u = 1 - (longNumber / lonBands);
                //var v = latNumber / latBands;
                normals.push(x);
                normals.push(y);
                normals.push(z);
                //texCoords.push(u);
                //texCoords.push(v);
                vertices.push(radius * x);
                vertices.push(radius * y);
                vertices.push(radius * z);
            }
        }
        for (let latNumber = 0; latNumber < latBands; latNumber++) {
            for (let longNumber = 0; longNumber < lonBands; longNumber++) {
                let first = (latNumber * (lonBands + 1)) + longNumber;
                let second = first + lonBands + 1;
                indices.push(first);
                indices.push(first + 1);
                indices.push(second);
                indices.push(second);
                indices.push(first + 1);
                indices.push(second + 1);
            }
        }
        return new Object3d({
            'vertices': vertices, 'normals': normals, 'indices': indices
        });
    }
    static createDisc(radius = 1.0, height = 0.0, radialSegments = 8, isTop = true, startIndex = 0, offsetX = 0, offsetY = 0, offsetZ = 0) {
        let vertices = [], indices = [], normals = [];
        let thetaStart = 0.0, thetaLength = Math.PI * 2;
        let sign = isTop ? 1.0 : -1.0;
        let centerIndexStart = startIndex;
        for (let x = 1; x <= radialSegments; x++) {
            vertices.push(offsetX, height * sign + offsetY, offsetZ);
            normals.push(0, sign, 0);
            //texCoords.push(0.5, 0.5);
            startIndex++;
        }
        let centerIndexEnd = startIndex;
        for (let x = 0; x <= radialSegments; x++) {
            let u = x / radialSegments;
            let theta = u * thetaLength + thetaStart;
            let cosTheta = Math.cos(theta);
            let sinTheta = Math.sin(theta);
            vertices.push(radius * sinTheta + offsetX, height * sign + offsetY, radius * cosTheta + offsetZ);
            normals.push(0, sign, 0);
            //texCoords.push((cosTheta * 0.5) + 0.5, (sinTheta * 0.5 * sign) + 0.5);
            startIndex++;
        }
        for (let x = 0; x < radialSegments; x++) {
            let c = centerIndexStart + x, i = centerIndexEnd + x;
            if (isTop) {
                indices.push(i, i + 1, c);
            }
            else {
                indices.push(i + 1, i, c);
            }
        }
        return new Object3d({
            'vertices': vertices, 'normals': normals, 'indices': indices
        });
    }
    /**
     * Returns scale parameters for a frustum geoObject created with only Object3d.createFrustum();
     * @param length
     * @param horizontalAngle
     * @param verticalAngle
     */
    static getFrustumScaleByCameraAngles(length, horizontalAngle, verticalAngle) {
        return new Vec3(2.0 * length * Math.tan(RADIANS_HALF * horizontalAngle), 2.0 * length * Math.tan(RADIANS_HALF * verticalAngle), length);
    }
    /**
     * Returns scale parameters for a frustum geoObject created with only Object3d.createFrustum();
     * @param length
     * @param horizontalAngle
     * @param aspectRatio
     */
    static getFrustumScaleByCameraAspectRatio(length, horizontalAngle, aspectRatio) {
        let vAngle = DEGREES_DOUBLE * Math.atan(Math.tan(RADIANS_HALF * horizontalAngle) / aspectRatio);
        return Object3d.getFrustumScaleByCameraAngles(length, horizontalAngle, vAngle);
    }
    static createFrustum(length = 1, width = 1, height = 1, xOffset = 0, yOffset = 0, zOffset = 0) {
        width *= 0.5;
        height *= 0.5;
        return new Object3d({
            vertices: [
                //
                //inside
                //
                //top
                0 + xOffset, 0 + yOffset, 0 + zOffset,
                -1 * width + xOffset, 1 * height + yOffset, -1 * length + zOffset,
                1 * width + xOffset, 1 * height + yOffset, -1 * length + zOffset,
                //bottop
                0 + xOffset, 0 + yOffset, 0 + zOffset,
                1 * width + xOffset, -1 * height + yOffset, -1 * length + zOffset,
                -1 * width + xOffset, -1 * height + yOffset, -1 * length + zOffset,
                //right
                0 + xOffset, 0 + yOffset, 0 + zOffset,
                1 * width + xOffset, 1 * height + yOffset, -1 * length + zOffset,
                1 * width + xOffset, -1 * height + yOffset, -1 * length + zOffset,
                //left
                0 + xOffset, 0 + yOffset, 0 + zOffset,
                -1 * width + xOffset, -1 * height + yOffset, -1 * length + zOffset,
                -1 * width + xOffset, 1 * height + yOffset, -1 * length + zOffset,
                //
                // outside
                //
                //top
                0 + xOffset, 0 + yOffset, 0 + zOffset,
                1 * width + xOffset, 1 * height + yOffset, -1 * length + zOffset,
                -1 * width + xOffset, 1 * height + yOffset, -1 * length + zOffset,
                //bottop
                0 + xOffset, 0 + yOffset, 0 + zOffset,
                -1 * width + xOffset, -1 * height + yOffset, -1 * length + zOffset,
                1 * width + xOffset, -1 * height + yOffset, -1 * length + zOffset,
                //right
                0 + xOffset, 0 + yOffset, 0 + zOffset,
                1 * width + xOffset, -1 * height + yOffset, -1 * length + zOffset,
                1 * width + xOffset, 1 * height + yOffset, -1 * length + zOffset,
                //left
                0 + xOffset, 0 + yOffset, 0 + zOffset,
                -1 * width + xOffset, 1 * height + yOffset, -1 * length + zOffset,
                -1 * width + xOffset, -1 * height + yOffset, -1 * length + zOffset
            ]
        });
    }
    static createCylinder(radiusTop = 1.0, radiusBottom = 1.0, height = 1.0, radialSegments = 32, heightSegments = 1.0, isTop = true, isBottom = true, offsetX = 0, offsetY = 0, offsetZ = 0) {
        let vertices = [], indices = [], normals = [];
        let thetaStart = 0.0, thetaLength = Math.PI * 2;
        let index = 0;
        let indexArray = [];
        let normal = new Vec3();
        let slope = (radiusBottom - radiusTop) / height;
        for (let y = 0; y <= heightSegments; y++) {
            let indexRow = [];
            let v = y / heightSegments;
            let radius = v * (radiusBottom - radiusTop) + radiusTop;
            for (let x = 0; x <= radialSegments; x++) {
                let u = x / radialSegments;
                let theta = u * thetaLength + thetaStart;
                let sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                vertices.push(radius * sinTheta + offsetX, -v * height + height + offsetY, radius * cosTheta + offsetZ);
                normal.set(sinTheta, slope, cosTheta).normalize();
                normals.push(normal.x, normal.y, normal.z);
                //texCoords.push(u, 1 - v);
                indexRow.push(index++);
            }
            indexArray.push(indexRow);
        }
        for (let x = 0; x < radialSegments; x++) {
            for (let y = 0; y < heightSegments; y++) {
                let a = indexArray[y][x], b = indexArray[y + 1][x], c = indexArray[y + 1][x + 1], d = indexArray[y][x + 1];
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        if (radiusTop !== 0.0 && isTop) {
            let cap = Object3d.createDisc(radiusTop, height, radialSegments, true, index, offsetX, offsetY, offsetZ);
            vertices.push(...cap.vertices);
            normals.push(...cap.normals);
            indices.push(...cap.indices);
        }
        if (radiusBottom !== 0.0 && isBottom) {
            let cap = Object3d.createDisc(radiusBottom, 0, radialSegments, false, index + (isTop ? (1 + 2 * radialSegments) : 0), offsetX, offsetY, offsetZ);
            vertices.push(...cap.vertices);
            normals.push(...cap.normals);
            indices.push(...cap.indices);
        }
        return new Object3d({
            vertices: vertices,
            normals: normals,
            indices: indices
        });
    }
    static createCube(length = 1, height = 1, depth = 1, xOffset = 0, yOffset = 0, zOffset = 0) {
        let l = length * 0.5 + xOffset, h = height * 0.5 + yOffset, d = depth * 0.5 + zOffset;
        return new Object3d({
            vertices: [
                -l, -h, d, l, -h, -d, l, -h, d, -l, -h, d, -l, -h, -d, l, -h, -d,
                //top
                -l, h, d, l, h, d, l, h, -d, -l, h, d, l, h, -d, -l, h, -d,
                //front
                -l, -h, d, l, -h, d, -l, h, d, -l, h, d, l, -h, d, l, h, d,
                //back
                -l, -h, -d, -l, h, -d, l, -h, -d, -l, h, -d, l, h, -d, l, -h, -d,
                //left
                l, -h, d, l, -h, -d, l, h, d, l, h, d, l, -h, -d, l, h, -d,
                //right
                -l, -h, d, -l, h, d, -l, -h, -d, -l, h, d, -l, h, -d, -l, -h, -d
            ]
        });
    }
    static createArrow(back = 0.0, height = 2.1, front = -15) {
        return new Object3d({
            vertices: [0, height, 0, 7, 0, 6, 0, 0, front,
                0, 0, back, 7, 0, 6, 0, height, 0,
                -7, 0, 6, 0, 0, back, 0, height, 0,
                -7, 0, 6, 0, height, 0, 0, 0, front,
                -7, 0, 6, 0, 0, front, 0, 0, back, 0, 0, back, 0, 0, front, 7, 0, 6]
        });
    }
    static async loadObj(src) {
        const obj = await fetch(src, { mode: "cors", })
            .then((response) => response.text())
            .then((data) => transformLeftToRightCoordinateSystem(objParser(data)))
            .catch(() => []);
        return obj.geometries.map(({ data: { vertices, normals, textures } }) => new Object3d({
            vertices,
            normals,
            texCoords: textures
        }));
    }
    merge(other) {
        const mergedVertices = [...this._vertices, ...other.vertices];
        const mergedNormals = [...this._normals, ...other.normals];
        const mergedTexCoords = [...this._texCoords, ...other.texCoords];
        const offset = this._vertices.length / 3;
        const mergedIndices = [
            ...this._indices,
            ...other.indices.map(index => index + offset)
        ];
        return new Object3d({
            name: `${this._name}_${other.name}`,
            vertices: mergedVertices,
            texCoords: mergedTexCoords,
            indices: mergedIndices,
            normals: mergedNormals,
            color: this.color
        });
    }
}

/**
 * @class
 * @param {Object} options -  Geo object parameters:
 * @param {Vec3} [options.position] - Geo object position.
 *
 * @todo: GeoObject and GeoObjectHandler provides instanced objects only.
 * It would be nice if it could provide not instanced rendering loop too.
 */
class GeoObject {
    constructor(options) {
        this._handlerIndex = -1;
        this._tag = options.tag || "none";
        this.instanced = true;
        this._entity = null;
        this._position = createVector3(options.position);
        this._positionHigh = new Vec3();
        this._positionLow = new Vec3();
        Vec3.doubleToTwoFloats(this._position, this._positionHigh, this._positionLow);
        this._pitch = options.pitch || 0.0;
        this._yaw = options.yaw || 0.0;
        this._roll = options.roll || 0.0;
        this._pitchRad = this._pitch * RADIANS;
        this._yawRad = this._yaw * RADIANS;
        this._rollRad = this._roll * RADIANS;
        this._scale = createVector3(options.scale, new Vec3(1, 1, 1));
        this._translate = createVector3(options.translate, new Vec3());
        this._color = createColorRGBA(options.color);
        this._qRot = Quat.IDENTITY;
        this._handler = null;
        this._handlerIndex = -1;
        this._tagData = null;
        this._tagDataIndex = -1;
        let object3d = options.object3d;
        if ((!options.object3d || options.object3d?.vertices.length === 0)) {
            object3d = new Object3d();
        }
        if (options.objSrc) {
            this.setObjectSrc(options.objSrc);
            this._objectSrc = options.objSrc;
        }
        this._object3d = object3d;
        if (options.textureSrc) {
            this.setTextureSrc(options.textureSrc);
        }
        this._visibility = (options.visibility != undefined ? options.visibility : true);
        this._children = [];
        this._direction = new Vec3();
        this._qNorthFrame = new Quat();
    }
    get tag() {
        return this._tag;
    }
    getPosition() {
        return this._position;
    }
    getPitch() {
        return this._pitch;
    }
    getYaw() {
        return this._yaw;
    }
    getRoll() {
        return this._roll;
    }
    get object3d() {
        return this._object3d;
    }
    get vertices() {
        return this._object3d.vertices;
    }
    get normals() {
        return this._object3d.normals;
    }
    get texCoords() {
        return this._object3d.texCoords;
    }
    get indices() {
        return this._object3d.indices;
    }
    /**
     * Sets geo object opacity.
     * @public
     * @param {number} a - Billboard opacity.
     */
    setOpacity(a) {
        this._color.w = a;
        this.setColor(this._color.x, this._color.y, this._color.z, a);
    }
    /**
     * Sets color.
     * @public
     * @param {number} r - Red.
     * @param {number} g - Green.
     * @param {number} b - Blue.
     * @param {number} [a] - Alpha.
     */
    setColor(r, g, b, a) {
        this._color.x = r;
        this._color.y = g;
        this._color.z = b;
        a != undefined && (this._color.w = a);
        this._handler && this._handler.setRgbaArr(this._tagData, this._tagDataIndex, this._color);
    }
    /**
     * Sets color.
     * @public
     * @param {Vec3 | Vec4} color - RGBA vector.
     */
    setColor4v(color) {
        this._color.x = color.x;
        this._color.y = color.y;
        this._color.z = color.z;
        color.w != undefined && (this._color.w = color.w);
        this._handler && this._handler.setRgbaArr(this._tagData, this._tagDataIndex, this._color);
    }
    /**
     * Sets geo object visibility.
     * @public
     * @param {boolean} visibility - Visibility flag.
     */
    setVisibility(visibility) {
        this._visibility = visibility;
        this._handler && this._handler.setVisibility(this._tagData, this._tagDataIndex, visibility);
    }
    /**
     * Returns geo object visibility.
     * @public
     * @returns {boolean}
     */
    getVisibility() {
        return this._visibility;
    }
    /**
     * Sets geo object position.
     * @public
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} z - Z coordinate.
     */
    setPosition(x, y, z) {
        this._position.x = x;
        this._position.y = y;
        this._position.z = z;
        Vec3.doubleToTwoFloats(this._position, this._positionHigh, this._positionLow);
        this._handler &&
            this._handler.setPositionArr(this._tagData, this._tagDataIndex, this._positionHigh, this._positionLow);
        this.updateRotation();
    }
    /**
     * Sets geo object position.
     * @public
     * @param {Vec3} position - Cartesian coordinates.
     */
    setPosition3v(position) {
        this._position.x = position.x;
        this._position.y = position.y;
        this._position.z = position.z;
        Vec3.doubleToTwoFloats(position, this._positionHigh, this._positionLow);
        this._handler && this._handler.setPositionArr(this._tagData, this._tagDataIndex, this._positionHigh, this._positionLow);
        this.updateRotation();
    }
    setYaw(yaw) {
        this._yaw = yaw;
        this._yawRad = yaw * RADIANS;
        this.updateRotation();
    }
    setObject(object) {
        this._object3d = object;
    }
    setObjectSrc(src) {
        this._objectSrc = src;
        this._handler && this._handler.setObjectSrc(src, this.tag);
    }
    setTextureSrc(src) {
        this._textureSrc = src;
        this._object3d && (this._object3d.src = src);
        this._handler && this._handler.setTextureTag(src, this.tag);
    }
    setColorHTML(color) {
        this.setColor4v(htmlColorToRgba(color));
    }
    /**
     *
     * @param {number} pitch - Pitch in radians
     */
    setPitch(pitch) {
        this._pitch = pitch;
        this._pitchRad = pitch * RADIANS;
        this.updateRotation();
    }
    setRoll(roll) {
        this._roll = roll;
        this._rollRad = roll * RADIANS;
        this.updateRotation();
    }
    setPitchYawRoll(pitch, yaw, roll) {
        this._pitch = pitch;
        this._yaw = yaw;
        this._roll = roll;
        this._pitchRad = pitch * RADIANS;
        this._yawRad = yaw * RADIANS;
        this._rollRad = roll * RADIANS;
        this.updateRotation();
    }
    setScale(scale) {
        this._scale.x = this._scale.y = this._scale.z = scale;
        this._handler && this._handler.setScaleArr(this._tagData, this._tagDataIndex, this._scale);
    }
    setScale3v(scale) {
        this._scale.copy(scale);
        this._handler && this._handler.setScaleArr(this._tagData, this._tagDataIndex, scale);
    }
    getScale() {
        return this._scale;
    }
    setTranslate3v(translate) {
        this._translate.copy(translate);
        this._handler && this._handler.setTranslateArr(this._tagData, this._tagDataIndex, translate);
    }
    getTranslate() {
        return this._translate;
    }
    /**
     * Removes geo object from handler.
     * @public
     */
    remove() {
        this._entity = null;
        this._handler && this._handler.remove(this);
    }
    /**
     * Sets billboard picking color.
     * @public
     * @param {Vec3} color - Picking color.
     */
    setPickingColor3v(color) {
        this._handler && this._handler.setPickingColorArr(this._tagData, this._tagDataIndex, color);
    }
    updateRotation() {
        if (this._handler && this._handler._planet) {
            this._qNorthFrame = this._handler._planet.getNorthFrameRotation(this._position);
            let qp = Quat.xRotation(-this._pitchRad);
            let qy = Quat.yRotation(this._yawRad);
            let qr = Quat.zRotation(-this._rollRad);
            this._qRot = qr.mul(qp).mul(qy).mul(this._qNorthFrame).conjugate();
            this._direction = this._qRot.mulVec3(new Vec3(0.0, 0.0, -1.0)).normalize();
            this._handler.setQRotArr(this._tagData, this._tagDataIndex, this._qRot);
        }
    }
    getDirection() {
        return this._direction.clone();
    }
}

const ALIGN = {
    RIGHT: 0,
    LEFT: 1,
    CENTER: 2
};
/**
 * Text align options.
 * @readonly
 * @enum {number}
 */
const STR2ALIGN = {
    left: ALIGN.LEFT,
    right: ALIGN.RIGHT,
    center: ALIGN.CENTER
};
/**
 * Billboard text label.
 * @class
 * @extends {BaseBillboard}
 * @param {Object} [options] - Label options:
 * @param {Vec3|Array.<number>} [options.position] - Billboard spatial position.
 * @param {number} [options.rotation] - Screen angle rotation.
 * @param {Vec4|string|Array.<number>} [options.color] - Billboard color.
 * @param {Vec3|Array.<number>} [options.alignedAxis] - Billboard aligned vector.
 * @param {Vec3|Array.<number>} [options.offset] - Billboard center screen offset.
 * @param {boolean} [options.visibility] - Visibility.
 * @param {string} [options.text] - Text string.
 * @param {string} [options.face] - HTML5 font face.
 * @param {number} [options.size] - Font size in pixels.
 * @param {string} [options.style] - HTML5 font style. Example 'normal', 'italic'.
 * @param {string} [options.weight] - HTML5 font weight. Example 'normal', 'bold'.
 * @param {number} [options.outline] - Text outline size. 0 - no outline, 1 - maximum outline. Default 0.58.
 * @param {Vec4|string|Array.<number>} [options.outlineColor] - Outline color.
 * @param {string} [options.align] - Text horizontal align: "left", "right" and "center".
 */
class Label extends BaseBillboard {
    constructor(options = {}) {
        super(options);
        this._handler = null;
        this._text = options.text || "";
        this._face = defaultString(options.face, "arial");
        this._size = options.size || 24;
        this._outline = options.outline != undefined ? options.outline : 0.0;
        this._outlineColor = createColorRGBA(options.outlineColor, new Vec4(0.0, 0.0, 0.0, 1.0));
        this._align = options.align ? STR2ALIGN[options.align.trim().toLowerCase()] || ALIGN.RIGHT : ALIGN.RIGHT;
        this._fontIndex = 0;
        this._fontAtlas = null;
        this._isRTL = options.isRTL || false;
        this._letterSpacing = options.letterSpacing || 0;
    }
    /**
     * Set label text.
     * @public
     * @param {string} text - Text string.
     * It can't be bigger than maximum labelHandler _maxLetters value.
     */
    setText(text) {
        this._text = text.toString();
        if (this._isReady && this._handler) {
            this._handler.setText(this._handlerIndex, text, this._fontIndex, this._align, this._letterSpacing, this._isRTL);
        }
    }
    /**
     * Set text letter spacing.
     * @public
     * @param {number} spacing - Letter spacing.
     */
    setLetterSpacing(letterSpacing) {
        this._letterSpacing = letterSpacing;
        if (this._isReady && this._handler) {
            this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align, letterSpacing, this._isRTL);
        }
    }
    /**
     * Returns label text letter spacing.
     * @public
     * @param {number} spacing - Letter spacing.
     */
    getLetterSpacing() {
        return this._letterSpacing;
    }
    /**
     * Change text direction.
     * @public
     * @param {boolean} isRTL - Text string.
     */
    setRtl(isRTL) {
        this._isRTL = isRTL;
        if (this._isReady && this._handler) {
            this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align, this._letterSpacing, this._isRTL);
        }
    }
    /**
     * Gets current text string.
     * @public
     * @returns {string}
     */
    getText() {
        return this._text;
    }
    /**
     * Sets label text align. Could be center, left or right. Left is default.
     * @public
     * @param {string} align - Text align.
     */
    setAlign(align) {
        this._align = STR2ALIGN[align.trim().toLowerCase()];
        if (this._isReady && this._handler) {
            this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align, this._letterSpacing, this._isRTL);
        }
        else if (this._lockId !== LOCK_FREE) {
            this._lockId = LOCK_UPDATE;
        }
    }
    /**
     * Gets label text current alignment.
     * @public
     * @returns {string}
     */
    getAlign() {
        return this._align;
    }
    /**
     * Sets font face family.
     * @public
     * @param {string} face - Font face family.
     */
    setFace(face) {
        this._face = face.trim();
        this.update();
    }
    /**
     * Gets current font face.
     * @public
     * @returns {string}
     */
    getFace() {
        return this._face;
    }
    /**
     * Sets label font size in pixels.
     * @public
     * @param {number} size - Label size in pixels.
     */
    setSize(size) {
        if (size !== this._size) {
            this._size = size;
            if (this._isReady && this._handler) {
                this._handler.setSizeArr(this._handlerIndex, size);
            }
            else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }
    }
    /**
     * Gets label size in pixels.
     * @public
     * @returns {number}
     */
    getSize() {
        return this._size;
    }
    /**
     * Sets text outline border size. Where 0 - is no outline, and 1 - is the maximum outline size.
     * @public
     * @param {number} outline - Text outline size.
     */
    setOutline(outline) {
        this._outline = outline;
        if (this._isReady && this._handler) {
            this._handler.setOutlineArr(this._handlerIndex, outline);
        }
        else if (this._lockId !== LOCK_FREE) {
            this._lockId = LOCK_UPDATE;
        }
    }
    /**
     * Gets text current outline size.
     * @public
     * @returns {number}
     */
    getOutline() {
        return this._outline;
    }
    /**
     * Sets label opacity.
     * @public
     * @param {number} a - Label opacity.
     */
    setOpacity(a) {
        super.setOpacity(a);
        this.setOutlineOpacity(a);
    }
    /**
     * Sets text outline color.
     * @public
     * @param {number} r - Red.
     * @param {number} g - Green.
     * @param {number} b - Blue.
     * @param {number} a - Alpha.
     */
    setOutlineColor(r, g, b, a) {
        if (a !== this._outlineColor.w || r !== this._outlineColor.x || g !== this._outlineColor.y || b !== this._outlineColor.z) {
            this._outlineColor.x = r;
            this._outlineColor.y = g;
            this._outlineColor.z = b;
            this._outlineColor.w = a;
            if (this._isReady && this._handler) {
                this._handler.setOutlineColorArr(this._handlerIndex, this._outlineColor);
            }
            else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }
    }
    /**
     * Sets text outline color.
     * @public
     * @param {Vec4} rgba - Color vector.
     */
    setOutlineColor4v(rgba) {
        this.setOutlineColor(rgba.x, rgba.y, rgba.z, rgba.w);
    }
    /**
     * Sets text outline color HTML string.
     * @public
     * @param {string} color - HTML string color.
     */
    setOutlineColorHTML(color) {
        this.setOutlineColor4v(htmlColorToRgba(color));
    }
    /**
     * Gets outline color vector.
     * @public
     * @returns {Vec4}
     */
    getOutlineColor() {
        return this._outlineColor;
    }
    /**
     * Sets outline opacity. Actually outline color alpha value.
     * @public
     * @param {number} opacity - Outline opacity.
     */
    setOutlineOpacity(opacity) {
        if (opacity !== this._outlineColor.w) {
            this._outlineColor.w = opacity;
            if (this._isReady && this._handler) {
                this._handler.setOutlineColorArr(this._handlerIndex, this._outlineColor);
            }
            else if (this._lockId !== LOCK_FREE) {
                this._lockId = LOCK_UPDATE;
            }
        }
    }
    /**
     * Gets outline opacity value.
     * @public
     * @returns {number}
     */
    getOutlineOpacity() {
        return this._outlineColor.w;
    }
    /**
     * Updates label parameters.
     * @public
     */
    async update() {
        if (this._fontAtlas) {
            const fontIndex = await this._fontAtlas.getFontIndex(this._face);
            this._applyFontIndex(fontIndex);
        }
    }
    _applyFontIndex(fontIndex) {
        this._fontIndex = fontIndex;
        if (this._isReady && this._handler) {
            this._handler.setFontIndexArr(this._handlerIndex, this._fontIndex);
            this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align, this._letterSpacing, this._isRTL);
        }
        else if (this._lockId !== LOCK_FREE) {
            this._lockId = LOCK_UPDATE;
        }
    }
    /**
     * Assigns font atlas and update.
     * @public
     * @param {FontAtlas} fontAtlas - Font atlas.
     */
    assignFontAtlas(fontAtlas) {
        if (!this._fontAtlas) {
            this._fontAtlas = fontAtlas;
        }
        this.update();
    }
    serializeWorkerData(workerId) {
        if (this._handler) {
            return new Float32Array([
                /*0*/ workerId,
                /*1*/ this._handler._maxLetters,
                /*2*/ this.getVisibility() ? 1 : 0,
                /*3, 4, 5*/ this._positionHigh.x, this._positionHigh.y, this._positionHigh.z,
                /*6, 7, 8*/ this._positionLow.x, this._positionLow.y, this._positionLow.z,
                /*9*/ this._size,
                /*10, 11, 12*/ this._offset.x, this._offset.y, this._offset.z,
                /*13, 14, 15, 16*/ this._color.x, this._color.y, this._color.z, this._color.w,
                /*17*/ this._rotation,
                /*18, 19, 20*/ this._alignedAxis.x, this._alignedAxis.y, this._alignedAxis.z,
                /*21*/ this._fontIndex,
                /*22*/ this._outline,
                /*23, 24, 25, 26*/ this._outlineColor.x, this._outlineColor.y, this._outlineColor.z, this._outlineColor.w,
                /*27, 28, 29*/ this._entity._pickingColor.x, this._entity._pickingColor.y, this._entity._pickingColor.z
            ]);
        }
        return null;
    }
}

const COORDINATES_BUFFER = 0;
const COLOR_BUFFER = 1;
const PICKING_COLOR_BUFFER = 2;
/**
 * PointCloud object.
 * @class
 * @param {*} [options] - Point cloud options:
 * @param {Array.<Array.<number>>} [options.points] - Points cartesian coordinates array,
 * where first three is cartesian coordinates, next fourth is an RGBA color, and last is a point properties.
 * @param {number} [options.pointSize] - Point screen size in pixels.
 * @param {number} [options.pickingScale] - Point border picking size in screen pixels.
 * @param {boolean} [options.visibility] - Point cloud visibility.
 * @example <caption>Creates point cloud with two ten pixel size points</caption>
 * new og.Entity({
 *     pointCloud: {
 *         pointSize: 10,
 *         points: [
 *             [0, 0, 0, 255, 255, 255, 255, { 'name': 'White point' }],
 *             [100, 100, 0, 255, 0, 0, 255, { 'name': 'Red point' }]
 *         ]
 *     }
 * });
 */
class PointCloud {
    constructor(options = {}) {
        this.__id = PointCloud.__counter__++;
        /**
         * Cloud visibility.
         * @public
         * @type {boolean}
         */
        this.visibility = options.visibility != undefined ? options.visibility : true;
        /**
         * Point screen size in pixels.
         * @public
         * @type {number}
         */
        this.pointSize = options.pointSize || 3;
        /**
         * Point picking border size in pixels.
         * @public
         * @type {number}
         */
        this.pickingScale = options.pickingScale || 0;
        /**
         * Parent collection render node.
         * @private
         * @type {RenderNode}
         */
        this._renderNode = null;
        /**
         * Entity instance that holds this point cloud.
         * @private
         * @type {Entity}
         */
        this._entity = null;
        /**
         * Points properties.
         * @private
         * @type {IPoint[]}
         */
        this._points = [];
        /**
         * Coordinates array.
         * @private
         * @type {Array.<number>}
         */
        this._coordinatesData = [];
        /**
         * Color array.
         * @private
         * @type {Array.<number>}
         */
        this._colorData = [];
        /**
         * Picking color array.
         * @private
         * @type {Array.<number>}
         */
        this._pickingColorData = [];
        this._coordinatesBuffer = null;
        this._colorBuffer = null;
        this._pickingColorBuffer = null;
        /**
         * Handler that stores and renders this object.
         * @private
         * @type {PointCloudHandler}
         */
        this._handler = null;
        this._handlerIndex = -1;
        this._buffersUpdateCallbacks = [];
        this._buffersUpdateCallbacks[COORDINATES_BUFFER] = this._createCoordinatesBuffer;
        this._buffersUpdateCallbacks[COLOR_BUFFER] = this._createColorBuffer;
        this._buffersUpdateCallbacks[PICKING_COLOR_BUFFER] = this._createPickingColorBuffer;
        this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
        if (options.points) {
            this.setPoints(options.points);
        }
    }
    /**
     * Clears point cloud data
     * @public
     */
    clear() {
        this._points.length = 0;
        this._points = [];
        this._coordinatesData.length = 0;
        this._coordinatesData = [];
        this._colorData.length = 0;
        this._colorData = [];
        this._pickingColorData.length = 0;
        this._pickingColorData = [];
        this._deleteBuffers();
    }
    /**
     * Sets cloud visibility.
     * @public
     * @param {boolean} visibility - Visibility flag.
     */
    setVisibility(visibility) {
        this.visibility = visibility;
    }
    /**
     * @return {boolean} Point cloud visibility.
     */
    getVisibility() {
        return this.visibility;
    }
    /**
     * Assign rendering scene node.
     * @public
     * @param {RenderNode}  renderNode - Assigned render node.
     */
    setRenderNode(renderNode) {
        this._renderNode = renderNode;
        this._setPickingColors();
    }
    /**
     * Removes from entity.
     * @public
     */
    remove() {
        this._entity = null;
        this._handler && this._handler.remove(this);
    }
    /**
     * Adds points to render.
     * @public
     * @param { Poi[]} points - Point cloud array.
     * @example
     * var points = [[0, 0, 0, 255, 255, 255, 255, { 'name': 'White point' }], [100, 100, 0, 255, 0, 0, 255, { 'name': 'Red point' }]];
     */
    setPoints(points) {
        this.clear();
        for (let i = 0; i < points.length; i++) {
            let pi = points[i];
            let pos = new Vec3(pi[0], pi[1], pi[2]), col = new Vec4(pi[3], pi[4], pi[5], pi[6] == undefined ? 255.0 : pi[6]);
            this._coordinatesData.push(pos.x, pos.y, pos.z);
            this._colorData.push(col.x / 255.0, col.y / 255.0, col.z / 255.0, col.w / 255.0);
            let p = {
                _entity: this._entity,
                _pickingColor: new Vec3(),
                _entityCollection: this._entity ? this._entity._entityCollection : null,
                index: i,
                position: pos,
                color: col,
                pointCloud: this,
                properties: pi[7] || {}
            };
            this._points.push(p);
            if (this._renderNode && this._renderNode.renderer) {
                this._renderNode.renderer.assignPickingColor(p);
                this._pickingColorData.push(p._pickingColor.x / 255.0, p._pickingColor.y / 255.0, p._pickingColor.z / 255.0, 1.0);
            }
        }
        this._changedBuffers[COORDINATES_BUFFER] = true;
        this._changedBuffers[COLOR_BUFFER] = true;
        this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }
    setPointPosition(index, x, y, z) {
        // TODO: ...
        this._changedBuffers[COORDINATES_BUFFER] = true;
    }
    setPointColor(index, r, g, b, a) {
        // TODO: ...
        this._changedBuffers[COLOR_BUFFER] = true;
    }
    addPoints(points) {
        // TODO: ...
        this._changedBuffers[COORDINATES_BUFFER] = true;
        this._changedBuffers[COLOR_BUFFER] = true;
        this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }
    addPoint(index, point) {
        // TODO: ...
        this._changedBuffers[COORDINATES_BUFFER] = true;
        this._changedBuffers[COLOR_BUFFER] = true;
        this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }
    /**
     * Returns specific point by index.
     * @public
     * @param {number} index - Point index.
     * @return {Poi} Specific point
     */
    getPoint(index) {
        return this._points[index];
    }
    removePoint(index) {
        // TODO: ...
        this._changedBuffers[COORDINATES_BUFFER] = true;
        this._changedBuffers[COLOR_BUFFER] = true;
        this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }
    insertPoint(index, point) {
        // TODO: ...
        this._changedBuffers[COORDINATES_BUFFER] = true;
        this._changedBuffers[COLOR_BUFFER] = true;
        this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }
    draw() {
        if (this.visibility && this._coordinatesData.length) {
            this._update();
            let rn = this._renderNode;
            let r = rn.renderer;
            let sh = r.handler.programs.pointCloud;
            let p = sh._program;
            let gl = r.handler.gl, sha = p.attributes, shu = p.uniforms;
            // gl.polygonOffset(
            //     this._handler._entityCollection.polygonOffsetFactor,
            //     this._handler._entityCollection.polygonOffsetUnits
            // );
            sh.activate();
            gl.uniformMatrix4fv(shu.projectionViewMatrix, false, r.activeCamera.getProjectionViewMatrix());
            gl.uniform1f(shu.opacity, this._handler._entityCollection._fadingOpacity);
            gl.uniform1f(shu.pointSize, this.pointSize);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._coordinatesBuffer);
            gl.vertexAttribPointer(sha.coordinates, this._coordinatesBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._colorBuffer);
            gl.vertexAttribPointer(sha.colors, this._colorBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.POINTS, 0, this._coordinatesBuffer.numItems);
        }
    }
    drawPicking() {
        if (this.visibility && this._coordinatesData.length) {
            let rn = this._renderNode;
            let r = rn.renderer;
            let sh = r.handler.programs.pointCloud;
            let p = sh._program;
            let gl = r.handler.gl, sha = p.attributes, shu = p.uniforms;
            sh.activate();
            // gl.polygonOffset(
            //     this._handler._entityCollection.polygonOffsetFactor,
            //     this._handler._entityCollection.polygonOffsetUnits
            // );
            gl.uniformMatrix4fv(shu.projectionViewMatrix, false, r.activeCamera.getProjectionViewMatrix());
            gl.uniform1f(shu.opacity, this._handler._entityCollection._fadingOpacity);
            gl.uniform1f(shu.pointSize, this.pointSize + this.pickingScale);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._coordinatesBuffer);
            gl.vertexAttribPointer(sha.coordinates, this._coordinatesBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._pickingColorBuffer);
            gl.vertexAttribPointer(sha.colors, this._pickingColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.POINTS, 0, this._coordinatesBuffer.numItems);
        }
    }
    /**
     * Update gl buffers.
     * @protected
     */
    _update() {
        if (this._renderNode) {
            let i = this._changedBuffers.length;
            while (i--) {
                if (this._changedBuffers[i]) {
                    this._buffersUpdateCallbacks[i].call(this);
                    this._changedBuffers[i] = false;
                }
            }
        }
    }
    /**
     * Delete buffers
     * @public
     */
    _deleteBuffers() {
        if (this._renderNode) {
            let r = this._renderNode.renderer, gl = r.handler.gl;
            gl.deleteBuffer(this._coordinatesBuffer);
            gl.deleteBuffer(this._colorBuffer);
            gl.deleteBuffer(this._pickingColorBuffer);
        }
        this._coordinatesBuffer = null;
        this._colorBuffer = null;
        this._pickingColorBuffer = null;
    }
    _createCoordinatesBuffer() {
        let h = this._renderNode.renderer.handler;
        h.gl.deleteBuffer(this._coordinatesBuffer);
        this._coordinatesBuffer = h.createArrayBuffer(new Float32Array(this._coordinatesData), 3, this._coordinatesData.length / 3);
    }
    _createColorBuffer() {
        let h = this._renderNode.renderer.handler;
        h.gl.deleteBuffer(this._colorBuffer);
        this._colorBuffer = h.createArrayBuffer(new Float32Array(this._colorData), 4, this._colorData.length / 4);
    }
    _createPickingColorBuffer() {
        let h = this._renderNode.renderer.handler;
        h.gl.deleteBuffer(this._pickingColorBuffer);
        this._pickingColorBuffer = h.createArrayBuffer(new Float32Array(this._pickingColorData), 4, this._pickingColorData.length / 4);
    }
    _setPickingColors() {
        if (this._renderNode && this._renderNode.renderer) {
            for (let i = 0; i < this._points.length; i++) {
                let p = this._points[i];
                p._entity = this._entity;
                p._entityCollection = this._entity._entityCollection;
                this._renderNode.renderer.assignPickingColor(p);
                this._pickingColorData.push(p._pickingColor.x / 255.0, p._pickingColor.y / 255.0, p._pickingColor.z / 255.0, 1.0);
            }
            this._changedBuffers[PICKING_COLOR_BUFFER] = true;
        }
    }
}
PointCloud.__counter__ = 0;

const VERTICES_BUFFER = 0;
const INDEX_BUFFER$1 = 1;
const COLORS_BUFFER = 2;
const DEFAULT_COLOR = "#0000FF";
const R = 0;
const G = 1;
const B = 2;
const A = 3;
/**
 * Polyline object.
 * @class
 * @param {Object} [options] - Polyline options:
 * @param {number} [options.thickness] - Thickness in screen pixels 1.5 is default.
 * @param {Number} [options.altitude] - Relative to ground layers altitude value.
 * @param {Vec4} [options.color] - RGBA color.
 * @param {Boolean} [options.opacity] - Line opacity.
 * @param {Boolean} [options.visibility] - Polyline visibility. True default.
 * @param {Boolean} [options.isClosed] - Closed geometry type identification.
 * @param {SegmentPathLonLatExt[]} [options.pathLonLat] - Polyline geodetic coordinates array. [[[0,0,0], [1,1,1],...]]
 * @param {SegmentPath3vExt[]} [options.path3v] - LinesString cartesian coordinates array. [[[0,0,0], [1,1,1],...]]
 * @param {SegmentPathColor[]} [options.pathColors] - Coordinates color. [[[1,0,0,1], [0,1,0,1],...]] for right and green colors.
 */
class Polyline {
    constructor(options = {}) {
        this.__id = Polyline.__counter__++;
        this.altitude = options.altitude || 0.0;
        this.thickness = options.thickness || 1.5;
        this._opacity = options.opacity != undefined ? options.opacity : 1.0;
        this._defaultColor = htmlColorToFloat32Array(options.color || DEFAULT_COLOR, options.opacity);
        this.visibility = options.visibility != undefined ? options.visibility : true;
        this._closedLine = options.isClosed || false;
        this._path3v = [];
        this._pathLengths = [];
        this._pathLonLat = [];
        this._pathLonLatMerc = [];
        this._pathColors = options.pathColors ? cloneArray(options.pathColors) : [];
        this._extent = new Extent();
        this._verticesHigh = [];
        this._verticesLow = [];
        this._orders = [];
        this._indexes = [];
        this._colors = [];
        this._verticesHighBuffer = null;
        this._verticesLowBuffer = null;
        this._ordersBuffer = null;
        this._indexesBuffer = null;
        this._colorsBuffer = null;
        this._pickingColor = [0, 0, 0];
        this._renderNode = null;
        this._entity = null;
        this._handler = null;
        this._handlerIndex = -1;
        this._buffersUpdateCallbacks = [];
        this._buffersUpdateCallbacks[VERTICES_BUFFER] = this._createVerticesBuffer;
        this._buffersUpdateCallbacks[INDEX_BUFFER$1] = this._createIndexBuffer;
        this._buffersUpdateCallbacks[COLORS_BUFFER] = this._createColorsBuffer;
        this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
        // create path
        if (options.pathLonLat) {
            this.setPathLonLat(options.pathLonLat);
        }
        else if (options.path3v) {
            this.setPath3v(options.path3v);
        }
        this._refresh();
    }
    /**
     * Appends to the line array new cartesian coordinates line data.
     * @static
     */
    static appendLineData3v(path3v, pathColors, defaultColor, isClosed, outVerticesHigh, outVerticesLow, outOrders, outIndexes, ellipsoid, outTransformedPathLonLat, outPath3v, outTransformedPathMerc, outExtent, outColors) {
        var index = 0;
        var v_high = new Vec3(), v_low = new Vec3();
        if (outExtent) {
            outExtent.southWest.set(180.0, 90.0);
            outExtent.northEast.set(-180.0, -90.0);
        }
        if (outIndexes.length > 0) {
            index = outIndexes[outIndexes.length - 5] + 9;
            outIndexes.push(index, index);
        }
        else {
            outIndexes.push(0, 0);
        }
        for (let j = 0, len = path3v.length; j < len; j++) {
            var path = path3v[j], pathColors_j = pathColors[j];
            outTransformedPathLonLat[j] = [];
            outTransformedPathMerc[j] = [];
            outPath3v[j] = [];
            if (path.length === 0) {
                continue;
            }
            var startIndex = index;
            var last;
            if (isClosed) {
                last = path[path.length - 1];
                if (last instanceof Array) {
                    last = new Vec3(last[0], last[1], last[2]);
                }
            }
            else {
                var p0 = path[0], p1 = path[1] || p0;
                if (p0 instanceof Array) {
                    p0 = new Vec3(p0[0], p0[1], p0[2]);
                }
                if (p1 instanceof Array) {
                    p1 = new Vec3(p1[0], p1[1], p1[2]);
                }
                p0 = p0;
                p1 = p1;
                last = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
            }
            let color = defaultColor;
            if (pathColors_j && pathColors_j[0]) {
                color = pathColors_j[0];
            }
            Vec3.doubleToTwoFloats(last, v_high, v_low);
            outVerticesHigh.push(v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z);
            outVerticesLow.push(v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z);
            let r = color[R], g = color[G], b = color[B], a = color[A] != undefined ? color[A] : 1.0;
            if (j > 0) {
                outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);
            }
            outOrders.push(1, -1, 2, -2);
            for (let i = 0, len = path.length; i < len; i++) {
                var cur = path[i];
                if (cur instanceof Array) {
                    cur = new Vec3(cur[0], cur[1], cur[2]);
                }
                outPath3v[j].push(cur);
                if (ellipsoid) {
                    var lonLat = ellipsoid.cartesianToLonLat(cur);
                    outTransformedPathLonLat[j].push(lonLat);
                    outTransformedPathMerc[j].push(lonLat.forwardMercator());
                    if (lonLat.lon < outExtent.southWest.lon) {
                        outExtent.southWest.lon = lonLat.lon;
                    }
                    if (lonLat.lat < outExtent.southWest.lat) {
                        outExtent.southWest.lat = lonLat.lat;
                    }
                    if (lonLat.lon > outExtent.northEast.lon) {
                        outExtent.northEast.lon = lonLat.lon;
                    }
                    if (lonLat.lat > outExtent.northEast.lat) {
                        outExtent.northEast.lat = lonLat.lat;
                    }
                }
                if (pathColors_j && pathColors_j[i]) {
                    color = pathColors_j[i];
                }
                r = color[R];
                g = color[G];
                b = color[B];
                a = color[A] != undefined ? color[A] : 1.0;
                Vec3.doubleToTwoFloats(cur, v_high, v_low);
                outVerticesHigh.push(v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z);
                outVerticesLow.push(v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z);
                outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);
                outOrders.push(1, -1, 2, -2);
                outIndexes.push(index++, index++, index++, index++);
            }
            var first;
            if (isClosed) {
                first = path[0];
                if (first instanceof Array) {
                    first = new Vec3(first[0], first[1], first[2]);
                }
                outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
            }
            else {
                let p0 = path[path.length - 1], p1 = path[path.length - 2] || p0;
                if (p0 instanceof Array) {
                    p0 = new Vec3(p0[0], p0[1], p0[2]);
                }
                else {
                    p0 = p0;
                }
                if (p1 instanceof Array) {
                    p1 = new Vec3(p1[0], p1[1], p1[2]);
                }
                else {
                    p1 = p1;
                }
                first = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
                outIndexes.push(index - 1, index - 1, index - 1, index - 1);
            }
            if (pathColors_j && pathColors_j[path.length - 1]) {
                color = pathColors_j[path.length - 1];
            }
            r = color[R];
            g = color[G];
            b = color[B];
            a = color[A] != undefined ? color[A] : 1.0;
            Vec3.doubleToTwoFloats(first, v_high, v_low);
            outVerticesHigh.push(v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z);
            outVerticesLow.push(v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z);
            outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);
            outOrders.push(1, -1, 2, -2);
            if (j < path3v.length - 1 && path3v[j + 1].length !== 0) {
                index += 8;
                outIndexes.push(index, index);
            }
        }
    }
    /**
     * Appends to the line new cartesian coordinates point data.
     * @static
     */
    static appendPoint3v(path3v, point3v, pathColors, color, isClosed, outVerticesHigh, outVerticesLow, outColors, outOrders, outIndexes, ellipsoid, outTransformedPathLonLat, outTransformedPathMerc, outExtent) {
        var v_high = new Vec3(), v_low = new Vec3();
        var ii = outIndexes.length - 4, index = outIndexes[ii - 1] + 1;
        if (path3v.length === 0) {
            path3v.push([]);
            if (!pathColors[0]) {
                pathColors[0] = [];
            }
        }
        else if (!pathColors[path3v.length - 1]) {
            pathColors[path3v.length - 1] = [];
        }
        var path = path3v[path3v.length - 1], len = path.length;
        path.push(point3v);
        let r = color[R], g = color[G], b = color[B], a = color[A] != undefined ? color[A] : 1.0, pathColors_last = pathColors[path3v.length - 1];
        if (pathColors_last[len]) {
            pathColors_last[len][R] = r;
            pathColors_last[len][G] = g;
            pathColors_last[len][B] = b;
            pathColors_last[len][A] = a;
        }
        else {
            pathColors_last.push(color);
        }
        if (len === 1) {
            var last;
            if (isClosed) {
                last = path[len - 1];
                if (last instanceof Array) {
                    last = new Vec3(last[0], last[1], last[2]);
                }
            }
            else {
                let p0 = path[0], p1 = path[1] || p0;
                if (p0 instanceof Array) {
                    p0 = new Vec3(p0[0], p0[1], p0[2]);
                }
                else {
                    p0 = p0;
                }
                if (p1 instanceof Array) {
                    p1 = new Vec3(p1[0], p1[1], p1[2]);
                }
                else {
                    p1 = p1;
                }
                last = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
            }
            Vec3.doubleToTwoFloats(last, v_high, v_low);
            let vi = outVerticesHigh.length - 3 * 12;
            outVerticesHigh[vi] = v_high.x;
            outVerticesHigh[vi + 1] = v_high.y;
            outVerticesHigh[vi + 2] = v_high.z;
            outVerticesHigh[vi + 3] = v_high.x;
            outVerticesHigh[vi + 4] = v_high.y;
            outVerticesHigh[vi + 5] = v_high.z;
            outVerticesHigh[vi + 6] = v_high.x;
            outVerticesHigh[vi + 7] = v_high.y;
            outVerticesHigh[vi + 8] = v_high.z;
            outVerticesHigh[vi + 9] = v_high.x;
            outVerticesHigh[vi + 10] = v_high.y;
            outVerticesHigh[vi + 11] = v_high.z;
            outVerticesLow[vi] = v_low.x;
            outVerticesLow[vi + 1] = v_low.y;
            outVerticesLow[vi + 2] = v_low.z;
            outVerticesLow[vi + 3] = v_low.x;
            outVerticesLow[vi + 4] = v_low.y;
            outVerticesLow[vi + 5] = v_low.z;
            outVerticesLow[vi + 6] = v_low.x;
            outVerticesLow[vi + 7] = v_low.y;
            outVerticesLow[vi + 8] = v_low.z;
            outVerticesLow[vi + 9] = v_low.x;
            outVerticesLow[vi + 10] = v_low.y;
            outVerticesLow[vi + 11] = v_low.z;
        }
        var startIndex = index;
        if (ellipsoid) {
            if (outTransformedPathLonLat.length === 0) {
                outTransformedPathLonLat.push([]);
            }
            if (outTransformedPathMerc.length === 0) {
                outTransformedPathMerc.push([]);
            }
            var transformedPathLonLat = outTransformedPathLonLat[outTransformedPathLonLat.length - 1], transformedPathMerc = outTransformedPathMerc[outTransformedPathMerc.length - 1];
            let lonLat = ellipsoid.cartesianToLonLat(point3v);
            transformedPathLonLat.push(lonLat);
            transformedPathMerc.push(lonLat.forwardMercator());
            if (lonLat.lon < outExtent.southWest.lon) {
                outExtent.southWest.lon = lonLat.lon;
            }
            if (lonLat.lat < outExtent.southWest.lat) {
                outExtent.southWest.lat = lonLat.lat;
            }
            if (lonLat.lon > outExtent.northEast.lon) {
                outExtent.northEast.lon = lonLat.lon;
            }
            if (lonLat.lat > outExtent.northEast.lat) {
                outExtent.northEast.lat = lonLat.lat;
            }
        }
        Vec3.doubleToTwoFloats(point3v, v_high, v_low);
        let vi = outVerticesHigh.length - 12;
        outVerticesHigh[vi] = v_high.x;
        outVerticesHigh[vi + 1] = v_high.y;
        outVerticesHigh[vi + 2] = v_high.z;
        outVerticesHigh[vi + 3] = v_high.x;
        outVerticesHigh[vi + 4] = v_high.y;
        outVerticesHigh[vi + 5] = v_high.z;
        outVerticesHigh[vi + 6] = v_high.x;
        outVerticesHigh[vi + 7] = v_high.y;
        outVerticesHigh[vi + 8] = v_high.z;
        outVerticesHigh[vi + 9] = v_high.x;
        outVerticesHigh[vi + 10] = v_high.y;
        outVerticesHigh[vi + 11] = v_high.z;
        outVerticesLow[vi] = v_low.x;
        outVerticesLow[vi + 1] = v_low.y;
        outVerticesLow[vi + 2] = v_low.z;
        outVerticesLow[vi + 3] = v_low.x;
        outVerticesLow[vi + 4] = v_low.y;
        outVerticesLow[vi + 5] = v_low.z;
        outVerticesLow[vi + 6] = v_low.x;
        outVerticesLow[vi + 7] = v_low.y;
        outVerticesLow[vi + 8] = v_low.z;
        outVerticesLow[vi + 9] = v_low.x;
        outVerticesLow[vi + 10] = v_low.y;
        outVerticesLow[vi + 11] = v_low.z;
        let ci = outColors.length - 16;
        outColors[ci] = r;
        outColors[ci + 1] = g;
        outColors[ci + 2] = b;
        outColors[ci + 3] = a;
        outColors[ci + 4] = r;
        outColors[ci + 5] = g;
        outColors[ci + 6] = b;
        outColors[ci + 7] = a;
        outColors[ci + 8] = r;
        outColors[ci + 9] = g;
        outColors[ci + 10] = b;
        outColors[ci + 11] = a;
        outColors[ci + 12] = r;
        outColors[ci + 13] = g;
        outColors[ci + 14] = b;
        outColors[ci + 15] = a;
        outIndexes[ii] = index++;
        outIndexes[ii + 1] = index++;
        outIndexes[ii + 2] = index++;
        outIndexes[ii + 3] = index++;
        //
        // Close path
        //
        var first;
        if (isClosed) {
            first = path[0];
            outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
        }
        else {
            let p0 = path[path.length - 1], p1 = path[path.length - 2] || p0;
            first = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
            outIndexes.push(index - 1, index - 1, index - 1, index - 1);
        }
        Vec3.doubleToTwoFloats(first, v_high, v_low);
        outVerticesHigh.push(v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z);
        outVerticesLow.push(v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z);
        outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);
        outOrders.push(1, -1, 2, -2);
    }
    static setPathColors(pathLonLat, pathColors, defaultColor, outColors) {
        for (let j = 0, len = pathLonLat.length; j < len; j++) {
            var path = pathLonLat[j], pathColors_j = pathColors[j];
            if (path.length === 0) {
                continue;
            }
            let color = defaultColor;
            if (pathColors_j && pathColors_j[0]) {
                color = pathColors_j[0];
            }
            let r = color[R], g = color[G], b = color[B], a = color[A] != undefined ? color[A] : 1.0;
            if (j > 0) {
                outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);
            }
            for (let i = 0, len = path.length; i < len; i++) {
                var cur = path[i];
                if (cur instanceof Array) {
                    cur = new LonLat(cur[0], cur[1], cur[2]);
                }
                if (pathColors_j && pathColors_j[i]) {
                    color = pathColors_j[i];
                }
                r = color[R];
                g = color[G];
                b = color[B];
                a = color[A] != undefined ? color[A] : 1.0;
                outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);
            }
            if (pathColors_j && pathColors_j[path.length - 1]) {
                color = pathColors_j[path.length - 1];
            }
            r = color[R];
            g = color[G];
            b = color[B];
            a = color[A] != undefined ? color[A] : 1.0;
            outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);
        }
    }
    /**
     * Appends to the line array new geodetic coordinates line data.
     * @static
     */
    static appendLineDataLonLat(pathLonLat, pathColors, defaultColor, isClosed, outVerticesHigh, outVerticesLow, outOrders, outIndexes, ellipsoid, outTransformedPathCartesian, outPathLonLat, outTransformedPathMerc, outExtent, outColors) {
        var index = 0;
        var v_high = new Vec3(), v_low = new Vec3();
        if (outExtent) {
            outExtent.southWest.set(180.0, 90.0);
            outExtent.northEast.set(-180.0, -90.0);
        }
        if (outIndexes.length > 0) {
            index = outIndexes[outIndexes.length - 5] + 9;
            outIndexes.push(index);
        }
        else {
            outIndexes.push(0);
        }
        for (let j = 0, len = pathLonLat.length; j < len; j++) {
            var path = pathLonLat[j], pathColors_j = pathColors[j];
            outTransformedPathCartesian[j] = [];
            outTransformedPathMerc[j] = [];
            outPathLonLat[j] = [];
            if (path.length === 0) {
                continue;
            }
            var startIndex = index;
            var last;
            if (isClosed) {
                let pp = path[path.length - 1];
                if (pp instanceof Array) {
                    last = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
                }
                else {
                    last = ellipsoid.lonLatToCartesian(pp);
                }
            }
            else {
                let p0, p1;
                let pp = path[0];
                if (pp instanceof Array) {
                    p0 = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
                }
                else {
                    p0 = ellipsoid.lonLatToCartesian(pp);
                }
                pp = path[1];
                if (!pp) {
                    pp = path[0];
                }
                if (pp instanceof Array) {
                    p1 = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
                }
                else {
                    p1 = ellipsoid.lonLatToCartesian(pp);
                }
                last = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
            }
            let color = defaultColor;
            if (pathColors_j && pathColors_j[0]) {
                color = pathColors_j[0];
            }
            Vec3.doubleToTwoFloats(last, v_high, v_low);
            outVerticesHigh.push(v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z);
            outVerticesLow.push(v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z);
            let r = color[R], g = color[G], b = color[B], a = color[A] != undefined ? color[A] : 1.0;
            if (j > 0) {
                outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);
            }
            outOrders.push(1, -1, 2, -2);
            for (let i = 0, len = path.length; i < len; i++) {
                var cur = path[i];
                if (cur instanceof Array) {
                    cur = new LonLat(cur[0], cur[1], cur[2]);
                }
                if (pathColors_j && pathColors_j[i]) {
                    color = pathColors_j[i];
                }
                r = color[R];
                g = color[G];
                b = color[B];
                a = color[A] != undefined ? color[A] : 1.0;
                var cartesian = ellipsoid.lonLatToCartesian(cur);
                outTransformedPathCartesian[j].push(cartesian);
                outPathLonLat[j].push(cur);
                outTransformedPathMerc[j].push(cur.forwardMercator());
                Vec3.doubleToTwoFloats(cartesian, v_high, v_low);
                outVerticesHigh.push(v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z);
                outVerticesLow.push(v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z);
                outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);
                outOrders.push(1, -1, 2, -2);
                outIndexes.push(index++, index++, index++, index++);
                if (cur.lon < outExtent.southWest.lon) {
                    outExtent.southWest.lon = cur.lon;
                }
                if (cur.lat < outExtent.southWest.lat) {
                    outExtent.southWest.lat = cur.lat;
                }
                if (cur.lon > outExtent.northEast.lon) {
                    outExtent.northEast.lon = cur.lon;
                }
                if (cur.lat > outExtent.northEast.lat) {
                    outExtent.northEast.lat = cur.lat;
                }
            }
            var first;
            if (isClosed) {
                let pp = path[0];
                if (pp instanceof Array) {
                    first = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
                }
                else {
                    first = ellipsoid.lonLatToCartesian(pp);
                }
                outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
            }
            else {
                let p0, p1;
                let pp = path[path.length - 1];
                if (pp instanceof Array) {
                    p0 = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
                }
                else {
                    p0 = ellipsoid.lonLatToCartesian(pp);
                }
                pp = path[path.length - 2];
                if (!pp) {
                    pp = path[0];
                }
                if (pp instanceof Array) {
                    p1 = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
                }
                else {
                    p1 = ellipsoid.lonLatToCartesian(pp);
                }
                first = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
                outIndexes.push(index - 1, index - 1, index - 1, index - 1);
            }
            if (pathColors_j && pathColors_j[path.length - 1]) {
                color = pathColors_j[path.length - 1];
            }
            r = color[R];
            g = color[G];
            b = color[B];
            a = color[A] != undefined ? color[A] : 1.0;
            Vec3.doubleToTwoFloats(first, v_high, v_low);
            outVerticesHigh.push(v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z);
            outVerticesLow.push(v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z);
            outColors.push(r, g, b, a, r, g, b, a, r, g, b, a, r, g, b, a);
            outOrders.push(1, -1, 2, -2);
            if (j < pathLonLat.length - 1 && pathLonLat[j + 1].length !== 0) {
                index += 8;
                outIndexes.push(index, index);
            }
        }
    }
    /**
     * Sets polyline path with cartesian coordinates.
     * @protected
     * @param {SegmentPath3vExt[]} path3v - Cartesian coordinates.
     */
    _setEqualPath3v(path3v) {
        var extent = this._extent;
        extent.southWest.set(180, 90);
        extent.northEast.set(-180, -90);
        var v_high = new Vec3(), v_low = new Vec3();
        var vh = this._verticesHigh, vl = this._verticesLow, l = this._pathLonLat, m = this._pathLonLatMerc, k = 0;
        var ellipsoid = this._renderNode.ellipsoid;
        for (let j = 0; j < path3v.length; j++) {
            var path = path3v[j];
            var last;
            if (this._closedLine) {
                last = path[path.length - 1];
            }
            else {
                last = new Vec3(path[0].x + path[0].x - path[1].x, path[0].y + path[0].y - path[1].y, path[0].z + path[0].z - path[1].z);
            }
            Vec3.doubleToTwoFloats(last, v_high, v_low);
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
            for (let i = 0; i < path.length; i++) {
                var cur = path[i], pji = this._path3v[j][i];
                pji.x = cur.x;
                pji.y = cur.y;
                pji.z = cur.z;
                if (ellipsoid) {
                    var lonLat = ellipsoid.cartesianToLonLat(cur);
                    this._pathLonLat[j][i] = lonLat;
                    l[j][i] = lonLat;
                    m[j][i] = lonLat.forwardMercator();
                    if (lonLat.lon < extent.southWest.lon) {
                        extent.southWest.lon = lonLat.lon;
                    }
                    if (lonLat.lat < extent.southWest.lat) {
                        extent.southWest.lat = lonLat.lat;
                    }
                    if (lonLat.lon > extent.northEast.lon) {
                        extent.northEast.lon = lonLat.lon;
                    }
                    if (lonLat.lat > extent.northEast.lat) {
                        extent.northEast.lat = lonLat.lat;
                    }
                }
                Vec3.doubleToTwoFloats(cur, v_high, v_low);
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
            }
            var first;
            if (this._closedLine) {
                first = path[0];
            }
            else {
                var l1 = path.length - 1;
                first = new Vec3(path[l1].x + path[l1].x - path[l1 - 1].x, path[l1].y + path[l1].y - path[l1 - 1].y, path[l1].z + path[l1].z - path[l1 - 1].z);
            }
            Vec3.doubleToTwoFloats(first, v_high, v_low);
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
        }
    }
    /**
     * Sets polyline with geodetic coordinates.
     * @protected
     * @param {SegmentPathLonLat[]} pathLonLat - Geodetic polyline path coordinates.
     */
    _setEqualPathLonLat(pathLonLat) {
        var extent = this._extent;
        extent.southWest.set(180.0, 90.0);
        extent.northEast.set(-180.0, -90.0);
        var v_high = new Vec3(), v_low = new Vec3();
        var vh = this._verticesHigh, vl = this._verticesLow, l = this._pathLonLat, m = this._pathLonLatMerc, c = this._path3v, k = 0;
        var ellipsoid = this._renderNode.ellipsoid;
        for (let j = 0; j < pathLonLat.length; j++) {
            var path = pathLonLat[j];
            var last;
            if (this._closedLine) {
                last = ellipsoid.lonLatToCartesian(path[path.length - 1]);
            }
            else {
                let p0 = ellipsoid.lonLatToCartesian(path[0]), p1 = ellipsoid.lonLatToCartesian(path[1]);
                last = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
            }
            Vec3.doubleToTwoFloats(last, v_high, v_low);
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
            for (let i = 0; i < path.length; i++) {
                var cur = path[i];
                var cartesian = ellipsoid.lonLatToCartesian(cur);
                c[j][i] = cartesian;
                m[j][i] = cur.forwardMercator();
                l[j][i] = cur;
                Vec3.doubleToTwoFloats(cartesian, v_high, v_low);
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                vh[k] = v_high.x;
                vl[k++] = v_low.x;
                vh[k] = v_high.y;
                vl[k++] = v_low.y;
                vh[k] = v_high.z;
                vl[k++] = v_low.z;
                if (cur.lon < extent.southWest.lon) {
                    extent.southWest.lon = cur.lon;
                }
                if (cur.lat < extent.southWest.lat) {
                    extent.southWest.lat = cur.lat;
                }
                if (cur.lon > extent.northEast.lon) {
                    extent.northEast.lon = cur.lon;
                }
                if (cur.lat > extent.northEast.lat) {
                    extent.northEast.lat = cur.lat;
                }
            }
            var first;
            if (this._closedLine) {
                first = ellipsoid.lonLatToCartesian(path[0]);
            }
            else {
                let p0 = ellipsoid.lonLatToCartesian(path[path.length - 1]), p1 = ellipsoid.lonLatToCartesian(path[path.length - 2]);
                first = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
            }
            Vec3.doubleToTwoFloats(first, v_high, v_low);
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
            vh[k] = v_high.x;
            vl[k++] = v_low.x;
            vh[k] = v_high.y;
            vl[k++] = v_low.y;
            vh[k] = v_high.z;
            vl[k++] = v_low.z;
        }
    }
    setPointLonLat(lonlat, index, segmentIndex) {
        if (this._renderNode && this._renderNode.ellipsoid) {
            let l = this._pathLonLat, m = this._pathLonLatMerc;
            l[segmentIndex][index] = lonlat;
            m[segmentIndex][index] = lonlat.forwardMercator();
            //
            // Apply new extent(TODO: think about optimization)
            //
            var extent = this._extent;
            extent.southWest.set(180.0, 90.0);
            extent.northEast.set(-180.0, -90.0);
            for (let i = 0; i < l.length; i++) {
                var pi = l[i];
                for (let j = 0; j < pi.length; j++) {
                    var lon = pi[j].lon, lat = pi[j].lat;
                    if (lon > extent.northEast.lon) {
                        extent.northEast.lon = lon;
                    }
                    if (lat > extent.northEast.lat) {
                        extent.northEast.lat = lat;
                    }
                    if (lon < extent.southWest.lon) {
                        extent.southWest.lon = lon;
                    }
                    if (lat < extent.southWest.lat) {
                        extent.southWest.lat = lat;
                    }
                }
            }
            this.setPoint3v(this._renderNode.ellipsoid.lonLatToCartesian(lonlat), index, segmentIndex, true);
        }
        else {
            let path = this._pathLonLat[segmentIndex];
            path[index].lon = lonlat.lon;
            path[index].lat = lonlat.lat;
            path[index].height = lonlat.height;
        }
    }
    /**
     * Changes cartesian point coordinates of the path
     * @param {Vec3} coordinates - New coordinates
     * @param {number} [index=0] - Path segment index
     * @param {number} [segmentIndex=0] - Index of the point in the path segment
     * @param {boolean} [skipLonLat=false] - Do not update geodetic coordinates
     */
    setPoint3v(coordinates, index = 0, segmentIndex = 0, skipLonLat = false) {
        if (this._renderNode) {
            var v_high = new Vec3(), v_low = new Vec3();
            var vh = this._verticesHigh, vl = this._verticesLow, l = this._pathLonLat, m = this._pathLonLatMerc, k = 0, kk = 0;
            //for (let i = 0; i < segmentIndex; i++) {
            //    kk += this._path3v[i].length * 12 + 24;
            //}
            kk = this._pathLengths[segmentIndex] * 12 + 24 * segmentIndex;
            let path = this._path3v[segmentIndex];
            path[index].x = coordinates.x;
            path[index].y = coordinates.y;
            path[index].z = coordinates.z;
            let _closedLine = this._closedLine || path.length === 1;
            if (index === 0 || index === 1) {
                var last;
                if (_closedLine) {
                    last = path[path.length - 1];
                }
                else {
                    last = new Vec3(path[0].x + path[0].x - path[1].x, path[0].y + path[0].y - path[1].y, path[0].z + path[0].z - path[1].z);
                }
                k = kk;
                Vec3.doubleToTwoFloats(last, v_high, v_low);
                vh[k] = v_high.x;
                vh[k + 1] = v_high.y;
                vh[k + 2] = v_high.z;
                vh[k + 3] = v_high.x;
                vh[k + 4] = v_high.y;
                vh[k + 5] = v_high.z;
                vh[k + 6] = v_high.x;
                vh[k + 7] = v_high.y;
                vh[k + 8] = v_high.z;
                vh[k + 9] = v_high.x;
                vh[k + 10] = v_high.y;
                vh[k + 11] = v_high.z;
                vl[k] = v_low.x;
                vl[k + 1] = v_low.y;
                vl[k + 2] = v_low.z;
                vl[k + 3] = v_low.x;
                vl[k + 4] = v_low.y;
                vl[k + 5] = v_low.z;
                vl[k + 6] = v_low.x;
                vl[k + 7] = v_low.y;
                vl[k + 8] = v_low.z;
                vl[k + 9] = v_low.x;
                vl[k + 10] = v_low.y;
                vl[k + 11] = v_low.z;
            }
            if (!skipLonLat && this._renderNode.ellipsoid) {
                var lonLat = this._renderNode.ellipsoid.cartesianToLonLat(coordinates);
                l[segmentIndex][index] = lonLat;
                m[segmentIndex][index] = lonLat.forwardMercator();
                //
                // Apply new extent(TODO: think about optimization)
                //
                var extent = this._extent;
                extent.southWest.set(180.0, 90.0);
                extent.northEast.set(-180.0, -90.0);
                for (let i = 0; i < l.length; i++) {
                    var pi = l[i];
                    for (let j = 0; j < pi.length; j++) {
                        var lon = pi[j].lon, lat = pi[j].lat;
                        if (lon > extent.northEast.lon) {
                            extent.northEast.lon = lon;
                        }
                        if (lat > extent.northEast.lat) {
                            extent.northEast.lat = lat;
                        }
                        if (lon < extent.southWest.lon) {
                            extent.southWest.lon = lon;
                        }
                        if (lat < extent.southWest.lat) {
                            extent.southWest.lat = lat;
                        }
                    }
                }
            }
            k = kk + index * 12 + 12;
            Vec3.doubleToTwoFloats(coordinates, v_high, v_low);
            vh[k] = v_high.x;
            vh[k + 1] = v_high.y;
            vh[k + 2] = v_high.z;
            vh[k + 3] = v_high.x;
            vh[k + 4] = v_high.y;
            vh[k + 5] = v_high.z;
            vh[k + 6] = v_high.x;
            vh[k + 7] = v_high.y;
            vh[k + 8] = v_high.z;
            vh[k + 9] = v_high.x;
            vh[k + 10] = v_high.y;
            vh[k + 11] = v_high.z;
            vl[k] = v_low.x;
            vl[k + 1] = v_low.y;
            vl[k + 2] = v_low.z;
            vl[k + 3] = v_low.x;
            vl[k + 4] = v_low.y;
            vl[k + 5] = v_low.z;
            vl[k + 6] = v_low.x;
            vl[k + 7] = v_low.y;
            vl[k + 8] = v_low.z;
            vl[k + 9] = v_low.x;
            vl[k + 10] = v_low.y;
            vl[k + 11] = v_low.z;
            if (index === path.length - 1 || index === path.length - 2) {
                var first;
                if (_closedLine) {
                    first = path[0];
                }
                else {
                    var l1 = path.length - 1;
                    first = new Vec3(path[l1].x + path[l1].x - path[l1 - 1].x, path[l1].y + path[l1].y - path[l1 - 1].y, path[l1].z + path[l1].z - path[l1 - 1].z);
                }
                k = kk + path.length * 12 + 12;
                Vec3.doubleToTwoFloats(first, v_high, v_low);
                vh[k] = v_high.x;
                vh[k + 1] = v_high.y;
                vh[k + 2] = v_high.z;
                vh[k + 3] = v_high.x;
                vh[k + 4] = v_high.y;
                vh[k + 5] = v_high.z;
                vh[k + 6] = v_high.x;
                vh[k + 7] = v_high.y;
                vh[k + 8] = v_high.z;
                vh[k + 9] = v_high.x;
                vh[k + 10] = v_high.y;
                vh[k + 11] = v_high.z;
                vl[k] = v_low.x;
                vl[k + 1] = v_low.y;
                vl[k + 2] = v_low.z;
                vl[k + 3] = v_low.x;
                vl[k + 4] = v_low.y;
                vl[k + 5] = v_low.z;
                vl[k + 6] = v_low.x;
                vl[k + 7] = v_low.y;
                vl[k + 8] = v_low.z;
                vl[k + 9] = v_low.x;
                vl[k + 10] = v_low.y;
                vl[k + 11] = v_low.z;
            }
            this._changedBuffers[VERTICES_BUFFER] = true;
        }
        else {
            let path = this._path3v[segmentIndex];
            path[index].x = coordinates.x;
            path[index].y = coordinates.y;
            path[index].z = coordinates.z;
        }
    }
    _resizePathLengths(index = 0) {
        this._pathLengths[0] = 0;
        for (let i = index + 1, len = this._path3v.length; i <= len; i++) {
            this._pathLengths[i] = this._pathLengths[i - 1] + this._path3v[i - 1].length;
        }
    }
    /**
     * Remove path segment
     * @param {number} index - Path segment index
     */
    removeSegment(index) {
        this._path3v.splice(index, 1);
        this.setPath3v([].concat(this._path3v));
    }
    /**
     * Remove point from the path
     * @param {number} index - Point index in a path segment
     * @param {number} [multiLineIndex=0] - Segment path index
     */
    removePoint(index, multiLineIndex = 0) {
        this._path3v[multiLineIndex].splice(index, 1);
        if (this._path3v[multiLineIndex].length === 0) {
            this._path3v.splice(multiLineIndex, 1);
        }
        this.setPath3v([].concat(this._path3v));
    }
    /**
     * Insert point coordinates in a path segment
     * @param {Vec3} point3v - Point coordinates
     * @param {number} [index=0] - Index in the path
     * @param {NumberArray4} [color] - Point color
     * @param {number} [multilineIndex=0] - Path segment index
     */
    insertPoint3v(point3v, index = 0, color, multilineIndex = 0) {
        let p = [].concat(this._path3v), pp = p[multilineIndex];
        if (pp) {
            let c = [].concat(this._pathColors);
            pp.splice(index, 0, point3v);
            if (color) {
                let cc = c[multilineIndex];
                if (!cc) {
                    cc = new Array(pp.length);
                }
                cc.splice(index, 0, color);
            }
            this.setPath3v(p, c);
        }
        else {
            this.addPoint3v(point3v, multilineIndex);
        }
    }
    /**
     * Adds a new cartesian point in the end of the path in a last line segment.
     * @public
     * @param {Vec3} point3v - New coordinates.
     * @param {NumberArray4} [color] -
     * @param {boolean} [skipEllipsoid] -
     */
    appendPoint3v(point3v, color, skipEllipsoid) {
        if (this._path3v.length === 0 || !this._renderNode) {
            this._pathColors.push([color || this._defaultColor]);
            this.addPoint3v(point3v);
        }
        else {
            //
            // Making typedArrays suitable for appendPoint function
            //
            this._verticesHigh = makeArray(this._verticesHigh);
            this._verticesLow = makeArray(this._verticesLow);
            this._colors = makeArray(this._colors);
            this._orders = makeArray(this._orders);
            this._indexes = makeArray(this._indexes);
            Polyline.appendPoint3v(this._path3v, point3v, this._pathColors, color || this._defaultColor, this._closedLine, this._verticesHigh, this._verticesLow, this._colors, this._orders, this._indexes, !skipEllipsoid ? this._renderNode.ellipsoid : null, this._pathLonLat, this._pathLonLatMerc, this._extent);
            this._pathLengths[this._path3v.length] += 1;
            this._changedBuffers[VERTICES_BUFFER] = true;
            this._changedBuffers[COLORS_BUFFER] = true;
            this._changedBuffers[INDEX_BUFFER$1] = true;
        }
    }
    /**
     * Append new point in the end of the path.
     * @public
     * @param {Vec3} point3v - New point coordinates.
     * @param {number} [multiLineIndex=0] - Path segment index, first by default.
     */
    addPoint3v(point3v, multiLineIndex = 0) {
        //
        // TODO: could be optimized
        //
        if (multiLineIndex >= this._path3v.length) {
            this._path3v.push([]);
        }
        this._path3v[multiLineIndex].push(point3v);
        this.setPath3v([].concat(this._path3v));
    }
    /**
     * Append new geodetic point in the end of the path.
     * @public
     * @param {LonLat} lonLat - New coordinate.
     * @param {number} [multiLineIndex=0] - Path segment index, first by default.
     */
    addPointLonLat(lonLat, multiLineIndex = 0) {
        //
        // TODO: could be optimized
        //
        if (multiLineIndex >= this._pathLonLat.length) {
            this._pathLonLat.push([]);
        }
        this._pathLonLat[multiLineIndex].push(lonLat);
        this.setPathLonLat([].concat(this._pathLonLat));
    }
    /**
     * Clear polyline data.
     * @public
     */
    clear() {
        this._clearData();
    }
    /**
     * Change path point color
     * @param {NumberArray4} color - New color
     * @param {number} [index=0] - Point index
     * @param {number} [segmentIndex=0] - Path segment index
     */
    setPointColor(color, index = 0, segmentIndex = 0) {
        if (this._renderNode && index < this._path3v[segmentIndex].length) {
            let colors = this._pathColors[segmentIndex];
            if (!colors) {
                if (this._path3v[segmentIndex] && index < this._path3v[segmentIndex].length) {
                    this._pathColors[segmentIndex] = new Array(this._path3v[segmentIndex].length);
                }
                else {
                    return;
                }
            }
            if (!colors[index]) {
                colors[index] = [color[R], color[G], color[B], color[A] || 1.0];
            }
            else {
                colors[index][R] = color[R];
                colors[index][G] = color[G];
                colors[index][B] = color[B];
                colors[index][A] = color[A] || 1.0;
            }
            let c = this._colors;
            //optimized with this._pathLengths
            //for (let i = 0; i < segmentIndex; i++) {
            //    kk += this._path3v[i].length * 16 + 32;
            //}
            let k = index * 16 + this._pathLengths[segmentIndex] * 16 + 32 * segmentIndex;
            c[k] = c[k + 4] = c[k + 8] = c[k + 12] = color[R];
            c[k + 1] = c[k + 5] = c[k + 9] = c[k + 13] = color[G];
            c[k + 2] = c[k + 6] = c[k + 10] = c[k + 14] = color[B];
            c[k + 3] = c[k + 7] = c[k + 11] = c[k + 15] = color[A] || 1.0;
            this._changedBuffers[COLORS_BUFFER] = true;
        }
        else {
            let pathColors = this._pathColors[segmentIndex];
            pathColors[index] = color;
        }
    }
    /**
     * Sets polyline opacity.
     * @public
     * @param {number} opacity - Opacity.
     */
    setOpacity(opacity) {
        this._opacity = opacity;
    }
    /**
     * Sets Polyline thickness in screen pixels.
     * @public
     * @param {number} thickness - Thickness.
     */
    setAltitude(altitude) {
        this.altitude = altitude;
    }
    /**
     * Sets Polyline thickness in screen pixels.
     * @public
     * @param {number} thickness - Thickness.
     */
    setThickness(thickness) {
        this.thickness = thickness;
    }
    /**
     * Returns thickness.
     * @public
     * @return {number} Thickness in screen pixels.
     */
    getThickness() {
        return this.thickness;
    }
    /**
     * Sets visibility.
     * @public
     * @param {boolean} visibility - Polyline visibility.
     */
    setVisibility(visibility) {
        this.visibility = visibility;
    }
    /**
     * Gets Polyline visibility.
     * @public
     * @return {boolean} Polyline visibility.
     */
    getVisibility() {
        return this.visibility;
    }
    /**
     * Assign with render node.
     * @public
     * @param {RenderNode} renderNode -
     */
    setRenderNode(renderNode) {
        if (renderNode) {
            this._renderNode = renderNode;
            if (this._pathLonLat.length) {
                this._createDataLonLat([].concat(this._pathLonLat));
            }
            else {
                this._createData3v([].concat(this._path3v));
            }
            this._refresh();
            if (renderNode.renderer && renderNode.renderer.isInitialized()) {
                this._update();
            }
        }
    }
    _clearData() {
        //@ts-ignore
        this._verticesHigh = null;
        //@ts-ignore
        this._verticesLow = null;
        //@ts-ignore
        this._orders = null;
        //@ts-ignore
        this._indexes = null;
        //@ts-ignore
        this._colors = null;
        this._verticesHigh = [];
        this._verticesLow = [];
        this._orders = [];
        this._indexes = [];
        this._colors = [];
        this._path3v.length = 0;
        this._pathLonLat.length = 0;
        this._pathLonLatMerc.length = 0;
        this._path3v = [];
        this._pathLonLat = [];
        this._pathLonLatMerc = [];
    }
    _createData3v(path3v) {
        this._clearData();
        Polyline.appendLineData3v(path3v, this._pathColors, this._defaultColor, this._closedLine, this._verticesHigh, this._verticesLow, this._orders, this._indexes, this._renderNode.ellipsoid, this._pathLonLat, this._path3v, this._pathLonLatMerc, this._extent, this._colors);
        this._resizePathLengths(0);
    }
    _createDataLonLat(pathLonlat) {
        this._clearData();
        Polyline.appendLineDataLonLat(pathLonlat, this._pathColors, this._defaultColor, this._closedLine, this._verticesHigh, this._verticesLow, this._orders, this._indexes, this._renderNode.ellipsoid, this._path3v, this._pathLonLat, this._pathLonLatMerc, this._extent, this._colors);
        this._resizePathLengths(0);
    }
    /**
     * Removes from an entity.
     * @public
     */
    remove() {
        this._entity = null;
        this._pathColors.length = 0;
        this._pathColors = [];
        //@ts-ignore
        this._verticesHigh = null;
        //@ts-ignore
        this._verticesLow = null;
        //@ts-ignore
        this._orders = null;
        //@ts-ignore
        this._indexes = null;
        //@ts-ignore
        this._colors = null;
        this._verticesHigh = [];
        this._verticesLow = [];
        this._orders = [];
        this._indexes = [];
        this._colors = [];
        this._deleteBuffers();
        this._handler && this._handler.remove(this);
    }
    setPickingColor3v(color) {
        this._pickingColor[0] = color.x / 255.0;
        this._pickingColor[1] = color.y / 255.0;
        this._pickingColor[2] = color.z / 255.0;
    }
    /**
     * Returns polyline geodetic extent.
     * @public
     * @returns {Extent} - Geodetic extent
     */
    getExtent() {
        return this._extent.clone();
    }
    /**
     * Returns path cartesian coordinates.
     * @return {SegmentPath3vExt[]} Polyline path.
     */
    getPath3v() {
        return this._path3v;
    }
    /**
     * Returns geodetic path coordinates.
     * @return {SegmentPathLonLatExt[]} Polyline path.
     */
    getPathLonLat() {
        return this._pathLonLat;
    }
    getPathColors() {
        return this._pathColors;
    }
    /**
     * @todo
     * @param {NumberArray4[][]} pathColors
     */
    setPathColors(pathColors) {
        if (pathColors) {
            this._colors = [];
            this._pathColors = [].concat(pathColors);
            Polyline.setPathColors(this._pathLonLat, pathColors, this._defaultColor, this._colors);
            // Mark the colors buffer as changed
            this._changedBuffers[COLORS_BUFFER] = true;
        }
    }
    /**
     * Sets polyline color
     * @param {string} htmlColor- HTML color
     */
    setColorHTML(htmlColor) {
        this._defaultColor = htmlColorToFloat32Array(htmlColor);
        let color = htmlColorToRgba(htmlColor), p = this._pathColors;
        for (let i = 0, len = p.length; i < len; i++) {
            let s = p[i];
            for (let j = 0, slen = s.length; j < slen; j++) {
                s[j][0] = color.x;
                s[j][1] = color.y;
                s[j][2] = color.z;
                s[j][3] = color.w;
            }
        }
        let c = this._colors;
        for (let i = 0, len = c.length; i < len; i += 4) {
            c[i] = color.x;
            c[i + 1] = color.y;
            c[i + 2] = color.z;
            c[i + 3] = color.w;
        }
        this._changedBuffers[COLORS_BUFFER] = true;
    }
    /**
     * Sets polyline geodetic coordinates.
     * @public
     * @param {SegmentPathLonLat[]} pathLonLat - Polyline path cartesian coordinates.
     * @param {Boolean} [forceEqual=false] - OPTIMIZATION FLAG: Makes assigning faster for size equal coordinates array.
     */
    setPathLonLat(pathLonLat, forceEqual = false) {
        if (this._renderNode && this._renderNode.ellipsoid) {
            if (forceEqual) {
                this._setEqualPathLonLat(pathLonLat);
                this._changedBuffers[VERTICES_BUFFER] = true;
                this._changedBuffers[COLORS_BUFFER] = true;
            }
            else {
                this._createDataLonLat(pathLonLat);
                this._changedBuffers[VERTICES_BUFFER] = true;
                this._changedBuffers[INDEX_BUFFER$1] = true;
                this._changedBuffers[COLORS_BUFFER] = true;
            }
        }
        else {
            this._pathLonLat = [].concat(pathLonLat);
        }
    }
    /**
     * Sets Polyline cartesian coordinates.
     * @public
     * @param {SegmentPath3vExt[]} path3v - Polyline path cartesian coordinates. (exactly 3 entries)
     * @param {SegmentPathColor[]} [pathColors] - Polyline path cartesian coordinates. (exactly 3 entries)
     * @param {Boolean} [forceEqual=false] - Makes assigning faster for size equal coordinates array.
     */
    setPath3v(path3v, pathColors, forceEqual = false) {
        if (pathColors) {
            this._pathColors = [].concat(pathColors);
        }
        if (this._renderNode) {
            if (forceEqual) {
                this._setEqualPath3v(path3v);
                this._changedBuffers[VERTICES_BUFFER] = true;
                this._changedBuffers[COLORS_BUFFER] = true;
            }
            else {
                this._createData3v(path3v);
                this._changedBuffers[VERTICES_BUFFER] = true;
                this._changedBuffers[INDEX_BUFFER$1] = true;
                this._changedBuffers[COLORS_BUFFER] = true;
            }
        }
        else {
            this._path3v = [].concat(path3v);
        }
    }
    draw() {
        if (this.visibility && this._path3v.length) {
            this._update();
            let rn = this._renderNode;
            let r = rn.renderer;
            let sh = r.handler.programs.polyline_screen;
            let p = sh._program;
            let gl = r.handler.gl, sha = p.attributes, shu = p.uniforms;
            let ec = this._handler._entityCollection;
            sh.activate();
            gl.disable(gl.CULL_FACE);
            gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits);
            gl.uniformMatrix4fv(shu.proj, false, r.activeCamera.getProjectionMatrix());
            gl.uniformMatrix4fv(shu.view, false, r.activeCamera.getViewMatrix());
            // gl.uniform4fv(shu.color, [this.color.x, this.color.y, this.color.z, this.color.w * this._handler._entityCollection._fadingOpacity]);
            gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
            gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);
            //gl.uniform2fv(shu.uFloatParams, [(rn as Planet)._planetRadius2 || 0.0, r.activeCamera!._tanViewAngle_hradOneByHeight]);
            gl.uniform2fv(shu.viewport, [r.handler.canvas.width, r.handler.canvas.height]);
            gl.uniform1f(shu.thickness, this.thickness * 0.5);
            gl.uniform1f(shu.opacity, this._opacity * ec._fadingOpacity);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._colorsBuffer);
            gl.vertexAttribPointer(sha.color, this._colorsBuffer.itemSize, gl.FLOAT, false, 0, 0);
            let v = this._verticesHighBuffer;
            gl.bindBuffer(gl.ARRAY_BUFFER, v);
            gl.vertexAttribPointer(sha.prevHigh, v.itemSize, gl.FLOAT, false, 12, 0);
            gl.vertexAttribPointer(sha.currentHigh, v.itemSize, gl.FLOAT, false, 12, 48);
            gl.vertexAttribPointer(sha.nextHigh, v.itemSize, gl.FLOAT, false, 12, 96);
            v = this._verticesLowBuffer;
            gl.bindBuffer(gl.ARRAY_BUFFER, v);
            gl.vertexAttribPointer(sha.prevLow, v.itemSize, gl.FLOAT, false, 12, 0);
            gl.vertexAttribPointer(sha.currentLow, v.itemSize, gl.FLOAT, false, 12, 48);
            gl.vertexAttribPointer(sha.nextLow, v.itemSize, gl.FLOAT, false, 12, 96);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._ordersBuffer);
            gl.vertexAttribPointer(sha.order, this._ordersBuffer.itemSize, gl.FLOAT, false, 4, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexesBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, this._indexesBuffer.numItems, gl.UNSIGNED_INT, 0);
            gl.enable(gl.CULL_FACE);
        }
    }
    drawPicking() {
        if (this.visibility && this._path3v.length) {
            let rn = this._renderNode;
            let r = rn.renderer;
            let sh = r.handler.programs.polyline_picking;
            let p = sh._program;
            let gl = r.handler.gl, sha = p.attributes, shu = p.uniforms;
            sh.activate();
            gl.disable(gl.CULL_FACE);
            gl.uniform1f(shu.depthOffset, this._handler._entityCollection.polygonOffsetUnits);
            gl.uniformMatrix4fv(shu.proj, false, r.activeCamera.getProjectionMatrix());
            gl.uniformMatrix4fv(shu.view, false, r.activeCamera.getViewMatrix());
            gl.uniform4fv(shu.color, [
                this._pickingColor[0],
                this._pickingColor[1],
                this._pickingColor[2],
                1.0
            ]);
            gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
            gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);
            gl.uniform2fv(shu.uFloatParams, [rn._planetRadius2 || 0.0, r.activeCamera._tanViewAngle_hradOneByHeight]);
            //@todo: replace to the handler property
            gl.uniform2fv(shu.viewport, [r.handler.canvas.width, r.handler.canvas.height]);
            gl.uniform1f(shu.thickness, this.thickness * 0.5);
            let v = this._verticesHighBuffer;
            gl.bindBuffer(gl.ARRAY_BUFFER, v);
            gl.vertexAttribPointer(sha.prevHigh, v.itemSize, gl.FLOAT, false, 12, 0);
            gl.vertexAttribPointer(sha.currentHigh, v.itemSize, gl.FLOAT, false, 12, 48);
            gl.vertexAttribPointer(sha.nextHigh, v.itemSize, gl.FLOAT, false, 12, 96);
            v = this._verticesLowBuffer;
            gl.bindBuffer(gl.ARRAY_BUFFER, v);
            gl.vertexAttribPointer(sha.prevLow, v.itemSize, gl.FLOAT, false, 12, 0);
            gl.vertexAttribPointer(sha.currentLow, v.itemSize, gl.FLOAT, false, 12, 48);
            gl.vertexAttribPointer(sha.nextLow, v.itemSize, gl.FLOAT, false, 12, 96);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._ordersBuffer);
            gl.vertexAttribPointer(sha.order, this._ordersBuffer.itemSize, gl.FLOAT, false, 4, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexesBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, this._indexesBuffer.numItems, gl.UNSIGNED_INT, 0);
            gl.enable(gl.CULL_FACE);
        }
    }
    /**
     * Refresh buffers.
     * @protected
     */
    _refresh() {
        let i = this._changedBuffers.length;
        while (i--) {
            this._changedBuffers[i] = true;
        }
    }
    /**
     * Updates render buffers.
     * @protected
     */
    _update() {
        if (this._renderNode) {
            let i = this._changedBuffers.length;
            while (i--) {
                if (this._changedBuffers[i]) {
                    this._buffersUpdateCallbacks[i].call(this);
                    this._changedBuffers[i] = false;
                }
            }
        }
    }
    /**
     * Clear GL buffers.
     * @public
     */
    _deleteBuffers() {
        if (this._renderNode) {
            let r = this._renderNode.renderer, gl = r.handler.gl;
            gl.deleteBuffer(this._verticesHighBuffer);
            gl.deleteBuffer(this._verticesLowBuffer);
            gl.deleteBuffer(this._ordersBuffer);
            gl.deleteBuffer(this._indexesBuffer);
            gl.deleteBuffer(this._colorsBuffer);
            this._verticesHighBuffer = null;
            this._verticesLowBuffer = null;
            this._ordersBuffer = null;
            this._indexesBuffer = null;
            this._colorsBuffer = null;
        }
    }
    /**
     * Creates vertices buffers.
     * @protected
     */
    _createVerticesBuffer() {
        let h = this._renderNode.renderer.handler;
        let numItems = this._verticesHigh.length / 3;
        if (!this._verticesHighBuffer || this._verticesHighBuffer.numItems !== numItems) {
            h.gl.deleteBuffer(this._verticesHighBuffer);
            h.gl.deleteBuffer(this._verticesLowBuffer);
            this._verticesHighBuffer = h.createStreamArrayBuffer(3, numItems);
            this._verticesLowBuffer = h.createStreamArrayBuffer(3, numItems);
        }
        this._verticesHigh = makeArrayTyped(this._verticesHigh);
        this._verticesLow = makeArrayTyped(this._verticesLow);
        h.setStreamArrayBuffer(this._verticesHighBuffer, this._verticesHigh);
        h.setStreamArrayBuffer(this._verticesLowBuffer, this._verticesLow);
    }
    /**
     * Creates gl index and order buffer.
     * @protected
     */
    _createIndexBuffer() {
        let h = this._renderNode.renderer.handler;
        h.gl.deleteBuffer(this._ordersBuffer);
        h.gl.deleteBuffer(this._indexesBuffer);
        this._orders = makeArrayTyped(this._orders);
        this._ordersBuffer = h.createArrayBuffer(this._orders, 1, this._orders.length / 2);
        this._indexes = makeArrayTyped(this._indexes, Uint32Array);
        this._indexesBuffer = h.createElementArrayBuffer(this._indexes, 1, this._indexes.length);
    }
    _createColorsBuffer() {
        let h = this._renderNode.renderer.handler;
        h.gl.deleteBuffer(this._colorsBuffer);
        this._colors = makeArrayTyped(this._colors);
        this._colorsBuffer = h.createArrayBuffer(new Float32Array(this._colors), 4, this._colors.length / 4);
    }
}
Polyline.__counter__ = 0;

/**
 * Ray class.
 * @class
 * @param {Object} [options] - Options:
 * @param {Vec3|Array.<number>} [options.startPosition] - Ray start point position.
 * @param {Vec3|Array.<number>} [options.endPosition] - Ray end point position.
 * @param {Vec3|Array.<number>} [options.startColor] - Ray start point color.
 * @param {Vec3|Array.<number>} [options.endColor] - Ray end point color.
 * @param {boolean} [options.visibility] - Visibility.
 */
class Ray {
    constructor(options = {}) {
        this.__id = Ray.__counter__++;
        this._thickness = options.thickness || 2.0;
        this._startPosition = createVector3(options.startPosition);
        this._startPositionHigh = new Vec3();
        this._startPositionLow = new Vec3();
        Vec3.doubleToTwoFloats(this._startPosition, this._startPositionHigh, this._startPositionLow);
        this._endPosition = createVector3(options.endPosition);
        this._endPositionHigh = new Vec3();
        this._endPositionLow = new Vec3();
        Vec3.doubleToTwoFloats(this._endPosition, this._endPositionHigh, this._endPositionLow);
        this._startColor = createColorRGBA(options.startColor);
        this._endColor = createColorRGBA(options.endColor);
        this._visibility = options.visibility != undefined ? options.visibility : true;
        this._entity = null;
        this._handler = null;
        this._handlerIndex = -1;
    }
    /**
     * Sets ray start position.
     * @public
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} z - Z coordinate.
     */
    setStartPosition(x, y, z) {
        this._startPosition.x = x;
        this._startPosition.y = y;
        this._startPosition.z = z;
        Vec3.doubleToTwoFloats(this._startPosition, this._startPositionHigh, this._startPositionLow);
        this._handler &&
            this._handler.setStartPositionArr(this._handlerIndex, this._startPositionHigh, this._startPositionLow);
    }
    getLength() {
        return this._startPosition.distance(this._endPosition);
    }
    /**
     * Sets ray start position.
     * @public
     * @param {Vec3} position - Cartesian coordinates.
     */
    setStartPosition3v(position) {
        this._startPosition.x = position.x;
        this._startPosition.y = position.y;
        this._startPosition.z = position.z;
        Vec3.doubleToTwoFloats(this._startPosition, this._startPositionHigh, this._startPositionLow);
        this._handler &&
            this._handler.setStartPositionArr(this._handlerIndex, this._startPositionHigh, this._startPositionLow);
    }
    /**
     * Sets ray end position.
     * @public
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} z - Z coordinate.
     */
    setEndPosition(x, y, z) {
        this._endPosition.x = x;
        this._endPosition.y = y;
        this._endPosition.z = z;
        Vec3.doubleToTwoFloats(this._endPosition, this._endPositionHigh, this._endPositionLow);
        this._handler &&
            this._handler.setEndPositionArr(this._handlerIndex, this._endPositionHigh, this._endPositionLow);
    }
    /**
     * Sets ray end position.
     * @public
     * @param {Vec3} position - Cartesian coordinates.
     */
    setEndPosition3v(position) {
        this._endPosition.x = position.x;
        this._endPosition.y = position.y;
        this._endPosition.z = position.z;
        Vec3.doubleToTwoFloats(this._endPosition, this._endPositionHigh, this._endPositionLow);
        this._handler &&
            this._handler.setEndPositionArr(this._handlerIndex, this._endPositionHigh, this._endPositionLow);
    }
    setThickness(thickness) {
        this._thickness = thickness;
        this._handler && this._handler.setThicknessArr(this._handlerIndex, thickness);
    }
    setColors4v(startColor, endColor) {
        if (startColor) {
            this._startColor.x = startColor.x;
            this._startColor.y = startColor.y;
            this._startColor.z = startColor.z;
            this._startColor.w = startColor.w;
        }
        if (endColor) {
            this._endColor.x = endColor.x;
            this._endColor.y = endColor.y;
            this._endColor.z = endColor.z;
            this._endColor.w = endColor.w;
        }
        this._handler &&
            this._handler.setRgbaArr(this._handlerIndex, this._startColor, this._endColor);
    }
    setColorsHTML(startColor, endColor) {
        if (startColor) {
            this._startColor = htmlColorToRgba(startColor);
        }
        if (endColor) {
            this._endColor = htmlColorToRgba(endColor);
        }
        this._handler && this._handler.setRgbaArr(this._handlerIndex, this._startColor, this._endColor);
    }
    /**
     * Returns ray start position.
     * @public
     * @returns {Vec3}
     */
    getStartPosition() {
        return this._startPosition;
    }
    /**
     * Returns ray end position.
     * @public
     * @returns {Vec3}
     */
    getEndPosition() {
        return this._endPosition;
    }
    /**
     * Sets visibility.
     * @public
     * @param {boolean} visibility - Visibility flag.
     */
    setVisibility(visibility) {
        this._visibility = visibility;
        this._handler && this._handler.setVisibility(this._handlerIndex, visibility);
    }
    /**
     * Returns visibility.
     * @public
     * @returns {boolean}
     */
    getVisibility() {
        return this._visibility;
    }
    /**
     * Remove from handler.
     * @public
     */
    remove() {
        this._entity = null;
        this._handler && this._handler.remove(this);
    }
    /**
     * Set picking color.
     * @public
     * @param {Vec3} color - Picking color.
     */
    setPickingColor3v(color) {
        this._handler && this._handler.setPickingColorArr(this._handlerIndex, color);
    }
}
Ray.__counter__ = 0;

let _tempHigh$2 = new Vec3(), _tempLow$2 = new Vec3();
/**
 * Strip object.
 * @class
 * @param {*} [options] - Strip options:
 * @param {boolean} [options.visibility] - Strip visibility.
 * @example <caption>Stripe example</caption>
 * new og.Entity({
 *     strip: {
 *         gridSize: 10,
 *         path: [
 *             [[],[]],
 *             [[],[]]
 *         ]
 *     }
 * });
 */
class Strip {
    constructor(options = {}) {
        this.__id = Strip.__counter__++;
        this.visibility = options.visibility != undefined ? options.visibility : true;
        this.color = new Float32Array([1.0, 1.0, 1.0, 0.5]);
        if (options.color) {
            let color = createColorRGBA(options.color);
            this.setColor(color.x, color.y, color.z, color.w);
        }
        if (options.opacity) {
            this.setOpacity(options.opacity);
        }
        /**
         * Parent collection render node.
         * @protected
         * @type {RenderNode}
         */
        this._renderNode = null;
        /**
         * Entity instance that holds this strip.
         * @protected
         * @type {Entity}
         */
        this._entity = null;
        this._verticesHighBuffer = null;
        this._verticesLowBuffer = null;
        this._indexBuffer = null;
        this._verticesHigh = [];
        this._verticesLow = [];
        this._indexes = [];
        this._path = [];
        this._pickingColor = new Float32Array(4);
        this._gridSize = 1;
        /**
         * Handler that stores and renders this object.
         * @protected
         * @type {StripHandler}
         */
        this._handler = null;
        this._handlerIndex = -1;
        if (options.path) {
            this.setPath(options.path);
        }
    }
    /**
     * Assign picking color.
     * @public
     * @param {Vec3} color - Picking RGB color.
     */
    setPickingColor3v(color) {
        this._pickingColor[0] = color.x / 255.0;
        this._pickingColor[1] = color.y / 255.0;
        this._pickingColor[2] = color.z / 255.0;
        this._pickingColor[3] = 1.0;
    }
    /**
     * Clears object
     * @public
     */
    clear() {
        this._path.length = 0;
        this._path = [];
        this._verticesHigh.length = 0;
        this._verticesHigh = [];
        this._verticesLow.length = 0;
        this._verticesLow = [];
        this._indexes.length = 0;
        this._indexes = [];
        this._deleteBuffers();
    }
    /**
     * Sets RGBA color. Each channel from 0.0 to 1.0.
     * @public
     * @param {Vec4} color - RGBA vector.
     */
    setColor4v(color) {
        this.setColor(color.x, color.y, color.z, color.w);
    }
    /**
     * Sets strip color.
     * @public
     * @param {string} color - HTML style color.
     */
    setColorHTML(color) {
        this.setColor4v(htmlColorToRgba(color));
    }
    setColor(r, g, b, a) {
        a = a || this.color[3];
        this.color[0] = r;
        this.color[1] = g;
        this.color[2] = b;
        this.color[3] = a;
    }
    /**
     * Set strip opacity.
     * @public
     * @param {number} opacity - opacity.
     */
    setOpacity(opacity) {
        this.color[3] = opacity || 0;
    }
    /**
     * Sets cloud visibility.
     * @public
     * @param {boolean} visibility - Visibility flag.
     */
    setVisibility(visibility) {
        this.visibility = visibility;
    }
    /**
     * @return {boolean} Strip visibility.
     */
    getVisibility() {
        return this.visibility;
    }
    /**
     * Assign rendering scene node.
     * @public
     * @param {RenderNode}  renderNode - Assigned render node.
     */
    setRenderNode(renderNode) {
        this._renderNode = renderNode;
        this._createBuffers();
    }
    /**
     * Removes from entity.
     * @public
     */
    remove() {
        this._entity = null;
        this._handler && this._handler.remove(this);
    }
    draw() {
        if (this.visibility && this._verticesHigh.length) {
            let r = this._renderNode.renderer;
            let gl = r.handler.gl;
            let sh = r.handler.programs.strip, p = sh._program, sha = p.attributes, shu = p.uniforms;
            sh.activate();
            gl.disable(gl.CULL_FACE);
            gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera.getViewMatrix());
            gl.uniformMatrix4fv(shu.projectionMatrix, false, r.activeCamera.getProjectionMatrix());
            gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
            gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);
            gl.uniform4fv(shu.uColor, this.color);
            gl.uniform1f(shu.uOpacity, this._entity._entityCollection._fadingOpacity);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesHighBuffer);
            gl.vertexAttribPointer(sha.aVertexPositionHigh, this._verticesHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesLowBuffer);
            gl.vertexAttribPointer(sha.aVertexPositionLow, this._verticesLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            gl.drawElements(r.handler.gl.TRIANGLE_STRIP, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
            gl.enable(gl.CULL_FACE);
        }
    }
    drawPicking() {
        if (this.visibility && this._verticesHigh.length) {
            let r = this._renderNode.renderer;
            let gl = r.handler.gl;
            let sh = r.handler.programs.strip, p = sh._program, sha = p.attributes, shu = p.uniforms;
            sh.activate();
            gl.disable(gl.CULL_FACE);
            gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera.getViewMatrix());
            gl.uniformMatrix4fv(shu.projectionMatrix, false, r.activeCamera.getProjectionMatrix());
            gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
            gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);
            gl.uniform1f(shu.uOpacity, this._entity._entityCollection._fadingOpacity != 0 ? 1 : 0);
            gl.uniform4fv(shu.uColor, this._pickingColor);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesHighBuffer);
            gl.vertexAttribPointer(sha.aVertexPositionHigh, this._verticesHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesLowBuffer);
            gl.vertexAttribPointer(sha.aVertexPositionLow, this._verticesLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            gl.drawElements(r.handler.gl.TRIANGLE_STRIP, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
            gl.enable(gl.CULL_FACE);
        }
    }
    /**
     * Delete buffers
     * @public
     */
    _deleteBuffers() {
        if (this._renderNode && this._renderNode.renderer) {
            let r = this._renderNode.renderer, gl = r.handler.gl;
            gl.deleteBuffer(this._indexBuffer);
            gl.deleteBuffer(this._verticesHighBuffer);
            gl.deleteBuffer(this._verticesLowBuffer);
        }
        this._verticesHighBuffer = null;
        this._verticesLowBuffer = null;
        this._indexBuffer = null;
    }
    _createBuffers() {
        if (this._renderNode && this._renderNode.renderer && this._renderNode.renderer.isInitialized()) {
            let gl = this._renderNode.renderer.handler.gl;
            gl.deleteBuffer(this._indexBuffer);
            gl.deleteBuffer(this._verticesHighBuffer);
            gl.deleteBuffer(this._verticesLowBuffer);
            this._verticesHighBuffer = this._renderNode.renderer.handler.createArrayBuffer(new Float32Array(this._verticesHigh), 3, this._verticesHigh.length / 3);
            this._verticesLowBuffer = this._renderNode.renderer.handler.createArrayBuffer(new Float32Array(this._verticesLow), 3, this._verticesLow.length / 3);
            this._indexBuffer = this._renderNode.renderer.handler.createElementArrayBuffer(new Uint32Array(this._indexes), 1, this._indexes.length);
        }
    }
    addEdge3v(p2, p3) {
        let length = this._path.length;
        if (length === 0) {
            this._path.push([p2.clone(), p3.clone()]);
        }
        else {
            let p0 = this._path[length - 1][0], p1 = this._path[length - 1][1];
            this._path.push([p2.clone(), p3.clone()]);
            let vHigh = this._verticesHigh, vLow = this._verticesLow;
            let gs = this._gridSize, gs1 = gs + 1;
            let p = new Vec3();
            let last = this._verticesHigh.length / 3, ind = last;
            let d = Math.abs(p0.sub(p1).normal().dot(p2.sub(p0).normal()));
            for (let i = 0; i < gs1; i++) {
                let di = i / gs;
                let p02 = p0.lerp(p2, di), p13 = p1.lerp(p3, di);
                for (let j = 0; j < gs1; j++) {
                    let dj = j / gs;
                    let p01 = p0.lerp(p1, dj), p23 = p2.lerp(p3, dj);
                    if (d !== 1.0) {
                        new Line3(p02, p13).intersects(new Line3(p01, p23), p);
                    }
                    else {
                        p = p23;
                    }
                    ind = last + i * gs1 + j;
                    Vec3.doubleToTwoFloats(p, _tempHigh$2, _tempLow$2);
                    let ind3 = ind * 3;
                    vHigh[ind3] = _tempHigh$2.x;
                    vHigh[ind3 + 1] = _tempHigh$2.y;
                    vHigh[ind3 + 2] = _tempHigh$2.z;
                    vLow[ind3] = _tempLow$2.x;
                    vLow[ind3 + 1] = _tempLow$2.y;
                    vLow[ind3 + 2] = _tempLow$2.z;
                    if (i < gs) {
                        this._indexes.push(ind, ind + gs1);
                    }
                }
                if (i < gs) {
                    this._indexes.push(ind + gs1, ind + 1);
                }
            }
            this._createBuffers();
        }
    }
    setEdge3v(p2, p3, index) {
        if (index === this._path.length) {
            this.addEdge3v(p2, p3);
            return;
        }
        if (this._path[index]) {
            this._path[index][0] = p2;
            this._path[index][1] = p3;
            if (this._path.length > 1) {
                let gs = this._gridSize, gs1 = gs + 1;
                let vSize = gs1 * gs1;
                let p = new Vec3();
                let vHigh = this._verticesHigh, vLow = this._verticesLow;
                if (index === this._path.length - 1) {
                    let p0 = this._path[index - 1][0], p1 = this._path[index - 1][1];
                    let prev = this._verticesHigh.length / 3 - vSize, ind = prev;
                    let d = Math.abs(p0.sub(p1).normal().dot(p2.sub(p0).normal()));
                    for (let i = 0; i < gs1; i++) {
                        let di = i / gs;
                        let p02 = p0.lerp(p2, di), p13 = p1.lerp(p3, di);
                        for (let j = 0; j < gs1; j++) {
                            let dj = j / gs;
                            let p01 = p0.lerp(p1, dj), p23 = p2.lerp(p3, dj);
                            if (d !== 1.0) {
                                new Line3(p02, p13).intersects(new Line3(p01, p23), p);
                            }
                            else {
                                p = p23;
                            }
                            ind = prev + i * gs1 + j;
                            Vec3.doubleToTwoFloats(p, _tempHigh$2, _tempLow$2);
                            let ind3 = ind * 3;
                            vHigh[ind3] = _tempHigh$2.x;
                            vHigh[ind3 + 1] = _tempHigh$2.y;
                            vHigh[ind3 + 2] = _tempHigh$2.z;
                            vLow[ind3] = _tempLow$2.x;
                            vLow[ind3 + 1] = _tempLow$2.y;
                            vLow[ind3 + 2] = _tempLow$2.z;
                        }
                    }
                }
                else if (index === 0) {
                    let ind = 0;
                    let p0 = p2, p1 = p3;
                    p2 = this._path[1][0];
                    p3 = this._path[1][1];
                    for (let i = 0; i < gs1; i++) {
                        let di = i / gs;
                        let p02 = p0.lerp(p2, di), p13 = p1.lerp(p3, di);
                        for (let j = 0; j < gs1; j++) {
                            let dj = j / gs;
                            let p01 = p0.lerp(p1, dj), p23 = p2.lerp(p3, dj);
                            new Line3(p02, p13).intersects(new Line3(p01, p23), p);
                            ind = i * gs1 + j;
                            Vec3.doubleToTwoFloats(p, _tempHigh$2, _tempLow$2);
                            let ind3 = ind * 3;
                            vHigh[ind3] = _tempHigh$2.x;
                            vHigh[ind3 + 1] = _tempHigh$2.y;
                            vHigh[ind3 + 2] = _tempHigh$2.z;
                            vLow[ind3] = _tempLow$2.x;
                            vLow[ind3 + 1] = _tempLow$2.y;
                            vLow[ind3 + 2] = _tempLow$2.z;
                        }
                    }
                }
                else if (index > 0 && index < this._path.length) {
                    let p0 = this._path[index - 1][0], p1 = this._path[index - 1][1];
                    let p4 = this._path[index + 1][0], p5 = this._path[index + 1][1];
                    let next = index * vSize, prev = (index - 1) * vSize, ind = prev;
                    for (let i = 0; i < gs1; i++) {
                        let di = i / gs;
                        let p02 = p0.lerp(p2, di), p35 = p3.lerp(p5, di), p24 = p2.lerp(p4, di), p13 = p1.lerp(p3, di);
                        for (let j = 0; j < gs1; j++) {
                            let dj = j / gs;
                            let p01 = p0.lerp(p1, dj), p23 = p2.lerp(p3, dj);
                            // prev
                            new Line3(p02, p13).intersects(new Line3(p01, p23), p);
                            let ij = i * gs1 + j;
                            ind = prev + ij;
                            Vec3.doubleToTwoFloats(p, _tempHigh$2, _tempLow$2);
                            let ind3 = ind * 3;
                            vHigh[ind3] = _tempHigh$2.x;
                            vHigh[ind3 + 1] = _tempHigh$2.y;
                            vHigh[ind3 + 2] = _tempHigh$2.z;
                            vLow[ind3] = _tempLow$2.x;
                            vLow[ind3 + 1] = _tempLow$2.y;
                            vLow[ind3 + 2] = _tempLow$2.z;
                            // next
                            let p45 = p4.lerp(p5, dj);
                            p23 = p2.lerp(p3, dj);
                            new Line3(p24, p35).intersects(new Line3(p23, p45), p);
                            ind = next + ij;
                            Vec3.doubleToTwoFloats(p, _tempHigh$2, _tempLow$2);
                            ind3 = ind * 3;
                            vHigh[ind3] = _tempHigh$2.x;
                            vHigh[ind3 + 1] = _tempHigh$2.y;
                            vHigh[ind3 + 2] = _tempHigh$2.z;
                            vLow[ind3] = _tempLow$2.x;
                            vLow[ind3 + 1] = _tempLow$2.y;
                            vLow[ind3 + 2] = _tempLow$2.z;
                        }
                    }
                }
                this._createBuffers();
            }
        }
        else {
            console.warn(`strip index ${index} is out of range`);
        }
    }
    removeEdge(index) {
        this._path.splice(index, 1);
        this.setPath([].concat(this._path));
    }
    setGridSize(gridSize) {
        this._gridSize = gridSize;
        this.setPath([].concat(this._path));
    }
    getPath() {
        return this._path;
    }
    setPath(path) {
        this._verticesHigh = [];
        this._verticesLow = [];
        this._indexes = [];
        this._path = [];
        for (let i = 0; i < path.length; i++) {
            let p0 = path[i][0], p1 = path[i][1];
            if (p0 instanceof Array) {
                p0 = new Vec3(p0[0], p0[1], p0[2]);
            }
            if (p1 instanceof Array) {
                p1 = new Vec3(p1[0], p1[1], p1[2]);
            }
            this.addEdge3v(p0, p1);
        }
    }
    insertEdge3v(p0, p1, index) {
        if (index < this._path.length) {
            let p = [].concat(this._path);
            p.splice(index, 0, [p0, p1]);
            this.setPath(p);
        }
        else if (index === this._path.length) {
            this.addEdge3v(p0, p1);
        }
    }
}
Strip.__counter__ = 0;

/**
 * Entity instances aggregate multiple forms of visualization into a single high-level object.
 * They can be created manually and added to entity collection.
 *
 * @class
 * @param {Object} [options] - Entity options:
 * @param {string} [options.name] - A human-readable name to display to users. It does not have to be unique.
 * @param {Vec3|Array.<number>} [options.cartesian] - Spatial entities like billboard, label etc. cartesian position.
 * @param {LonLat} [options.lonlat] - Geodetic coordinates for an entities like billboard, label etc.
 * @param {boolean} [options.aground] - True for entities that have to be placed on the relief.
 * @param {boolean} [options.visibility] - Entity visibility.
 * @param {*} [options.billboard] - Billboard options(see {@link Billboard}).
 * @param {*} [options.label] - Label options(see {@link Label}).
 * @param {*} [options.polyline] - Polyline options(see {@link Polyline}).
 * @param {*} [options.ray] - Ray options(see {@link Ray}).
 * @param {*} [options.pointCloud] - Point cloud options(see {@link PointCloud}).
 * @param {*} [options.geometry] - Geometry options (see {@link Geometry}), available for vector layer only.
 * @param {*} [options.properties] - Entity custom properties.
 */
class Entity {
    constructor(options = {}) {
        options.properties = options.properties || {};
        this.__id = Entity.__counter__++;
        this.properties = options.properties || {};
        this.properties.name = this.properties.name != undefined ? this.properties.name : "";
        this.childrenNodes = [];
        this.parent = null;
        this._cartesian = createVector3(options.cartesian);
        this._lonLat = createLonLat(options.lonlat);
        this._lonLatMerc = new LonLat();
        this._altitude = options.altitude || 0.0;
        this._visibility = options.visibility != undefined ? options.visibility : true;
        this._entityCollection = null;
        this._entityCollectionIndex = -1;
        this._layer = null;
        this._layerIndex = -1;
        this._pickingColor = new Vec3(0, 0, 0);
        this._independentPicking = options.independentPicking || false;
        this._featureConstructorArray = {
            billboard: [Billboard, this.setBillboard],
            label: [Label, this.setLabel],
            polyline: [Polyline, this.setPolyline],
            pointCloud: [PointCloud, this.setPointCloud],
            geometry: [Geometry, this.setGeometry],
            geoObject: [GeoObject, this.setGeoObject],
            strip: [Strip, this.setStrip],
            ray: [Ray, this.setRay]
        };
        this.billboard = this._createOptionFeature("billboard", options.billboard);
        this.label = this._createOptionFeature("label", options.label);
        this.polyline = this._createOptionFeature("polyline", options.polyline);
        this.ray = this._createOptionFeature("ray", options.ray);
        this.pointCloud = this._createOptionFeature("pointCloud", options.pointCloud);
        this.geometry = this._createOptionFeature("geometry", options.geometry);
        this.geoObject = this._createOptionFeature("geoObject", options.geoObject);
        this.strip = this._createOptionFeature("strip", options.strip);
    }
    get id() {
        return this.__id;
    }
    isEqual(entity) {
        return this.__id === entity.__id;
    }
    get layerIndex() {
        return this._layerIndex;
    }
    get instanceName() {
        return "Entity";
    }
    _createOptionFeature(featureName, options) {
        if (options) {
            let c = this._featureConstructorArray[featureName];
            return c[1].call(this, new c[0](options));
        }
        return null;
    }
    getCollectionIndex() {
        return this._entityCollectionIndex;
    }
    /**
     * Adds current entity into the specified entity collection.
     * @public
     * @param {EntityCollection | Vector} collection - Specified entity collection or vector layer.
     * @param {Boolean} [rightNow=false] - Entity insertion option for vector layer.
     * @returns {Entity} - This object.
     */
    addTo(collection, rightNow = false) {
        collection.add(this, rightNow);
        return this;
    }
    /**
     * Removes current entity from collection and layer.
     * @public
     */
    remove() {
        this._layer && this._layer.removeEntity(this);
        this._entityCollection && this._entityCollection.removeEntity(this);
    }
    /**
     * Sets the entity visibility.
     * @public
     * @param {boolean} visibility - Entity visibility.
     */
    setVisibility(visibility) {
        this._visibility = visibility;
        // billboards
        this.billboard && this.billboard.setVisibility(visibility);
        // geoObject
        this.geoObject && this.geoObject.setVisibility(visibility);
        // labels
        this.label && this.label.setVisibility(visibility);
        // polyline
        this.polyline && this.polyline.setVisibility(visibility);
        // ray
        this.ray && this.ray.setVisibility(visibility);
        // geometry
        this.geometry && this.geometry.setVisibility(visibility);
        for (let i = 0; i < this.childrenNodes.length; i++) {
            this.childrenNodes[i].setVisibility(visibility);
        }
    }
    /**
     * Returns entity visibility.
     * @public
     * @returns {boolean} -
     */
    getVisibility() {
        return this._visibility;
    }
    /**
     * Sets entity cartesian position.
     * @public
     * @param {Vec3} cartesian - Cartesian position in 3d space.
     */
    setCartesian3v(cartesian) {
        this.setCartesian(cartesian.x, cartesian.y, cartesian.z);
    }
    /**
     * Sets entity cartesian position.
     * @public
     * @param {number} x - 3d space X - position.
     * @param {number} y - 3d space Y - position.
     * @param {number} z - 3d space Z - position.
     */
    setCartesian(x, y, z) {
        let p = this._cartesian;
        p.x = x || 0.0;
        p.y = y || 0.0;
        p.z = z || 0.0;
        // billboards
        this.billboard && this.billboard.setPosition3v(p);
        // geoObject
        this.geoObject && this.geoObject.setPosition3v(p);
        // labels
        this.label && this.label.setPosition3v(p);
        for (let i = 0; i < this.childrenNodes.length; i++) {
            this.childrenNodes[i].setCartesian(x, y, z);
        }
        let ec = this._entityCollection;
        if (ec && ec.renderNode && ec.renderNode.ellipsoid) {
            this._lonLat = ec.renderNode.ellipsoid.cartesianToLonLat(p);
            if (Math.abs(this._lonLat.lat) < MAX_LAT) {
                this._lonLatMerc = this._lonLat.forwardMercator();
            }
            else {
                this._lonLatMerc.lon = this._lonLatMerc.lat = this._lonLatMerc.height = 0;
            }
        }
        //ec && ec.events.dispatch(ec.events.entitymove, this);
    }
    /**
     * Sets entity cartesian position without event dispatching.
     * @public
     * @param {Vec3} cartesian - Cartesian position in 3d space.
     * @param {boolean} skipLonLat - skip geodetic calculation.
     */
    _setCartesian3vSilent(cartesian, skipLonLat = false) {
        let p = this._cartesian;
        p.x = cartesian.x || 0.0;
        p.y = cartesian.y || 0.0;
        p.z = cartesian.z || 0.0;
        // billboards
        this.billboard && this.billboard.setPosition3v(p);
        // geoObject
        this.geoObject && this.geoObject.setPosition3v(p);
        // labels
        this.label && this.label.setPosition3v(p);
        for (let i = 0; i < this.childrenNodes.length; i++) {
            this.childrenNodes[i].setCartesian(p.x, p.y, p.z);
        }
        let ec = this._entityCollection;
        if (!skipLonLat && ec && ec.renderNode && ec.renderNode.ellipsoid) {
            this._lonLat = ec.renderNode.ellipsoid.cartesianToLonLat(p);
            if (Math.abs(this._lonLat.lat) < MAX_LAT) {
                this._lonLatMerc = this._lonLat.forwardMercator();
            }
        }
    }
    /**
     * Gets entity geodetic coordinates.
     * @public
     * @returns {LonLat} -
     */
    getLonLat() {
        return this._lonLat.clone();
    }
    /**
     * Sets geodetic coordinates of the entity point object.
     * @public
     * @param {LonLat} lonlat - WGS84 coordinates.
     */
    setLonLat(lonlat) {
        let l = this._lonLat;
        l.lon = lonlat.lon;
        l.lat = lonlat.lat;
        l.height = lonlat.height;
        let ec = this._entityCollection;
        if (ec && ec.renderNode && ec.renderNode.ellipsoid) {
            if (Math.abs(l.lat) < MAX_LAT) {
                this._lonLatMerc = l.forwardMercator();
            }
            ec.renderNode.ellipsoid.lonLatToCartesianRes(l, this._cartesian);
            this.setCartesian3v(this._cartesian);
        }
    }
    /**
     * Sets geodetic coordinates of the entity point object.
     * @public
     * @param {number} lon - Longitude.
     * @param {number} lat - Latitude
     * @param {number} [height] - Height
     */
    setLonLat2(lon, lat, height) {
        let l = this._lonLat;
        l.lon = lon;
        l.lat = lat;
        l.height = height != undefined ? height : l.height;
        let ec = this._entityCollection;
        if (ec && ec.renderNode && ec.renderNode.ellipsoid) {
            if (Math.abs(l.lat) < MAX_LAT) {
                this._lonLatMerc = l.forwardMercator();
            }
            else {
                this._lonLatMerc.lon = this._lonLatMerc.lat = this._lonLatMerc.height = 0;
            }
            ec.renderNode.ellipsoid.lonLatToCartesianRes(l, this._cartesian);
            this.setCartesian3v(this._cartesian);
        }
    }
    /**
     * Sets entity altitude over the planet.
     * @public
     * @param {number} altitude - Altitude.
     */
    setAltitude(altitude) {
        this._altitude = altitude;
    }
    /**
     * Sets entity altitude over the planet.
     * @public
     * @return {number} Altitude.
     */
    getAltitude() {
        return this._altitude;
    }
    /**
     * Returns cartesian position.
     * @public
     * @returns {Vec3} -
     */
    getCartesian() {
        return this._cartesian.clone();
    }
    /**
     * Sets entity billboard.
     * @public
     * @param {Billboard} billboard - Billboard object.
     * @returns {Billboard} -
     */
    setBillboard(billboard) {
        if (this.billboard) {
            this.billboard.remove();
        }
        this.billboard = billboard;
        this.billboard._entity = this;
        this.billboard.setPosition3v(this._cartesian);
        this.billboard.setVisibility(this._visibility);
        this._entityCollection && this._entityCollection.billboardHandler.add(billboard);
        return billboard;
    }
    /**
     * Sets entity label.
     * @public
     * @param {Label} label - Text label.
     * @returns {Label} -
     */
    setLabel(label) {
        if (this.label) {
            this.label.remove();
        }
        this.label = label;
        this.label._entity = this;
        this.label.setPosition3v(this._cartesian);
        this.label.setVisibility(this._visibility);
        this._entityCollection && this._entityCollection.labelHandler.add(label);
        return label;
    }
    /**
     * Sets entity ray.
     * @public
     * @param {Ray} ray - Ray object.
     * @returns {Ray} -
     */
    setRay(ray) {
        if (this.ray) {
            this.ray.remove();
        }
        this.ray = ray;
        this.ray._entity = this;
        this.ray.setVisibility(this._visibility);
        this._entityCollection && this._entityCollection.rayHandler.add(ray);
        return ray;
    }
    /**
     * Sets entity polyline.
     * @public
     * @param {Polyline} polyline - Polyline object.
     * @returns {Polyline} -
     */
    setPolyline(polyline) {
        if (this.polyline) {
            this.polyline.remove();
        }
        this.polyline = polyline;
        this.polyline._entity = this;
        this.polyline.setVisibility(this._visibility);
        this._entityCollection && this._entityCollection.polylineHandler.add(polyline);
        return polyline;
    }
    /**
     * Sets entity pointCloud.
     * @public
     * @param {PointCloud} pointCloud - PointCloud object.
     * @returns {PointCloud} -
     */
    setPointCloud(pointCloud) {
        if (this.pointCloud) {
            this.pointCloud.remove();
        }
        this.pointCloud = pointCloud;
        this.pointCloud._entity = this;
        this.pointCloud.setVisibility(this._visibility);
        this._entityCollection && this._entityCollection.pointCloudHandler.add(pointCloud);
        return pointCloud;
    }
    /**
     * Sets entity geometry.
     * @public
     * @param {Geometry} geometry - Geometry object.
     * @returns {Geometry} -
     */
    setGeometry(geometry) {
        if (this.geometry) {
            this.geometry.remove();
        }
        this.geometry = geometry;
        this.geometry._entity = this;
        this.geometry.setVisibility(this._visibility);
        let layer = this._layer;
        if (this._layer) {
            this._layer.removeEntity(this);
        }
        layer && layer.add(this);
        return geometry;
    }
    /**
     * Sets entity geoObject.
     * @public
     * @param {GeoObject} geoObject - GeoObject.
     * @returns {GeoObject} -
     */
    setGeoObject(geoObject) {
        if (this.geoObject) {
            this.geoObject.remove();
        }
        this.geoObject = geoObject;
        this.geoObject._entity = this;
        this.geoObject.setPosition3v(this._cartesian);
        this.geoObject.setVisibility(this._visibility);
        this._entityCollection && this._entityCollection.geoObjectHandler.add(geoObject);
        return geoObject;
    }
    /**
     * Sets entity strip.
     * @public
     * @param {Strip} strip - Strip object.
     * @returns {Strip} -
     */
    setStrip(strip) {
        if (this.strip) {
            this.strip.remove();
        }
        this.strip = strip;
        this.strip._entity = this;
        this.strip.setVisibility(this._visibility);
        this._entityCollection && this._entityCollection.stripHandler.add(strip);
        return strip;
    }
    get layer() {
        return this._layer;
    }
    get rendererEvents() {
        if (this._layer) {
            return this._layer.events;
        }
        else if (this._entityCollection) {
            return this._entityCollection.events;
        }
        return null;
    }
    /**
     * Append child entity.
     * @public
     * @param {Entity} entity - Child entity.
     */
    appendChild(entity) {
        entity._entityCollection = this._entityCollection;
        if (!entity._independentPicking) {
            entity._pickingColor = this._pickingColor;
        }
        entity.parent = this;
        this.childrenNodes.push(entity);
        this._entityCollection && this._entityCollection.appendChildEntity(entity);
    }
    /**
     * Appends entity items(billboard, label etc.) picking color.
     * @public
     */
    setPickingColor() {
        let c = this._pickingColor;
        this.billboard && this.billboard.setPickingColor3v(c);
        this.label && this.label.setPickingColor3v(c);
        this.polyline && this.polyline.setPickingColor3v(c);
        this.ray && this.ray.setPickingColor3v(c);
        this.strip && this.strip.setPickingColor3v(c);
        this.geoObject && this.geoObject.setPickingColor3v(c);
        for (let i = 0; i < this.childrenNodes.length; i++) {
            this.childrenNodes[i].setPickingColor();
        }
    }
    /**
     * Return geodetic extent.
     * @public
     * @returns {Extent} -
     */
    getExtent() {
        let res;
        let c = this._lonLat;
        if (this.billboard || this.label) {
            res = new Extent(new LonLat(c.lon, c.lat), new LonLat(c.lon, c.lat));
        }
        else {
            res = new Extent(new LonLat(180.0, 90.0), new LonLat(-180.0, -90.0));
        }
        let sw = res.southWest, ne = res.northEast;
        if (this.polyline) {
            let e = this.polyline.getExtent();
            if (e.southWest.lon < sw.lon)
                sw.lon = e.southWest.lon;
            if (e.southWest.lat < sw.lat)
                sw.lat = e.southWest.lat;
            if (e.northEast.lon > ne.lon)
                ne.lon = e.northEast.lon;
            if (e.northEast.lat > ne.lat)
                ne.lat = e.northEast.lat;
        }
        if (this.geometry) {
            let e = this.geometry.getExtent();
            if (e.southWest.lon < sw.lon)
                sw.lon = e.southWest.lon;
            if (e.southWest.lat < sw.lat)
                sw.lat = e.southWest.lat;
            if (e.northEast.lon > ne.lon)
                ne.lon = e.northEast.lon;
            if (e.northEast.lat > ne.lat)
                ne.lat = e.northEast.lat;
        }
        for (let i = 0; i < this.childrenNodes.length; i++) {
            let e = this.childrenNodes[i].getExtent();
            if (e.southWest.lon < sw.lon)
                sw.lon = e.southWest.lon;
            if (e.southWest.lat < sw.lat)
                sw.lat = e.southWest.lat;
            if (e.northEast.lon > ne.lon)
                ne.lon = e.northEast.lon;
            if (e.northEast.lat > ne.lat)
                ne.lat = e.northEast.lat;
        }
        return res;
    }
}
Entity.__counter__ = 0;

/**
 * Scene node base class.
 * @class
 * @param {string} name - Node name.
 */
class BaseNode {
    constructor(name) {
        this.__id = BaseNode.__counter__++;
        this._name = name || `nonameNode:${this.__id}`;
        this.topNode = this;
        this._dictionary = {};
        this._dictionary[this._name] = this;
        this.childNodes = [];
        this.parentNode = null;
    }
    get name() {
        return this._name;
    }
    /**
     * Adds node to the current hierarchy.
     * @public
     * @type {BaseNode}
     */
    addNode(node) {
        if (this.parentNode == null) {
            node.topNode = this;
        }
        else {
            node.topNode = this.topNode;
        }
        node.parentNode = this;
        node._dictionary = this.topNode._dictionary;
        this.childNodes.push(node);
        this.topNode._dictionary[node.name] = node;
    }
    /**
     * Destroy node.
     * @public
     */
    destroy() {
        for (let i = 0; i < this.childNodes.length; i++) {
            this.childNodes[i].destroy();
        }
        this._clear();
    }
    /**
     * Gets node by name in the current.
     * @public
     * @param {string} name - Node name.
     * @return {RenderNode} Node object in the current node.
     */
    getNodeByName(name) {
        return this._dictionary[name];
    }
    /**
     * Clear current node.
     * @protected
     */
    _clear() {
        this.parentNode = null;
        this.topNode = this;
        this.childNodes.length = 0;
    }
    isEqual(node) {
        return node.__id === this.__id;
    }
}
BaseNode.__counter__ = 0;

/**
 * Render node is a logical part of a render mechanism. Represents scene rendering.
 * For example one scene node for rendering the Earth, another one for rendering the Moon, another node for rendering stars etc.
 * Each render node has own model view space defined with matrices(scale, rotation, translation, transformation).
 * There are collections of light sources, entities and so on in the node.
 * Access to the node is renderer.renderNodes["Earth"]
 * @class
 * @extends {BaseNode}
 * @param {string} name - Node name.
 */
class RenderNode extends BaseNode {
    constructor(name) {
        super(name);
        this.childNodes = [];
        this.renderer = null;
        this.drawMode = 0;
        this.show = true;
        this._isActive = true;
        this.lightEnabled = false;
        this._lights = [];
        this._lightsNames = [];
        this._lightsPositions = [];
        this._lightsParamsv = [];
        this._lightsParamsf = [];
        this.entityCollections = [];
        this._pickingId = -1;
    }
    /**
     * Adds node to the current hierarchy.
     * @public
     * @type {RenderNode}
     */
    addNode(node) {
        super.addNode(node);
        this.renderer && node.assign(this.renderer);
    }
    /**
     * Assign render node with renderer.
     * @public
     * @param {Renderer} renderer - Render node's renderer.
     */
    assign(renderer) {
        this.renderer = renderer;
        this._pickingId = renderer.addPickingCallback(this, this._entityCollectionPickingCallback);
        this.initialize();
    }
    initialize() {
        if (this.renderer && this.renderer.isInitialized()) {
            for (let i = 0; i < this.entityCollections.length; i++) {
                this.entityCollections[i].bindRenderNode(this);
            }
            this.init();
        }
    }
    init() {
        //virtual
    }
    onremove() {
        //virtual
    }
    remove() {
        let r = this.renderer, n = this.name;
        if (r) {
            // TODO: replace to renderer
            if (r.renderNodes[n] && r.renderNodes[n].isEqual(this)) {
                // @ts-ignore
                r.renderNodes[n] = null;
                delete r.renderNodes[n];
            }
            for (let i = 0; i < r._renderNodesArr.length; i++) {
                if (r._renderNodesArr[i].isEqual(this)) {
                    r._renderNodesArr.splice(i, 1);
                    break;
                }
            }
            r.removePickingCallback(this._pickingId);
            this._pickingId = -1;
            this.onremove && this.onremove();
        }
    }
    /**
     * Adds entity collection.
     * @public
     * @param {EntityCollection} entityCollection - Entity collection.
     * @param {boolean} [isHidden] - If it's true that this collection has specific rendering.
     * @returns {RenderNode} -
     */
    addEntityCollection(entityCollection, isHidden) {
        entityCollection.addTo(this, isHidden);
        return this;
    }
    /**
     * Removes entity collection.
     * @public
     * @param {EntityCollection} entityCollection - Entity collection for remove.
     */
    removeEntityCollection(entityCollection) {
        entityCollection.remove();
    }
    /**
     * Adds point light source.
     * @public
     * @param {LightSource} light - Light source.
     * @returns {RenderNode}
     */
    addLight(light) {
        light.addTo(this);
        return this;
    }
    /**
     * Gets light object by its name.
     * @public
     * @param {string} name - Point light name.
     * @returns {LightSource}
     */
    getLightByName(name) {
        let li = this._lightsNames.indexOf(name);
        return this._lights[li];
    }
    /**
     * Removes light source.
     * @public
     * @param {LightSource} light - Light source object.
     */
    removeLight(light) {
        light.remove();
    }
    /**
     * Calls render frame node's callback. Used in renderer.
     * @public
     */
    preDrawNode() {
        this._isActive && this._preDrawNodes();
    }
    /**
     * Calls render frame node's callback. Used in renderer.
     * @public
     */
    drawNode() {
        this._isActive && this._drawNodes();
    }
    /**
     * Gets render node activity.
     * @public
     * @returns {Boolean} -
     */
    isActive() {
        return this._isActive;
    }
    /**
     * Rendering activation.
     * @public
     * @param {boolean} isActive - Activation flag.
     */
    setActive(isActive) {
        this._isActive = isActive;
        if (this.renderer) {
            if (this._isActive && this._pickingId === -1) {
                // This picking callback MUST be the first picking callback
                // in the rendering queue in the renderer. It affects on blending.
                this._pickingId = this.renderer.addPickingCallback(this, this._entityCollectionPickingCallback);
            }
            else if (!this._isActive && this._pickingId !== -1) {
                this.renderer.removePickingCallback(this._pickingId);
                this._pickingId = -1;
            }
        }
        for (let i = 0; i < this.childNodes.length; i++) {
            this.childNodes[i].setActive(isActive);
        }
    }
    /**
     * Sets draw mode
     * @public
     * @param {Number} mode - Draw mode, such as gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.LINES etc.
     */
    setDrawMode(mode) {
        this.drawMode = mode;
        for (let i = 0; i < this.childNodes.length; i++) {
            this.childNodes[i].setDrawMode(mode);
        }
    }
    /**
     * IMPORTANT: This function have to be called manually in each render node frame callback, before drawing scene geometry.
     * @public
     */
    transformLights() {
        for (let i = 0; i < this._lights.length; i++) {
            let ii = i * 3;
            let tp;
            tp = this._lights[i]._position;
            this._lightsPositions[ii] = tp.x;
            this._lightsPositions[ii + 1] = tp.y;
            this._lightsPositions[ii + 2] = tp.z;
        }
        // for (let i = 0; i < this._lights.length; i++) {
        //     var ii = i * 4;
        //     var tp;
        //     if (this._lights[i].directional) {
        //         tp = r.activeCamera._normalMatrix.mulVec(this._lights[i]._position);
        //         this._lightsTransformedPositions[ii + 3] = 0;
        //     } else {
        //         tp = r.activeCamera._viewMatrix.mulVec3(this._lights[i]._position);
        //         this._lightsTransformedPositions[ii + 3] = 1;
        //     }
        //     this._lightsTransformedPositions[ii] = tp.x;
        //     this._lightsTransformedPositions[ii + 1] = tp.y;
        //     this._lightsTransformedPositions[ii + 2] = tp.z;
        // }
    }
    updateBillboardsTexCoords() {
        for (let i = 0; i < this.entityCollections.length; i++) {
            this.entityCollections[i].billboardHandler.refreshTexCoordsArr();
        }
    }
    // public updateGeoObjectsTexCoords() {
    //     for (let i = 0; i < this.entityCollections.length; i++) {
    //         this.entityCollections[i].geoObjectHandler.refreshTexCoordsArr();
    //     }
    // }
    frame() {
        // virtual
    }
    preFrame() {
        // virtual
    }
    _preDrawNodes() {
        for (let i = 0; i < this.childNodes.length; i++) {
            if (this.childNodes[i]._isActive) {
                this.childNodes[i]._preDrawNodes();
            }
        }
        if (this.show) {
            //this.lightEnabled && this.transformLights();
            this.preFrame();
            this.drawEntityCollections(this.entityCollections);
        }
    }
    _drawNodes() {
        for (let i = 0; i < this.childNodes.length; i++) {
            if (this.childNodes[i]._isActive) {
                this.childNodes[i]._drawNodes();
            }
        }
        if (this.show) {
            this.frame();
        }
    }
    drawEntityCollections(ec) {
        this.renderer.enqueueEntityCollectionsToDraw(ec);
    }
    /**
     * Draw entity collections picking frame.
     * @public
     * @param {Array<EntityCollection>} ec - Entity collection array.
     */
    drawPickingEntityCollections(ec) {
        if (ec.length) {
            // billboard pass
            let i = ec.length;
            while (i--) {
                ec[i]._fadingOpacity && ec[i].billboardHandler.drawPicking();
            }
            // geoObject pass
            i = ec.length;
            while (i--) {
                ec[i]._fadingOpacity && ec[i].geoObjectHandler.drawPicking();
            }
            // label pass
            i = ec.length;
            while (i--) {
                ec[i]._fadingOpacity && ec[i].labelHandler.drawPicking();
            }
            // ray pass
            i = ec.length;
            while (i--) {
                ec[i]._fadingOpacity && ec[i].rayHandler.drawPicking();
            }
            // polyline pass
            i = ec.length;
            while (i--) {
                ec[i]._visibility && ec[i].polylineHandler.drawPicking();
            }
            //Strip pass
            i = ec.length;
            while (i--) {
                ec[i]._visibility && ec[i].stripHandler.drawPicking();
            }
            // //pointClouds pass
            // i = ec.length;
            // while (i--) {
            //    ec[i]._visibility && ec[i].pointCloudHandler.drawPicking();
            // }
        }
    }
    _entityCollectionPickingCallback() {
        this.drawPickingEntityCollections(this.entityCollections);
    }
}

/**
 * Console logging singleton object.
 * @class
 */
class Cons {
    constructor() {
        this._container = document.createElement("div");
        this._container.classList.add("ogConsole");
        this._container.style.display = "none";
        if (document.body) {
            document.body.appendChild(this._container);
        }
        this._visibility = false;
    }
    getVisibility() {
        return this._visibility;
    }
    setVisibility(visibility) {
        if (this._visibility != visibility) {
            this._visibility = visibility;
            if (this._visibility) {
                this.show();
            }
            else {
                this.hide();
            }
        }
    }
    /**
     * Show console panel.
     * @public
     */
    show() {
        if (!this._container.parentNode) {
            if (document.body) {
                document.body.appendChild(this._container);
            }
        }
        this._container.style.display = "block";
        this._visibility = true;
    }
    /**
     * Hide console panel.
     * @public
     */
    hide() {
        this._container.style.display = "none";
        this._visibility = false;
    }
    /**
     * Adds error text in the console.
     * @public
     * @param {string} str - Error text.
     */
    logErr(str) {
        let d = document.createElement("div");
        d.classList.add("ogConsole-text");
        d.classList.add("ogConsole-error");
        d.innerHTML = "error: " + str;
        console.trace(d.innerHTML);
        this._container.appendChild(d);
        this.show();
    }
    /**
     * Adds warning text in the console.
     * @public
     * @param {string} str - Warning text.
     */
    logWrn(str) {
        let d = document.createElement("div");
        d.classList.add("ogConsole-text");
        d.classList.add("ogConsole-warning");
        d.innerHTML = "warning: " + str;
        console.trace(d.innerHTML);
        this._container.appendChild(d);
        this.show();
    }
    /**
     * Adds log text in the console.
     * @public
     * @param {string} str - Log text.
     */
    log(str) {
        let d = document.createElement("div");
        d.classList.add("ogConsole-text");
        d.innerHTML = str;
        console.trace(str);
        this._container.appendChild(d);
        this.show();
    }
}
const cons = new Cons();

/**
 * @module og/webgl/types
 */
let _declarations = [
    "FLOAT", "DOUBLE", "BOOL", "INT", "UINT",
    "VEC2", "VEC3", "VEC4", "DVEC2",
    "DVEC3", "DVEC4",
    "BVEC2", "BVEC3", "BVEC4",
    "IVEC2", "IVEC3", "IVEC4",
    "UVEC2", "UVEC3", "UVEC4",
    "MAT2", "DMAT2", "MAT3", "DMAT3", "MAT4", "DMAT4",
    "MAT2X3", "MAT2X4", "MAT3X2", "MAT3X4", "MAT4X2",
    "MAT4X3", "DMAT2X3", "DMAT2X4", "DMAT3X2", "DMAT3X4",
    "DMAT4X2", "DMAT4X3",
    "SAMPLER1D", "SAMPLER2D", "SAMPLER3D", "SAMPLERCUBE", "SAMPLER2DSHADOW",
    "SAMPLER2DARRAY",
    "INTXX", "FLOATXX"
];
const types = {};
for (let i = 0; i < _declarations.length; i++) {
    types[_declarations[i]] = i;
}
const typeStr = {};
for (let i = 0; i < _declarations.length; i++) {
    typeStr[_declarations[i].toLowerCase()] = types[_declarations[i]];
}

/**
 * @module og/webgl/variableHandlers
 */
/*=========================
   Uniforms callbacks
 =========================*/
const variableHandlers = {
    u: [],
    a: []
};
variableHandlers.u[types.MAT4] = function (program, variable) {
    program.gl.uniformMatrix4fv(variable._pName, false, variable.value);
};
variableHandlers.u[types.MAT3] = function (program, variable) {
    program.gl.uniformMatrix3fv(variable._pName, false, variable.value);
};
variableHandlers.u[types.FLOAT] = function (program, variable) {
    program.gl.uniform1f(variable._pName, variable.value);
};
variableHandlers.u[types.INT] = function (program, variable) {
    program.gl.uniform1i(variable._pName, variable.value);
};
variableHandlers.u[types.VEC2] = function (program, variable) {
    program.gl.uniform2fv(variable._pName, variable.value);
};
variableHandlers.u[types.VEC3] = function (program, variable) {
    program.gl.uniform3fv(variable._pName, variable.value);
};
variableHandlers.u[types.VEC4] = function (program, variable) {
    program.gl.uniform4fv(variable._pName, variable.value);
};
variableHandlers.u[types.SAMPLER2D] = function (program, variable) {
    let pgl = program.gl;
    pgl.activeTexture(pgl.TEXTURE0 + program._textureID);
    pgl.bindTexture(pgl.TEXTURE_2D, variable.value);
    pgl.uniform1i(variable._pName, program._textureID);
    program._textureID++;
};
variableHandlers.u[types.SAMPLERCUBE] = function (program, variable) {
    let pgl = program.gl;
    pgl.activeTexture(pgl.TEXTURE0 + program._textureID);
    pgl.bindTexture(pgl.TEXTURE_CUBE_MAP, variable.value);
    pgl.uniform1i(variable._pName, program._textureID);
    program._textureID++;
};
variableHandlers.u[types.SAMPLER2DARRAY] = function (program, variable) {
    let value = variable.value;
    let pgl = program.gl, size = value.length;
    let samplerArr = new Int32Array(size);
    for (let i = 0; i < size; i++) {
        pgl.activeTexture(pgl.TEXTURE0 + program._textureID + i);
        pgl.bindTexture(pgl.TEXTURE_2D, value[i]);
        samplerArr[i] = i;
    }
    pgl.uniform1iv(variable._pName, samplerArr);
};
variableHandlers.u[types.INTXX] = function (program, variable) {
    program.gl.uniform1iv(variable._pName, variable.value);
};
variableHandlers.u[types.FLOATXX] = function (program, variable) {
    program.gl.uniform1fv(variable._pName, variable.value);
};
/*========================
   Attributes callbacks
 ========================*/
variableHandlers.a[types.FLOAT] = function (program, variable) {
    program.gl.vertexAttrib1f(variable._pName, variable.value);
};
variableHandlers.a[types.VEC2] = function (program, variable) {
    program.gl.vertexAttrib2fv(variable._pName, variable.value);
};
variableHandlers.a[types.VEC3] = function (program, variable) {
    program.gl.vertexAttrib3fv(variable._pName, variable.value);
};
//VariableHandlers.a[types.VEC4] = function (program, variable) {
//    program.gl.vertexAttrib4fv(variable._pName, variable.value);
//};

const itemTypes = ["BYTE", "SHORT", "UNSIGNED_BYTE", "UNSIGNED_SHORT", "FLOAT", "HALF_FLOAT"];
/**
 * Represents more comfortable using WebGL shader program.
 * @class
 * @param {string} name - Program name.
 * @param {ProgramMaterial} material - Object stores uniforms, attributes and program codes:
 * @param {Record<string, any>} material.uniforms - Uniforms definition section.
 * @param {Record<string, any>} material.attributes - Attributes definition section.
 * @param {string} material.vertexShader - Vertex glsl code.
 * @param {string} material.fragmentShader - Fragment glsl code.
 */
class Program {
    constructor(name, material) {
        this.name = name;
        this._attributes = {};
        for (let t in material.attributes) {
            if (typeof material.attributes[t] === "string" ||
                typeof material.attributes[t] === "number") {
                this._attributes[t] = { type: material.attributes[t] };
            }
            else {
                this._attributes[t] = material.attributes[t];
            }
        }
        this._uniforms = {};
        for (let t in material.uniforms) {
            if (typeof material.uniforms[t] === "string" ||
                typeof material.uniforms[t] === "number") {
                this._uniforms[t] = { type: material.uniforms[t] };
            }
            else {
                this._uniforms[t] = material.uniforms[t];
            }
        }
        this.vertexShader = material.vertexShader;
        this.fragmentShader = material.fragmentShader;
        this.gl = null;
        this._variables = {};
        this._p = null;
        this._textureID = 0;
        this._attribArrays = [];
        this._attribDivisor = [];
        this.attributes = {};
        this.uniforms = {};
        this.vertexAttribDivisor = null;
        this.drawElementsInstanced = null;
    }
    /**
     * Bind program buffer.
     * @function
     * @param {Program} program - Used program.
     * @param {Object} variable - Variable represents buffer data.
     */
    static bindBuffer(program, variable) {
        let gl = program.gl;
        if (gl) {
            gl.bindBuffer(gl.ARRAY_BUFFER, variable.value);
            gl.vertexAttribPointer(variable._pName, variable.value.itemSize, variable.itemType, variable.normalized, 0, 0);
        }
    }
    /**
     * Sets the current program frame.
     * @public
     */
    use() {
        this.gl && this.gl.useProgram(this._p);
    }
    /**
     * Sets program variables.
     * @public
     * @param {Object} material - Variables and values object.
     */
    set(material) {
        this._textureID = 0;
        for (let i in material) {
            this._variables[i].value = material[i];
            this._variables[i].func(this, this._variables[i]);
        }
    }
    /**
     * Apply current variables.
     * @public
     */
    apply() {
        this._textureID = 0;
        let v = this._variables;
        for (let i in v) {
            v[i].func(this, v[i]);
        }
    }
    /**
     * Calls drawElements index buffer function.
     * @public
     * @param {number} mode - Draw mode(GL_TRIANGLES, GL_LINESTRING etc.).
     * @param {Object} buffer - Index buffer.
     */
    drawIndexBuffer(mode, buffer) {
        let gl = this.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
        gl.drawElements(mode, buffer.numItems, gl.UNSIGNED_SHORT, 0);
    }
    /**
     * Calls drawArrays function.
     * @public
     * @param {number} mode - Draw mode GL_TRIANGLES, GL_LINESTRING, etc.
     * @param {number} numItems - Items to draw
     */
    drawArrays(mode, numItems) {
        this.gl.drawArrays(mode, 0, numItems);
    }
    /**
     * Check and log for a shader compile errors and warnings. Returns True - if no errors otherwise returns False.
     * @private
     * @param {WebGLShader} shader - WebGl shader program.
     * @param {string} src - Shader program source.
     * @returns {boolean} -
     */
    _getShaderCompileStatus(shader, src) {
        if (!this.gl)
            return false;
        this.gl.shaderSource(shader, src);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            cons.logErr(`Shader program "${this.name}":${this.gl.getShaderInfoLog(shader)}.`);
            return false;
        }
        return true;
    }
    /**
     * Returns compiled vertex shader program pointer.
     * @private
     * @param {string} src - Vertex shader source code.
     * @returns {Object} -
     */
    _createVertexShader(src) {
        if (!this.gl)
            return;
        let shader = this.gl.createShader(this.gl.VERTEX_SHADER);
        if (shader && this._getShaderCompileStatus(shader, src)) {
            return shader;
        }
    }
    /**
     * Returns compiled fragment shader program pointer.
     * @private
     * @param {string} src - Vertex shader source code.
     * @returns {Object} -
     */
    _createFragmentShader(src) {
        if (!this.gl)
            return;
        let shader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        if (shader && this._getShaderCompileStatus(shader, src)) {
            return shader;
        }
    }
    /**
     * Disable current program vertexAttribArrays.
     * @public
     */
    disableAttribArrays() {
        let gl = this.gl;
        let a = this._attribArrays;
        for (let i = 0, len = a.length; i < len; i++) {
            gl.disableVertexAttribArray(a[i]);
            this.vertexAttribDivisor(a[i], 0);
        }
    }
    /**
     * Enable current program vertexAttribArrays.
     * @public
     */
    enableAttribArrays() {
        let gl = this.gl;
        let a = this._attribArrays;
        let d = this._attribDivisor;
        for (let i = 0, len = a.length; i < len; i++) {
            gl.enableVertexAttribArray(a[i]);
            this.vertexAttribDivisor(a[i], d[i]);
        }
    }
    // public vertexAttribDivisor(index: number, divisor: number) {
    //     const gl = this.gl!;
    //     gl.vertexAttribDivisor ?
    //         gl.vertexAttribDivisor(index, divisor) :
    //         gl.getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(index, divisor);
    // }
    /**
     * Delete program.
     * @public
     */
    delete() {
        this.gl && this.gl.deleteProgram(this._p);
    }
    /**
     * Creates program.
     * @public
     * @param {Object} gl - WebGl context.
     */
    createProgram(gl) {
        this.gl = gl;
        this._p = this.gl.createProgram();
        if (!this._p)
            return;
        let fs = this._createFragmentShader(this.fragmentShader);
        let vs = this._createVertexShader(this.vertexShader);
        if (!fs || !vs)
            return;
        gl.attachShader(this._p, fs);
        gl.attachShader(this._p, vs);
        gl.linkProgram(this._p);
        if (!this.drawElementsInstanced) {
            if (gl.drawElementsInstanced) {
                this.drawElementsInstanced = gl.drawElementsInstanced.bind(gl);
            }
            else {
                let ext = gl.getExtension('ANGLE_instanced_arrays');
                if (ext) {
                    this.drawElementsInstanced = ext.drawElementsInstancedANGLE.bind(ext);
                }
            }
            // this.drawElementsInstanced =
            //     gl.drawElementsInstanced ?
            //         gl.drawElementsInstanced.bind(gl) :
            //         gl.getExtension('ANGLE_instanced_arrays').drawElementsInstancedANGLE.bind(gl.getExtension('ANGLE_instanced_arrays'));
        }
        if (!this.vertexAttribDivisor) {
            if (gl.vertexAttribDivisor) {
                this.vertexAttribDivisor = gl.vertexAttribDivisor.bind(gl);
            }
            else {
                let ext = gl.getExtension('ANGLE_instanced_arrays');
                if (ext) {
                    this.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);
                }
            }
            // this.vertexAttribDivisor =
            //     gl.vertexAttribDivisor ?
            //         gl.vertexAttribDivisor.bind(gl) :
            //         gl.getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE.bind(gl.getExtension('ANGLE_instanced_arrays'));
        }
        if (!gl.getProgramParameter(this._p, gl.LINK_STATUS)) {
            cons.logErr(`Shader program "${this.name}": initialization failed. ${gl.getProgramInfoLog(this._p)}.`);
            gl.deleteProgram(this._p);
            return;
        }
        this.use();
        for (let a in this._attributes) {
            //this.attributes[a]._name = a;
            this._variables[a] = this._attributes[a];
            this._attributes[a].func = Program.bindBuffer;
            let t = this._attributes[a].itemType;
            let itemTypeStr = t ? t.trim().toUpperCase() : "FLOAT";
            if (itemTypes.indexOf(itemTypeStr) == -1) {
                cons.logErr(`Shader program "${this.name}": attribute '${a}', item type '${this._attributes[a].itemType}' not exists.`);
                this._attributes[a].itemType = gl.FLOAT;
            }
            else {
                this._attributes[a].itemType = gl[itemTypeStr];
            }
            this._attributes[a].normalized = this._attributes[a].normalized || false;
            this._attributes[a].divisor = this._attributes[a].divisor || 0;
            this._p[a] = gl.getAttribLocation(this._p, a);
            if (this._p[a] == undefined) {
                cons.logErr(`Shader program "${this.name}":  attribute '${a}' not exists.`);
                gl.deleteProgram(this._p);
                return;
            }
            let type = this._attributes[a].type;
            if (typeof type === "string") {
                type = typeStr[type.trim().toLowerCase()];
            }
            let d = this._attributes[a].divisor;
            if (type === types.MAT4) {
                let loc = this._p[a];
                this._attribArrays.push(loc, loc + 1, loc + 2, loc + 3);
                this._attribDivisor.push(d, d, d, d);
            }
            else {
                this._attribArrays.push(this._p[a]);
                this._attribDivisor.push(d);
            }
            gl.enableVertexAttribArray(this._p[a]);
            this._attributes[a]._pName = this._p[a];
            this.attributes[a] = this._p[a];
        }
        for (let u in this._uniforms) {
            if (typeof this._uniforms[u].type === "string") {
                let t = this._uniforms[u].type;
                this._uniforms[u].func = variableHandlers.u[typeStr[t.trim().toLowerCase()]];
            }
            else {
                this._uniforms[u].func = variableHandlers.u[this._uniforms[u].type];
            }
            this._variables[u] = this._uniforms[u];
            this._p[u] = gl.getUniformLocation(this._p, u);
            if (this._p[u] == undefined) {
                cons.logErr(`Shader program "${this.name}": uniform '${u}' not exists.`);
                gl.deleteProgram(this._p);
                return;
            }
            this._uniforms[u]._pName = this._p[u];
            this.uniforms[u] = this._p[u];
        }
        gl.detachShader(this._p, fs);
        gl.detachShader(this._p, vs);
        gl.deleteShader(fs);
        gl.deleteShader(vs);
    }
}

const PROJECT$1 = `vec2 project(vec4 p) {
                    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;
                }`;
const ROTATE2D$1 = `mat2 rotate2d(float angle) {
        return mat2(cos(angle), -sin(angle),
           sin(angle), cos(angle));
     }`;
function billboardPicking() {
    return new Program("billboardPicking", {
        uniforms: {
            viewport: "vec2",
            projectionMatrix: "mat4",
            viewMatrix: "mat4",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            planetRadius: "float",
            uScaleByDistance: "vec3",
            opacity: "float",
            depthOffset: "float"
        },
        attributes: {
            a_vertices: "vec2",
            a_positionsHigh: "vec3",
            a_positionsLow: "vec3",
            a_offset: "vec3",
            a_size: "vec2",
            a_rotation: "float",
            a_rgba: "vec4"
        },
        vertexShader: `precision highp float;
            attribute vec2 a_vertices;
            attribute vec3 a_positionsHigh;
            attribute vec3 a_positionsLow;
            attribute vec3 a_offset;
            attribute vec2 a_size;
            attribute float a_rotation;
            attribute vec4 a_rgba;

            varying vec3 v_rgb;

            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform vec3 uScaleByDistance;
            uniform float opacity;
            uniform float planetRadius;
            uniform vec2 viewport;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);

            ${PROJECT$1}

            ${ROTATE2D$1}

            void main() {

                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;

                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                v_rgb = a_rgba.rgb;

                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                //vec3 up = vec3( viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1] );
                //vec3 right = vec3( viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0] );

                float scd = (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookDist)) * (1.0 - step(uScaleByDistance[2], lookDist));

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                
                projPos.z += depthOffset + a_offset.z;
                                
                vec2 screenPos = project(projPos);

                vec2 v =  screenPos + rotate2d(a_rotation) * (a_vertices * a_size * scd + a_offset.xy);

                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
        fragmentShader: `precision highp float;
            varying vec3 v_rgb;
            void main () {
                gl_FragColor = vec4(v_rgb, 1.0);
            }`
    });
}
function billboard_screen() {
    return new Program("billboard", {
        uniforms: {
            viewport: "vec2",
            u_texture: "sampler2d",
            projectionMatrix: "mat4",
            viewMatrix: "mat4",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            planetRadius: "float",
            uScaleByDistance: "vec3",
            opacity: "float",
            depthOffset: "float"
        },
        attributes: {
            a_vertices: "vec2",
            a_texCoord: "vec2",
            a_positionsHigh: "vec3",
            a_positionsLow: "vec3",
            a_offset: "vec3",
            a_size: "vec2",
            a_rotation: "float",
            a_rgba: "vec4",
        },
        vertexShader: `precision highp float;
            attribute vec2 a_vertices;
            attribute vec2 a_texCoord;
            attribute vec3 a_positionsHigh;
            attribute vec3 a_positionsLow;
            attribute vec3 a_offset;
            attribute vec2 a_size;
            attribute float a_rotation;
            attribute vec4 a_rgba;

            varying vec2 v_texCoords;
            varying vec4 v_rgba;

            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform vec3 uScaleByDistance;
            uniform float opacity;
            uniform float planetRadius;
            uniform vec2 viewport;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);

            ${PROJECT$1}

            ${ROTATE2D$1}

            void main() {
                
                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;

                v_texCoords = a_texCoord;
                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                v_rgba = a_rgba;

                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                //vec3 up = vec3( viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1] );
                //vec3 right = vec3( viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0] );

                float scd = (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookDist)) * (1.0 - step(uScaleByDistance[2], lookDist));

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                                                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                
                projPos.z += depthOffset + a_offset.z;
                
                vec2 screenPos = project(projPos);

                vec2 v = screenPos + rotate2d(a_rotation) * (a_vertices * a_size * scd + a_offset.xy);

                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
        fragmentShader: `precision highp float;
            uniform sampler2D u_texture;
            varying vec2 v_texCoords;
            varying vec4 v_rgba;
            void main () {
                vec4 color = texture2D(u_texture, v_texCoords);
                if(color.a < 0.1)
                    discard;
                gl_FragColor = color * v_rgba;
            }`
    });
}

const PICKINGCOLOR_BUFFER$3 = 0;
const POSITION_BUFFER$2 = 1;
const SIZE_BUFFER$2 = 2;
const OFFSET_BUFFER$1 = 3;
const RGBA_BUFFER$3 = 4;
const ROTATION_BUFFER$1 = 5;
const TEXCOORD_BUFFER$2 = 6;
const VERTEX_BUFFER$3 = 7;
/**
 * @class BaseBillboardHandler
 */
class BaseBillboardHandler {
    constructor(entityCollection) {
        this.__id = BaseBillboardHandler.__counter__++;
        this.pickingEnabled = true;
        this._entityCollection = entityCollection;
        this._renderer = null;
        this._billboards = [];
        this._positionHighBuffer = null;
        this._positionLowBuffer = null;
        this._sizeBuffer = null;
        this._offsetBuffer = null;
        this._rgbaBuffer = null;
        this._rotationBuffer = null;
        this._texCoordBuffer = null;
        this._vertexBuffer = null;
        this._pickingColorBuffer = null;
        this._texCoordArr = new Float32Array([]);
        this._vertexArr = new Float32Array([]);
        this._positionHighArr = new Float32Array([]);
        this._positionLowArr = new Float32Array([]);
        this._sizeArr = new Float32Array([]);
        this._offsetArr = new Float32Array([]);
        this._rgbaArr = new Float32Array([]);
        this._rotationArr = new Float32Array([]);
        this._pickingColorArr = new Float32Array([]);
        this._buffersUpdateCallbacks = [];
        this._buffersUpdateCallbacks[PICKINGCOLOR_BUFFER$3] = this.createPickingColorBuffer;
        this._buffersUpdateCallbacks[POSITION_BUFFER$2] = this.createPositionBuffer;
        this._buffersUpdateCallbacks[SIZE_BUFFER$2] = this.createSizeBuffer;
        this._buffersUpdateCallbacks[OFFSET_BUFFER$1] = this.createOffsetBuffer;
        this._buffersUpdateCallbacks[RGBA_BUFFER$3] = this.createRgbaBuffer;
        this._buffersUpdateCallbacks[ROTATION_BUFFER$1] = this.createRotationBuffer;
        this._buffersUpdateCallbacks[TEXCOORD_BUFFER$2] = this.createTexCoordBuffer;
        this._buffersUpdateCallbacks[VERTEX_BUFFER$3] = this.createVertexBuffer;
        this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
    }
    isEqual(handler) {
        return handler && (handler.__id === this.__id);
    }
    static concArr(dest, curr) {
        for (let i = 0; i < curr.length; i++) {
            dest.push(curr[i]);
        }
    }
    initProgram() {
        if (this._renderer && this._renderer.handler) {
            if (!this._renderer.handler.programs.billboard) {
                this._renderer.handler.addProgram(billboard_screen());
            }
            if (!this._renderer.handler.programs.billboardPicking) {
                this._renderer.handler.addProgram(billboardPicking());
            }
        }
    }
    setRenderer(renderer) {
        this._renderer = renderer;
        this.initProgram();
    }
    refresh() {
        let i = this._changedBuffers.length;
        while (i--) {
            this._changedBuffers[i] = true;
        }
    }
    _removeBillboards() {
        let i = this._billboards.length;
        while (i--) {
            let bi = this._billboards[i];
            bi._handlerIndex = -1;
            bi._handler = null;
            bi._isReady = false;
            bi._lockId = LOCK_FREE;
        }
        this._billboards.length = 0;
        this._billboards = [];
    }
    clear() {
        // @ts-ignore
        this._texCoordArr = null;
        // @ts-ignore
        this._vertexArr = null;
        // @ts-ignore
        this._positionHighArr = null;
        // @ts-ignore
        this._positionLowArr = null;
        // @ts-ignore
        this._sizeArr = null;
        // @ts-ignore
        this._offsetArr = null;
        // @ts-ignore
        this._rgbaArr = null;
        // @ts-ignore
        this._rotationArr = null;
        // @ts-ignore
        this._pickingColorArr = null;
        this._texCoordArr = new Float32Array([]);
        this._vertexArr = new Float32Array([]);
        this._positionHighArr = new Float32Array([]);
        this._positionLowArr = new Float32Array([]);
        this._sizeArr = new Float32Array([]);
        this._offsetArr = new Float32Array([]);
        this._rgbaArr = new Float32Array([]);
        this._rotationArr = new Float32Array([]);
        this._pickingColorArr = new Float32Array([]);
        this._removeBillboards();
        this._deleteBuffers();
        this.refresh();
    }
    _deleteBuffers() {
        if (this._renderer) {
            let gl = this._renderer.handler.gl;
            gl.deleteBuffer(this._positionHighBuffer);
            gl.deleteBuffer(this._positionLowBuffer);
            gl.deleteBuffer(this._sizeBuffer);
            gl.deleteBuffer(this._offsetBuffer);
            gl.deleteBuffer(this._rgbaBuffer);
            gl.deleteBuffer(this._rotationBuffer);
            gl.deleteBuffer(this._vertexBuffer);
            gl.deleteBuffer(this._texCoordBuffer);
            gl.deleteBuffer(this._pickingColorBuffer);
        }
        this._positionHighBuffer = null;
        this._positionLowBuffer = null;
        this._sizeBuffer = null;
        this._offsetBuffer = null;
        this._rgbaBuffer = null;
        this._rotationBuffer = null;
        this._vertexBuffer = null;
        this._texCoordBuffer = null;
        this._pickingColorBuffer = null;
    }
    update() {
        if (this._renderer) {
            let i = this._changedBuffers.length;
            while (i--) {
                if (this._changedBuffers[i]) {
                    this._buffersUpdateCallbacks[i].call(this);
                    this._changedBuffers[i] = false;
                }
            }
        }
    }
    add(billboard) {
        if (billboard._handlerIndex == -1) {
            billboard._isReady = true;
            billboard._handler = this;
            billboard._handlerIndex = this._billboards.length;
            this._billboards.push(billboard);
        }
    }
    _displayPASS() {
        let r = this._renderer;
        let h = r.handler;
        h.programs.billboard.activate();
        let sh = h.programs.billboard._program;
        let sha = sh.attributes, shu = sh.uniforms;
        let gl = h.gl, ec = this._entityCollection;
        gl.disable(gl.CULL_FACE);
        gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits);
        gl.uniform1i(shu.u_texture, 0);
        gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera.getViewMatrix());
        gl.uniformMatrix4fv(shu.projectionMatrix, false, r.activeCamera.getProjectionMatrix());
        gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
        gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);
        gl.uniform3fv(shu.uScaleByDistance, ec.scaleByDistance);
        gl.uniform1f(shu.opacity, ec._fadingOpacity);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordBuffer);
        gl.vertexAttribPointer(sha.a_texCoord, this._texCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._positionHighBuffer);
        gl.vertexAttribPointer(sha.a_positionsHigh, this._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._positionLowBuffer);
        gl.vertexAttribPointer(sha.a_positionsLow, this._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._rgbaBuffer);
        gl.vertexAttribPointer(sha.a_rgba, this._rgbaBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
        gl.vertexAttribPointer(sha.a_size, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
        gl.vertexAttribPointer(sha.a_offset, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.uniform1f(shu.planetRadius, ec.renderNode._planetRadius2 || 0);
        gl.uniform2fv(shu.viewport, [h.canvas.clientWidth, h.canvas.clientHeight]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
        gl.vertexAttribPointer(sha.a_rotation, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
        gl.enable(gl.CULL_FACE);
    }
    _pickingPASS() {
        let r = this._renderer;
        let h = r.handler;
        h.programs.billboardPicking.activate();
        let sh = h.programs.billboardPicking._program;
        let sha = sh.attributes, shu = sh.uniforms;
        let gl = h.gl, ec = this._entityCollection;
        gl.disable(gl.CULL_FACE);
        gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits);
        gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera.getViewMatrix());
        gl.uniformMatrix4fv(shu.projectionMatrix, false, r.activeCamera.getProjectionMatrix());
        gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
        gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);
        gl.uniform3fv(shu.uScaleByDistance, ec.scaleByDistance);
        gl.uniform1f(shu.opacity, ec._fadingOpacity);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._positionHighBuffer);
        gl.vertexAttribPointer(sha.a_positionsHigh, this._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._positionLowBuffer);
        gl.vertexAttribPointer(sha.a_positionsLow, this._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._pickingColorBuffer);
        gl.vertexAttribPointer(sha.a_rgba, this._pickingColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
        gl.vertexAttribPointer(sha.a_size, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
        gl.vertexAttribPointer(sha.a_offset, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.uniform1f(shu.planetRadius, ec.renderNode._planetRadius2 || 0);
        gl.uniform2fv(shu.viewport, [h.canvas.clientWidth, h.canvas.clientHeight]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
        gl.vertexAttribPointer(sha.a_rotation, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
        gl.enable(gl.CULL_FACE);
    }
    draw() {
        if (this._billboards.length) {
            this.update();
            this._displayPASS();
        }
    }
    drawPicking() {
        if (this._billboards.length && this.pickingEnabled) {
            this._pickingPASS();
        }
    }
    reindexBillboardsArray(startIndex) {
        let b = this._billboards;
        for (let i = startIndex; i < b.length; i++) {
            b[i]._handlerIndex = i;
        }
    }
    _removeBillboard(billboard) {
        let bi = billboard._handlerIndex;
        this._billboards.splice(bi, 1);
        let i = bi * 24;
        this._rgbaArr = spliceTypedArray(this._rgbaArr, i, 24);
        i = bi * 18;
        this._positionHighArr = spliceTypedArray(this._positionHighArr, i, 18);
        this._positionLowArr = spliceTypedArray(this._positionLowArr, i, 18);
        this._offsetArr = spliceTypedArray(this._offsetArr, i, 18);
        //this._alignedAxisArr = spliceTypedArray(this._alignedAxisArr, i, 18) as Float32Array;
        this._pickingColorArr = spliceTypedArray(this._pickingColorArr, i, 18);
        i = bi * 12;
        this._vertexArr = spliceTypedArray(this._vertexArr, i, 12);
        this._sizeArr = spliceTypedArray(this._sizeArr, i, 12);
        this._texCoordArr = spliceTypedArray(this._texCoordArr, i, 12);
        i = bi * 6;
        this._rotationArr = spliceTypedArray(this._rotationArr, i, 6);
        this.reindexBillboardsArray(bi);
        this.refresh();
        billboard._handlerIndex = -1;
        billboard._handler = null;
        billboard._isReady = false;
        billboard._lockId = LOCK_FREE;
    }
    setAlignedAxisArr(index, alignedAxis) {
        //...
    }
    remove(billboard) {
        if (billboard._handler) {
            if (billboard._isReady && this.__id === billboard._handler.__id) {
                this._removeBillboard(billboard);
            }
            else {
                billboard._handler = null;
            }
        }
    }
    setPositionArr(index, positionHigh, positionLow) {
        let i = index * 18;
        // High
        let a = this._positionHighArr, x = positionHigh.x, y = positionHigh.y, z = positionHigh.z;
        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;
        a[i + 3] = x;
        a[i + 4] = y;
        a[i + 5] = z;
        a[i + 6] = x;
        a[i + 7] = y;
        a[i + 8] = z;
        a[i + 9] = x;
        a[i + 10] = y;
        a[i + 11] = z;
        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;
        a[i + 15] = x;
        a[i + 16] = y;
        a[i + 17] = z;
        // Low
        a = this._positionLowArr;
        x = positionLow.x;
        y = positionLow.y;
        z = positionLow.z;
        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;
        a[i + 3] = x;
        a[i + 4] = y;
        a[i + 5] = z;
        a[i + 6] = x;
        a[i + 7] = y;
        a[i + 8] = z;
        a[i + 9] = x;
        a[i + 10] = y;
        a[i + 11] = z;
        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;
        a[i + 15] = x;
        a[i + 16] = y;
        a[i + 17] = z;
        this._changedBuffers[POSITION_BUFFER$2] = true;
    }
    setPickingColorArr(index, color) {
        let i = index * 18;
        let a = this._pickingColorArr, x = color.x / 255, y = color.y / 255, z = color.z / 255;
        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;
        a[i + 3] = x;
        a[i + 4] = y;
        a[i + 5] = z;
        a[i + 6] = x;
        a[i + 7] = y;
        a[i + 8] = z;
        a[i + 9] = x;
        a[i + 10] = y;
        a[i + 11] = z;
        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;
        a[i + 15] = x;
        a[i + 16] = y;
        a[i + 17] = z;
        this._changedBuffers[PICKINGCOLOR_BUFFER$3] = true;
    }
    setSizeArr(index, width, height) {
        let i = index * 12;
        let a = this._sizeArr, x = width, y = height;
        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = x;
        a[i + 3] = y;
        a[i + 4] = x;
        a[i + 5] = y;
        a[i + 6] = x;
        a[i + 7] = y;
        a[i + 8] = x;
        a[i + 9] = y;
        a[i + 10] = x;
        a[i + 11] = y;
        this._changedBuffers[SIZE_BUFFER$2] = true;
    }
    setOffsetArr(index, offset) {
        let i = index * 18;
        let a = this._offsetArr, x = offset.x, y = offset.y, z = offset.z;
        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;
        a[i + 3] = x;
        a[i + 4] = y;
        a[i + 5] = z;
        a[i + 6] = x;
        a[i + 7] = y;
        a[i + 8] = z;
        a[i + 9] = x;
        a[i + 10] = y;
        a[i + 11] = z;
        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;
        a[i + 15] = x;
        a[i + 16] = y;
        a[i + 17] = z;
        this._changedBuffers[OFFSET_BUFFER$1] = true;
    }
    setRgbaArr(index, rgba) {
        let i = index * 24;
        let a = this._rgbaArr, x = rgba.x, y = rgba.y, z = rgba.z, w = rgba.w;
        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;
        a[i + 3] = w;
        a[i + 4] = x;
        a[i + 5] = y;
        a[i + 6] = z;
        a[i + 7] = w;
        a[i + 8] = x;
        a[i + 9] = y;
        a[i + 10] = z;
        a[i + 11] = w;
        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;
        a[i + 15] = w;
        a[i + 16] = x;
        a[i + 17] = y;
        a[i + 18] = z;
        a[i + 19] = w;
        a[i + 20] = x;
        a[i + 21] = y;
        a[i + 22] = z;
        a[i + 23] = w;
        this._changedBuffers[RGBA_BUFFER$3] = true;
    }
    setRotationArr(index, rotation) {
        let i = index * 6;
        let a = this._rotationArr;
        a[i] = rotation;
        a[i + 1] = rotation;
        a[i + 2] = rotation;
        a[i + 3] = rotation;
        a[i + 4] = rotation;
        a[i + 5] = rotation;
        this._changedBuffers[ROTATION_BUFFER$1] = true;
    }
    setTexCoordArr(index, tcoordArr) {
        let i = index * 12;
        let a = this._texCoordArr;
        a[i] = tcoordArr[0];
        a[i + 1] = tcoordArr[1];
        a[i + 2] = tcoordArr[2];
        a[i + 3] = tcoordArr[3];
        a[i + 4] = tcoordArr[4];
        a[i + 5] = tcoordArr[5];
        a[i + 6] = tcoordArr[6];
        a[i + 7] = tcoordArr[7];
        a[i + 8] = tcoordArr[8];
        a[i + 9] = tcoordArr[9];
        a[i + 10] = tcoordArr[10];
        a[i + 11] = tcoordArr[11];
        this._changedBuffers[TEXCOORD_BUFFER$2] = true;
    }
    setVisibility(index, visibility) {
        let vArr;
        if (visibility) {
            vArr = [-0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5];
        }
        else {
            vArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        this.setVertexArr(index, vArr);
    }
    setVertexArr(index, vertexArr) {
        let i = index * 12;
        let a = this._vertexArr;
        a[i] = vertexArr[0];
        a[i + 1] = vertexArr[1];
        a[i + 2] = vertexArr[2];
        a[i + 3] = vertexArr[3];
        a[i + 4] = vertexArr[4];
        a[i + 5] = vertexArr[5];
        a[i + 6] = vertexArr[6];
        a[i + 7] = vertexArr[7];
        a[i + 8] = vertexArr[8];
        a[i + 9] = vertexArr[9];
        a[i + 10] = vertexArr[10];
        a[i + 11] = vertexArr[11];
        this._changedBuffers[VERTEX_BUFFER$3] = true;
    }
    createPositionBuffer() {
        let h = this._renderer.handler, numItems = this._positionHighArr.length / 3;
        if (!this._positionHighBuffer || this._positionHighBuffer.numItems !== numItems) {
            h.gl.deleteBuffer(this._positionHighBuffer);
            h.gl.deleteBuffer(this._positionLowBuffer);
            this._positionHighBuffer = h.createStreamArrayBuffer(3, numItems);
            this._positionLowBuffer = h.createStreamArrayBuffer(3, numItems);
        }
        h.setStreamArrayBuffer(this._positionHighBuffer, this._positionHighArr);
        h.setStreamArrayBuffer(this._positionLowBuffer, this._positionLowArr);
    }
    createSizeBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._sizeBuffer);
        this._sizeBuffer = h.createArrayBuffer(this._sizeArr, 2, this._sizeArr.length / 2);
    }
    createOffsetBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._offsetBuffer);
        this._offsetBuffer = h.createArrayBuffer(this._offsetArr, 3, this._offsetArr.length / 3);
    }
    createRgbaBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._rgbaBuffer);
        this._rgbaBuffer = h.createArrayBuffer(this._rgbaArr, 4, this._rgbaArr.length / 4);
    }
    createRotationBuffer() {
        let h = this._renderer.handler;
        if (!this._rotationBuffer || this._rotationBuffer.numItems !== this._rotationArr.length) {
            h.gl.deleteBuffer(this._rotationBuffer);
            this._rotationBuffer = h.createStreamArrayBuffer(1, this._rotationArr.length);
        }
        h.setStreamArrayBuffer(this._rotationBuffer, this._rotationArr);
    }
    createVertexBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._vertexBuffer);
        this._vertexBuffer = h.createArrayBuffer(this._vertexArr, 2, this._vertexArr.length / 2);
    }
    createTexCoordBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._texCoordBuffer);
        this._texCoordBuffer = h.createArrayBuffer(this._texCoordArr, 2, this._texCoordArr.length / 2);
    }
    //createAlignedAxisBuffer() {
    //    var h = this._renderer.handler;
    //    h.gl.deleteBuffer(this._alignedAxisBuffer);
    //    this._alignedAxisBuffer = h.createArrayBuffer(
    //        this._alignedAxisArr,
    //        3,
    //        this._alignedAxisArr.length / 3
    //    );
    //}
    createPickingColorBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._pickingColorBuffer);
        this._pickingColorBuffer = h.createArrayBuffer(this._pickingColorArr, 3, this._pickingColorArr.length / 3);
    }
    refreshTexCoordsArr() {
    }
}
BaseBillboardHandler.__counter__ = 0;

/**
 * @class BillboardHandler
 */
class BillboardHandler extends BaseBillboardHandler {
    constructor(props) {
        super(props);
        this._billboards = [];
    }
    add(billboard) {
        if (billboard._handlerIndex == -1) {
            super.add(billboard);
            this._addBillboardToArrays(billboard);
            this.refresh();
            let src = billboard.getSrc() || (billboard.getImage() && billboard.getImage().src);
            if (src) {
                billboard.setSrc(src);
            }
        }
    }
    _addBillboardToArrays(billboard) {
        if (billboard.getVisibility()) {
            this._vertexArr = concatTypedArrays(this._vertexArr, [-0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5]);
        }
        else {
            this._vertexArr = concatTypedArrays(this._vertexArr, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        }
        this._texCoordArr = concatTypedArrays(this._texCoordArr, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        let x = billboard._positionHigh.x, y = billboard._positionHigh.y, z = billboard._positionHigh.z, w;
        this._positionHighArr = concatTypedArrays(this._positionHighArr, [
            x, y, z,
            x, y, z,
            x, y, z,
            x, y, z,
            x, y, z,
            x, y, z
        ]);
        x = billboard._positionLow.x;
        y = billboard._positionLow.y;
        z = billboard._positionLow.z;
        this._positionLowArr = concatTypedArrays(this._positionLowArr, [
            x, y, z,
            x, y, z,
            x, y, z,
            x, y, z,
            x, y, z,
            x, y, z
        ]);
        x = billboard._width;
        y = billboard._height;
        this._sizeArr = concatTypedArrays(this._sizeArr, [x, y, x, y, x, y, x, y, x, y, x, y]);
        x = billboard._offset.x;
        y = billboard._offset.y;
        z = billboard._offset.z;
        this._offsetArr = concatTypedArrays(this._offsetArr, [
            x, y, z,
            x, y, z,
            x, y, z,
            x, y, z,
            x, y, z,
            x, y, z
        ]);
        x = billboard._color.x;
        y = billboard._color.y;
        z = billboard._color.z;
        w = billboard._color.w;
        this._rgbaArr = concatTypedArrays(this._rgbaArr, [
            x, y, z, w,
            x, y, z, w,
            x, y, z, w,
            x, y, z, w,
            x, y, z, w,
            x, y, z, w
        ]);
        x = billboard._rotation;
        this._rotationArr = concatTypedArrays(this._rotationArr, [x, x, x, x, x, x]);
        x = billboard._entity._pickingColor.x / 255;
        y = billboard._entity._pickingColor.y / 255;
        z = billboard._entity._pickingColor.z / 255;
        this._pickingColorArr = concatTypedArrays(this._pickingColorArr, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);
    }
    get billboards() {
        return this._billboards;
    }
    refreshTexCoordsArr() {
        let bc = this._entityCollection;
        if (bc && this._renderer) {
            let ta = this._renderer.billboardsTextureAtlas;
            for (let i = 0; i < this._billboards.length; i++) {
                let bi = this._billboards[i];
                let img = bi.getImage();
                if (img) {
                    let imageNode = ta.get(img.__nodeIndex);
                    if (imageNode) {
                        this.setTexCoordArr(bi._handlerIndex, imageNode.texCoords);
                    }
                }
            }
        }
    }
}

const QROT = `vec3 qRotate(vec4 q, vec3 v){
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}`;
const geo_object = () => new Program("geo_object", {
    uniforms: {
        viewMatrix: "mat4",
        projectionMatrix: "mat4",
        uScaleByDistance: "vec3",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        lightsPositions: "vec3",
        lightsParamsv: "vec3",
        lightsParamsf: "float",
        uTexture: "sampler2d",
        uUseTexture: "float",
        useLighting: "float"
    },
    attributes: {
        aVertexPosition: "vec3",
        aVertexNormal: "vec3",
        aTexCoord: "vec2",
        aPositionHigh: { type: "vec3", divisor: 1 },
        aPositionLow: { type: "vec3", divisor: 1 },
        aColor: { type: "vec4", divisor: 1 },
        aScale: { type: "vec3", divisor: 1 },
        aTranslate: { type: "vec3", divisor: 1 },
        aDispose: { type: "float", divisor: 1 },
        qRot: { type: "vec4", divisor: 1 }
    },
    vertexShader: `precision highp float;
            
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal; 
            attribute vec3 aPositionHigh;
            attribute vec3 aPositionLow;    
            attribute vec4 aColor;
            attribute vec3 aScale;
            attribute vec3 aTranslate;
            attribute float aDispose;
            attribute float aUseTexture;
            attribute vec2 aTexCoord;
            attribute vec4 qRot;
            
            uniform vec3 uScaleByDistance;
            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;

            varying vec3 cameraPosition;
            varying vec3 vNormal;
            varying vec3 v_vertex;           
            varying vec4 vColor;
            varying float vDispose;
            varying vec2 vTexCoords;
            
            ${QROT}
           
            void main(void) {
                        
                if (aDispose == 0.0) {
                   return;
                }
                
                vec3 position = aPositionHigh + aPositionLow;
                cameraPosition = eyePositionHigh + eyePositionLow;
                
                vec3 look = cameraPosition - position;
                float lookLength = length(look);

                vColor = aColor;
                vTexCoords = aTexCoord;
              
                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = aPositionHigh - eyePositionHigh;
                vec3 lowDiff = aPositionLow - eyePositionLow;
             
                vNormal = qRotate(qRot, aVertexNormal);
                               
                // if(lookLength > uScaleByDistance[1])
                // {
                //     scd = uScaleByDistance[1] / uScaleByDistance[0];
                // }
                // else if(lookLength > uScaleByDistance[0])
                // {
                //     scd = lookLength / uScaleByDistance[0];
                // }
                // ... is the same math
                // use scaleByDistance: [1.0, 1.0, 1.0] for real sized objects 
                float scd = uScaleByDistance[2] * clamp(lookLength, uScaleByDistance[0], uScaleByDistance[1]) / uScaleByDistance[0];
                
                vec3 vert = qRotate(qRot, scd * (aVertexPosition * aScale + aTranslate));
                
                vert += lowDiff;
                               
                gl_Position = projectionMatrix * viewMatrixRTE  * vec4(highDiff * step(1.0, length(highDiff)) + vert, 1.0);
                
                v_vertex = position + vert;
            }`,
    fragmentShader: `precision highp float;

                #define MAX_POINT_LIGHTS 1
                
                uniform vec3 lightsPositions[MAX_POINT_LIGHTS];
                uniform vec3 lightsParamsv[MAX_POINT_LIGHTS * 3];
                uniform float lightsParamsf[MAX_POINT_LIGHTS];
                uniform sampler2D uTexture;
                uniform float uUseTexture;
                uniform float useLighting;                
                            
                varying vec3 cameraPosition;
                varying vec3 v_vertex;                
                varying vec4 vColor;
                varying vec3 vNormal;
                varying vec2 vTexCoords;
                
                void main(void) {        
                                        
                    vec3 lightWeighting = vec3(1.0);
                
                    if(useLighting != 0.0){
                        vec3 normal = normalize(vNormal);
                        vec3 lightDir = normalize(lightsPositions[0]);
                        vec3 viewDir = normalize(cameraPosition - v_vertex);                
                        vec3 reflectionDirection = reflect(-lightDir, normal);
                        float reflection = max( dot(reflectionDirection, viewDir), 0.0);
                        float specularLightWeighting = pow( reflection, lightsParamsf[0]);                                        
                        float diffuseLightWeighting = max(dot(normal, lightDir), 0.0);
                        lightWeighting = lightsParamsv[0] + lightsParamsv[1] * diffuseLightWeighting + lightsParamsv[2] * specularLightWeighting;
                    }
                                       
                    if(uUseTexture > 0.0) {
                        vec4 tColor = texture2D(uTexture, vTexCoords);
                        gl_FragColor = vec4(tColor.rgb * lightWeighting, tColor.a);
                    } else {
                        gl_FragColor = vec4(vColor.rgb * lightWeighting, vColor.a);
                    }
                }`
});
const geo_object_picking = () => new Program("geo_object_picking", {
    uniforms: {
        viewMatrix: "mat4",
        projectionMatrix: "mat4",
        uScaleByDistance: "vec3",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        pickingScale: "vec3"
    },
    attributes: {
        aVertexPosition: "vec3",
        aPositionHigh: { type: "vec3", divisor: 1 },
        aPositionLow: { type: "vec3", divisor: 1 },
        aPickingColor: { type: "vec3", divisor: 1 },
        aScale: { type: "vec3", divisor: 1 },
        aTranslate: { type: "vec3", divisor: 1 },
        aDispose: { type: "float", divisor: 1 },
        qRot: { type: "vec4", divisor: 1 }
    },
    vertexShader: `precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aPositionHigh;
            attribute vec3 aPositionLow;
            attribute vec3 aPickingColor;    
            attribute vec3 aScale;
            attribute vec3 aTranslate;
            attribute float aDispose;
            attribute vec4 qRot;
            
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform vec3 uScaleByDistance;
            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec3 pickingScale;

            varying vec3 vColor;
            
            ${QROT}

            void main(void) {

                if (aDispose == 0.0) {
                    return;
                 }
            
                 vColor = aPickingColor;
                
                 vec3 position = aPositionHigh + aPositionLow;
                 vec3 cameraPosition = eyePositionHigh + eyePositionLow;
 
                 mat4 viewMatrixRTE = viewMatrix;
                 viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);
 
                 vec3 highDiff = aPositionHigh - eyePositionHigh;
                 vec3 lowDiff = aPositionLow - eyePositionLow;
              
                 vec3 look = cameraPosition - position;
                 float lookLength = length(look);
                                
                 // if(lookLength > uScaleByDistance[1])
                 // {
                 //     scd = uScaleByDistance[1] / uScaleByDistance[0];
                 // }
                 // else if(lookLength > uScaleByDistance[0])
                 // {
                 //     scd = lookLength / uScaleByDistance[0];
                 // }
                 // ... is the same math above
                 // @hack
                 // pickingScale replace to this line, because when it s
                 // tays in the vert above it affects on Mac Safari jitter
                 float scd = uScaleByDistance[2] * clamp(lookLength, uScaleByDistance[0], uScaleByDistance[1]) / uScaleByDistance[0];

                 //vec3 vert = qRotate(qRot, (aVertexPosition * aScale + aTranslate) * pickingScale) * scd;
                 vec3 vert = qRotate(qRot, scd * pickingScale * (aVertexPosition * aScale + aTranslate));
                 
                 vert += lowDiff;
                                
                 gl_Position = projectionMatrix * viewMatrixRTE  * vec4(highDiff * step(1.0, length(highDiff)) + vert, 1.0);
            }`,
    fragmentShader: `precision highp float;
            varying vec3 vColor;
            void main () {
                gl_FragColor = vec4(vColor, 1.0);
            }`
});

const VERTEX_BUFFER$2 = 0;
const POSITION_BUFFER$1 = 1;
const RGBA_BUFFER$2 = 2;
const NORMALS_BUFFER = 3;
const INDEX_BUFFER = 4;
const QROT_BUFFER = 5;
const SIZE_BUFFER$1 = 6;
const PICKINGCOLOR_BUFFER$2 = 7;
const VISIBLE_BUFFER = 8;
const TEXCOORD_BUFFER$1 = 9;
const TRANSLATE_BUFFER = 10;
function setParametersToArray(arr, index = 0, length = 0, itemSize = 1, ...params) {
    const currIndex = index * length;
    for (let i = currIndex, len = currIndex + length; i < len; i++) {
        arr[i] = params[i % itemSize];
    }
    return arr;
}
// function setParametersToArrayArr(arr: number[] | TypedArray, index: number = 0, length: number = 0, itemSize: number = 1, paramsArr: number[]): number[] | TypedArray {
//     const currIndex = index * length;
//     for (let i = currIndex, len = currIndex + length; i < len; i++) {
//         arr[i] = paramsArr[i % itemSize];
//     }
//     return arr;
// }
class InstanceData {
    constructor(geoObjectHandler) {
        this.isFree = true;
        this._geoObjectHandler = geoObjectHandler;
        this.geoObjects = [];
        this.numInstances = 0;
        this._texture = null;
        this._textureSrc = null;
        this._sizeArr = [];
        this._translateArr = [];
        this._vertexArr = [];
        this._positionHighArr = [];
        this._positionLowArr = [];
        this._qRotArr = [];
        this._rgbaArr = [];
        this._normalsArr = [];
        this._indicesArr = [];
        this._pickingColorArr = [];
        this._visibleArr = [];
        this._texCoordArr = [];
        this._sizeBuffer = null;
        this._translateBuffer = null;
        this._vertexBuffer = null;
        this._positionHighBuffer = null;
        this._positionLowBuffer = null;
        this._qRotBuffer = null;
        this._rgbaBuffer = null;
        this._normalsBuffer = null;
        this._indicesBuffer = null;
        this._pickingColorBuffer = null;
        this._visibleBuffer = null;
        this._texCoordBuffer = null;
        this._buffersUpdateCallbacks = [];
        this._buffersUpdateCallbacks[PICKINGCOLOR_BUFFER$2] = this.createPickingColorBuffer;
        this._buffersUpdateCallbacks[POSITION_BUFFER$1] = this.createPositionBuffer;
        this._buffersUpdateCallbacks[NORMALS_BUFFER] = this.createNormalsBuffer;
        this._buffersUpdateCallbacks[RGBA_BUFFER$2] = this.createRgbaBuffer;
        this._buffersUpdateCallbacks[INDEX_BUFFER] = this.createIndicesBuffer;
        this._buffersUpdateCallbacks[VERTEX_BUFFER$2] = this.createVertexBuffer;
        this._buffersUpdateCallbacks[SIZE_BUFFER$1] = this.createSizeBuffer;
        this._buffersUpdateCallbacks[VISIBLE_BUFFER] = this.createVisibleBuffer;
        this._buffersUpdateCallbacks[TEXCOORD_BUFFER$1] = this.createTexCoordBuffer;
        this._buffersUpdateCallbacks[QROT_BUFFER] = this.createQRotBuffer;
        this._buffersUpdateCallbacks[TRANSLATE_BUFFER] = this.createTranslateBuffer;
        this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
    }
    createTexture(image) {
        if (this._geoObjectHandler && this._geoObjectHandler._planet) {
            this._texture = this._geoObjectHandler._planet.renderer.handler.createTextureDefault(image);
        }
    }
    clear() {
        this.numInstances = 0;
        this.geoObjects = [];
        this._sizeArr = [];
        this._translateArr = [];
        this._vertexArr = [];
        this._positionHighArr = [];
        this._positionLowArr = [];
        this._qRotArr = [];
        this._rgbaArr = [];
        this._normalsArr = [];
        this._indicesArr = [];
        this._pickingColorArr = [];
        this._visibleArr = [];
        this._texCoordArr = [];
        this._deleteBuffers();
        this.isFree = false;
        //this._geoObjectHandler = null;
    }
    _deleteBuffers() {
        if (this._geoObjectHandler && this._geoObjectHandler._planet && this._geoObjectHandler._planet.renderer) {
            let h = this._geoObjectHandler._planet.renderer.handler, gl = h.gl;
            h.deleteTexture(this._texture);
            this._texture = null;
            gl.deleteBuffer(this._sizeBuffer);
            gl.deleteBuffer(this._translateBuffer);
            gl.deleteBuffer(this._vertexBuffer);
            gl.deleteBuffer(this._positionHighBuffer);
            gl.deleteBuffer(this._positionLowBuffer);
            gl.deleteBuffer(this._qRotBuffer);
            gl.deleteBuffer(this._rgbaBuffer);
            gl.deleteBuffer(this._normalsBuffer);
            gl.deleteBuffer(this._indicesBuffer);
            gl.deleteBuffer(this._pickingColorBuffer);
            gl.deleteBuffer(this._visibleBuffer);
            gl.deleteBuffer(this._texCoordBuffer);
        }
        this._sizeBuffer = null;
        this._translateBuffer = null;
        this._vertexBuffer = null;
        this._positionHighBuffer = null;
        this._positionLowBuffer = null;
        this._qRotBuffer = null;
        this._rgbaBuffer = null;
        this._normalsBuffer = null;
        this._indicesBuffer = null;
        this._pickingColorBuffer = null;
        this._visibleBuffer = null;
        this._texCoordBuffer = null;
    }
    createVertexBuffer() {
        const h = this._geoObjectHandler._planet.renderer.handler;
        h.gl.deleteBuffer(this._vertexBuffer);
        this._vertexArr = makeArrayTyped(this._vertexArr);
        this._vertexBuffer = h.createArrayBuffer(this._vertexArr, 3, this._vertexArr.length / 3);
    }
    createVisibleBuffer() {
        const h = this._geoObjectHandler._planet.renderer.handler, numItems = this._visibleArr.length;
        if (!this._visibleBuffer || this._visibleBuffer.numItems !== numItems) {
            h.gl.deleteBuffer(this._visibleBuffer);
            this._visibleBuffer = h.createStreamArrayBuffer(1, numItems);
        }
        this._visibleArr = makeArrayTyped(this._visibleArr);
        h.setStreamArrayBuffer(this._visibleBuffer, this._visibleArr);
    }
    createSizeBuffer() {
        let h = this._geoObjectHandler._planet.renderer.handler, numItems = this._sizeArr.length / 3;
        if (!this._sizeBuffer || this._sizeBuffer.numItems !== numItems) {
            h.gl.deleteBuffer(this._sizeBuffer);
            this._sizeBuffer = h.createStreamArrayBuffer(3, numItems);
        }
        this._sizeArr = makeArrayTyped(this._sizeArr);
        h.setStreamArrayBuffer(this._sizeBuffer, this._sizeArr);
    }
    createTranslateBuffer() {
        let h = this._geoObjectHandler._planet.renderer.handler, numItems = this._translateArr.length / 3;
        if (!this._translateBuffer || this._translateBuffer.numItems !== numItems) {
            h.gl.deleteBuffer(this._translateBuffer);
            this._translateBuffer = h.createStreamArrayBuffer(3, numItems);
        }
        this._translateArr = makeArrayTyped(this._translateArr);
        h.setStreamArrayBuffer(this._translateBuffer, this._translateArr);
    }
    createTexCoordBuffer() {
        const h = this._geoObjectHandler._planet.renderer.handler;
        h.gl.deleteBuffer(this._texCoordBuffer);
        this._texCoordArr = makeArrayTyped(this._texCoordArr);
        this._texCoordBuffer = h.createArrayBuffer(this._texCoordArr, 2, this._texCoordArr.length / 2);
    }
    createPositionBuffer() {
        let h = this._geoObjectHandler._planet.renderer.handler, numItems = this._positionHighArr.length / 3;
        if (!this._positionHighBuffer || this._positionHighBuffer.numItems !== numItems) {
            h.gl.deleteBuffer(this._positionHighBuffer);
            h.gl.deleteBuffer(this._positionLowBuffer);
            this._positionHighBuffer = h.createStreamArrayBuffer(3, numItems);
            this._positionLowBuffer = h.createStreamArrayBuffer(3, numItems);
        }
        this._positionHighArr = makeArrayTyped(this._positionHighArr);
        this._positionLowArr = makeArrayTyped(this._positionLowArr);
        h.setStreamArrayBuffer(this._positionHighBuffer, this._positionHighArr);
        h.setStreamArrayBuffer(this._positionLowBuffer, this._positionLowArr);
    }
    createRgbaBuffer() {
        let h = this._geoObjectHandler._planet.renderer.handler, numItems = this._rgbaArr.length / 4;
        if (!this._rgbaBuffer || this._rgbaBuffer.numItems !== numItems) {
            h.gl.deleteBuffer(this._rgbaBuffer);
            this._rgbaBuffer = h.createStreamArrayBuffer(4, numItems);
        }
        this._rgbaArr = makeArrayTyped(this._rgbaArr);
        h.setStreamArrayBuffer(this._rgbaBuffer, this._rgbaArr);
    }
    createQRotBuffer() {
        let h = this._geoObjectHandler._planet.renderer.handler, numItems = this._qRotArr.length / 4;
        if (!this._qRotBuffer || this._qRotBuffer.numItems !== numItems) {
            h.gl.deleteBuffer(this._qRotBuffer);
            this._qRotBuffer = h.createStreamArrayBuffer(4, numItems);
        }
        this._qRotArr = makeArrayTyped(this._qRotArr);
        h.setStreamArrayBuffer(this._qRotBuffer, this._qRotArr);
    }
    createNormalsBuffer() {
        const h = this._geoObjectHandler._planet.renderer.handler;
        h.gl.deleteBuffer(this._normalsBuffer);
        this._normalsArr = makeArrayTyped(this._normalsArr);
        this._normalsBuffer = h.createArrayBuffer(this._normalsArr, 3, this._normalsArr.length / 3);
    }
    createIndicesBuffer() {
        const h = this._geoObjectHandler._planet.renderer.handler;
        h.gl.deleteBuffer(this._indicesBuffer);
        this._indicesArr = makeArrayTyped(this._indicesArr, Uint32Array);
        this._indicesBuffer = h.createElementArrayBuffer(this._indicesArr, 1, this._indicesArr.length);
    }
    createPickingColorBuffer() {
        const h = this._geoObjectHandler._planet.renderer.handler;
        h.gl.deleteBuffer(this._pickingColorBuffer);
        this._pickingColorArr = makeArrayTyped(this._pickingColorArr);
        this._pickingColorBuffer = h.createArrayBuffer(this._pickingColorArr, 3, this._pickingColorArr.length / 3);
    }
    refresh() {
        let i = this._changedBuffers.length;
        while (i--) {
            this._changedBuffers[i] = true;
        }
    }
    update() {
        if (this._geoObjectHandler._planet) {
            let i = this._changedBuffers.length;
            while (i--) {
                if (this._changedBuffers[i]) {
                    this._buffersUpdateCallbacks[i].call(this);
                    this._changedBuffers[i] = false;
                }
            }
            this.isFree = true;
        }
    }
}
class GeoObjectHandler {
    constructor(entityCollection) {
        this.__id = GeoObjectHandler.__counter__++;
        this.pickingEnabled = true;
        this._entityCollection = entityCollection;
        this._planet = null;
        this._geoObjects = [];
        this._instanceDataMap = new Map();
        this._instanceDataMapValues = [];
        this._dataTagUpdateQueue = [];
    }
    initProgram() {
        if (this._planet && this._planet.renderer) {
            if (!this._planet.renderer.handler.programs.geo_object) {
                this._planet.renderer.handler.addProgram(geo_object());
            }
            if (!this._planet.renderer.handler.programs.geo_object_picking) {
                this._planet.renderer.handler.addProgram(geo_object_picking());
            }
        }
    }
    setRenderNode(renderNode) {
        this._planet = renderNode;
        this.initProgram();
        //
        // in case of lazy initialization loading data here
        for (let i = 0; i < this._instanceDataMapValues.length; i++) {
            this._loadDataTagTexture(this._instanceDataMapValues[i]);
        }
        for (let i = 0; i < this._geoObjects.length; i++) {
            this._geoObjects[i].updateRotation();
        }
        this.update();
    }
    setTextureTag(src, tag) {
        const tagData = this._instanceDataMap.get(tag);
        if (tagData) {
            tagData._textureSrc = src;
            this._instanceDataMap.set(tag, tagData);
            this._loadDataTagTexture(tagData);
        }
    }
    setObjectSrc(src, tag) {
        const tagData = this._instanceDataMap.get(tag);
        if (src) {
            if (tagData && tagData._objectSrc !== src) {
                tagData._objectSrc = src;
                Object3d.loadObj(src).then((object3d) => {
                    this._updateInstanceData(object3d[0], tag);
                });
            }
        }
    }
    _updateInstanceData(object, tag) {
        const tagData = this._instanceDataMap.get(tag);
        if (tagData) {
            if (object.vertices.length !== tagData._vertexArr.length) {
                tagData._vertexArr = object.vertices;
                tagData._changedBuffers[VERTEX_BUFFER$2] = true;
            }
            if (object.normals.length !== tagData._normalsArr.length) {
                tagData._normalsArr = object.normals;
                tagData._changedBuffers[NORMALS_BUFFER] = true;
            }
            if (object.indices.length !== tagData._indicesArr.length) {
                tagData._indicesArr = object.indices;
                tagData._changedBuffers[INDEX_BUFFER] = true;
            }
            if (object.texCoords.length !== tagData._texCoordArr.length) {
                tagData._texCoordArr = object.texCoords;
                tagData._changedBuffers[TEXCOORD_BUFFER$1] = true;
            }
            tagData._textureSrc = object.src;
            this._loadDataTagTexture(tagData);
            this._updateTag(tagData);
            this._instanceDataMapValues = Array.from(this._instanceDataMap.values());
        }
    }
    _addGeoObjectToArray(geoObject) {
        const tag = geoObject.tag;
        let tagData = this._instanceDataMap.get(tag);
        if (!tagData) {
            tagData = new InstanceData(this);
            this._instanceDataMap.set(tag, tagData);
            this._instanceDataMapValues = Array.from(this._instanceDataMap.values());
            //
            // Setting instanced data
            tagData._vertexArr = geoObject.vertices;
            tagData._normalsArr = geoObject.normals;
            tagData._indicesArr = geoObject.indices;
            tagData._texCoordArr = geoObject.texCoords;
            tagData._textureSrc = geoObject.object3d.src;
            this._loadDataTagTexture(tagData);
        }
        geoObject._tagDataIndex = tagData.numInstances++;
        geoObject._tagData = tagData;
        tagData.geoObjects.push(geoObject);
        let itemSize = 3;
        tagData._visibleArr = concatArrays(tagData._visibleArr, setParametersToArray([], 0, 1, 1, geoObject.getVisibility() ? 1 : 0));
        let x = geoObject._positionHigh.x, y = geoObject._positionHigh.y, z = geoObject._positionHigh.z, w;
        tagData._positionHighArr = concatArrays(tagData._positionHighArr, setParametersToArray([], 0, itemSize, itemSize, x, y, z));
        x = geoObject._positionLow.x;
        y = geoObject._positionLow.y;
        z = geoObject._positionLow.z;
        tagData._positionLowArr = concatArrays(tagData._positionLowArr, setParametersToArray([], 0, itemSize, itemSize, x, y, z));
        x = geoObject._entity._pickingColor.x / 255;
        y = geoObject._entity._pickingColor.y / 255;
        z = geoObject._entity._pickingColor.z / 255;
        tagData._pickingColorArr = concatArrays(tagData._pickingColorArr, setParametersToArray([], 0, itemSize, itemSize, x, y, z));
        itemSize = 4;
        x = geoObject._qRot.x;
        y = geoObject._qRot.y;
        z = geoObject._qRot.z;
        w = geoObject._qRot.w;
        tagData._qRotArr = concatArrays(tagData._qRotArr, setParametersToArray([], 0, itemSize, itemSize, x, y, z, w));
        x = geoObject._color.x;
        y = geoObject._color.y;
        z = geoObject._color.z;
        w = geoObject._color.w;
        tagData._rgbaArr = concatArrays(tagData._rgbaArr, setParametersToArray([], 0, itemSize, itemSize, x, y, z, w));
        itemSize = 3;
        let scale = geoObject.getScale();
        x = scale.x;
        y = scale.y;
        z = scale.z;
        tagData._sizeArr = concatArrays(tagData._sizeArr, setParametersToArray([], 0, itemSize, itemSize, x, y, z));
        let translate = geoObject.getTranslate();
        x = translate.x;
        y = translate.y;
        z = translate.z;
        tagData._translateArr = concatArrays(tagData._translateArr, setParametersToArray([], 0, itemSize, itemSize, x, y, z));
    }
    _displayPASS() {
        let r = this._planet.renderer, sh = r.handler.programs.geo_object, p = sh._program, u = p.uniforms, a = p.attributes, gl = r.handler.gl, ec = this._entityCollection;
        sh.activate();
        //gl.disable(gl.CULL_FACE);
        //
        // Could be in VAO
        //
        gl.uniform3fv(u.uScaleByDistance, ec.scaleByDistance);
        gl.uniform1f(u.useLighting, ec._useLighting);
        gl.uniform3fv(u.eyePositionHigh, r.activeCamera.eyeHigh);
        gl.uniform3fv(u.eyePositionLow, r.activeCamera.eyeLow);
        gl.uniformMatrix4fv(u.projectionMatrix, false, r.activeCamera.getProjectionMatrix());
        gl.uniformMatrix4fv(u.viewMatrix, false, r.activeCamera.getViewMatrix());
        gl.uniform3fv(u.lightsPositions, this._planet._lightsPositions);
        gl.uniform3fv(u.lightsParamsv, this._planet._lightsParamsv);
        gl.uniform1fv(u.lightsParamsf, this._planet._lightsParamsf);
        for (let i = 0; i < this._instanceDataMapValues.length; i++) {
            let tagData = this._instanceDataMapValues[i];
            //
            //  Instance individual data
            //
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._qRotBuffer);
            gl.vertexAttribPointer(a.qRot, tagData._qRotBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._sizeBuffer);
            gl.vertexAttribPointer(a.aScale, tagData._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._translateBuffer);
            gl.vertexAttribPointer(a.aTranslate, tagData._translateBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._rgbaBuffer);
            gl.vertexAttribPointer(a.aColor, tagData._rgbaBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._visibleBuffer);
            gl.vertexAttribPointer(a.aDispose, tagData._visibleBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.uniform1f(u.uUseTexture, tagData._texture ? 1 : 0);
            //
            // Instance common data(could be in VAO)
            //
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._positionHighBuffer);
            gl.vertexAttribPointer(a.aPositionHigh, tagData._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._positionLowBuffer);
            gl.vertexAttribPointer(a.aPositionLow, tagData._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._normalsBuffer);
            gl.vertexAttribPointer(a.aVertexNormal, tagData._normalsBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._vertexBuffer);
            gl.vertexAttribPointer(a.aVertexPosition, tagData._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, (tagData._texture || r.handler.defaultTexture));
            gl.uniform1i(u.uTexture, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._texCoordBuffer);
            gl.vertexAttribPointer(a.aTexCoord, tagData._texCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tagData._indicesBuffer);
            p.drawElementsInstanced(gl.TRIANGLES, tagData._indicesBuffer.numItems, gl.UNSIGNED_INT, 0, tagData.numInstances);
        }
    }
    drawPicking() {
        if (this._geoObjects.length && this.pickingEnabled) {
            this.update();
            this._pickingPASS();
        }
    }
    _pickingPASS() {
        let r = this._planet.renderer, sh = r.handler.programs.geo_object_picking, p = sh._program, u = p.uniforms, a = p.attributes, gl = r.handler.gl, ec = this._entityCollection;
        sh.activate();
        gl.uniform3fv(u.uScaleByDistance, ec.scaleByDistance);
        gl.uniform3fv(u.pickingScale, ec.pickingScale);
        gl.uniform3fv(u.eyePositionHigh, r.activeCamera.eyeHigh);
        gl.uniform3fv(u.eyePositionLow, r.activeCamera.eyeLow);
        gl.uniformMatrix4fv(u.projectionMatrix, false, r.activeCamera.getProjectionMatrix());
        gl.uniformMatrix4fv(u.viewMatrix, false, r.activeCamera.getViewMatrix());
        for (let i = 0; i < this._instanceDataMapValues.length; i++) {
            let tagData = this._instanceDataMapValues[i];
            //
            // Instance individual data
            //
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._qRotBuffer);
            gl.vertexAttribPointer(a.qRot, tagData._qRotBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._sizeBuffer);
            gl.vertexAttribPointer(a.aScale, tagData._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._translateBuffer);
            gl.vertexAttribPointer(a.aTranslate, tagData._translateBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._pickingColorBuffer);
            gl.vertexAttribPointer(a.aPickingColor, tagData._pickingColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._positionHighBuffer);
            gl.vertexAttribPointer(a.aPositionHigh, tagData._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._positionLowBuffer);
            gl.vertexAttribPointer(a.aPositionLow, tagData._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._visibleBuffer);
            gl.vertexAttribPointer(a.aDispose, tagData._visibleBuffer.itemSize, gl.FLOAT, false, 0, 0);
            //
            // Instance common data(could be in VAO)
            //
            gl.bindBuffer(gl.ARRAY_BUFFER, tagData._vertexBuffer);
            gl.vertexAttribPointer(a.aVertexPosition, tagData._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tagData._indicesBuffer);
            p.drawElementsInstanced(gl.TRIANGLES, tagData._indicesBuffer.numItems, gl.UNSIGNED_INT, 0, tagData.numInstances);
        }
    }
    async _loadDataTagTexture(tagData) {
        if (this._planet && tagData._textureSrc) {
            const image = await loadImage(tagData._textureSrc);
            tagData.createTexture(image);
        }
    }
    setQRotArr(tagData, tagDataIndex, qRot) {
        setParametersToArray(tagData._qRotArr, tagDataIndex, 4, 4, qRot.x, qRot.y, qRot.z, qRot.w);
        tagData._changedBuffers[QROT_BUFFER] = true;
        this._updateTag(tagData);
    }
    setVisibility(tagData, tagDataIndex, visibility) {
        setParametersToArray(tagData._visibleArr, tagDataIndex, 1, 1, visibility ? 1 : 0);
        tagData._changedBuffers[VISIBLE_BUFFER] = true;
        this._updateTag(tagData);
    }
    setPositionArr(tagData, tagDataIndex, positionHigh, positionLow) {
        setParametersToArray(tagData._positionHighArr, tagDataIndex, 3, 3, positionHigh.x, positionHigh.y, positionHigh.z);
        setParametersToArray(tagData._positionLowArr, tagDataIndex, 3, 3, positionLow.x, positionLow.y, positionLow.z);
        tagData._changedBuffers[POSITION_BUFFER$1] = true;
        this._updateTag(tagData);
    }
    setRgbaArr(tagData, tagDataIndex, rgba) {
        setParametersToArray(tagData._rgbaArr, tagDataIndex, 4, 4, rgba.x, rgba.y, rgba.z, rgba.w);
        tagData._changedBuffers[RGBA_BUFFER$2] = true;
        this._updateTag(tagData);
    }
    setPickingColorArr(tagData, tagDataIndex, color) {
        setParametersToArray(tagData._pickingColorArr, tagDataIndex, 3, 3, color.x / 255, color.y / 255, color.z / 255);
        tagData._changedBuffers[PICKINGCOLOR_BUFFER$2] = true;
        this._updateTag(tagData);
    }
    // setTexCoordArr(tagData, tagDataIndex, tcoordArr) {
    //     setParametersToArray(tagData._texCoordArr, tagDataIndex, 2, 2, ...tcoordArr);
    //     tagData._changedBuffers[TEXCOORD_BUFFER] = true;
    //     this._updateTag(tagData);
    // }
    setScaleArr(tagData, tagDataIndex, scale) {
        setParametersToArray(tagData._sizeArr, tagDataIndex, 3, 3, scale.x, scale.y, scale.z);
        tagData._changedBuffers[SIZE_BUFFER$1] = true;
        this._updateTag(tagData);
    }
    setTranslateArr(tagData, tagDataIndex, translate) {
        setParametersToArray(tagData._translateArr, tagDataIndex, 3, 3, translate.x, translate.y, translate.z);
        tagData._changedBuffers[TRANSLATE_BUFFER] = true;
        this._updateTag(tagData);
    }
    _updateTag(dataTag) {
        if (dataTag.isFree) {
            dataTag.isFree = false;
            this._dataTagUpdateQueue.push(dataTag);
        }
    }
    update() {
        for (let i = 0, len = this._dataTagUpdateQueue.length; i < len; i++) {
            this._dataTagUpdateQueue[i].update();
        }
        this._dataTagUpdateQueue = [];
    }
    _removeAll() {
        let i = this._geoObjects.length;
        while (i--) {
            const gi = this._geoObjects[i];
            gi._tagDataIndex = -1;
            gi._tagData = null;
            gi._handlerIndex = -1;
            gi._handler = null;
        }
        this._geoObjects.length = 0;
        this._geoObjects = [];
        for (let i = 0; i < this._instanceDataMapValues.length; i++) {
            this._instanceDataMapValues[i].clear();
        }
        this._instanceDataMap.clear();
        this._instanceDataMapValues = [];
    }
    clear() {
        this._removeAll();
    }
    draw() {
        if (this._geoObjects.length) {
            this.update();
            this._displayPASS();
        }
    }
    add(geoObject) {
        if (geoObject._handlerIndex === -1) {
            geoObject._handler = this;
            geoObject._handlerIndex = this._geoObjects.length;
            this._geoObjects.push(geoObject);
            this._addGeoObjectToArray(geoObject);
            geoObject.updateRotation();
            geoObject._tagData.refresh();
            this._updateTag(geoObject._tagData);
            geoObject.setObjectSrc(geoObject._objectSrc);
        }
    }
    remove(geoObject) {
        if (geoObject._handler && this.__id == geoObject._handler.__id) {
            this._removeGeoObject(geoObject);
        }
    }
    _clearDataTagQueue() {
        this._dataTagUpdateQueue = [];
    }
    _removeGeoObject(geoObject) {
        let tagData = geoObject._tagData;
        let tag = geoObject.tag;
        tagData.numInstances--;
        let isEmpty = false;
        // dataTag becomes empty, remove it from the rendering
        if (tagData.numInstances === 0) {
            tagData.clear();
            this._instanceDataMap.delete(tag);
            this._instanceDataMapValues = [];
            this._clearDataTagQueue();
            isEmpty = true;
        }
        this._geoObjects.splice(geoObject._handlerIndex, 1);
        for (let i = geoObject._handlerIndex, len = this._geoObjects.length; i < len; i++) {
            let gi = this._geoObjects[i];
            gi._handlerIndex = gi._handlerIndex - 1;
        }
        let tdi = geoObject._tagDataIndex;
        tagData.geoObjects.splice(tdi, 1);
        for (let i = geoObject._tagDataIndex, len = tagData.geoObjects.length; i < len; i++) {
            let gi = tagData.geoObjects[i];
            gi._tagDataIndex = gi._tagDataIndex - 1;
        }
        tagData._rgbaArr = spliceArray(tagData._rgbaArr, tdi * 4, 4);
        tagData._positionHighArr = spliceArray(tagData._positionHighArr, tdi * 3, 3);
        tagData._positionLowArr = spliceArray(tagData._positionLowArr, tdi * 3, 3);
        tagData._qRotArr = spliceArray(tagData._qRotArr, tdi * 4, 4);
        tagData._pickingColorArr = spliceArray(tagData._pickingColorArr, tdi * 3, 3);
        tagData._sizeArr = spliceArray(tagData._sizeArr, tdi * 3, 3);
        tagData._translateArr = spliceArray(tagData._translateArr, tdi * 3, 3);
        tagData._visibleArr = spliceArray(tagData._visibleArr, tdi, 1);
        geoObject._handlerIndex = -1;
        geoObject._handler = null;
        geoObject._tagDataIndex = -1;
        geoObject._tagData = null;
        if (!isEmpty) {
            tagData.refresh();
            this._updateTag(tagData);
        }
    }
}
GeoObjectHandler.__counter__ = 0;

const DEFINE = `
#define EMPTY -1.0
#define RTL 1.0`;
const PROJECT = `vec2 project(vec4 p) {
                    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;
                }`;
const ROTATE2D = `mat2 rotate2d(float angle) {
        return mat2(cos(angle), -sin(angle),
           sin(angle), cos(angle));
     }`;
function label_webgl2() {
    return new Program("label", {
        uniforms: {
            viewport: "vec2",
            fontTextureArr: "sampler2darray",
            sdfParamsArr: "vec4",
            projectionMatrix: "mat4",
            viewMatrix: "mat4",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            planetRadius: "float",
            scaleByDistance: "vec3",
            opacity: "float",
            isOutlinePass: "int",
            depthOffset: "float"
        },
        attributes: {
            a_outline: "float",
            a_gliphParam: "vec4",
            a_vertices: "vec2",
            a_texCoord: "vec4",
            a_positionsHigh: "vec3",
            a_positionsLow: "vec3",
            a_size: "float",
            a_rotation: "float",
            a_rgba: "vec4",
            a_offset: "vec3",
            a_fontIndex: "float"
        },
        vertexShader: `#version 300 es
            
            ${DEFINE}
            
            in float a_outline;
            in vec4 a_gliphParam;
            in vec2 a_vertices;
            in vec4 a_texCoord;
            in vec3 a_positionsHigh;
            in vec3 a_positionsLow;
            in vec3 a_offset;
            in float a_size;
            in float a_rotation;
            in vec4 a_rgba;
            in float a_fontIndex;

            out vec2 v_uv;
            out vec4 v_rgba;
            flat out int v_fontIndex;            
            out vec4 v_outlineColor;
            flat out float v_outline;

            uniform vec2 viewport;
            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float planetRadius;
            uniform vec3 scaleByDistance;
            uniform float opacity;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);
           
            ${PROJECT}

            ${ROTATE2D}

            void main() {

                if(a_texCoord.w == EMPTY) {
                    gl_Position = vec4(0.0);
                    v_fontIndex = -1;
                    return;
                }
               
                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;

                v_outline = a_outline;

                v_fontIndex = int(a_fontIndex);
                v_uv = a_texCoord.xy;
                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                v_rgba = a_rgba;
                
                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                float scd = (1.0 - smoothstep(scaleByDistance[0], scaleByDistance[1], lookDist)) * (1.0 - step(scaleByDistance[2], lookDist));

                v_rgba.a *= opacity;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;                  
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                        
                projPos.z += depthOffset + a_offset.z;
                               
                vec2 screenPos = project(projPos);
                
                vec2 vert = a_vertices;                
                vec4 gp = a_gliphParam;                                
                if(a_texCoord.w == RTL){
                    vert.x = step(vert.x * 0.5 + 1.0, 1.0);
                    gp.x = -a_gliphParam.x;
                    gp.z = -(a_gliphParam.z + a_texCoord.z);
                }else{
                    gp.z = a_gliphParam.z + a_texCoord.z;
                }
                                
                vec2 v = screenPos + rotate2d(a_rotation) * ((vert * gp.xy + gp.zw) * a_size * scd + a_offset.xy);

                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
        fragmentShader: `#version 300 es

            uniform int isOutlinePass;
            
            precision highp float;

            const int MAX_SIZE = 11;

            // x - ATLAS_WIDTH = 512.0;
            // y - ATLAS_HEIGHT = 512.0;
            // z - ATLAS_GLYPH_SIZE = 32.0;
            // w - ATLAS_FIELD_RANGE = 8.0;

            uniform sampler2D fontTextureArr[MAX_SIZE];
            uniform vec4 sdfParamsArr[MAX_SIZE];

            flat in int v_fontIndex;
            in vec2 v_uv;
            in vec4 v_rgba;           

            flat in float v_outline;

            in vec3 v_pickingColor;

            layout(location = 0) out vec4 outScreen;

            float median(float r, float g, float b) {
                return max(min(r, g), min(max(r, g), b));
            }

            float getDistance() {
                vec3 msdf;
                if(v_fontIndex == 0) {
                    msdf = texture(fontTextureArr[0], v_uv).rgb;
                } else if(v_fontIndex == 1){
                    msdf = texture(fontTextureArr[1], v_uv).rgb;
                } else if(v_fontIndex == 2){
                    msdf = texture(fontTextureArr[2], v_uv).rgb;
                } else if(v_fontIndex == 3){
                    msdf = texture(fontTextureArr[3], v_uv).rgb;
                } else if(v_fontIndex == 4){
                    msdf = texture(fontTextureArr[4], v_uv).rgb;
                } else if(v_fontIndex == 5){
                    msdf = texture(fontTextureArr[5], v_uv).rgb;
                } else if(v_fontIndex == 6){
                    msdf = texture(fontTextureArr[6], v_uv).rgb;
                } else if(v_fontIndex == 7){
                    msdf = texture(fontTextureArr[7], v_uv).rgb;
                } else if(v_fontIndex == 8){
                    msdf = texture(fontTextureArr[8], v_uv).rgb;
                } else if(v_fontIndex == 9){
                    msdf = texture(fontTextureArr[9], v_uv).rgb;
                } else if(v_fontIndex == 10){
                    msdf = texture(fontTextureArr[10], v_uv).rgb;
                }
                return median(msdf.r, msdf.g, msdf.b);
            }
                        
            void main () {
            
                if(v_fontIndex == -1) {
                    return;
                }
                
                vec4 sdfParams = sdfParamsArr[v_fontIndex];
                float sd = getDistance();             
                vec2 dxdy = fwidth(v_uv) * sdfParams.xy;

                if(isOutlinePass == 0){                             
                    float dist = sd + min(0.001, 0.5 - 1.0 / sdfParams.w) - 0.5;
                    float opacity = clamp(dist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);
                    if(opacity <= 0.1){
                        discard;
                    }
                    outScreen = vec4(v_rgba.rgb, opacity * v_rgba.a);
                } else {             
                    float dist = sd + min(v_outline, 0.5 - 1.0 / sdfParams.w) - 0.5;
                    float opacity = clamp(dist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);                       
                    if(opacity <= 0.1){
                        discard;
                    }
                    outScreen = vec4(v_rgba.rgb, opacity * v_rgba.a);
                    //outScreen = v_rgba * strokeAlpha * (0.5 - opacity) * 2.0;
                }         
            }`
    });
}
function label_screen() {
    return new Program("label", {
        uniforms: {
            viewport: "vec2",
            fontTextureArr: "sampler2darray",
            sdfParamsArr: "vec4",
            projectionMatrix: "mat4",
            viewMatrix: "mat4",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            planetRadius: "float",
            scaleByDistance: "vec3",
            opacity: "float",
            isOutlinePass: "int",
            depthOffset: "float"
        },
        attributes: {
            a_outline: "float",
            a_gliphParam: "vec4",
            a_vertices: "vec2",
            a_texCoord: "vec4",
            a_positionsHigh: "vec3",
            a_positionsLow: "vec3",
            a_size: "float",
            a_rotation: "float",
            a_rgba: "vec4",
            a_offset: "vec3",
            a_fontIndex: "float"
        },
        vertexShader: `            
            ${DEFINE}
                        
            attribute float a_outline;
            attribute vec4 a_gliphParam;
            attribute vec2 a_vertices;
            attribute vec4 a_texCoord;
            attribute vec3 a_positionsHigh;
            attribute vec3 a_positionsLow;
            attribute vec3 a_offset;
            attribute float a_size;
            attribute float a_rotation;
            attribute vec4 a_rgba;
            attribute float a_fontIndex;

            varying float v_outline;
            varying vec2 v_uv;
            varying vec4 v_rgba;
            varying float v_fontIndex;            

            uniform vec2 viewport;
            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float planetRadius;
            uniform vec3 scaleByDistance;
            uniform float opacity;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);

            ${PROJECT}

            ${ROTATE2D}

            void main() {

                if(a_texCoord.w == EMPTY) {
                    gl_Position = vec4(0.0);
                    v_fontIndex = -1.0;
                    return;
                }
               
                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;

                v_outline = a_outline;
                v_uv = vec2(a_texCoord.xy);
                v_rgba = a_rgba;
                v_fontIndex = a_fontIndex;
                
                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                
                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                float scd = (1.0 - smoothstep(scaleByDistance[0], scaleByDistance[1], lookDist)) * (1.0 - step(scaleByDistance[2], lookDist));

                v_rgba.a *= opacity;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;                  
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                        
                projPos.z += depthOffset + a_offset.z;
                               
                vec2 screenPos = project(projPos);
                
                vec2 vert = a_vertices;                
                vec4 gp = a_gliphParam;                                
                if(a_texCoord.w == RTL){
                    vert.x = step(vert.x * 0.5 + 1.0, 1.0);
                    gp.x = -a_gliphParam.x;
                    gp.z = -(a_gliphParam.z + a_texCoord.z);
                }else{
                    gp.z = a_gliphParam.z + a_texCoord.z;
                }
                                
                vec2 v = screenPos + rotate2d(a_rotation) * ((vert * gp.xy + gp.zw) * a_size * scd + a_offset.xy);
                
                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
        fragmentShader: `#extension GL_OES_standard_derivatives : enable

            precision highp float;
            precision highp int;

            const int MAX_SIZE = 11;

            // x - ATLAS_WIDTH = 512.0;
            // y - ATLAS_HEIGHT = 512.0;
            // z - ATLAS_GLYPH_SIZE = 32.0;
            // w - ATLAS_FIELD_RANGE = 8.0;

            uniform sampler2D fontTextureArr[MAX_SIZE];
            uniform vec4 sdfParamsArr[MAX_SIZE];
            uniform int isOutlinePass;
            
            varying float v_outline;
            varying vec2 v_uv;
            varying vec4 v_rgba;           
            varying float v_fontIndex;
            
            float fontIndex;

            float median(float r, float g, float b) {
                return max(min(r, g), min(max(r, g), b));
            }

            float getDistance() {
                vec3 msdf;
                if(fontIndex >= 0.0 && fontIndex < 1.0) {
                    msdf = texture2D(fontTextureArr[0], v_uv).rgb;
                } else if(fontIndex >= 1.0 && fontIndex < 2.0){
                    msdf = texture2D(fontTextureArr[1], v_uv).rgb;
                } else if(fontIndex >= 2.0 && fontIndex < 3.0){
                    msdf = texture2D(fontTextureArr[2], v_uv).rgb;
                } else if(fontIndex >= 3.0 && fontIndex < 4.0){
                    msdf = texture2D(fontTextureArr[3], v_uv).rgb;
                } else if(fontIndex >= 4.0 && fontIndex < 5.0){
                    msdf = texture2D(fontTextureArr[4], v_uv).rgb;
                } else if(fontIndex >= 5.0 && fontIndex < 6.0){
                    msdf = texture2D(fontTextureArr[5], v_uv).rgb;
                } else if(fontIndex >= 6.0 && fontIndex < 7.0){
                    msdf = texture2D(fontTextureArr[6], v_uv).rgb;
                } else if(fontIndex >= 7.0 && fontIndex < 8.0){
                    msdf = texture2D(fontTextureArr[7], v_uv).rgb;
                } else if(fontIndex >= 8.0 && fontIndex < 9.0){
                    msdf = texture2D(fontTextureArr[8], v_uv).rgb;
                } else if(fontIndex >= 9.0 && fontIndex < 10.0){
                    msdf = texture2D(fontTextureArr[9], v_uv).rgb;
                } else if(fontIndex >= 10.0 && fontIndex < 11.0){
                    msdf = texture2D(fontTextureArr[10], v_uv).rgb;
                }
                return median(msdf.r, msdf.g, msdf.b);
            }


            vec4 getSDFParams() {
                if(fontIndex >= 0.0 && fontIndex < 1.0) {
                    return sdfParamsArr[0];
                } else if(fontIndex >= 1.0 && fontIndex < 2.0){
                    return sdfParamsArr[1];
                } else if(fontIndex >= 2.0 && fontIndex < 3.0){
                    return sdfParamsArr[2];
                } else if(fontIndex >= 3.0 && fontIndex < 4.0){
                    return sdfParamsArr[3];
                } else if(fontIndex >= 4.0 && fontIndex < 5.0){
                    return sdfParamsArr[4];
                } else if(fontIndex >= 5.0 && fontIndex < 6.0){
                    return sdfParamsArr[5];
                } else if(fontIndex >= 6.0 && fontIndex < 7.0){
                    return sdfParamsArr[6];
                } else if(fontIndex >= 7.0 && fontIndex < 8.0){
                    return sdfParamsArr[7];
                } else if(fontIndex >= 8.0 && fontIndex < 9.0){
                    return sdfParamsArr[8];
                } else if(fontIndex >= 9.0 && fontIndex < 10.0){
                    return sdfParamsArr[9];
                } else if(fontIndex >= 10.0 && fontIndex < 11.0){
                    return sdfParamsArr[10];
                }
            }
                    
            void main () {

                fontIndex = v_fontIndex + 0.1;
                
                if(v_fontIndex < 0.0){
                    return;
                }
                
                vec4 sdfParams = getSDFParams();
                float sd = getDistance();             
                vec2 dxdy = fwidth(v_uv) * sdfParams.xy;
                float dist = sd + min(0.001, 0.5 - 1.0 / sdfParams.w) - 0.5;
                float opacity = clamp(dist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);

                if(isOutlinePass == 0){                             
                    //gl_FragColor = vec4(v_rgba.rgb, opacity * v_rgba.a);
                } else {                
                    float strokeDist = sd + min(v_outline, 0.5 - 1.0 / sdfParams.w) - 0.5;
                    float strokeAlpha = v_rgba.a * clamp(strokeDist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);                    
                    if(strokeAlpha < 0.1){
                        discard;
                    }
                    //gl_FragColor = v_rgba * strokeAlpha * (0.5 - opacity) * 2.0;
                }
            }`
    });
}
function labelPicking() {
    return new Program("labelPicking", {
        uniforms: {
            viewport: "vec2",
            projectionMatrix: "mat4",
            viewMatrix: "mat4",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            planetRadius: "float",
            scaleByDistance: "vec3",
            opacity: "float",
            depthOffset: "float"
        },
        attributes: {
            a_gliphParam: "vec4",
            a_vertices: "vec2",
            a_texCoord: "vec4",
            a_positionsHigh: "vec3",
            a_positionsLow: "vec3",
            a_offset: "vec3",
            a_size: "float",
            a_rotation: "float",
            a_rgba: "vec4"
        },
        vertexShader: `
            
            ${DEFINE}
            
            attribute vec4 a_gliphParam;
            attribute vec2 a_vertices;
            attribute vec4 a_texCoord;
            attribute vec3 a_positionsHigh;
            attribute vec3 a_positionsLow;
            attribute vec3 a_offset;
            attribute float a_size;
            attribute float a_rotation;
            attribute vec4 a_rgba;

            varying vec4 v_rgba;

            uniform vec2 viewport;
            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float planetRadius;
            uniform vec3 scaleByDistance;
            uniform float opacity;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);

            ${PROJECT}

            ${ROTATE2D}

            void main() {
                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;
                v_rgba = a_rgba;
                
                if(a_texCoord.w == EMPTY) {
                    v_rgba.a = 0.0;
                    gl_Position = vec4(0.0);
                    return;
                }

                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                float scd = (1.0 - smoothstep(scaleByDistance[0], scaleByDistance[1], lookDist)) * (1.0 - step(scaleByDistance[2], lookDist));

                v_rgba.a *= opacity;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;                  
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                        
                projPos.z += depthOffset + a_offset.z;
                
                vec2 screenPos = project(projPos);
                
                vec2 vert = a_vertices;                
                vec4 gp = a_gliphParam;                                
                if(a_texCoord.w == RTL){
                    vert.x = step(vert.x * 0.5 + 1.0, 1.0);
                    gp.x = -a_gliphParam.x;
                    gp.z = -(a_gliphParam.z + a_texCoord.z);
                }else{
                    gp.z = a_gliphParam.z + a_texCoord.z;
                }
                                
                vec2 v = screenPos + rotate2d(a_rotation) * ((vert * gp.xy + gp.zw) * a_size * scd + a_offset.xy);
                                
                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
        fragmentShader: `precision highp float;

            varying vec4 v_rgba;

            varying vec3 v_pickingColor;

            void main () {

                vec4 color = v_rgba;
                if (color.a < 0.05) {
                    return;
                }

                gl_FragColor = vec4(v_rgba.rgb, v_rgba.a);
            }`
    });
}

const PICKINGCOLOR_BUFFER$1 = 0;
const POSITION_BUFFER = 1;
const SIZE_BUFFER = 2;
const OFFSET_BUFFER = 3;
const RGBA_BUFFER$1 = 4;
const ROTATION_BUFFER = 5;
const TEXCOORD_BUFFER = 6;
const VERTEX_BUFFER$1 = 7;
const FONTINDEX_BUFFER = 8;
const OUTLINE_BUFFER = 9;
const OUTLINECOLOR_BUFFER = 10;
const EMPTY = -1.0;
const RTL = 1.0;
class LabelHandler extends BaseBillboardHandler {
    constructor(entityCollection, maxLetters = 21) {
        super(entityCollection);
        this._billboards = [];
        this._gliphParamBuffer = null;
        this._fontIndexBuffer = null;
        this._outlineBuffer = null;
        this._outlineColorBuffer = null;
        this._gliphParamArr = new Float32Array([]);
        this._fontIndexArr = new Float32Array([]);
        this._outlineArr = new Float32Array([]);
        this._outlineColorArr = new Float32Array([]);
        this._buffersUpdateCallbacks[FONTINDEX_BUFFER] = this.createFontIndexBuffer;
        this._buffersUpdateCallbacks[OUTLINE_BUFFER] = this.createOutlineBuffer;
        this._buffersUpdateCallbacks[OUTLINECOLOR_BUFFER] = this.createOutlineColorBuffer;
        this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
        this._maxLetters = maxLetters;
    }
    initProgram() {
        if (this._renderer && this._renderer.handler && this._renderer.handler.gl) {
            if (!this._renderer.handler.programs.label) {
                if (this._renderer.handler.gl.type === "webgl2") {
                    this._renderer.handler.addProgram(label_webgl2());
                }
                else {
                    this._renderer.handler.addProgram(label_screen());
                }
            }
            if (!this._renderer.handler.programs.labelPicking) {
                this._renderer.handler.addProgram(labelPicking());
            }
        }
    }
    get labels() {
        return this._billboards;
    }
    add(label) {
        if (!label._handler) {
            label._handler = this;
            this.assignFontAtlas(label);
            this.refresh();
        }
    }
    updateFonts() {
        let l = [...this._billboards];
        this._billboards = [];
        for (let i = 0; i < l.length; i++) {
            this.assignFontAtlas(l[i]);
        }
    }
    _addLabelToArrays(label) {
        this._renderer && this._renderer.labelWorker.make({ handler: this, label: label });
    }
    assignFontAtlas(label) {
        if (this._entityCollection && this._renderer) {
            label.assignFontAtlas(this._renderer.fontAtlas);
            this._addLabelToArrays(label);
        }
        else {
            this._billboards.push(label);
        }
    }
    workerCallback(data, label) {
        if (label._lockId !== LOCK_FREE && label._handler && this.isEqual(label._handler)) {
            label._isReady = true;
            label._lockId = LOCK_FREE;
            label._handlerIndex = this._billboards.length;
            this._billboards.push(label);
            this._vertexArr = concatTypedArrays(this._vertexArr, data.vertexArr);
            this._texCoordArr = concatTypedArrays(this._texCoordArr, data.texCoordArr);
            this._gliphParamArr = concatTypedArrays(this._gliphParamArr, data.gliphParamArr);
            this._positionHighArr = concatTypedArrays(this._positionHighArr, data.positionHighArr);
            this._positionLowArr = concatTypedArrays(this._positionLowArr, data.positionLowArr);
            this._sizeArr = concatTypedArrays(this._sizeArr, data.sizeArr);
            this._offsetArr = concatTypedArrays(this._offsetArr, data.offsetArr);
            this._rgbaArr = concatTypedArrays(this._rgbaArr, data.rgbaArr);
            this._rotationArr = concatTypedArrays(this._rotationArr, data.rotationArr);
            this._fontIndexArr = concatTypedArrays(this._fontIndexArr, data.fontIndexArr);
            this._outlineArr = concatTypedArrays(this._outlineArr, data.outlineArr);
            this._outlineColorArr = concatTypedArrays(this._outlineColorArr, data.outlineColorArr);
            this._pickingColorArr = concatTypedArrays(this._pickingColorArr, data.pickingColorArr);
            label.update();
            this.refresh();
        }
    }
    clear() {
        // @ts-ignore
        this._texCoordArr = null;
        // @ts-ignore
        this._gliphParamArr = null;
        // @ts-ignore
        this._vertexArr = null;
        // @ts-ignore
        this._positionHighArr = null;
        // @ts-ignore
        this._positionLowArr = null;
        // @ts-ignore
        this._sizeArr = null;
        // @ts-ignore
        this._offsetArr = null;
        // @ts-ignore
        this._rgbaArr = null;
        // @ts-ignore
        this._rotationArr = null;
        // @ts-ignore
        this._fontIndexArr = null;
        // @ts-ignore
        this._outlineArr = null;
        // @ts-ignore
        this._outlineColorArr = null;
        this._texCoordArr = new Float32Array([]);
        this._gliphParamArr = new Float32Array([]);
        this._vertexArr = new Float32Array([]);
        this._positionHighArr = new Float32Array([]);
        this._positionLowArr = new Float32Array([]);
        this._sizeArr = new Float32Array([]);
        this._offsetArr = new Float32Array([]);
        this._rgbaArr = new Float32Array([]);
        this._rotationArr = new Float32Array([]);
        this._fontIndexArr = new Float32Array([]);
        this._outlineArr = new Float32Array([]);
        this._outlineColorArr = new Float32Array([]);
        this._removeBillboards();
        this._deleteBuffers();
        this.refresh();
    }
    _deleteBuffers() {
        if (this._renderer) {
            let gl = this._renderer.handler.gl;
            gl.deleteBuffer(this._gliphParamBuffer);
            gl.deleteBuffer(this._sizeBuffer);
            gl.deleteBuffer(this._fontIndexBuffer);
            gl.deleteBuffer(this._texCoordBuffer);
            gl.deleteBuffer(this._outlineBuffer);
            gl.deleteBuffer(this._outlineColorBuffer);
            gl.deleteBuffer(this._positionHighBuffer);
            gl.deleteBuffer(this._positionLowBuffer);
            gl.deleteBuffer(this._sizeBuffer);
            gl.deleteBuffer(this._offsetBuffer);
            gl.deleteBuffer(this._rgbaBuffer);
            gl.deleteBuffer(this._rotationBuffer);
            gl.deleteBuffer(this._vertexBuffer);
            gl.deleteBuffer(this._texCoordBuffer);
            gl.deleteBuffer(this._pickingColorBuffer);
            this._gliphParamBuffer = null;
            this._sizeBuffer = null;
            this._fontIndexBuffer = null;
            this._texCoordBuffer = null;
            this._outlineBuffer = null;
            this._outlineColorBuffer = null;
            this._positionHighBuffer = null;
            this._positionLowBuffer = null;
            this._sizeBuffer = null;
            this._offsetBuffer = null;
            this._rgbaBuffer = null;
            this._rotationBuffer = null;
            this._vertexBuffer = null;
            this._texCoordBuffer = null;
            this._pickingColorBuffer = null;
        }
    }
    _displayPASS() {
        let r = this._renderer;
        let h = r.handler;
        h.programs.label.activate();
        let sh = h.programs.label._program;
        let sha = sh.attributes, shu = sh.uniforms;
        let gl = h.gl, ec = this._entityCollection;
        gl.disable(gl.CULL_FACE);
        gl.uniform1iv(shu.fontTextureArr, r.fontAtlas.samplerArr);
        gl.uniform4fv(shu.sdfParamsArr, r.fontAtlas.sdfParamsArr);
        gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera.getViewMatrix());
        gl.uniformMatrix4fv(shu.projectionMatrix, false, r.activeCamera.getProjectionMatrix());
        gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
        gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);
        gl.uniform3fv(shu.scaleByDistance, ec.scaleByDistance);
        gl.uniform1f(shu.opacity, ec._fadingOpacity);
        gl.uniform1f(shu.planetRadius, ec.renderNode._planetRadius2 || 0);
        gl.uniform2fv(shu.viewport, [h.canvas.clientWidth, h.canvas.clientHeight]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordBuffer);
        gl.vertexAttribPointer(sha.a_texCoord, this._texCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._gliphParamBuffer);
        gl.vertexAttribPointer(sha.a_gliphParam, this._gliphParamBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._positionHighBuffer);
        gl.vertexAttribPointer(sha.a_positionsHigh, this._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._positionLowBuffer);
        gl.vertexAttribPointer(sha.a_positionsLow, this._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
        gl.vertexAttribPointer(sha.a_size, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
        gl.vertexAttribPointer(sha.a_rotation, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
        gl.vertexAttribPointer(sha.a_offset, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._fontIndexBuffer);
        gl.vertexAttribPointer(sha.a_fontIndex, this._fontIndexBuffer.itemSize, gl.FLOAT, false, 0, 0);
        //
        // outline PASS
        gl.uniform1i(shu.isOutlinePass, 1);
        gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._outlineColorBuffer);
        gl.vertexAttribPointer(sha.a_rgba, this._outlineColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._outlineBuffer);
        gl.vertexAttribPointer(sha.a_outline, this._outlineBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
        //
        // no outline PASS
        gl.depthFunc(gl.EQUAL);
        gl.uniform1i(shu.isOutlinePass, 0);
        gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._rgbaBuffer);
        gl.vertexAttribPointer(sha.a_rgba, this._rgbaBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
        gl.depthFunc(gl.LESS);
        gl.enable(gl.CULL_FACE);
    }
    _pickingPASS() {
        let r = this._renderer;
        let h = r.handler;
        h.programs.labelPicking.activate();
        let sh = h.programs.labelPicking._program;
        let sha = sh.attributes, shu = sh.uniforms;
        let gl = h.gl, ec = this._entityCollection;
        let rn = ec.renderNode;
        gl.disable(gl.CULL_FACE);
        gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera.getViewMatrix());
        gl.uniformMatrix4fv(shu.projectionMatrix, false, r.activeCamera.getProjectionMatrix());
        gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
        gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);
        gl.uniform3fv(shu.scaleByDistance, ec.scaleByDistance);
        gl.uniform1f(shu.opacity, ec._fadingOpacity);
        gl.uniform1f(shu.planetRadius, rn._planetRadius2 || 0);
        gl.uniform2fv(shu.viewport, [h.canvas.clientWidth, h.canvas.clientHeight]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordBuffer);
        gl.vertexAttribPointer(sha.a_texCoord, this._texCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._gliphParamBuffer);
        gl.vertexAttribPointer(sha.a_gliphParam, this._gliphParamBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._positionHighBuffer);
        gl.vertexAttribPointer(sha.a_positionsHigh, this._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._positionLowBuffer);
        gl.vertexAttribPointer(sha.a_positionsLow, this._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
        gl.vertexAttribPointer(sha.a_size, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
        gl.vertexAttribPointer(sha.a_rotation, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
        gl.vertexAttribPointer(sha.a_offset, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._pickingColorBuffer);
        gl.vertexAttribPointer(sha.a_rgba, this._pickingColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits);
        gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
        gl.enable(gl.CULL_FACE);
    }
    _removeBillboard(label) {
        let li = label._handlerIndex;
        this._billboards.splice(li, 1);
        let ml = 24 * this._maxLetters;
        let i = li * ml;
        this._rgbaArr = spliceTypedArray(this._rgbaArr, i, ml);
        this._outlineColorArr = spliceTypedArray(this._outlineColorArr, i, ml);
        this._texCoordArr = spliceTypedArray(this._texCoordArr, i, ml);
        this._gliphParamArr = spliceTypedArray(this._gliphParamArr, i, ml);
        ml = 18 * this._maxLetters;
        i = li * ml;
        this._positionHighArr = spliceTypedArray(this._positionHighArr, i, ml);
        this._positionLowArr = spliceTypedArray(this._positionLowArr, i, ml);
        this._offsetArr = spliceTypedArray(this._offsetArr, i, ml);
        this._pickingColorArr = spliceTypedArray(this._pickingColorArr, i, ml);
        ml = 12 * this._maxLetters;
        i = li * ml;
        this._vertexArr = spliceTypedArray(this._vertexArr, i, ml);
        ml = 6 * this._maxLetters;
        i = li * ml;
        this._sizeArr = spliceTypedArray(this._sizeArr, i, ml);
        this._rotationArr = spliceTypedArray(this._rotationArr, i, ml);
        this._fontIndexArr = spliceTypedArray(this._fontIndexArr, i, ml);
        this._outlineArr = spliceTypedArray(this._outlineArr, i, ml);
        this.reindexBillboardsArray(li);
        this.refresh();
        label._handlerIndex = -1;
        label._handler = null;
        label._isReady = false;
    }
    setText(index, text, fontIndex, align, letterSpacing = 0, isRTL = false) {
        text = text.normalize('NFKC');
        let fa = this._renderer.fontAtlas.atlasesArr[fontIndex];
        if (!fa)
            return;
        let i = index * 24 * this._maxLetters;
        let a = this._texCoordArr, g = this._gliphParamArr;
        let c = 0;
        let len = Math.min(this._maxLetters, text.length);
        let _rtl_ = 0.0;
        if (isRTL) {
            _rtl_ = RTL;
        }
        let offset = 0.0;
        let kern = fa.kernings;
        for (c = 0; c < len; c++) {
            let j = i + c * 24;
            let char = text[c];
            let n = fa.get(char.charCodeAt(0)) || fa.get(" ".charCodeAt(0));
            if (!n)
                continue;
            let tc = n.texCoords;
            let m = n.metrics;
            a[j] = tc[0];
            a[j + 1] = tc[1];
            a[j + 2] = offset;
            a[j + 3] = _rtl_;
            a[j + 4] = tc[2];
            a[j + 5] = tc[3];
            a[j + 6] = offset;
            a[j + 7] = _rtl_;
            a[j + 8] = tc[4];
            a[j + 9] = tc[5];
            a[j + 10] = offset;
            a[j + 11] = _rtl_;
            a[j + 12] = tc[6];
            a[j + 13] = tc[7];
            a[j + 14] = offset;
            a[j + 15] = _rtl_;
            a[j + 16] = tc[8];
            a[j + 17] = tc[9];
            a[j + 18] = offset;
            a[j + 19] = _rtl_;
            a[j + 20] = tc[10];
            a[j + 21] = tc[11];
            a[j + 22] = offset;
            a[j + 23] = _rtl_;
            //
            // Gliph
            //
            g[j] = m.nWidth;
            g[j + 1] = m.nHeight;
            g[j + 2] = m.nXOffset;
            g[j + 3] = m.nYOffset;
            g[j + 4] = m.nWidth;
            g[j + 5] = m.nHeight;
            g[j + 6] = m.nXOffset;
            g[j + 7] = m.nYOffset;
            g[j + 8] = m.nWidth;
            g[j + 9] = m.nHeight;
            g[j + 10] = m.nXOffset;
            g[j + 11] = m.nYOffset;
            g[j + 12] = m.nWidth;
            g[j + 13] = m.nHeight;
            g[j + 14] = m.nXOffset;
            g[j + 15] = m.nYOffset;
            g[j + 16] = m.nWidth;
            g[j + 17] = m.nHeight;
            g[j + 18] = m.nXOffset;
            g[j + 19] = m.nYOffset;
            g[j + 20] = m.nWidth;
            g[j + 21] = m.nHeight;
            g[j + 22] = m.nXOffset;
            g[j + 23] = m.nYOffset;
            let k = kern[char.charCodeAt(0)];
            if (k && text[c + 1]) {
                let kk = k[text[c + 1].charCodeAt(0)];
                if (kk) {
                    offset += m.nAdvance + kk + letterSpacing;
                }
                else {
                    offset += m.nAdvance + letterSpacing;
                }
            }
            else {
                offset += m.nAdvance + letterSpacing;
            }
        }
        // 49/512 - font atlas left border letter offset
        if (align === ALIGN.CENTER) {
            offset *= -0.5;
            for (c = 0; c < len; c++) {
                let j = i + c * 24;
                a[j + 2] += offset;
                a[j + 6] += offset;
                a[j + 10] += offset;
                a[j + 14] += offset;
                a[j + 18] += offset;
                a[j + 22] += offset;
            }
        }
        for (; c < this._maxLetters; c++) {
            let j = i + c * 24;
            a[j + 3] = EMPTY;
            a[j + 7] = EMPTY;
            a[j + 11] = EMPTY;
            a[j + 15] = EMPTY;
            a[j + 19] = EMPTY;
            a[j + 23] = EMPTY;
        }
        this._changedBuffers[TEXCOORD_BUFFER] = true;
    }
    setPositionArr(index, positionHigh, positionLow) {
        let i = index * 18 * this._maxLetters;
        let a = this._positionHighArr, x = positionHigh.x, y = positionHigh.y, z = positionHigh.z, b = this._positionLowArr, xl = positionLow.x, yl = positionLow.y, zl = positionLow.z;
        for (let q = 0; q < this._maxLetters; q++) {
            let j = i + q * 18;
            a[j] = x;
            a[j + 1] = y;
            a[j + 2] = z;
            a[j + 3] = x;
            a[j + 4] = y;
            a[j + 5] = z;
            a[j + 6] = x;
            a[j + 7] = y;
            a[j + 8] = z;
            a[j + 9] = x;
            a[j + 10] = y;
            a[j + 11] = z;
            a[j + 12] = x;
            a[j + 13] = y;
            a[j + 14] = z;
            a[j + 15] = x;
            a[j + 16] = y;
            a[j + 17] = z;
            // low
            b[j] = xl;
            b[j + 1] = yl;
            b[j + 2] = zl;
            b[j + 3] = xl;
            b[j + 4] = yl;
            b[j + 5] = zl;
            b[j + 6] = xl;
            b[j + 7] = yl;
            b[j + 8] = zl;
            b[j + 9] = xl;
            b[j + 10] = yl;
            b[j + 11] = zl;
            b[j + 12] = xl;
            b[j + 13] = yl;
            b[j + 14] = zl;
            b[j + 15] = xl;
            b[j + 16] = yl;
            b[j + 17] = zl;
        }
        this._changedBuffers[POSITION_BUFFER] = true;
    }
    setPickingColorArr(index, color) {
        let i = index * 18 * this._maxLetters;
        let a = this._pickingColorArr, x = color.x / 255, y = color.y / 255, z = color.z / 255;
        for (let q = 0; q < this._maxLetters; q++) {
            let j = i + q * 18;
            a[j] = x;
            a[j + 1] = y;
            a[j + 2] = z;
            a[j + 3] = x;
            a[j + 4] = y;
            a[j + 5] = z;
            a[j + 6] = x;
            a[j + 7] = y;
            a[j + 8] = z;
            a[j + 9] = x;
            a[j + 10] = y;
            a[j + 11] = z;
            a[j + 12] = x;
            a[j + 13] = y;
            a[j + 14] = z;
            a[j + 15] = x;
            a[j + 16] = y;
            a[j + 17] = z;
        }
        this._changedBuffers[PICKINGCOLOR_BUFFER$1] = true;
    }
    setSizeArr(index, size) {
        let i = index * 6 * this._maxLetters;
        let a = this._sizeArr;
        for (let q = 0; q < this._maxLetters; q++) {
            let j = i + q * 6;
            a[j] = size;
            a[j + 1] = size;
            a[j + 2] = size;
            a[j + 3] = size;
            a[j + 4] = size;
            a[j + 5] = size;
        }
        this._changedBuffers[SIZE_BUFFER] = true;
    }
    setOffsetArr(index, offset) {
        let i = index * 18 * this._maxLetters;
        let a = this._offsetArr, x = offset.x, y = offset.y, z = offset.z;
        for (let q = 0; q < this._maxLetters; q++) {
            let j = i + q * 18;
            a[j] = x;
            a[j + 1] = y;
            a[j + 2] = z;
            a[j + 3] = x;
            a[j + 4] = y;
            a[j + 5] = z;
            a[j + 6] = x;
            a[j + 7] = y;
            a[j + 8] = z;
            a[j + 9] = x;
            a[j + 10] = y;
            a[j + 11] = z;
            a[j + 12] = x;
            a[j + 13] = y;
            a[j + 14] = z;
            a[j + 15] = x;
            a[j + 16] = y;
            a[j + 17] = z;
        }
        this._changedBuffers[OFFSET_BUFFER] = true;
    }
    setRgbaArr(index, rgba) {
        let i = index * 24 * this._maxLetters;
        let a = this._rgbaArr, x = rgba.x, y = rgba.y, z = rgba.z, w = rgba.w;
        for (let q = 0; q < this._maxLetters; q++) {
            let j = i + q * 24;
            a[j] = x;
            a[j + 1] = y;
            a[j + 2] = z;
            a[j + 3] = w;
            a[j + 4] = x;
            a[j + 5] = y;
            a[j + 6] = z;
            a[j + 7] = w;
            a[j + 8] = x;
            a[j + 9] = y;
            a[j + 10] = z;
            a[j + 11] = w;
            a[j + 12] = x;
            a[j + 13] = y;
            a[j + 14] = z;
            a[j + 15] = w;
            a[j + 16] = x;
            a[j + 17] = y;
            a[j + 18] = z;
            a[j + 19] = w;
            a[j + 20] = x;
            a[j + 21] = y;
            a[j + 22] = z;
            a[j + 23] = w;
        }
        this._changedBuffers[RGBA_BUFFER$1] = true;
    }
    setOutlineColorArr(index, rgba) {
        let i = index * 24 * this._maxLetters;
        let a = this._outlineColorArr, x = rgba.x, y = rgba.y, z = rgba.z, w = rgba.w;
        for (let q = 0; q < this._maxLetters; q++) {
            let j = i + q * 24;
            a[j] = x;
            a[j + 1] = y;
            a[j + 2] = z;
            a[j + 3] = w;
            a[j + 4] = x;
            a[j + 5] = y;
            a[j + 6] = z;
            a[j + 7] = w;
            a[j + 8] = x;
            a[j + 9] = y;
            a[j + 10] = z;
            a[j + 11] = w;
            a[j + 12] = x;
            a[j + 13] = y;
            a[j + 14] = z;
            a[j + 15] = w;
            a[j + 16] = x;
            a[j + 17] = y;
            a[j + 18] = z;
            a[j + 19] = w;
            a[j + 20] = x;
            a[j + 21] = y;
            a[j + 22] = z;
            a[j + 23] = w;
        }
        this._changedBuffers[OUTLINECOLOR_BUFFER] = true;
    }
    setOutlineArr(index, outline) {
        let i = index * 6 * this._maxLetters;
        let a = this._outlineArr;
        for (let q = 0; q < this._maxLetters; q++) {
            let j = i + q * 6;
            a[j] = outline;
            a[j + 1] = outline;
            a[j + 2] = outline;
            a[j + 3] = outline;
            a[j + 4] = outline;
            a[j + 5] = outline;
        }
        this._changedBuffers[OUTLINE_BUFFER] = true;
    }
    setRotationArr(index, rotation) {
        let i = index * 6 * this._maxLetters;
        let a = this._rotationArr;
        for (let q = 0; q < this._maxLetters; q++) {
            let j = i + q * 6;
            a[j] = rotation;
            a[j + 1] = rotation;
            a[j + 2] = rotation;
            a[j + 3] = rotation;
            a[j + 4] = rotation;
            a[j + 5] = rotation;
        }
        this._changedBuffers[ROTATION_BUFFER] = true;
    }
    setVisibility(index, visibility) {
        let vArr;
        if (visibility) {
            vArr = [0, 0, 0, -1, 1, -1, 1, -1, 1, 0, 0, 0];
        }
        else {
            vArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        this.setVertexArr(index, vArr);
    }
    setVertexArr(index, vertexArr) {
        let i = index * 12 * this._maxLetters;
        let a = this._vertexArr;
        for (let q = 0; q < this._maxLetters; q++) {
            let j = i + q * 12;
            a[j] = vertexArr[0];
            a[j + 1] = vertexArr[1];
            a[j + 2] = vertexArr[2];
            a[j + 3] = vertexArr[3];
            a[j + 4] = vertexArr[4];
            a[j + 5] = vertexArr[5];
            a[j + 6] = vertexArr[6];
            a[j + 7] = vertexArr[7];
            a[j + 8] = vertexArr[8];
            a[j + 9] = vertexArr[9];
            a[j + 10] = vertexArr[10];
            a[j + 11] = vertexArr[11];
        }
        this._changedBuffers[VERTEX_BUFFER$1] = true;
    }
    setFontIndexArr(index, fontIndex) {
        let i = index * 6 * this._maxLetters;
        let a = this._fontIndexArr;
        for (let q = 0; q < this._maxLetters; q++) {
            let j = i + q * 6;
            a[j] = fontIndex;
            a[j + 1] = fontIndex;
            a[j + 2] = fontIndex;
            a[j + 3] = fontIndex;
            a[j + 4] = fontIndex;
            a[j + 5] = fontIndex;
        }
        this._changedBuffers[FONTINDEX_BUFFER] = true;
    }
    createSizeBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._sizeBuffer);
        this._sizeBuffer = h.createArrayBuffer(this._sizeArr, 1, this._sizeArr.length);
    }
    createFontIndexBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._fontIndexBuffer);
        this._fontIndexBuffer = h.createArrayBuffer(this._fontIndexArr, 1, this._fontIndexArr.length);
    }
    createTexCoordBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._texCoordBuffer);
        this._texCoordBuffer = h.createArrayBuffer(this._texCoordArr, 4, this._texCoordArr.length / 4);
        h.gl.deleteBuffer(this._gliphParamBuffer);
        this._gliphParamBuffer = h.createArrayBuffer(this._gliphParamArr, 4, this._gliphParamArr.length / 4);
    }
    createOutlineBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._outlineBuffer);
        this._outlineBuffer = h.createArrayBuffer(this._outlineArr, 1, this._outlineArr.length);
    }
    createOutlineColorBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._outlineColorBuffer);
        this._outlineColorBuffer = h.createArrayBuffer(this._outlineColorArr, 4, this._outlineColorArr.length / 4);
    }
    setMaxLetters(c) {
        this._maxLetters = c;
        // TODO: ...
    }
}

//Picking is the same
function pointCloud() {
    return new Program("pointCloud", {
        uniforms: {
            projectionViewMatrix: "mat4",
            opacity: "float",
            pointSize: "float"
        },
        attributes: {
            coordinates: "vec3",
            colors: "vec3"
        },
        vertexShader: `attribute vec3 coordinates;
            attribute vec4 colors;
            uniform mat4 projectionViewMatrix;
            uniform float opacity;
            uniform float pointSize;
            varying vec4 color;
            void main() {
                color = colors;
                color.a *= opacity;
                gl_Position = projectionViewMatrix * vec4(coordinates, 1.0);
                gl_PointSize = pointSize;
            }`,
        fragmentShader: `precision highp float;
            varying vec4 color;
            void main(void) {
                gl_FragColor = color;
            }`
    });
}

class PointCloudHandler {
    constructor(entityCollection) {
        /**
         * Picking rendering option.
         * @public
         * @type {boolean}
         */
        this.pickingEnabled = true;
        this.__id = PointCloudHandler.__counter__++;
        this.pickingEnabled = true;
        this._entityCollection = entityCollection;
        this._renderer = null;
        this._pointClouds = [];
    }
    _initProgram() {
        if (this._renderer && this._renderer.handler) {
            if (!this._renderer.handler.programs.pointCloud) {
                this._renderer.handler.addProgram(pointCloud());
            }
        }
    }
    setRenderNode(renderNode) {
        this._renderer = renderNode.renderer;
        this._initProgram();
        for (let i = 0; i < this._pointClouds.length; i++) {
            this._pointClouds[i].setRenderNode(renderNode);
        }
    }
    add(pointCloud) {
        if (pointCloud._handlerIndex === -1) {
            pointCloud._handler = this;
            pointCloud._handlerIndex = this._pointClouds.length;
            this._pointClouds.push(pointCloud);
            this._entityCollection &&
                this._entityCollection.renderNode &&
                pointCloud.setRenderNode(this._entityCollection.renderNode);
        }
    }
    remove(pointCloud) {
        let index = pointCloud._handlerIndex;
        if (index !== -1) {
            pointCloud._deleteBuffers();
            pointCloud._handlerIndex = -1;
            pointCloud._handler = null;
            this._pointClouds.splice(index, 1);
            this._reindexPointCloudArray(index);
        }
    }
    _reindexPointCloudArray(startIndex) {
        let pc = this._pointClouds;
        for (let i = startIndex; i < pc.length; i++) {
            pc[i]._handlerIndex = i;
        }
    }
    draw() {
        let i = this._pointClouds.length;
        while (i--) {
            this._pointClouds[i].draw();
        }
    }
    drawPicking() {
        if (this.pickingEnabled) {
            let i = this._pointClouds.length;
            while (i--) {
                this._pointClouds[i].drawPicking();
            }
        }
    }
    clear() {
        let i = this._pointClouds.length;
        while (i--) {
            this._pointClouds[i]._deleteBuffers();
            this._pointClouds[i]._handler = null;
            this._pointClouds[i]._handlerIndex = -1;
        }
        this._pointClouds.length = 0;
        this._pointClouds = [];
    }
}
PointCloudHandler.__counter__ = 0;

function polyline_screen() {
    return new Program("polyline_screen", {
        uniforms: {
            viewport: "vec2",
            proj: "mat4",
            view: "mat4",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            //uFloatParams: "vec2",
            thickness: "float",
            opacity: "float",
            depthOffset: "float"
        },
        attributes: {
            prevHigh: "vec3",
            currentHigh: "vec3",
            nextHigh: "vec3",
            prevLow: "vec3",
            currentLow: "vec3",
            nextLow: "vec3",
            order: "float",
            color: "vec4"
        },
        vertexShader: `precision highp float;

                attribute vec3 prevHigh;
                attribute vec3 currentHigh;
                attribute vec3 nextHigh;

                attribute vec3 prevLow;
                attribute vec3 currentLow;
                attribute vec3 nextLow;

                attribute float order;

                attribute vec4 color;

                uniform float thickness;
                uniform mat4 proj;
                uniform mat4 view;
                uniform vec2 viewport;
                uniform vec3 eyePositionHigh;
                uniform vec3 eyePositionLow;
                uniform float opacity;
                uniform float depthOffset;

                varying vec4 vColor;
                varying vec3 vPos;
                varying vec3 uCamPos;

                const float NEAR = -1.0;

                vec2 getIntersection(vec2 start1, vec2 end1, vec2 start2, vec2 end2){
                    vec2 dir = end2 - start2;
                    vec2 perp = vec2(-dir.y, dir.x);
                    float d2 = dot(perp, start2);
                    float seg = dot(perp, start1) - d2;
                    float prl = seg - dot(perp, end1) + d2;
                    if(prl > -1.0 && prl < 1.0){
                        return start1;
                    }
                    float u = seg / prl;
                    return start1 + u * (end1 - start1);
                }

                vec2 project(vec4 p){
                    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;
                }

                void main(){

                    uCamPos = eyePositionHigh + eyePositionLow;

                    vColor = vec4(color.rgb, color.a * opacity);

                    vec3 current = currentHigh + currentLow;

                    vPos = current;

                    mat4 viewMatrixRTE = view;
                    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                    vec3 highDiff, lowDiff;

                    highDiff = currentHigh - eyePositionHigh;
                    lowDiff = currentLow - eyePositionLow;
                    vec4 vCurrent = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    highDiff = prevHigh - eyePositionHigh;
                    lowDiff = prevLow - eyePositionLow;
                    vec4 vPrev = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    highDiff = nextHigh - eyePositionHigh;
                    lowDiff = nextLow - eyePositionLow;
                    vec4 vNext = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    /*Clip near plane, the point behind view plane*/
                    if(vCurrent.z > NEAR) {
                        if(vPrev.z < NEAR && abs(order) == 1.0){
                            vCurrent = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);
                        } else if(vNext.z < NEAR && abs(order) == 2.0){
                            vCurrent = vNext + (vCurrent - vNext) * (NEAR - vNext.z) / (vCurrent.z - vNext.z);
                        }
                    }

                    vec4 dCurrent = proj * vCurrent;
                    vec2 _next = project(proj * vNext);
                    vec2 _prev = project(proj * vPrev);
                    vec2 _current = project(dCurrent);

                    if(_prev == _current){
                        if(_next == _current){
                            _next = _current + vec2(1.0, 0.0);
                            _prev = _current - _next;
                        }else{
                            _prev = _current + normalize(_current - _next);
                        }
                    }

                    if(_next == _current){
                        _next = _current + normalize(_current - _prev);
                    }

                    vec2 sNext = _next,
                         sCurrent = _current,
                         sPrev = _prev;

                    vec2 dirNext = normalize(sNext - sCurrent);
                    vec2 dirPrev = normalize(sPrev - sCurrent);
                    float dotNP = dot(dirNext, dirPrev);

                    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));
                    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));

                    float d = thickness * sign(order);

                    vec2 m;
                    if(dotNP >= 0.99991){
                        m = sCurrent - normalPrev * d;
                    }else{
                        m = getIntersection( sCurrent + normalPrev * d, sPrev + normalPrev * d,
                                sCurrent + normalNext * d, sNext + normalNext * d );

                        if( dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0 ){
                            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);
                            if(occw == -1.0){
                                m = sCurrent + normalPrev * d;
                            }else if(occw == 1.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == -2.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == 2.0){
                                m = sCurrent + normalPrev * d;
                            }
                        }else if(distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))){
                            m = sCurrent + normalNext * d;
                        }
                    }

                    gl_Position = vec4((2.0 * m / viewport - 1.0) * dCurrent.w, dCurrent.z + depthOffset, dCurrent.w);
                }`,
        fragmentShader: `precision highp float;
                //uniform vec2 uFloatParams;
                varying vec3 uCamPos;
                varying vec4 vColor;
                varying vec3 vPos;
                void main() {
                    vec3 look = vPos - uCamPos;
                    float lookLength = length(look);
                    //float a = vColor.a * step(lookLength, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(vPos,vPos) - uFloatParams[0]));
                    float a = vColor.a;
                    gl_FragColor = vec4(vColor.rgb, a);
                }`
    });
}
function polyline_picking() {
    return new Program("polyline_picking", {
        uniforms: {
            viewport: "vec2",
            proj: "mat4",
            view: "mat4",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            //uFloatParams: "vec2",
            color: "vec4",
            thickness: "float",
            depthOffset: "float"
        },
        attributes: {
            prevHigh: "vec3",
            currentHigh: "vec3",
            nextHigh: "vec3",
            prevLow: "vec3",
            currentLow: "vec3",
            nextLow: "vec3",
            order: "float"
        },
        vertexShader: `precision highp float;
                
                attribute vec3 prevHigh;
                attribute vec3 currentHigh;
                attribute vec3 nextHigh;
                
                attribute vec3 prevLow;
                attribute vec3 currentLow;
                attribute vec3 nextLow;

                attribute float order;

                uniform float thickness;
                uniform vec4 color;
                uniform mat4 proj;
                uniform mat4 view;
                uniform vec2 viewport;
                uniform vec3 eyePositionHigh;
                uniform vec3 eyePositionLow;
                uniform float depthOffset;

                varying vec4 vColor;
                varying vec3 vPos;
                varying vec3 uCamPos;
               
                
                const float NEAR = -1.0;
                
                vec2 getIntersection(vec2 start1, vec2 end1, vec2 start2, vec2 end2){
                    vec2 dir = end2 - start2;
                    vec2 perp = vec2(-dir.y, dir.x);
                    float d2 = dot(perp, start2);
                    float seg = dot(perp, start1) - d2;
                    float prl = seg - dot(perp, end1) + d2;
                    if(prl > -1.0 && prl < 1.0){
                        return start1;
                    }
                    float u = seg / prl;
                    return start1 + u * (end1 - start1);
                }
                
                vec2 project(vec4 p){
                    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;
                }
                
                void main(){

                    uCamPos = eyePositionHigh + eyePositionLow;

                    vColor = color;

                    vec3 current = currentHigh + currentLow;

                    vPos = current;                    

                    vec3 highDiff, lowDiff;

                    mat4 viewMatrixRTE = view;
                    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                    highDiff = currentHigh - eyePositionHigh;
                    lowDiff = currentLow - eyePositionLow;
                    vec4 vCurrent = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    highDiff = prevHigh - eyePositionHigh;
                    lowDiff = prevLow - eyePositionLow;    
                    vec4 vPrev = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    highDiff = nextHigh - eyePositionHigh;
                    lowDiff = nextLow - eyePositionLow;    
                    vec4 vNext = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    /*Clip near plane*/
                    if(vCurrent.z > NEAR) {
                        if(vPrev.z < NEAR && abs(order) == 1.0){
                            vCurrent = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);
                        } else if(vNext.z < NEAR && abs(order) == 2.0){
                            vCurrent = vNext + (vCurrent - vNext) * (NEAR - vNext.z) / (vCurrent.z - vNext.z);
                        }
                    }
                    
                    vec4 dCurrent = proj * vCurrent;
                    vec2 _next = project(proj * vNext);
                    vec2 _prev = project(proj * vPrev);
                    vec2 _current = project(dCurrent);
                    if(_prev == _current){
                        if(_next == _current){
                            _next = _current + vec2(1.0, 0.0);
                            _prev = _current - _next;
                        }else{
                            _prev = _current + normalize(_current - _next);
                        }
                    }
                    if(_next == _current){
                        _next = _current + normalize(_current - _prev);
                    }
                    
                    vec2 sNext = _next,
                         sCurrent = _current,
                         sPrev = _prev;

                    vec2 dirNext = normalize(sNext - sCurrent);
                    vec2 dirPrev = normalize(sPrev - sCurrent);
                    float dotNP = dot(dirNext, dirPrev);
                    
                    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));
                    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));
                    
                    float d = thickness * sign(order);
                    
                    vec2 m;
                    if(dotNP >= 0.99991){
                        m = sCurrent - normalPrev * d;
                    }else{
                        m = getIntersection( sCurrent + normalPrev * d, sPrev + normalPrev * d,
                                sCurrent + normalNext * d, sNext + normalNext * d );
                        
                        if( dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0 ){
                            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);
                            if(occw == -1.0){
                                m = sCurrent + normalPrev * d;
                            }else if(occw == 1.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == -2.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == 2.0){
                                m = sCurrent + normalPrev * d;
                            }
                        }
                        else if(distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))){
                            m = sCurrent + normalNext * d;
                        }
                    }
                    gl_Position = vec4((2.0 * m / viewport - 1.0) * dCurrent.w, dCurrent.z + depthOffset, dCurrent.w);
                }`,
        fragmentShader: `precision highp float;
                //uniform vec2 uFloatParams;
                varying vec3 uCamPos;
                varying vec4 vColor;
                varying vec3 vPos;
                void main() {
                    vec3 look = vPos - uCamPos;
                    float lookLength = length(look);
                    //float a = vColor.a * step(lookLength, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(vPos,vPos) - uFloatParams[0]));
                    float a = vColor.a;                    
                    gl_FragColor = vec4(vColor.rgb, a);
                }`
    });
}

class PolylineHandler {
    constructor(entityCollection) {
        this.__id = PolylineHandler.__counter__++;
        this._entityCollection = entityCollection;
        this._renderer = null;
        this._polylines = [];
        this.pickingEnabled = true;
    }
    _initProgram() {
        if (this._renderer && this._renderer.handler) {
            if (!this._renderer.handler.programs.polyline_screen) {
                this._renderer.handler.addProgram(polyline_screen());
            }
            if (!this._renderer.handler.programs.polyline_picking) {
                this._renderer.handler.addProgram(polyline_picking());
            }
        }
    }
    setRenderNode(renderNode) {
        this._renderer = renderNode.renderer;
        this._initProgram();
        for (let i = 0; i < this._polylines.length; i++) {
            this._polylines[i].setRenderNode(renderNode);
        }
    }
    add(polyline) {
        if (polyline._handlerIndex === -1) {
            polyline._handler = this;
            polyline._handlerIndex = this._polylines.length;
            this._polylines.push(polyline);
            this._entityCollection && this._entityCollection.renderNode &&
                polyline.setRenderNode(this._entityCollection.renderNode);
        }
    }
    remove(polyline) {
        let index = polyline._handlerIndex;
        if (index !== -1) {
            polyline._deleteBuffers();
            polyline._handlerIndex = -1;
            polyline._handler = null;
            this._polylines.splice(index, 1);
            this.reindexPolylineArray(index);
        }
    }
    reindexPolylineArray(startIndex) {
        let ls = this._polylines;
        for (let i = startIndex; i < ls.length; i++) {
            ls[i]._handlerIndex = i;
        }
    }
    draw() {
        let i = this._polylines.length;
        while (i--) {
            this._polylines[i].draw();
        }
    }
    drawPicking() {
        if (this.pickingEnabled) {
            let i = this._polylines.length;
            while (i--) {
                this._polylines[i].drawPicking();
            }
        }
    }
    clear() {
        let i = this._polylines.length;
        while (i--) {
            this._polylines[i]._deleteBuffers();
            this._polylines[i]._handler = null;
            this._polylines[i]._handlerIndex = -1;
        }
        this._polylines.length = 0;
        this._polylines = [];
    }
}
PolylineHandler.__counter__ = 0;

function rayScreen() {
    return new Program("rayScreen", {
        uniforms: {
            projectionMatrix: "mat4",
            viewMatrix: "mat4",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            resolution: "float",
            uOpacity: "float"
        },
        attributes: {
            a_vertices: "vec2",
            a_startPosHigh: "vec3",
            a_startPosLow: "vec3",
            a_endPosHigh: "vec3",
            a_endPosLow: "vec3",
            a_thickness: "float",
            a_rgba: "vec4"
        },
        vertexShader: `precision highp float;

            attribute vec4 a_rgba;
            attribute vec3 a_startPosHigh;
            attribute vec3 a_startPosLow;
            attribute vec3 a_endPosHigh;
            attribute vec3 a_endPosLow;
            attribute vec2 a_vertices;
            attribute float a_thickness;

            varying vec4 v_rgba;

            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float resolution;
            uniform float uOpacity;

            void main() {

                v_rgba = vec4(a_rgba.rgb, a_rgba.a * uOpacity);

                vec3 v = (a_endPosHigh - a_startPosHigh) + (a_endPosLow - a_startPosLow);

                vec3 look = (a_startPosHigh - eyePositionHigh) + (a_startPosLow - eyePositionLow) + v * a_vertices.y;
                vec3 up = normalize(normalize(v));
                vec3 right = normalize(cross(look,up));
 
                float dist = dot(look, vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]));
                float focalSize = 2.0 * dist * resolution;
                vec3 vert = right * a_thickness * focalSize * a_vertices.x;

                vec3 highDiff;
                if(a_vertices.y == 0.0){
                    highDiff = a_startPosHigh - eyePositionHigh;
                    vert += a_startPosLow - eyePositionLow;
                }else{
                    highDiff = a_endPosHigh - eyePositionHigh;
                    vert += a_endPosLow - eyePositionLow;
                }

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);
                
                // Hack for iMac M1, looks like it doesnt 
                // work correctly with zeroes in highDiff
                // if(length(highDiff) < 1.0){
                //     highDiff = vec3(0.0);
                // }
                
                gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + vert, 1.0);
            }`,
        fragmentShader: `precision highp float;
            varying vec4 v_rgba;
            void main () {
                gl_FragColor = v_rgba;
            }`
    });
}

const PICKINGCOLOR_BUFFER = 0;
const START_POSITION_BUFFER = 1;
const END_POSITION_BUFFER = 2;
const RGBA_BUFFER = 3;
const THICKNESS_BUFFER = 4;
const VERTEX_BUFFER = 5;
/*
 * og.RayHandler
 *
 *
 */
class RayHandler {
    constructor(entityCollection) {
        this.__id = RayHandler.__counter__++;
        /**
         * Picking rendering option.
         * @public
         * @type {boolean}
         */
        this.pickingEnabled = true;
        this._entityCollection = entityCollection;
        this._renderer = null;
        this._rays = [];
        this._vertexBuffer = null;
        this._startPositionHighBuffer = null;
        this._startPositionLowBuffer = null;
        this._endPositionHighBuffer = null;
        this._endPositionLowBuffer = null;
        this._thicknessBuffer = null;
        this._rgbaBuffer = null;
        this._pickingColorBuffer = null;
        this._vertexArr = [];
        this._startPositionHighArr = [];
        this._startPositionLowArr = [];
        this._endPositionHighArr = [];
        this._endPositionLowArr = [];
        this._thicknessArr = [];
        this._rgbaArr = [];
        this._pickingColorArr = [];
        this._buffersUpdateCallbacks = [];
        this._buffersUpdateCallbacks[VERTEX_BUFFER] = this.createVertexBuffer;
        this._buffersUpdateCallbacks[START_POSITION_BUFFER] = this.createStartPositionBuffer;
        this._buffersUpdateCallbacks[END_POSITION_BUFFER] = this.createEndPositionBuffer;
        this._buffersUpdateCallbacks[THICKNESS_BUFFER] = this.createThicknessBuffer;
        this._buffersUpdateCallbacks[RGBA_BUFFER] = this.createRgbaBuffer;
        this._buffersUpdateCallbacks[PICKINGCOLOR_BUFFER] = this.createPickingColorBuffer;
        this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
    }
    static concArr(dest, curr) {
        for (let i = 0; i < curr.length; i++) {
            dest.push(curr[i]);
        }
    }
    initProgram() {
        if (this._renderer && this._renderer.handler) {
            if (!this._renderer.handler.programs.rayScreen) {
                this._renderer.handler.addProgram(rayScreen());
            }
            // @todo: ray picking
            // if (!this._renderer.handler.programs.billboardPicking) {
            //     this._renderer.handler.addProgram(shaders.billboardPicking());
            // }
        }
    }
    setRenderer(renderer) {
        this._renderer = renderer;
        this.initProgram();
    }
    refresh() {
        let i = this._changedBuffers.length;
        while (i--) {
            this._changedBuffers[i] = true;
        }
    }
    _removeRays() {
        let i = this._rays.length;
        while (i--) {
            let ri = this._rays[i];
            ri._handlerIndex = -1;
            ri._handler = null;
        }
        this._rays.length = 0;
        this._rays = [];
    }
    clear() {
        //@ts-ignore
        this._vertexArr = null;
        //@ts-ignore
        this._startPositionHighArr = null;
        //@ts-ignore
        this._startPositionLowArr = null;
        //@ts-ignore
        this._endPositionHighArr = null;
        //@ts-ignore
        this._endPositionLowArr = null;
        //@ts-ignore
        this._thicknessArr = null;
        //@ts-ignore
        this._rgbaArr = null;
        this._vertexArr = new Float32Array([]);
        this._startPositionHighArr = new Float32Array([]);
        this._startPositionLowArr = new Float32Array([]);
        this._endPositionHighArr = new Float32Array([]);
        this._endPositionLowArr = new Float32Array([]);
        this._thicknessArr = new Float32Array([]);
        this._rgbaArr = new Float32Array([]);
        this._removeRays();
        this._deleteBuffers();
        this.refresh();
    }
    _deleteBuffers() {
        if (this._renderer) {
            let gl = this._renderer.handler.gl;
            if (gl) {
                gl.deleteBuffer(this._startPositionHighBuffer);
                gl.deleteBuffer(this._startPositionLowBuffer);
                gl.deleteBuffer(this._endPositionHighBuffer);
                gl.deleteBuffer(this._endPositionLowBuffer);
                gl.deleteBuffer(this._thicknessBuffer);
                gl.deleteBuffer(this._rgbaBuffer);
                gl.deleteBuffer(this._vertexBuffer);
            }
            this._startPositionHighBuffer = null;
            this._startPositionLowBuffer = null;
            this._endPositionHighBuffer = null;
            this._endPositionLowBuffer = null;
            this._thicknessBuffer = null;
            this._rgbaBuffer = null;
            this._vertexBuffer = null;
        }
    }
    update() {
        if (this._renderer) {
            let i = this._changedBuffers.length;
            while (i--) {
                if (this._changedBuffers[i]) {
                    this._buffersUpdateCallbacks[i].call(this);
                    this._changedBuffers[i] = false;
                }
            }
        }
    }
    add(ray) {
        if (ray._handlerIndex == -1) {
            ray._handler = this;
            ray._handlerIndex = this._rays.length;
            this._rays.push(ray);
            this._addRayToArrays(ray);
            this.refresh();
        }
    }
    _addRayToArrays(ray) {
        if (ray.getVisibility()) {
            this._vertexArr = concatArrays(this._vertexArr, [-0.5, 1.0, -0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 1.0, -0.5, 1.0]);
        }
        else {
            this._vertexArr = concatArrays(this._vertexArr, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        }
        let x = ray._startPositionHigh.x, y = ray._startPositionHigh.y, z = ray._startPositionHigh.z;
        this._startPositionHighArr = concatArrays(this._startPositionHighArr, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);
        x = ray._startPositionLow.x;
        y = ray._startPositionLow.y;
        z = ray._startPositionLow.z;
        this._startPositionLowArr = concatArrays(this._startPositionLowArr, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);
        x = ray._endPositionHigh.x;
        y = ray._endPositionHigh.y;
        z = ray._endPositionHigh.z;
        this._endPositionHighArr = concatArrays(this._endPositionHighArr, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);
        x = ray._endPositionLow.x;
        y = ray._endPositionLow.y;
        z = ray._endPositionLow.z;
        this._endPositionLowArr = concatArrays(this._endPositionLowArr, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);
        x = ray._thickness;
        this._thicknessArr = concatArrays(this._thicknessArr, [x, x, x, x, x, x]);
        let r0 = ray._startColor.x, g0 = ray._startColor.y, b0 = ray._startColor.z, a0 = ray._startColor.w, r1 = ray._endColor.x, g1 = ray._endColor.y, b1 = ray._endColor.z, a1 = ray._endColor.w;
        this._rgbaArr = concatArrays(this._rgbaArr, [
            r1, g1, b1, a1,
            r0, g0, b0, a0,
            r0, g0, b0, a0,
            r0, g0, b0, a0,
            r1, g1, b1, a1,
            r1, g1, b1, a1
        ]);
        x = ray._entity._pickingColor.x / 255;
        y = ray._entity._pickingColor.y / 255;
        z = ray._entity._pickingColor.z / 255;
        this._pickingColorArr = concatArrays(this._pickingColorArr, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);
    }
    _displayPASS() {
        let r = this._renderer;
        let h = r.handler;
        h.programs.rayScreen.activate();
        let sh = h.programs.rayScreen._program;
        let sha = sh.attributes, shu = sh.uniforms;
        let gl = h.gl, ec = this._entityCollection;
        //gl.polygonOffset(ec.polygonOffsetFactor, ec.polygonOffsetUnits);
        gl.disable(gl.CULL_FACE);
        gl.uniform1f(shu.uOpacity, ec._fadingOpacity);
        gl.uniformMatrix4fv(shu.viewMatrix, false, r.activeCamera.getViewMatrix());
        gl.uniformMatrix4fv(shu.projectionMatrix, false, r.activeCamera.getProjectionMatrix());
        gl.uniform3fv(shu.eyePositionHigh, r.activeCamera.eyeHigh);
        gl.uniform3fv(shu.eyePositionLow, r.activeCamera.eyeLow);
        gl.uniform1f(shu.resolution, r.activeCamera._tanViewAngle_hradOneByHeight);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._startPositionHighBuffer);
        gl.vertexAttribPointer(sha.a_startPosHigh, this._startPositionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._startPositionLowBuffer);
        gl.vertexAttribPointer(sha.a_startPosLow, this._startPositionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._endPositionHighBuffer);
        gl.vertexAttribPointer(sha.a_endPosHigh, this._endPositionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._endPositionLowBuffer);
        gl.vertexAttribPointer(sha.a_endPosLow, this._endPositionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._rgbaBuffer);
        gl.vertexAttribPointer(sha.a_rgba, this._rgbaBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._thicknessBuffer);
        gl.vertexAttribPointer(sha.a_thickness, this._thicknessBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
        gl.enable(gl.CULL_FACE);
    }
    _pickingPASS() {
        // ...
    }
    draw() {
        if (this._rays.length) {
            this.update();
            this._displayPASS();
        }
    }
    drawPicking() {
        if (this._rays.length && this.pickingEnabled) {
            this._pickingPASS();
        }
    }
    reindexRaysArray(startIndex) {
        let r = this._rays;
        for (let i = startIndex; i < r.length; i++) {
            r[i]._handlerIndex = i;
        }
    }
    _removeRay(ray) {
        let ri = ray._handlerIndex;
        this._rays.splice(ri, 1);
        let i = ri * 24;
        this._rgbaArr = spliceArray(this._rgbaArr, i, 24);
        i = ri * 18;
        this._startPositionHighArr = spliceArray(this._startPositionHighArr, i, 18);
        this._startPositionLowArr = spliceArray(this._startPositionLowArr, i, 18);
        this._endPositionHighArr = spliceArray(this._endPositionHighArr, i, 18);
        this._endPositionLowArr = spliceArray(this._endPositionLowArr, i, 18);
        this._pickingColorArr = spliceArray(this._pickingColorArr, i, 18);
        i = ri * 12;
        this._vertexArr = spliceArray(this._vertexArr, i, 12);
        i = ri * 6;
        this._thicknessArr = spliceArray(this._thicknessArr, i, 6);
        this.reindexRaysArray(ri);
        this.refresh();
        ray._handlerIndex = -1;
        ray._handler = null;
    }
    remove(ray) {
        if (ray._handler && this.__id === ray._handler.__id) {
            this._removeRay(ray);
        }
    }
    setStartPositionArr(index, positionHigh, positionLow) {
        let i = index * 18;
        // High
        let a = this._startPositionHighArr, x = positionHigh.x, y = positionHigh.y, z = positionHigh.z;
        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;
        a[i + 3] = x;
        a[i + 4] = y;
        a[i + 5] = z;
        a[i + 6] = x;
        a[i + 7] = y;
        a[i + 8] = z;
        a[i + 9] = x;
        a[i + 10] = y;
        a[i + 11] = z;
        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;
        a[i + 15] = x;
        a[i + 16] = y;
        a[i + 17] = z;
        // Low
        a = this._startPositionLowArr;
        x = positionLow.x;
        y = positionLow.y;
        z = positionLow.z;
        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;
        a[i + 3] = x;
        a[i + 4] = y;
        a[i + 5] = z;
        a[i + 6] = x;
        a[i + 7] = y;
        a[i + 8] = z;
        a[i + 9] = x;
        a[i + 10] = y;
        a[i + 11] = z;
        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;
        a[i + 15] = x;
        a[i + 16] = y;
        a[i + 17] = z;
        this._changedBuffers[START_POSITION_BUFFER] = true;
    }
    setEndPositionArr(index, positionHigh, positionLow) {
        let i = index * 18;
        // High
        let a = this._endPositionHighArr, x = positionHigh.x, y = positionHigh.y, z = positionHigh.z;
        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;
        a[i + 3] = x;
        a[i + 4] = y;
        a[i + 5] = z;
        a[i + 6] = x;
        a[i + 7] = y;
        a[i + 8] = z;
        a[i + 9] = x;
        a[i + 10] = y;
        a[i + 11] = z;
        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;
        a[i + 15] = x;
        a[i + 16] = y;
        a[i + 17] = z;
        // Low
        a = this._endPositionLowArr;
        x = positionLow.x;
        y = positionLow.y;
        z = positionLow.z;
        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;
        a[i + 3] = x;
        a[i + 4] = y;
        a[i + 5] = z;
        a[i + 6] = x;
        a[i + 7] = y;
        a[i + 8] = z;
        a[i + 9] = x;
        a[i + 10] = y;
        a[i + 11] = z;
        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;
        a[i + 15] = x;
        a[i + 16] = y;
        a[i + 17] = z;
        this._changedBuffers[END_POSITION_BUFFER] = true;
    }
    setPickingColorArr(index, color) {
        let i = index * 18;
        let a = this._pickingColorArr, x = color.x / 255, y = color.y / 255, z = color.z / 255;
        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;
        a[i + 3] = x;
        a[i + 4] = y;
        a[i + 5] = z;
        a[i + 6] = x;
        a[i + 7] = y;
        a[i + 8] = z;
        a[i + 9] = x;
        a[i + 10] = y;
        a[i + 11] = z;
        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;
        a[i + 15] = x;
        a[i + 16] = y;
        a[i + 17] = z;
        this._changedBuffers[PICKINGCOLOR_BUFFER] = true;
    }
    setRgbaArr(index, startColor, endColor) {
        let i = index * 24;
        let a = this._rgbaArr, r0 = startColor.x, g0 = startColor.y, b0 = startColor.z, a0 = startColor.w, r1 = endColor.x, g1 = endColor.y, b1 = endColor.z, a1 = endColor.w;
        a[i] = r1;
        a[i + 1] = g1;
        a[i + 2] = b1;
        a[i + 3] = a1;
        a[i + 4] = r0;
        a[i + 5] = g0;
        a[i + 6] = b0;
        a[i + 7] = a0;
        a[i + 8] = r0;
        a[i + 9] = g0;
        a[i + 10] = b0;
        a[i + 11] = a0;
        a[i + 12] = r0;
        a[i + 13] = g0;
        a[i + 14] = b0;
        a[i + 15] = a0;
        a[i + 16] = r1;
        a[i + 17] = g1;
        a[i + 18] = b1;
        a[i + 19] = a1;
        a[i + 20] = r1;
        a[i + 21] = g1;
        a[i + 22] = b1;
        a[i + 23] = a1;
        this._changedBuffers[RGBA_BUFFER] = true;
    }
    setThicknessArr(index, thickness) {
        let i = index * 6;
        let a = this._thicknessArr;
        a[i] = thickness;
        a[i + 1] = thickness;
        a[i + 2] = thickness;
        a[i + 3] = thickness;
        a[i + 4] = thickness;
        a[i + 5] = thickness;
        this._changedBuffers[THICKNESS_BUFFER] = true;
    }
    setVisibility(index, visibility) {
        let vArr;
        if (visibility) {
            vArr = [-0.5, 1.0, -0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 1.0, -0.5, 1.0];
        }
        else {
            vArr = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
        }
        this.setVertexArr(index, vArr);
    }
    setVertexArr(index, vertexArr) {
        let i = index * 12;
        let a = this._vertexArr;
        a[i] = vertexArr[0];
        a[i + 1] = vertexArr[1];
        a[i + 2] = vertexArr[2];
        a[i + 3] = vertexArr[3];
        a[i + 4] = vertexArr[4];
        a[i + 5] = vertexArr[5];
        a[i + 6] = vertexArr[6];
        a[i + 7] = vertexArr[7];
        a[i + 8] = vertexArr[8];
        a[i + 9] = vertexArr[9];
        a[i + 10] = vertexArr[10];
        a[i + 11] = vertexArr[11];
        this._changedBuffers[VERTEX_BUFFER] = true;
    }
    createStartPositionBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._startPositionHighBuffer);
        this._startPositionHighArr = makeArrayTyped(this._startPositionHighArr);
        this._startPositionHighBuffer = h.createArrayBuffer(this._startPositionHighArr, 3, this._startPositionHighArr.length / 3, h.gl.DYNAMIC_DRAW);
        h.gl.deleteBuffer(this._startPositionLowBuffer);
        this._startPositionLowArr = makeArrayTyped(this._startPositionLowArr);
        this._startPositionLowBuffer = h.createArrayBuffer(this._startPositionLowArr, 3, this._startPositionLowArr.length / 3, h.gl.DYNAMIC_DRAW);
    }
    createEndPositionBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._endPositionHighBuffer);
        this._endPositionHighArr = makeArrayTyped(this._endPositionHighArr);
        this._endPositionHighBuffer = h.createArrayBuffer(this._endPositionHighArr, 3, this._endPositionHighArr.length / 3, h.gl.DYNAMIC_DRAW);
        h.gl.deleteBuffer(this._endPositionLowBuffer);
        this._endPositionLowArr = makeArrayTyped(this._endPositionLowArr);
        this._endPositionLowBuffer = h.createArrayBuffer(this._endPositionLowArr, 3, this._endPositionLowArr.length / 3, h.gl.DYNAMIC_DRAW);
    }
    createRgbaBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._rgbaBuffer);
        this._rgbaArr = makeArrayTyped(this._rgbaArr);
        this._rgbaBuffer = h.createArrayBuffer(this._rgbaArr, 4, this._rgbaArr.length / 4);
    }
    createThicknessBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._thicknessBuffer);
        this._thicknessArr = makeArrayTyped(this._thicknessArr);
        this._thicknessBuffer = h.createArrayBuffer(this._thicknessArr, 1, this._thicknessArr.length, h.gl.DYNAMIC_DRAW);
    }
    createVertexBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._vertexBuffer);
        this._vertexArr = makeArrayTyped(this._vertexArr);
        this._vertexBuffer = h.createArrayBuffer(this._vertexArr, 2, this._vertexArr.length / 2, h.gl.DYNAMIC_DRAW);
    }
    createPickingColorBuffer() {
        let h = this._renderer.handler;
        h.gl.deleteBuffer(this._pickingColorBuffer);
        this._pickingColorArr = makeArrayTyped(this._pickingColorArr);
        this._pickingColorBuffer = h.createArrayBuffer(this._pickingColorArr, 3, this._pickingColorArr.length / 3);
    }
}
RayHandler.__counter__ = 0;

class StripHandler {
    constructor(entityCollection) {
        this.__id = StripHandler.__counter__++;
        this.pickingEnabled = true;
        this._entityCollection = entityCollection;
        this._renderer = null;
        this._strips = [];
    }
    _initProgram() {
        if (this._renderer && this._renderer.handler) {
            !this._renderer.handler.programs.strip &&
                this._renderer.handler.addProgram(new Program("strip", {
                    uniforms: {
                        projectionMatrix: { type: "mat4" },
                        viewMatrix: { type: "mat4" },
                        eyePositionHigh: "vec3",
                        eyePositionLow: "vec3",
                        uColor: { type: "vec4" },
                        uOpacity: { type: "float" }
                    },
                    attributes: {
                        aVertexPositionHigh: { type: "vec3" },
                        aVertexPositionLow: { type: "vec3" }
                    },
                    vertexShader: `attribute vec3 aVertexPositionHigh;
                        attribute vec3 aVertexPositionLow;
                        uniform mat4 projectionMatrix;
                        uniform mat4 viewMatrix;
                        uniform vec3 eyePositionHigh;
                        uniform vec3 eyePositionLow;
                        void main(void) {

                            vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                            vec3 lowDiff = aVertexPositionLow - eyePositionLow;

                            mat4 viewMatrixRTE = viewMatrix;
                            viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                            gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);
                        }`,
                    fragmentShader: `precision highp float;
                        uniform vec4 uColor;
                        uniform float uOpacity;
                        void main(void) {
                            gl_FragColor = vec4(uColor.rgb, uColor.a * uOpacity);
                        }`
                }));
        }
    }
    setRenderNode(renderNode) {
        this._renderer = renderNode.renderer;
        this._initProgram();
        for (let i = 0; i < this._strips.length; i++) {
            this._strips[i].setRenderNode(renderNode);
        }
    }
    add(strip) {
        if (strip._handlerIndex === -1) {
            strip._handler = this;
            strip._handlerIndex = this._strips.length;
            this._strips.push(strip);
            this._entityCollection &&
                this._entityCollection.renderNode &&
                strip.setRenderNode(this._entityCollection.renderNode);
        }
    }
    remove(strip) {
        let index = strip._handlerIndex;
        if (index !== -1) {
            strip._deleteBuffers();
            strip._handlerIndex = -1;
            strip._handler = null;
            this._strips.splice(index, 1);
            this.reindexStripArray(index);
        }
    }
    reindexStripArray(startIndex) {
        let pc = this._strips;
        for (let i = startIndex; i < pc.length; i++) {
            pc[i]._handlerIndex = i;
        }
    }
    draw() {
        let i = this._strips.length;
        while (i--) {
            this._strips[i].draw();
        }
    }
    drawPicking() {
        if (this.pickingEnabled) {
            let i = this._strips.length;
            while (i--) {
                this._strips[i].drawPicking();
            }
        }
    }
    clear() {
        let i = this._strips.length;
        while (i--) {
            this._strips[i]._deleteBuffers();
            this._strips[i]._handler = null;
            this._strips[i]._handlerIndex = -1;
        }
        this._strips.length = 0;
        this._strips = [];
    }
}
StripHandler.__counter__ = 0;

/**
 * An observable collection of og.Entity instances where each entity has a unique id.
 * Entity collection provide handlers for each type of entity like billboard, label or 3ds object.
 * @constructor
 * @param {Object} [options] - Entity options:
 * @param {Array.<Entity>} [options.entities] - Entities array.
 * @param {boolean} [options.visibility=true] - Entity visibility.
 * @param {Array.<number>} [options.scaleByDistance] - Entity scale by distance parameters. (exactly 3 entries)
 * First index - near distance to the entity, after entity becomes full scale.
 * Second index - far distance to the entity, when entity becomes zero scale.
 * Third index - far distance to the entity, when entity becomes invisible.
 * @param {number} [options.opacity] - Entity global opacity.
 * @param {boolean} [options.pickingEnabled=true] - Entity picking enable.
 * @param {Number} [options.polygonOffsetUnits=0.0] - The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset. The default value is 0.
 * //@fires EntityCollection#entitymove
 * @fires EntityCollection#draw
 * @fires EntityCollection#drawend
 * @fires EntityCollection#add
 * @fires EntityCollection#remove
 * @fires EntityCollection#entityadd
 * @fires EntityCollection#entityremove
 * @fires EntityCollection#visibilitychange
 * @fires EntityCollection#mousemove
 * @fires EntityCollection#mouseenter
 * @fires EntityCollection#mouseleave
 * @fires EntityCollection#lclick
 * @fires EntityCollection#rclick
 * @fires EntityCollection#mclick
 * @fires EntityCollection#ldblclick
 * @fires EntityCollection#rdblclick
 * @fires EntityCollection#mdblclick
 * @fires EntityCollection#lup
 * @fires EntityCollection#rup
 * @fires EntityCollection#mup
 * @fires EntityCollection#ldown
 * @fires EntityCollection#rdown
 * @fires EntityCollection#mdown
 * @fires EntityCollection#lhold
 * @fires EntityCollection#rhold
 * @fires EntityCollection#mhold
 * @fires EntityCollection#mousewheel
 * @fires EntityCollection#touchmove
 * @fires EntityCollection#touchstart
 * @fires EntityCollection#touchend
 * @fires EntityCollection#doubletouch
 * @fires EntityCollection#touchleave
 * @fires EntityCollection#touchenter
 */
class EntityCollection {
    constructor(options = {}) {
        this.__id = EntityCollection.__counter__++;
        this._renderNodeIndex = -1;
        this.renderNode = null;
        this._visibility = options.visibility == undefined ? true : options.visibility;
        this.polygonOffsetUnits =
            options.polygonOffsetUnits != undefined ? options.polygonOffsetUnits : 0.0;
        this.billboardHandler = new BillboardHandler(this);
        this.labelHandler = new LabelHandler(this, options.labelMaxLetters);
        this.polylineHandler = new PolylineHandler(this);
        this.rayHandler = new RayHandler(this);
        this.pointCloudHandler = new PointCloudHandler(this);
        this.stripHandler = new StripHandler(this);
        this.geoObjectHandler = new GeoObjectHandler(this);
        if (options.pickingEnabled != undefined) {
            this.setPickingEnabled(options.pickingEnabled);
        }
        this._entities = [];
        this.scaleByDistance = options.scaleByDistance || [MAX32, MAX32, MAX32];
        let pickingScale = new Float32Array([1.0, 1.0, 1.0]);
        if (options.pickingScale !== undefined) {
            if (options.pickingScale instanceof Array) {
                pickingScale[0] = options.pickingScale[0] || pickingScale[0];
                pickingScale[1] = options.pickingScale[1] || pickingScale[1];
                pickingScale[2] = options.pickingScale[2] || pickingScale[2];
            }
            else if (typeof options.pickingScale === 'number') {
                pickingScale[0] = options.pickingScale;
                pickingScale[1] = options.pickingScale;
                pickingScale[2] = options.pickingScale;
            }
        }
        this.pickingScale = pickingScale;
        this._opacity = options.opacity == undefined ? 1.0 : options.opacity;
        this._fadingOpacity = this._opacity;
        this.events = this.rendererEvents = createEvents(ENTITYCOLLECTION_EVENTS, this);
        this._useLighting = options.useLighting != undefined ? (options.useLighting ? 1.0 : 0.0) : 1.0;
        // initialize current entities
        if (options.entities) {
            this.addEntities(options.entities);
        }
    }
    isEmpty() {
        return this._entities.length == 0;
    }
    get id() {
        return this.__id;
    }
    get useLighting() {
        return Boolean(this._useLighting);
    }
    set useLighting(f) {
        this._useLighting = Number(f);
    }
    isEqual(ec) {
        return this.__id === ec.__id;
    }
    /**
     * Sets collection visibility.
     * @public
     * @param {boolean} visibility - Visibility flag.
     */
    setVisibility(visibility) {
        this._visibility = visibility;
        this._fadingOpacity = this._opacity * (visibility ? 1 : 0);
        this.events.dispatch(this.events.visibilitychange, this);
    }
    /**
     * Returns collection visibility.
     * @public
     * @returns {boolean} -
     */
    getVisibility() {
        return this._visibility;
    }
    /**
     * Sets collection opacity.
     * @public
     * @param {number} opacity - Opacity.
     */
    setOpacity(opacity) {
        this._opacity = opacity;
    }
    /**
     * Sets collection picking ability.
     * @public
     * @param {boolean} enable - Picking enable flag.
     */
    setPickingEnabled(enable) {
        this.billboardHandler.pickingEnabled = enable;
        this.labelHandler.pickingEnabled = enable;
        this.polylineHandler.pickingEnabled = enable;
        this.rayHandler.pickingEnabled = enable;
        this.pointCloudHandler.pickingEnabled = enable;
        this.stripHandler.pickingEnabled = enable;
        this.geoObjectHandler.pickingEnabled = enable;
    }
    /**
     * Gets collection opacity.
     * @public
     * @returns {number} -
     */
    getOpacity() {
        return this._opacity;
    }
    /**
     * Sets scale by distance parameters.
     * @public
     * @param {number} near - Full scale entity distance.
     * @param {number} far - Zero scale entity distance.
     * @param {number} [farInvisible] - Entity visibility distance.
     */
    setScaleByDistance(near, far, farInvisible) {
        this.scaleByDistance[0] = near;
        this.scaleByDistance[1] = far;
        this.scaleByDistance[2] = farInvisible || MAX32;
    }
    appendChildEntity(entity) {
        this._addRecursively(entity);
    }
    _addRecursively(entity) {
        // billboard
        entity.billboard && this.billboardHandler.add(entity.billboard);
        // label
        entity.label && this.labelHandler.add(entity.label);
        // polyline
        entity.polyline && this.polylineHandler.add(entity.polyline);
        // ray
        entity.ray && this.rayHandler.add(entity.ray);
        // pointCloud
        entity.pointCloud && this.pointCloudHandler.add(entity.pointCloud);
        // strip
        entity.strip && this.stripHandler.add(entity.strip);
        //geoObject
        entity.geoObject && this.geoObjectHandler.add(entity.geoObject);
        this.events.dispatch(this.events.entityadd, entity);
        let rn = this.renderNode;
        for (let i = 0; i < entity.childrenNodes.length; i++) {
            entity.childrenNodes[i]._entityCollection = this;
            entity.childrenNodes[i]._entityCollectionIndex = entity._entityCollectionIndex;
            if (entity.childrenNodes[i]._independentPicking) {
                if (rn) {
                    rn.renderer && rn.renderer.assignPickingColor(entity.childrenNodes[i]);
                }
            }
            else {
                entity.childrenNodes[i]._pickingColor = entity._pickingColor;
            }
            this._addRecursively(entity.childrenNodes[i]);
        }
    }
    /**
     * Adds entity to the collection and returns collection.
     * @public
     * @param {Entity} entity - Entity.
     * @returns {EntityCollection} -
     */
    add(entity) {
        if (!entity._entityCollection) {
            entity._entityCollection = this;
            entity._entityCollectionIndex = this._entities.length;
            this._entities.push(entity);
            let rn = this.renderNode;
            if (rn) {
                rn.renderer && rn.renderer.assignPickingColor(entity);
                if (rn.ellipsoid && entity._cartesian.isZero()) {
                    entity.setCartesian3v(rn.ellipsoid.lonLatToCartesian(entity._lonLat));
                }
            }
            this._addRecursively(entity);
            entity.setPickingColor();
        }
        return this;
    }
    /**
     * Adds entities array to the collection and returns collection.
     * @public
     * @param {Array.<Entity>} entities - Entities array.
     * @returns {EntityCollection} -
     */
    addEntities(entities) {
        for (let i = 0, len = entities.length; i < len; i++) {
            this.add(entities[i]);
        }
        return this;
    }
    /**
     * Returns true if the entity belongs this collection, otherwise returns false.
     * @public
     * @param {Entity} entity - Entity.
     * @returns {boolean} -
     */
    belongs(entity) {
        return entity._entityCollection && this._renderNodeIndex === entity._entityCollection._renderNodeIndex;
    }
    _removeRecursively(entity) {
        entity._entityCollection = null;
        entity._entityCollectionIndex = -1;
        // billboard
        entity.billboard && this.billboardHandler.remove(entity.billboard);
        // label
        entity.label && this.labelHandler.remove(entity.label);
        // polyline
        entity.polyline && this.polylineHandler.remove(entity.polyline);
        // ray
        entity.ray && this.rayHandler.remove(entity.ray);
        // pointCloud
        entity.pointCloud && this.pointCloudHandler.remove(entity.pointCloud);
        // strip
        entity.strip && this.stripHandler.remove(entity.strip);
        // geoObject
        entity.geoObject && this.geoObjectHandler.remove(entity.geoObject);
        for (let i = 0; i < entity.childrenNodes.length; i++) {
            this._removeRecursively(entity.childrenNodes[i]);
        }
    }
    /**
     * Removes entity from this collection.
     * @public
     * @param {Entity} entity - Entity to remove.
     */
    removeEntity(entity) {
        this._entities.splice(entity._entityCollectionIndex, 1);
        this.reindexEntitiesArray(entity._entityCollectionIndex);
        // clear picking color
        if (this.renderNode && this.renderNode.renderer) {
            this.renderNode.renderer.clearPickingColor(entity);
            entity._pickingColor.clear();
        }
        if (this.belongs(entity)) {
            this._removeRecursively(entity);
        }
        this.events.dispatch(this.events.entityremove, entity);
    }
    _removeEntitySilent(entity) {
        this._entities.splice(entity._entityCollectionIndex, 1);
        this.reindexEntitiesArray(entity._entityCollectionIndex);
        // clear picking color
        if (this.renderNode && this.renderNode.renderer) {
            this.renderNode.renderer.clearPickingColor(entity);
            entity._pickingColor.clear();
        }
        if (this.belongs(entity)) {
            this._removeRecursively(entity);
        }
    }
    /**
     * Creates or refresh collected entities picking color.
     * @public
     */
    createPickingColors() {
        if (!(this.renderNode && this.renderNode.renderer))
            return;
        let e = this._entities;
        for (let i = 0; i < e.length; i++) {
            if (!e[i].parent) {
                this.renderNode.renderer.assignPickingColor(e[i]);
                e[i].setPickingColor();
            }
        }
    }
    /**
     * Refresh collected entities indexes from startIndex entities collection array position.
     * @public
     * @param {number} startIndex - Entities collection array index.
     */
    reindexEntitiesArray(startIndex) {
        let e = this._entities;
        for (let i = startIndex; i < e.length; i++) {
            e[i]._entityCollectionIndex = i;
        }
    }
    /**
     * Adds this collection to render node.
     * @public
     * @param {RenderNode} renderNode - Render node.
     * @param {boolean} [isHidden] - Uses in vector layers that render in planet render specific function.
     * @returns {EntityCollection} -
     */
    addTo(renderNode, isHidden = false) {
        if (!this.renderNode) {
            this.renderNode = renderNode;
            if (!isHidden) {
                this._renderNodeIndex = renderNode.entityCollections.length;
                renderNode.entityCollections.push(this);
            }
            renderNode.ellipsoid && this._updateGeodeticCoordinates(renderNode.ellipsoid);
            this.bindRenderNode(renderNode);
            this.events.dispatch(this.events.add, this);
        }
        return this;
    }
    /**
     * This function is called in the RenderNode assign function.
     * @public
     * @param {RenderNode} renderNode
     */
    bindRenderNode(renderNode) {
        if (renderNode.renderer && renderNode.renderer.isInitialized()) {
            this.billboardHandler.setRenderer(renderNode.renderer);
            this.labelHandler.setRenderer(renderNode.renderer);
            this.rayHandler.setRenderer(renderNode.renderer);
            this.geoObjectHandler.setRenderNode(renderNode);
            this.polylineHandler.setRenderNode(renderNode);
            this.pointCloudHandler.setRenderNode(renderNode);
            this.stripHandler.setRenderNode(renderNode);
            this.updateBillboardsTextureAtlas();
            this.updateLabelsFontAtlas();
            this.createPickingColors();
        }
    }
    /**
     * Updates coordinates all lonLat entities in collection after collection attached to the planet node.
     * @protected
     * @param {Ellipsoid} ellipsoid - Globe ellipsoid.
     */
    _updateGeodeticCoordinates(ellipsoid) {
        let e = this._entities;
        let i = e.length;
        while (i--) {
            let ei = e[i];
            ei._lonLat && ei.setCartesian3v(ellipsoid.lonLatToCartesian(ei._lonLat));
        }
    }
    /**
     * Updates billboard texture atlas.
     * @public
     */
    updateBillboardsTextureAtlas() {
        let b = this.billboardHandler.billboards;
        for (let i = 0; i < b.length; i++) {
            b[i].setSrc(b[i].getSrc());
        }
    }
    /**
     * Updates labels font atlas.
     * @public
     */
    updateLabelsFontAtlas() {
        if (this.renderNode) {
            // let l = ([] as Label[]).concat(this.labelHandler.labels);
            // this.labelHandler._billboards = [];
            // for (let i = 0; i < l.length; i++) {
            //     this.labelHandler.assignFontAtlas(l[i]);
            // }
            this.labelHandler.updateFonts();
        }
    }
    /**
     * Removes collection from render node.
     * @public
     */
    remove() {
        if (this.renderNode) {
            if (this._renderNodeIndex !== -1) {
                this.renderNode.entityCollections.splice(this._renderNodeIndex, 1);
                // reindex in the renderNode
                for (let i = this._renderNodeIndex; i < this.renderNode.entityCollections.length; i++) {
                    this.renderNode.entityCollections[i]._renderNodeIndex = i;
                }
            }
            this.renderNode = null;
            this._renderNodeIndex = -1;
            this.events.dispatch(this.events.remove, this);
        }
    }
    /**
     * Gets entity array.
     * @public
     * @returns {Array.<Entity>} -
     */
    getEntities() {
        return [].concat(this._entities);
    }
    /**
     * Safety entities loop.
     * @public
     * @param {function} callback - Entity callback.
     */
    each(callback) {
        let i = this._entities.length;
        while (i--) {
            let ei = this._entities[i];
            ei && callback(ei);
        }
    }
    /**
     * Removes all entities from collection and clear handlers.
     * @public
     */
    clear() {
        // TODO: Optimize by replace delete
        // code to the clearEntity function.
        this.billboardHandler.clear();
        this.labelHandler.clear();
        this.polylineHandler.clear();
        this.rayHandler.clear();
        this.pointCloudHandler.clear();
        this.stripHandler.clear();
        this.geoObjectHandler.clear();
        let i = this._entities.length;
        while (i--) {
            let ei = this._entities[i];
            if (this.renderNode && this.renderNode.renderer) {
                this.renderNode.renderer.clearPickingColor(ei);
                ei._pickingColor.clear();
            }
            this._clearEntity(ei);
        }
        this._entities.length = 0;
        this._entities = [];
    }
    /**
     * Clears entity recursively.
     * @private
     * @param {Entity} entity - Entity to clear.
     */
    _clearEntity(entity) {
        entity._entityCollection = null;
        entity._entityCollectionIndex = -1;
        for (let i = 0; i < entity.childrenNodes.length; i++) {
            this._clearEntity(entity.childrenNodes[i]);
        }
    }
}
EntityCollection.__counter__ = 0;
const ENTITYCOLLECTION_EVENTS = [
    // /**
    //  * Triggered when entity has moved.
    //  * @event EntityCollection#entitymove
    //  */
    // "entitymove",
    /**
     * Triggered when collection entities begin draw.
     * @event EntityCollection#draw
     */
    "draw",
    /**
     * Triggered after collection has drawn.
     * @event EntityCollection#drawend
     */
    "drawend",
    /**
     * Triggered when added to the render node.
     * @event EntityCollection#add
     */
    "add",
    /**
     * Triggered when removed from the render node.
     * @event EntityCollection#remove
     */
    "remove",
    /**
     * Triggered when new entity added to the collection.
     * @event EntityCollection#entityadd
     */
    "entityadd",
    /**
     * Triggered when entity removes from the collection.
     * @event EntityCollection#entityremove
     */
    "entityremove",
    /**
     * Triggered when visibility changes.
     * @event EntityCollection#visibilitychange
     */
    "visibilitychange",
    /**
     * Triggered when mouse moves over the entity.
     * @event EntityCollection#mousemove
     */
    "mousemove",
    /**
     * Triggered when mouse has entered over the entity.
     * @event EntityCollection#mouseenter
     */
    "mouseenter",
    /**
     * Triggered when mouse leaves the entity.
     * @event EntityCollection#mouseleave
     */
    "mouseleave",
    /**
     * Mouse left button clicked.
     * @event EntityCollection#lclick
     */
    "lclick",
    /**
     * Mouse right button clicked.
     * @event EntityCollection#rclick
     */
    "rclick",
    /**
     * Mouse right button clicked.
     * @event EntityCollection#mclick
     */
    "mclick",
    /**
     * Mouse left button double click.
     * @event EntityCollection#ldblclick
     */
    "ldblclick",
    /**
     * Mouse right button double click.
     * @event EntityCollection#rdblclick
     */
    "rdblclick",
    /**
     * Mouse middle button double click.
     * @event EntityCollection#mdblclick
     */
    "mdblclick",
    /**
     * Mouse left button up(stop pressing).
     * @event EntityCollection#lup
     */
    "lup",
    /**
     * Mouse right button up(stop pressing).
     * @event EntityCollection#rup
     */
    "rup",
    /**
     * Mouse middle button up(stop pressing).
     * @event EntityCollection#mup
     */
    "mup",
    /**
     * Mouse left button is just pressed down(start pressing).
     * @event EntityCollection#ldown
     */
    "ldown",
    /**
     * Mouse right button is just pressed down(start pressing).
     * @event EntityCollection#rdown
     */
    "rdown",
    /**
     * Mouse middle button is just pressed down(start pressing).
     * @event EntityCollection#mdown
     */
    "mdown",
    /**
     * Mouse left button is pressing.
     * @event EntityCollection#lhold
     */
    "lhold",
    /**
     * Mouse right button is pressing.
     * @event EntityCollection#rhold
     */
    "rhold",
    /**
     * Mouse middle button is pressing.
     * @event EntityCollection#mhold
     */
    "mhold",
    /**
     * Mouse wheel is rotated.
     * @event EntityCollection#mousewheel
     */
    "mousewheel",
    /**
     * Triggered when touch moves over the entity.
     * @event EntityCollection#touchmove
     */
    "touchmove",
    /**
     * Triggered when entity begins to touch.
     * @event EntityCollection#touchstart
     */
    "touchstart",
    /**
     * Triggered when entity ends touching.
     * @event EntityCollection#touchend
     */
    "touchend",
    /**
     * Triggered entity double touch.
     * @event EntityCollection#doubletouch
     */
    "doubletouch",
    /**
     * Triggered when touching leaves entity.
     * @event EntityCollection#touchleave
     */
    "touchleave",
    /**
     * Triggered when touch enters over the entity.
     * @event EntityCollection#touchenter
     */
    "touchenter"
];

/**
 * @module og/math/coder
 */
/**
 * Decode RGBA vector to 32 bit float value.
 * @function
 * @param {NumberArray4 | NumberArray3} arr - RGBA encoded 32 bit float value.
 * @param {boolean} [use32=false] Use 32 bit result
 * @returns {number} - Float value.
 */
function decodeFloatFromRGBAArr(arr, use32 = false) {
    let s = 1.0 - step(128.0, arr[0]) * 2.0;
    let e = 2.0 * mod(arr[0], 128.0) + step(128.0, arr[1]) - 127.0;
    let m = mod(arr[1], 128.0) * 65536.0 + arr[2] * 256.0 + (use32 ? arr[3] || 0.0 : 0.0) + 8388608.0;
    return s * exp2(e) * (m * 1.1920928955078125e-7);
}
/**
 * Separate 64 bit value to two 32-bit float values.
 * @function
 * @param {number} value - Double type value.
 * @param {NumberArray2 | Float32Array} - Reference out array.
 * @returns {NumberArray2 | Float32Array} Encoded array. (exactly 2 entries)
 */
function doubleToTwoFloats2(value, highLowArr) {
    if (value >= 0.0) {
        let doubleHigh = Math.floor(value / 65536.0) * 65536.0;
        highLowArr[0] = Math.fround(doubleHigh);
        highLowArr[1] = Math.fround(value - doubleHigh);
    }
    else {
        let doubleHigh = Math.floor(-value / 65536.0) * 65536.0;
        highLowArr[0] = Math.fround(-doubleHigh);
        highLowArr[1] = Math.fround(value + doubleHigh);
    }
    return highLowArr;
}
/**
 * Separate 64 bit value to two 32-bit float values.
 * @function
 * @param {number} value - Double type value.
 * @param {Vec2} highLowVec - Reference out vector object.
 * @returns {Vec2} Encoded array. (exactly 2 entries)
 */
function doubleToTwoFloatsV2(value, highLowVec) {
    if (value >= 0.0) {
        let doubleHigh = Math.floor(value / 65536.0) * 65536.0;
        highLowVec.x = Math.fround(doubleHigh);
        highLowVec.y = Math.fround(value - doubleHigh);
    }
    else {
        let doubleHigh = Math.floor(-value / 65536.0) * 65536.0;
        highLowVec.x = Math.fround(-doubleHigh);
        highLowVec.y = Math.fround(value + doubleHigh);
    }
    return highLowVec;
}

// @ts-nocheck
/* eslint-disable no-unused-vars */
/* eslint-disable curly */
/* eslint-disable operator-linebreak */
/* eslint-disable no-mixed-operators */
/**
 * @module og/utils/earcut
 */
// ISC License
//
// Copyright (c) 2016, Mapbox
//
// Permission to use, copy, modify, and/or distribute this software for any purpose
// with or without fee is hereby granted, provided that the above copyright notice
// and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
// OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
// THIS SOFTWARE.
//
//https://github.com/mapbox/earcut
function earcut(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode)
        return triangles;
    var minX, minY, maxX, maxY, x, y, size;
    if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (let i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX)
                minX = x;
            if (y < minY)
                minY = y;
            if (x > maxX)
                maxX = x;
            if (y > maxY)
                maxY = y;
        }
        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, size);
    return triangles;
}
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;
    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim)
            last = insertNode(i, data[i], data[i + 1], last);
    }
    else {
        for (i = end - dim; i >= start; i -= dim)
            last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start)
        return start;
    if (!end)
        end = start;
    var p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
                return null;
            again = true;
        }
        else {
            p = p.next;
        }
    } while (again || p !== end);
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear)
        return;
    // interlink polygon nodes in z-order
    if (!pass && size)
        indexCurve(ear, minX, minY, size);
    var stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
                // if this didn't work, try curing all small self-intersections locally
            }
            else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);
                // as a last resort, try splitting the remaining polygon into two
            }
            else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
        return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;
    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0)
            return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
        return false; // reflex, can't be an ear
    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size);
    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;
    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0)
            return false;
        p = p.nextZ;
    }
    // then look for points in decreasing z-order
    p = ear.prevZ;
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0)
            return false;
        p = p.prevZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    } while (p !== start);
    return p;
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);
                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [], i, len, start, end, list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
            list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y)
                        return p;
                    if (hy === p.next.y)
                        return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);
    if (!m)
        return null;
    if (hx === qx)
        return m.prev; // hole touches outer segment; pick lower endpoint
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
    p = m.next;
    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
            pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }
    return m;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null)
            p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q)
                    break;
            }
            qSize = inSize;
            while (pSize > 0 || (qSize > 0 && q)) {
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                }
                else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail)
                    tail.nextZ = e;
                else
                    list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    } while (numMerges > 1);
    return list;
}
// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;
    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;
    return x | (y << 1);
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start, leftmost = start;
    do {
        if (p.x < leftmost.x)
            leftmost = p;
        p = p.next;
    } while (p !== start);
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
        (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
        (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
        locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}
// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1)))
        return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
        area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
            intersects(p, p.next, a, b))
            return true;
        p = p.next;
    } while (p !== a);
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
            (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node$2(a.i, a.x, a.y), b2 = new Node$2(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node$2(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    }
    else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ)
        p.prevZ.nextZ = p.nextZ;
    if (p.nextZ)
        p.nextZ.prevZ = p.prevZ;
}
function Node$2(i, x, y) {
    // vertice index in coordinates array
    this.i = i;
    // vertex coordinates
    this.x = x;
    this.y = y;
    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = null;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
function signedArea(data, start, end, dim) {
    var sum = 0;
    for (let i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}
// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
function flatten(data) {
    var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
    for (let i = 0; i < data.length; i++) {
        for (let j = 0; j < data[i].length; j++) {
            for (let d = 0; d < dim; d++)
                result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
}

const POLYVERTICES_BUFFER = 0;
const POLYINDEXES_BUFFER = 1;
const POLYCOLORS_BUFFER = 2;
const LINEVERTICES_BUFFER = 3;
const LINEINDEXES_BUFFER = 4;
const LINEORDERS_BUFFER = 5;
const LINECOLORS_BUFFER = 6;
const LINETHICKNESS_BUFFER = 7;
const LINESTROKES_BUFFER = 8;
const LINESTROKECOLORS_BUFFER = 9;
const POLYPICKINGCOLORS_BUFFER = 10;
const LINEPICKINGCOLORS_BUFFER = 11;
function doubleToTwoFloats(v, high, low) {
    let x = v[0], y = v[1];
    if (x >= 0.0) {
        let doubleHigh = Math.floor(x / 65536.0) * 65536.0;
        high.x = Math.fround(doubleHigh);
        low.x = Math.fround(x - doubleHigh);
    }
    else {
        let doubleHigh = Math.floor(-x / 65536.0) * 65536.0;
        high.x = Math.fround(-doubleHigh);
        low.x = Math.fround(x + doubleHigh);
    }
    if (y >= 0.0) {
        let doubleHigh = Math.floor(y / 65536.0) * 65536.0;
        high.y = Math.fround(doubleHigh);
        low.y = Math.fround(y - doubleHigh);
    }
    else {
        let doubleHigh = Math.floor(-y / 65536.0) * 65536.0;
        high.y = Math.fround(-doubleHigh);
        low.y = Math.fround(y + doubleHigh);
    }
}
let tempHigh = new Vec2(), tempLow = new Vec2(), tempHighLow = new Vec2();
class GeometryHandler {
    constructor(layer) {
        this.__id = GeometryHandler.__counter__++;
        this._layer = layer;
        this._handler = null;
        this._geometries = [];
        this._updatedGeometryArr = [];
        this._updatedGeometry = {};
        this._removeGeometryExtentArr = [];
        this._removeGeometryExtents = {};
        // Polygon arrays
        this._polyVerticesHighMerc = [];
        this._polyVerticesLowMerc = [];
        this._polyColors = [];
        this._polyPickingColors = [];
        this._polyIndexes = [];
        // Line arrays
        this._lineVerticesHighMerc = [];
        this._lineVerticesLowMerc = [];
        this._lineOrders = [];
        this._lineIndexes = [];
        this._lineColors = [];
        this._linePickingColors = [];
        this._lineThickness = [];
        this._lineStrokes = [];
        this._lineStrokeColors = [];
        // Buffers
        this._polyVerticesHighBufferMerc = null;
        this._polyVerticesLowBufferMerc = null;
        this._polyColorsBuffer = null;
        this._polyPickingColorsBuffer = null;
        this._polyIndexesBuffer = null;
        this._lineVerticesHighBufferMerc = null;
        this._lineVerticesLowBufferMerc = null;
        this._lineColorsBuffer = null;
        this._linePickingColorsBuffer = null;
        this._lineThicknessBuffer = null;
        this._lineStrokesBuffer = null;
        this._lineStrokeColorsBuffer = null;
        this._lineOrdersBuffer = null;
        this._lineIndexesBuffer = null;
        this._buffersUpdateCallbacks = [];
        this._buffersUpdateCallbacks[POLYVERTICES_BUFFER] = this.createPolyVerticesBuffer;
        this._buffersUpdateCallbacks[POLYINDEXES_BUFFER] = this.createPolyIndexesBuffer;
        this._buffersUpdateCallbacks[POLYCOLORS_BUFFER] = this.createPolyColorsBuffer;
        this._buffersUpdateCallbacks[LINEVERTICES_BUFFER] = this.createLineVerticesBuffer;
        this._buffersUpdateCallbacks[LINEINDEXES_BUFFER] = this.createLineIndexesBuffer;
        this._buffersUpdateCallbacks[LINEORDERS_BUFFER] = this.createLineOrdersBuffer;
        this._buffersUpdateCallbacks[LINECOLORS_BUFFER] = this.createLineColorsBuffer;
        this._buffersUpdateCallbacks[LINETHICKNESS_BUFFER] = this.createLineThicknessBuffer;
        this._buffersUpdateCallbacks[LINESTROKES_BUFFER] = this.createLineStrokesBuffer;
        this._buffersUpdateCallbacks[LINESTROKECOLORS_BUFFER] = this.createLineStrokeColorsBuffer;
        this._buffersUpdateCallbacks[POLYPICKINGCOLORS_BUFFER] = this.createPolyPickingColorsBuffer;
        this._buffersUpdateCallbacks[LINEPICKINGCOLORS_BUFFER] = this.createLinePickingColorsBuffer;
        this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
    }
    static appendLineData(pathArr, isClosed, color, pickingColor, thickness, strokeColor, strokeSize, outVerticesHigh, outVerticesLow, outOrders, outIndexes, outColors, outPickingColors, outThickness, outStrokeColors, outStrokes, outVerticesHigh2, outVerticesLow2) {
        var index = 0;
        if (outIndexes.length > 0) {
            index = outIndexes[outIndexes.length - 5] + 9;
            outIndexes.push(index, index);
        }
        else {
            outIndexes.push(0, 0);
        }
        var t = thickness, c = [color.x, color.y, color.z, color.w], s = strokeSize, sc = [strokeColor.x, strokeColor.y, strokeColor.z, strokeColor.w], p = [pickingColor.x, pickingColor.y, pickingColor.z, 1.0];
        for (let j = 0; j < pathArr.length; j++) {
            var path = pathArr[j];
            if (path.length === 0) {
                continue;
            }
            let startIndex = index;
            let last;
            if (isClosed) {
                last = path[path.length - 1];
            }
            else {
                let p0 = path[0], p1 = path[1];
                if (!p1) {
                    p1 = p0;
                }
                last = [p0[0] + p0[0] - p1[0], p0[1] + p0[1] - p1[1]];
            }
            doubleToTwoFloats(last, tempHigh, tempLow);
            outVerticesHigh.push(tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y);
            outVerticesLow.push(tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y);
            outVerticesHigh2.push(tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y);
            outVerticesLow2.push(tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y);
            outOrders.push(1, -1, 2, -2);
            outThickness.push(t, t, t, t);
            outStrokes.push(s, s, s, s);
            outColors.push(c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3]);
            outStrokeColors.push(sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3]);
            outPickingColors.push(p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3]);
            for (let i = 0; i < path.length; i++) {
                let cur = path[i];
                doubleToTwoFloats(cur, tempHigh, tempLow);
                outVerticesHigh.push(tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y);
                outVerticesLow.push(tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y);
                outVerticesHigh2.push(tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y);
                outVerticesLow2.push(tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y);
                outOrders.push(1, -1, 2, -2);
                outThickness.push(t, t, t, t);
                outStrokes.push(s, s, s, s);
                outColors.push(c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3]);
                outStrokeColors.push(sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3]);
                outPickingColors.push(p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3]);
                outIndexes.push(index++, index++, index++, index++);
            }
            let first;
            if (isClosed) {
                first = path[0];
                outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
            }
            else {
                let p0 = path[path.length - 1], p1 = path[path.length - 2];
                if (!p1) {
                    p1 = p0;
                }
                first = [p0[0] + p0[0] - p1[0], p0[1] + p0[1] - p1[1]];
                outIndexes.push(index - 1, index - 1, index - 1, index - 1);
            }
            doubleToTwoFloats(first, tempHigh, tempLow);
            outVerticesHigh.push(tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y);
            outVerticesLow.push(tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y);
            outVerticesHigh2.push(tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y);
            outVerticesLow2.push(tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y);
            outOrders.push(1, -1, 2, -2);
            outThickness.push(t, t, t, t);
            outStrokes.push(s, s, s, s);
            outColors.push(c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3]);
            outStrokeColors.push(sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3]);
            outPickingColors.push(p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3]);
            if (j < pathArr.length - 1) {
                index += 8;
                outIndexes.push(index, index);
            }
        }
    }
    assignHandler(handler) {
        this._handler = handler;
        this.refresh();
        if (handler.isInitialized()) {
            this.update();
        }
    }
    /**
     * @public
     * @param {Geometry} geometry - Geometry object.
     */
    add(geometry) {
        //
        // Triangulates polygon and sets geometry data.
        if (geometry._handlerIndex === -1) {
            geometry._handler = this;
            geometry._handlerIndex = this._geometries.length;
            this._geometries.push(geometry);
            let pickingColor = geometry._entity._pickingColor.scaleTo(1 / 255);
            geometry._polyVerticesHighMerc = [];
            geometry._polyVerticesLowMerc = [];
            geometry._lineVerticesHighMerc = [];
            geometry._lineVerticesLowMerc = [];
            if (geometry._coordinates[0].length) {
                if (geometry.type === GeometryTypeEnum.POLYGON) {
                    let coordinates = geometry._coordinates;
                    let ci = [];
                    for (let j = 0; j < coordinates.length; j++) {
                        ci[j] = [];
                        for (let k = 0; k < coordinates[j].length; k++) {
                            ci[j][k] = [forward_lon(coordinates[j][k][0]), forward_lat(coordinates[j][k][1])];
                        }
                    }
                    let data = flatten(ci);
                    let indexes = earcut(data.vertices, data.holes, 2);
                    geometry._polyVerticesHandlerIndex = this._polyVerticesHighMerc.length;
                    geometry._polyIndexesHandlerIndex = this._polyIndexes.length;
                    for (let i = 0; i < indexes.length; i++) {
                        this._polyIndexes.push(indexes[i] + geometry._polyVerticesHandlerIndex * 0.5);
                    }
                    let color = geometry._style.fillColor;
                    let verticesHigh = [], verticesLow = [];
                    for (let i = 0; i < data.vertices.length * 0.5; i++) {
                        this._polyColors.push(color.x, color.y, color.z, color.w);
                        this._polyPickingColors.push(pickingColor.x, pickingColor.y, pickingColor.z, 1.0);
                    }
                    for (let i = 0; i < data.vertices.length; i++) {
                        doubleToTwoFloatsV2(data.vertices[i], tempHighLow);
                        verticesHigh[i] = tempHighLow.x;
                        verticesLow[i] = tempHighLow.y;
                    }
                    geometry._polyVerticesHighMerc = verticesHigh;
                    geometry._polyVerticesLowMerc = verticesLow;
                    this._polyVerticesHighMerc.push.apply(this._polyVerticesHighMerc, verticesHigh);
                    this._polyVerticesLowMerc.push.apply(this._polyVerticesLowMerc, verticesLow);
                    geometry._polyVerticesLength = data.vertices.length;
                    geometry._polyIndexesLength = indexes.length;
                    // Creates polygon stroke data
                    geometry._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
                    geometry._lineOrdersHandlerIndex = this._lineOrders.length;
                    geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
                    geometry._lineColorsHandlerIndex = this._lineColors.length;
                    geometry._lineThicknessHandlerIndex = this._lineThickness.length;
                    GeometryHandler.appendLineData(ci, true, geometry._style.lineColor, pickingColor, geometry._style.lineWidth, geometry._style.strokeColor, geometry._style.strokeWidth, this._lineVerticesHighMerc, this._lineVerticesLowMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors, this._lineThickness, this._lineStrokeColors, this._lineStrokes, geometry._lineVerticesHighMerc, geometry._lineVerticesLowMerc);
                    geometry._lineVerticesLength = this._lineVerticesHighMerc.length - geometry._lineVerticesHandlerIndex;
                    geometry._lineOrdersLength = this._lineOrders.length - geometry._lineOrdersHandlerIndex;
                    geometry._lineIndexesLength = this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
                    geometry._lineColorsLength = this._lineColors.length - geometry._lineColorsHandlerIndex;
                    geometry._lineThicknessLength = this._lineThickness.length - geometry._lineThicknessHandlerIndex;
                }
                else if (geometry.type === GeometryTypeEnum.MULTIPOLYGON) {
                    let coordinates = geometry._coordinates;
                    let vertices = [], indexes = [];
                    // Creates polygon stroke data
                    geometry._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
                    geometry._lineOrdersHandlerIndex = this._lineOrders.length;
                    geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
                    geometry._lineColorsHandlerIndex = this._lineColors.length;
                    geometry._lineThicknessHandlerIndex = this._lineThickness.length;
                    for (let i = 0; i < coordinates.length; i++) {
                        let cci = coordinates[i];
                        let ci = [];
                        for (let j = 0; j < cci.length; j++) {
                            ci[j] = [];
                            for (let k = 0; k < coordinates[i][j].length; k++) {
                                ci[j][k] = [forward_lon(cci[j][k][0]), forward_lat(cci[j][k][1])];
                            }
                        }
                        let data = flatten(ci);
                        let dataIndexes = earcut(data.vertices, data.holes, 2);
                        for (let j = 0; j < dataIndexes.length; j++) {
                            indexes.push(dataIndexes[j] + vertices.length * 0.5);
                        }
                        vertices.push.apply(vertices, data.vertices);
                        GeometryHandler.appendLineData(ci, true, geometry._style.lineColor, pickingColor, geometry._style.lineWidth, geometry._style.strokeColor, geometry._style.strokeWidth, this._lineVerticesHighMerc, this._lineVerticesLowMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors, this._lineThickness, this._lineStrokeColors, this._lineStrokes, geometry._lineVerticesHighMerc, geometry._lineVerticesLowMerc);
                    }
                    geometry._polyVerticesHandlerIndex = this._polyVerticesHighMerc.length;
                    geometry._polyIndexesHandlerIndex = this._polyIndexes.length;
                    for (let i = 0; i < indexes.length; i++) {
                        this._polyIndexes.push(indexes[i] + geometry._polyVerticesHandlerIndex * 0.5);
                    }
                    let color = geometry._style.fillColor;
                    let verticesHigh = [], verticesLow = [];
                    for (let i = 0; i < vertices.length * 0.5; i++) {
                        this._polyColors.push(color.x, color.y, color.z, color.w);
                        this._polyPickingColors.push(pickingColor.x, pickingColor.y, pickingColor.z, 1.0);
                    }
                    for (let i = 0; i < vertices.length; i++) {
                        doubleToTwoFloatsV2(vertices[i], tempHighLow);
                        verticesHigh[i] = tempHighLow.x;
                        verticesLow[i] = tempHighLow.y;
                    }
                    geometry._polyVerticesHighMerc = verticesHigh;
                    geometry._polyVerticesLowMerc = verticesLow;
                    this._polyVerticesHighMerc.push.apply(this._polyVerticesHighMerc, verticesHigh);
                    this._polyVerticesLowMerc.push.apply(this._polyVerticesLowMerc, verticesLow);
                    geometry._polyVerticesLength = vertices.length;
                    geometry._polyIndexesLength = indexes.length;
                    geometry._lineVerticesLength = this._lineVerticesHighMerc.length - geometry._lineVerticesHandlerIndex;
                    geometry._lineOrdersLength = this._lineOrders.length - geometry._lineOrdersHandlerIndex;
                    geometry._lineIndexesLength = this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
                    geometry._lineColorsLength = this._lineColors.length - geometry._lineColorsHandlerIndex;
                    geometry._lineThicknessLength = this._lineThickness.length - geometry._lineThicknessHandlerIndex;
                }
                else if (geometry.type === GeometryTypeEnum.LINESTRING) {
                    let coordinates = geometry._coordinates;
                    let ci = new Array(coordinates.length);
                    for (let j = 0; j < coordinates.length; j++) {
                        ci[j] = [forward_lon(coordinates[j][0]), forward_lat(coordinates[j][1])];
                    }
                    // Creates polygon stroke data
                    geometry._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
                    geometry._lineOrdersHandlerIndex = this._lineOrders.length;
                    geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
                    geometry._lineColorsHandlerIndex = this._lineColors.length;
                    geometry._lineThicknessHandlerIndex = this._lineThickness.length;
                    GeometryHandler.appendLineData([ci], false, geometry._style.lineColor, pickingColor, geometry._style.lineWidth, geometry._style.strokeColor, geometry._style.strokeWidth, this._lineVerticesHighMerc, this._lineVerticesLowMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors, this._lineThickness, this._lineStrokeColors, this._lineStrokes, geometry._lineVerticesHighMerc, geometry._lineVerticesLowMerc);
                    geometry._lineVerticesLength = this._lineVerticesHighMerc.length - geometry._lineVerticesHandlerIndex;
                    geometry._lineOrdersLength = this._lineOrders.length - geometry._lineOrdersHandlerIndex;
                    geometry._lineIndexesLength = this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
                    geometry._lineColorsLength = this._lineColors.length - geometry._lineColorsHandlerIndex;
                    geometry._lineThicknessLength = this._lineThickness.length - geometry._lineThicknessHandlerIndex;
                }
                else if (geometry.type === GeometryTypeEnum.MULTILINESTRING) {
                    let coordinates = geometry._coordinates;
                    let ci = [];
                    for (let j = 0; j < coordinates.length; j++) {
                        ci[j] = [];
                        for (let k = 0; k < coordinates[j].length; k++) {
                            ci[j][k] = [forward_lon(coordinates[j][k][0]), forward_lat(coordinates[j][k][1])];
                        }
                    }
                    // Creates polygon stroke data
                    geometry._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
                    geometry._lineOrdersHandlerIndex = this._lineOrders.length;
                    geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
                    geometry._lineColorsHandlerIndex = this._lineColors.length;
                    geometry._lineThicknessHandlerIndex = this._lineThickness.length;
                    GeometryHandler.appendLineData(ci, false, geometry._style.lineColor, pickingColor, geometry._style.lineWidth, geometry._style.strokeColor, geometry._style.strokeWidth, this._lineVerticesHighMerc, this._lineVerticesLowMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors, this._lineThickness, this._lineStrokeColors, this._lineStrokes, geometry._lineVerticesHighMerc, geometry._lineVerticesLowMerc);
                    geometry._lineVerticesLength = this._lineVerticesHighMerc.length - geometry._lineVerticesHandlerIndex;
                    geometry._lineOrdersLength = this._lineOrders.length - geometry._lineOrdersHandlerIndex;
                    geometry._lineIndexesLength = this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
                    geometry._lineColorsLength = this._lineColors.length - geometry._lineColorsHandlerIndex;
                    geometry._lineThicknessLength = this._lineThickness.length - geometry._lineThicknessHandlerIndex;
                }
            }
            // Refresh visibility
            this.setGeometryVisibility(geometry);
            !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
            this._updatedGeometry[geometry.__id] = true;
            this.refresh();
        }
    }
    remove(geometry) {
        const index = geometry._handlerIndex;
        if (index !== -1) {
            this._geometries.splice(index, 1);
            // polygon
            // this._polyVerticesLonLat.splice(geometry._polyVerticesHandlerIndex, geometry._polyVerticesLength);
            this._polyVerticesHighMerc.splice(geometry._polyVerticesHandlerIndex, geometry._polyVerticesLength);
            this._polyVerticesLowMerc.splice(geometry._polyVerticesHandlerIndex, geometry._polyVerticesLength);
            this._polyColors.splice(geometry._polyVerticesHandlerIndex * 2, geometry._polyVerticesLength * 2);
            this._polyPickingColors.splice(geometry._polyVerticesHandlerIndex * 2, geometry._polyVerticesLength * 2);
            this._polyIndexes.splice(geometry._polyIndexesHandlerIndex, geometry._polyIndexesLength);
            let di = geometry._polyVerticesLength * 0.5;
            for (let i = geometry._polyIndexesHandlerIndex; i < this._polyIndexes.length; i++) {
                this._polyIndexes[i] -= di;
            }
            // line
            // this._lineVerticesLonLat.splice(geometry._lineVerticesHandlerIndex, geometry._lineVerticesLength);
            this._lineVerticesHighMerc.splice(geometry._lineVerticesHandlerIndex, geometry._lineVerticesLength);
            this._lineVerticesLowMerc.splice(geometry._lineVerticesHandlerIndex, geometry._lineVerticesLength);
            this._lineOrders.splice(geometry._lineOrdersHandlerIndex, geometry._lineOrdersLength);
            this._lineColors.splice(geometry._lineColorsHandlerIndex, geometry._lineColorsLength);
            this._linePickingColors.splice(geometry._lineColorsHandlerIndex, geometry._lineColorsLength);
            this._lineStrokeColors.splice(geometry._lineColorsHandlerIndex, geometry._lineColorsLength);
            this._lineThickness.splice(geometry._lineThicknessHandlerIndex, geometry._lineThicknessLength);
            this._lineStrokes.splice(geometry._lineThicknessHandlerIndex, geometry._lineThicknessLength);
            this._lineIndexes.splice(geometry._lineIndexesHandlerIndex, geometry._lineIndexesLength);
            di = geometry._lineVerticesLength * 0.5;
            for (let i = geometry._lineIndexesHandlerIndex; i < this._lineIndexes.length; i++) {
                this._lineIndexes[i] -= di;
            }
            // reindex
            let g = this._geometries;
            for (let i = index; i < g.length; i++) {
                let gi = g[i];
                gi._handlerIndex = i;
                gi._polyVerticesHandlerIndex -= geometry._polyVerticesLength;
                gi._polyIndexesHandlerIndex -= geometry._polyIndexesLength;
                gi._lineVerticesHandlerIndex -= geometry._lineVerticesLength;
                gi._lineOrdersHandlerIndex -= geometry._lineOrdersLength;
                gi._lineColorsHandlerIndex -= geometry._lineColorsLength;
                gi._lineThicknessHandlerIndex -= geometry._lineThicknessLength;
                gi._lineIndexesHandlerIndex -= geometry._lineIndexesLength;
            }
            geometry._pickingReady = false;
            geometry._handler = null;
            geometry._handlerIndex = -1;
            geometry._polyVerticesHighMerc = [];
            geometry._polyVerticesLowMerc = [];
            geometry._polyVerticesLength = -1;
            geometry._polyIndexesLength = -1;
            geometry._polyVerticesHandlerIndex = -1;
            geometry._polyIndexesHandlerIndex = -1;
            geometry._lineVerticesHighMerc = [];
            geometry._lineVerticesLowMerc = [];
            geometry._lineVerticesLength = -1;
            geometry._lineOrdersLength = -1;
            geometry._lineIndexesLength = -1;
            geometry._lineColorsLength = -1;
            geometry._lineThicknessLength = -1;
            geometry._lineVerticesHandlerIndex = -1;
            geometry._lineOrdersHandlerIndex = -1;
            geometry._lineIndexesHandlerIndex = -1;
            geometry._lineThicknessHandlerIndex = -1;
            geometry._lineColorsHandlerIndex = -1;
            !this._removeGeometryExtents[geometry.__id] && this._removeGeometryExtentArr.push(geometry.getExtent());
            this._removeGeometryExtents[geometry.__id] = true;
            this.refresh();
        }
    }
    _refreshRecursevely(geometry, treeNode) {
        if (treeNode.ready) {
            let lid = this._layer._id;
            for (let i = 0; i < treeNode.nodes.length; i++) {
                let ni = treeNode.nodes[i];
                if (geometry.overlaps(ni.segment.getExtentLonLat())) {
                    this._refreshRecursevely(geometry, ni);
                    let m = ni.segment.materials[lid];
                    if (m && m.isReady) {
                        if (m.segment.node.getState() !== RENDERING) {
                            m.layer.clearMaterial(m);
                        }
                        else {
                            m.pickingReady = m.pickingReady && geometry._pickingReady;
                            m.isReady = false;
                            m._updateTexture = m.texture;
                            m._updatePickingMask = m.pickingMask;
                        }
                        geometry._pickingReady = true;
                    }
                }
            }
        }
    }
    _refreshRecursevelyExt(extent, treeNode) {
        if (treeNode.ready) {
            let lid = this._layer.__id;
            for (let i = 0; i < treeNode.nodes.length; i++) {
                let ni = treeNode.nodes[i];
                if (extent.overlaps(ni.segment.getExtentLonLat())) {
                    this._refreshRecursevelyExt(extent, ni);
                    let m = ni.segment.materials[lid];
                    if (m && m.isReady) {
                        m.layer.clearMaterial(m);
                        // m.pickingReady = false;
                        // m.isReady = false;
                        // m._updateTexture = m.texture;
                        // m._updatePickingMask = m.pickingMask;
                    }
                }
            }
        }
    }
    _refreshPlanetNode(treeNode) {
        let i;
        let e = this._removeGeometryExtentArr;
        for (i = 0; i < e.length; i++) {
            this._refreshRecursevelyExt(e[i], treeNode);
        }
        let g = this._updatedGeometryArr;
        for (i = 0; i < g.length; i++) {
            this._refreshRecursevely(g[i], treeNode);
        }
    }
    _updatePlanet() {
        let p = this._layer._planet;
        if (p) {
            let ql = p.quadTreeStrategy.quadTreeList;
            for (let i = 0; i < ql.length; i++) {
                this._refreshPlanetNode(ql[i]);
            }
            // p.quadTreeStrategy.quadTreeList.forEach((quadTree: Node) => {
            //     this._refreshPlanetNode(quadTree);
            // });
        }
        this._updatedGeometryArr.length = 0;
        this._updatedGeometryArr = [];
        this._updatedGeometry = {};
        this._removeGeometryExtentArr.length = 0;
        this._removeGeometryExtentArr = [];
        this._removeGeometryExtents = {};
    }
    refresh() {
        let i = this._changedBuffers.length;
        while (i--) {
            this._changedBuffers[i] = true;
        }
    }
    update() {
        if (this._handler) {
            let needUpdate = false;
            let i = this._changedBuffers.length;
            while (i--) {
                if (this._changedBuffers[i]) {
                    needUpdate = true;
                    this._buffersUpdateCallbacks[i].call(this);
                    this._changedBuffers[i] = false;
                }
            }
            needUpdate && this._updatePlanet();
        }
    }
    setGeometryVisibility(geometry) {
        let v = geometry.getVisibility() ? 1.0 : 0.0;
        let a = this._polyVerticesHighMerc, b = this._polyVerticesLowMerc;
        let l = geometry._polyVerticesLength;
        let ind = geometry._polyVerticesHandlerIndex;
        for (let i = 0; i < l; i++) {
            a[ind + i] = geometry._polyVerticesHighMerc[i] * v;
            b[ind + i] = geometry._polyVerticesLowMerc[i] * v;
        }
        a = this._lineVerticesHighMerc;
        b = this._lineVerticesLowMerc;
        l = geometry._lineVerticesLength;
        ind = geometry._lineVerticesHandlerIndex;
        for (let i = 0; i < l; i++) {
            a[ind + i] = geometry._lineVerticesHighMerc[i] * v;
            b[ind + i] = geometry._lineVerticesLowMerc[i] * v;
        }
        this._changedBuffers[POLYVERTICES_BUFFER] = true;
        this._changedBuffers[LINEVERTICES_BUFFER] = true;
        !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
        this._updatedGeometry[geometry.__id] = true;
    }
    setPolyColorArr(geometry, color) {
        let index = geometry._polyVerticesHandlerIndex * 2, // ... / 2 * 4
        size = index + geometry._polyVerticesLength * 2; // ... / 2 * 4
        let a = this._polyColors;
        for (let i = index; i < size; i += 4) {
            a[i] = color.x;
            a[i + 1] = color.y;
            a[i + 2] = color.z;
            a[i + 3] = color.w;
        }
        this._changedBuffers[POLYCOLORS_BUFFER] = true;
        !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
        this._updatedGeometry[geometry.__id] = true;
    }
    setLineStrokeColorArr(geometry, color) {
        let index = geometry._lineColorsHandlerIndex, size = index + geometry._lineColorsLength;
        let a = this._lineStrokeColors;
        for (let i = index; i < size; i += 4) {
            a[i] = color.x;
            a[i + 1] = color.y;
            a[i + 2] = color.z;
            a[i + 3] = color.w;
        }
        this._changedBuffers[LINESTROKECOLORS_BUFFER] = true;
        !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
        this._updatedGeometry[geometry.__id] = true;
    }
    setLineColorArr(geometry, color) {
        let index = geometry._lineColorsHandlerIndex, size = index + geometry._lineColorsLength;
        let a = this._lineColors;
        for (let i = index; i < size; i += 4) {
            a[i] = color.x;
            a[i + 1] = color.y;
            a[i + 2] = color.z;
            a[i + 3] = color.w;
        }
        this._changedBuffers[LINECOLORS_BUFFER] = true;
        !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
        this._updatedGeometry[geometry.__id] = true;
    }
    setLineStrokeArr(geometry, width) {
        // let index = geometry._lineStrokesHandlerIndex,
        //     size = index + geometry._lineStrokesLength;
        // let a = this._lineStrokes;
        // for (let i = index; i < size; i++) {
        //     a[i] = width;
        // }
        // this._changedBuffers[LINESTROKES_BUFFER] = true;
        // !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
        // this._updatedGeometry[geometry.__id] = true;
    }
    setLineThicknessArr(geometry, width) {
        let index = geometry._lineThicknessHandlerIndex, size = index + geometry._lineThicknessLength;
        let a = this._lineThickness;
        for (let i = index; i < size; i++) {
            a[i] = width;
        }
        this._changedBuffers[LINETHICKNESS_BUFFER] = true;
        !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
        this._updatedGeometry[geometry.__id] = true;
    }
    bringToFront(geometry) {
        let polyIndexes = this._polyIndexes.splice(geometry._polyIndexesHandlerIndex, geometry._polyIndexesLength);
        let lineIndexes = this._lineIndexes.splice(geometry._lineIndexesHandlerIndex, geometry._lineIndexesLength);
        this._geometries.splice(geometry._handlerIndex, 1);
        let g = this._geometries;
        for (let i = geometry._handlerIndex; i < g.length; i++) {
            let gi = g[i];
            gi._handlerIndex = i;
            gi._polyIndexesHandlerIndex -= geometry._polyIndexesLength;
            gi._lineIndexesHandlerIndex -= geometry._lineIndexesLength;
        }
        geometry._polyIndexesHandlerIndex = this._polyIndexes.length;
        geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
        geometry._handlerIndex = this._geometries.length;
        this._geometries.push(geometry);
        this._polyIndexes.push.apply(this._polyIndexes, polyIndexes);
        this._lineIndexes.push.apply(this._lineIndexes, lineIndexes);
        this._changedBuffers[POLYINDEXES_BUFFER] = true;
        this._changedBuffers[LINEINDEXES_BUFFER] = true;
        !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
        this._updatedGeometry[geometry.__id] = true;
    }
    createPolyVerticesBuffer() {
        let h = this._handler;
        h.gl.deleteBuffer(this._polyVerticesHighBufferMerc);
        this._polyVerticesHighBufferMerc = h.createArrayBuffer(new Float32Array(this._polyVerticesHighMerc), 2, this._polyVerticesHighMerc.length / 2);
        h.gl.deleteBuffer(this._polyVerticesLowBufferMerc);
        this._polyVerticesLowBufferMerc = h.createArrayBuffer(new Float32Array(this._polyVerticesLowMerc), 2, this._polyVerticesLowMerc.length / 2);
    }
    createPolyIndexesBuffer() {
        let h = this._handler;
        h.gl.deleteBuffer(this._polyIndexesBuffer);
        this._polyIndexesBuffer = h.createElementArrayBuffer(new Uint32Array(this._polyIndexes), 1, this._polyIndexes.length);
    }
    createPolyColorsBuffer() {
        let h = this._handler;
        h.gl.deleteBuffer(this._polyColorsBuffer);
        this._polyColorsBuffer = h.createArrayBuffer(new Float32Array(this._polyColors), 4, this._polyColors.length / 4);
    }
    createPolyPickingColorsBuffer() {
        let h = this._handler;
        h.gl.deleteBuffer(this._polyPickingColorsBuffer);
        this._polyPickingColorsBuffer = h.createArrayBuffer(new Float32Array(this._polyPickingColors), 4, this._polyPickingColors.length / 4);
    }
    createLineVerticesBuffer() {
        let h = this._handler;
        h.gl.deleteBuffer(this._lineVerticesHighBufferMerc);
        this._lineVerticesHighBufferMerc = h.createArrayBuffer(new Float32Array(this._lineVerticesHighMerc), 2, this._lineVerticesHighMerc.length / 2);
        h.gl.deleteBuffer(this._lineVerticesLowBufferMerc);
        this._lineVerticesLowBufferMerc = h.createArrayBuffer(new Float32Array(this._lineVerticesLowMerc), 2, this._lineVerticesLowMerc.length / 2);
    }
    createLineIndexesBuffer() {
        let h = this._handler;
        h.gl.deleteBuffer(this._lineIndexesBuffer);
        this._lineIndexesBuffer = h.createElementArrayBuffer(new Uint32Array(this._lineIndexes), 1, this._lineIndexes.length);
    }
    createLineOrdersBuffer() {
        let h = this._handler;
        h.gl.deleteBuffer(this._lineOrdersBuffer);
        this._lineOrdersBuffer = h.createArrayBuffer(new Float32Array(this._lineOrders), 1, this._lineOrders.length / 2);
    }
    createLineColorsBuffer() {
        let h = this._handler;
        h.gl.deleteBuffer(this._lineColorsBuffer);
        this._lineColorsBuffer = h.createArrayBuffer(new Float32Array(this._lineColors), 4, this._lineColors.length / 4);
    }
    createLinePickingColorsBuffer() {
        let h = this._handler;
        h.gl.deleteBuffer(this._linePickingColorsBuffer);
        this._linePickingColorsBuffer = h.createArrayBuffer(new Float32Array(this._linePickingColors), 4, this._linePickingColors.length / 4);
    }
    createLineThicknessBuffer() {
        let h = this._handler;
        h.gl.deleteBuffer(this._lineThicknessBuffer);
        this._lineThicknessBuffer = h.createArrayBuffer(new Float32Array(this._lineThickness), 1, this._lineThickness.length);
    }
    createLineStrokesBuffer() {
        let h = this._handler;
        h.gl.deleteBuffer(this._lineStrokesBuffer);
        this._lineStrokesBuffer = h.createArrayBuffer(new Float32Array(this._lineStrokes), 1, this._lineStrokes.length);
    }
    createLineStrokeColorsBuffer() {
        let h = this._handler;
        h.gl.deleteBuffer(this._lineStrokeColorsBuffer);
        this._lineStrokeColorsBuffer = h.createArrayBuffer(new Float32Array(this._lineStrokeColors), 4, this._lineStrokeColors.length / 4);
    }
    clear() {
        this._geometries = [];
        this._polyVerticesHighMerc = [];
        this._polyVerticesLowMerc = [];
        this._polyIndexes = [];
        this._polyColors = [];
        this._polyPickingColors = [];
        this._lineVerticesHighMerc = [];
        this._lineVerticesLowMerc = [];
        this._lineOrders = [];
        this._lineIndexes = [];
        this._lineColors = [];
        this._linePickingColors = [];
        this._lineThickness = [];
        this._lineStrokeColors = [];
        this._lineStrokes = [];
        this._deleteBuffers();
        this._polyVerticesHighBufferMerc = null;
        this._polyVerticesLowBufferMerc = null;
        this._polyIndexesBuffer = null;
        this._polyColorsBuffer = null;
        this._polyPickingColorsBuffer = null;
        this._lineVerticesHighBufferMerc = null;
        this._lineVerticesLowBufferMerc = null;
        this._lineIndexesBuffer = null;
        this._lineOrdersBuffer = null;
        this._lineColorsBuffer = null;
        this._linePickingColorsBuffer = null;
        this._lineThicknessBuffer = null;
        this._lineStrokeColorsBuffer = null;
        this._lineStrokesBuffer = null;
        this._updatedGeometryArr = [];
        this._updatedGeometry = {};
        this._removeGeometryExtentArr = [];
        this._removeGeometryExtents = {};
        this.refresh();
    }
    _deleteBuffers() {
        if (this._layer._planet && this._layer._planet.renderer) {
            let h = this._layer._planet.renderer.handler, gl = h.gl;
            if (gl) {
                gl.deleteBuffer(this._polyVerticesHighBufferMerc);
                gl.deleteBuffer(this._polyVerticesLowBufferMerc);
                gl.deleteBuffer(this._polyIndexesBuffer);
                gl.deleteBuffer(this._polyColorsBuffer);
                gl.deleteBuffer(this._polyPickingColorsBuffer);
                gl.deleteBuffer(this._lineVerticesHighBufferMerc);
                gl.deleteBuffer(this._lineVerticesLowBufferMerc);
                gl.deleteBuffer(this._lineIndexesBuffer);
                gl.deleteBuffer(this._lineOrdersBuffer);
                gl.deleteBuffer(this._lineColorsBuffer);
                gl.deleteBuffer(this._linePickingColorsBuffer);
                gl.deleteBuffer(this._lineThicknessBuffer);
                gl.deleteBuffer(this._lineStrokeColorsBuffer);
                gl.deleteBuffer(this._lineStrokesBuffer);
            }
        }
    }
}
GeometryHandler.__counter__ = 0;

/**
 * Creates entity instance array.
 * @param {Entity[] | IEntityParams[]} entities - Entity array.
 * @returns {Entity[]} - Entity array.
 */
function _entitiesConstructor(entities) {
    let res = [];
    for (let i = 0; i < entities.length; i++) {
        let ei = entities[i];
        if (ei.instanceName === "Entity") {
            res.push(ei);
        }
        else {
            res.push(new Entity(ei));
        }
    }
    return res;
}
/**
 * Vector layer represents alternative entities store. Used for geospatial data rendering like
 * points, lines, polygons, geometry objects etc.
 * @class
 * @extends {Layer}
 * @param {string} [name="noname"] - Layer name.
 * @param {IVectorParams} [options] - Layer options:
 * @param {number} [options.minZoom=0] - Minimal visible zoom. 0 is default
 * @param {number} [options.maxZoom=50] - Maximal visible zoom. 50 is default.
 * @param {string} [options.attribution] - Layer attribution.
 * @param {string} [options.zIndex=0] - Layer Z-order index. 0 is default.
 * @param {boolean} [options.visibility=true] - Layer visibility. True is default.
 * @param {boolean} [options.isBaseLayer=false] - Layer base layer. False is default.
 * @param {Array.<Entity>} [options.entities] - Entities array.
 * @param {Array.<number>} [options.scaleByDistance] - Scale by distance parameters. (exactly 3 entries)
 *      First index - near distance to the entity, after entity becomes full scale.
 *      Second index - far distance to the entity, when entity becomes zero scale.
 *      Third index - far distance to the entity, when entity becomes invisible.
 *      Use [1.0, 1.0, 1.0] for real sized objects
 * @param {number} [options.nodeCapacity=30] - Maximum entities quantity in the tree node. Rendering optimization parameter. 30 is default.
 * @param {boolean} [options.async=true] - Asynchronous vector data handling before rendering. True for optimization huge data.
 * @param {boolean} [options.clampToGround = false] - Clamp vector data to the ground.
 * @param {boolean} [options.relativeToGround = false] - Place vector data relative to the ground relief.
 * @param {Number} [options.polygonOffsetUnits=0.0] - The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset.
 *
 * //@fires EventsHandler<VectorEventsList>#entitymove
 * @fires EventsHandler<VectorEventsList>#draw
 * @fires EventsHandler<VectorEventsList>#add
 * @fires EventsHandler<VectorEventsList>#remove
 * @fires EventsHandler<VectorEventsList>#entityadd
 * @fires EventsHandler<VectorEventsList>#entityremove
 * @fires EventsHandler<VectorEventsList>#visibilitychange
 */
class Vector extends Layer {
    constructor(name, options = {}) {
        super(name, options);
        // @ts-ignore
        this.events = this.events.registerNames(VECTOR_EVENTS);
        this.isVector = true;
        this._hasImageryTiles = false;
        this.scaleByDistance = options.scaleByDistance || [MAX32, MAX32, MAX32];
        this._useLighting = options.useLighting !== undefined ? options.useLighting : true;
        let pickingScale = new Float32Array([1.0, 1.0, 1.0]);
        if (options.pickingScale !== undefined) {
            if (options.pickingScale instanceof Array) {
                pickingScale[0] = options.pickingScale[0] || pickingScale[0];
                pickingScale[1] = options.pickingScale[1] || pickingScale[1];
                pickingScale[2] = options.pickingScale[2] || pickingScale[2];
            }
            else if (typeof options.pickingScale === 'number') {
                pickingScale[0] = options.pickingScale;
                pickingScale[1] = options.pickingScale;
                pickingScale[2] = options.pickingScale;
            }
        }
        this.pickingScale = pickingScale;
        this.async = options.async !== undefined ? options.async : true;
        this.clampToGround = options.clampToGround || false;
        this.relativeToGround = options.relativeToGround || false;
        this._entities = _entitiesConstructor(options.entities || []);
        this._labelMaxLetters = options.labelMaxLetters || 24;
        this._stripEntityCollection = new EntityCollection({
            pickingEnabled: this.pickingEnabled
        });
        this._bindEventsDefault(this._stripEntityCollection);
        this._polylineEntityCollection = new EntityCollection({
            pickingEnabled: this.pickingEnabled
        });
        this._bindEventsDefault(this._polylineEntityCollection);
        this._geoObjectEntityCollection = new EntityCollection({
            pickingEnabled: this.pickingEnabled,
            useLighting: this._useLighting
        });
        this._bindEventsDefault(this._geoObjectEntityCollection);
        this._geometryHandler = new GeometryHandler(this);
        this._nodeCapacity = options.nodeCapacity || 60;
        this._entityCollectionsTreeStrategy = null;
        this.setEntities(this._entities);
        this.polygonOffsetUnits = options.polygonOffsetUnits != undefined ? options.polygonOffsetUnits : 0.0;
        this.pickingEnabled = this._pickingEnabled;
    }
    get useLighting() {
        return this._useLighting;
    }
    set useLighting(f) {
        if (f !== this._useLighting) {
            this._geoObjectEntityCollection.useLighting = f;
            this._useLighting = f;
        }
    }
    get labelMaxLetters() {
        return this._labelMaxLetters;
    }
    get instanceName() {
        return "Vector";
    }
    _bindPicking() {
        this._pickingColor.clear();
    }
    /**
     * Adds layer to the planet.
     * @public
     * @param {Planet} planet - Planet scene object.
     * @returns {Vector} -
     */
    addTo(planet) {
        if (!this._planet) {
            this._assignPlanet(planet);
            this._geometryHandler.assignHandler(planet.renderer.handler);
            this._polylineEntityCollection.addTo(planet, true);
            this._stripEntityCollection.addTo(planet, true);
            this._geoObjectEntityCollection.addTo(planet, true);
            this.setEntities(this._entities);
        }
    }
    remove() {
        super.remove();
        this._polylineEntityCollection.remove();
        this._stripEntityCollection.remove();
        this._geoObjectEntityCollection.remove();
        return this;
    }
    /**
     * Returns stored entities.
     * @public
     * @returns {Array.<Entity>} -
     */
    getEntities() {
        return [].concat(this._entities);
    }
    /**
     * Adds entity to the layer.
     * @public
     * @param {Entity} entity - Entity.
     * @param {boolean} [rightNow=false] - Entity insertion option. False is default.
     * @returns {Vector} - Returns this layer.
     */
    add(entity, rightNow = false) {
        if (!(entity._layer || entity._entityCollection)) {
            entity._layer = this;
            entity._layerIndex = this._entities.length;
            //this._fitExtent(entity);
            this._entities.push(entity);
            this._proceedEntity(entity, rightNow);
        }
        return this;
    }
    /**
     * Adds entity to the layer in the index position.
     * @public
     * @param {Entity} entity - Entity.
     * @param {Number} index - Index position.
     * @param {boolean} [rightNow] - Entity insertion option. False is default.
     * @returns {Vector} - Returns this layer.
     */
    insert(entity, index, rightNow = false) {
        if (!(entity._layer || entity._entityCollection)) {
            entity._layer = this;
            entity._layerIndex = index;
            //this._fitExtent(entity);
            this._entities.splice(index, 0, entity);
            for (let i = index + 1, len = this._entities.length; i < len; i++) {
                this._entities[i]._layerIndex = i;
            }
            this._proceedEntity(entity, rightNow);
        }
        return this;
    }
    _proceedEntity(entity, rightNow = false) {
        let temp = this._hasImageryTiles;
        let isEmpty = !(entity.strip || entity.polyline || entity.ray || entity.geoObject || entity.geometry);
        if (entity.strip) {
            this._stripEntityCollection.add(entity);
        }
        if (entity.polyline || entity.ray) {
            this._polylineEntityCollection.add(entity);
        }
        if (entity.geoObject || isEmpty) {
            this._geoObjectEntityCollection.add(entity);
        }
        if (entity.geometry) {
            this._hasImageryTiles = true;
            if (this._planet) {
                this._planet.renderer.assignPickingColor(entity);
                this._geometryHandler.add(entity.geometry);
            }
        }
        if (this._planet) {
            if (entity.billboard || entity.label || entity.geoObject || isEmpty) {
                if (entity._cartesian.isZero() && !entity._lonLat.isZero()) {
                    entity._setCartesian3vSilent(this._planet.ellipsoid.lonLatToCartesian(entity._lonLat));
                }
                else {
                    entity._lonLat = this._planet.ellipsoid.cartesianToLonLat(entity._cartesian);
                    // IT's important event for degrees proj strategies
                    if (Math.abs(entity._lonLat.lat) < MAX_LAT) {
                        entity._lonLatMerc = entity._lonLat.forwardMercator();
                    }
                    else {
                        entity._lonLatMerc.lon = entity._lonLatMerc.lat = entity._lonLatMerc.height = 0;
                    }
                }
            }
            if (entity.billboard || entity.label) {
                this._entityCollectionsTreeStrategy?.insertEntity(entity);
            }
        }
        if (this._planet && this._hasImageryTiles !== temp) {
            this._planet.updateVisibleLayers();
        }
        this.events.dispatch(this.events.entityadd, entity);
    }
    /**
     * Adds entity array to the layer.
     * @public
     * @param {Array.<Entity>} entities - Entities array.
     * @param {boolean} [rightNow=false] - Entity insertion option. False is default.
     * @returns {Vector} - Returns this layer.
     */
    addEntities(entities, rightNow = false) {
        let i = entities.length;
        while (i--) {
            this.add(entities[i], rightNow);
        }
        return this;
    }
    /**
     * Remove entity from layer.
     * TODO: memory leaks.
     * @public
     * @param {Entity} entity - Entity to remove.
     * @returns {Vector} - Returns this layer.
     */
    removeEntity(entity) {
        if (entity._layer && this.isEqual(entity._layer)) {
            this._entities.splice(entity._layerIndex, 1);
            this._reindexEntitiesArray(entity._layerIndex);
            entity._layer = null;
            entity._layerIndex = -1;
            if (entity._entityCollection) {
                entity._entityCollection._removeEntitySilent(entity);
                let node = entity._nodePtr;
                while (node) {
                    node.count--;
                    node = node.parentNode;
                }
                if (entity._nodePtr &&
                    entity._nodePtr.count === 0 &&
                    entity._nodePtr.deferredEntities.length === 0) {
                    entity._nodePtr.entityCollection = null;
                    //
                    // ...
                    //
                }
            }
            else if (entity._nodePtr && entity._nodePtr.deferredEntities.length) {
                let defEntities = entity._nodePtr.deferredEntities;
                let j = defEntities.length;
                while (j--) {
                    if (defEntities[j].id === entity.id) {
                        defEntities.splice(j, 1);
                        let node = entity._nodePtr;
                        while (node) {
                            node.count--;
                            node = node.parentNode;
                        }
                        break;
                    }
                }
            }
            if (this._planet && entity.geometry) {
                this._geometryHandler.remove(entity.geometry);
                this._planet.renderer.clearPickingColor(entity);
            }
            entity._nodePtr = undefined;
            this.events.dispatch(this.events.entityremove, entity);
        }
        return this;
    }
    /**
     * Set layer picking events active.
     * @public
     * @param {boolean} picking - Picking enable flag.
     */
    set pickingEnabled(picking) {
        this._pickingEnabled = picking;
        this._stripEntityCollection.setPickingEnabled(picking);
        this._polylineEntityCollection.setPickingEnabled(picking);
        this._geoObjectEntityCollection.setPickingEnabled(picking);
        this._entityCollectionsTreeStrategy?.setPickingEnabled(picking);
    }
    /**
     * Refresh collected entities indexes from startIndex entities collection array position.
     * @protected
     * @param {number} startIndex - Entity array index.
     */
    _reindexEntitiesArray(startIndex) {
        const e = this._entities;
        for (let i = startIndex; i < e.length; i++) {
            e[i]._layerIndex = i;
        }
    }
    /**
     * Removes entities from layer.
     * @public
     * @param {Array.<Entity>} entities - Entity array.
     * @returns {Vector} - Returns this layer.
     */
    removeEntities(entities) {
        let i = entities.length;
        while (i--) {
            this.removeEntity(entities[i]);
        }
        return this;
    }
    /**
     * Clear the layer.
     * @public
     */
    clear() {
        super.clear();
        let temp = new Array(this._entities.length);
        for (let i = 0; i < temp.length; i++) {
            temp[i] = this._entities[i];
        }
        let i = this._entities.length;
        while (i--) {
            this._entities[i].remove();
        }
        this._entities.length = 0;
        this._entities = [];
        for (let i = 0; i < temp.length; i++) {
            this._entities[i] = temp[i];
        }
        this._entityCollectionsTreeStrategy?.dispose();
        this._entityCollectionsTreeStrategy = null;
        this._geometryHandler.clear();
    }
    /**
     * Safety entities loop.
     * @public
     * @param {(entity: Entity, index?: number) => void} callback - Entity callback.
     */
    each(callback) {
        let e = this._entities;
        let i = e.length;
        while (i--) {
            callback(e[i], i);
        }
    }
    /**
     * Removes current entities from layer and adds new entities.
     * @public
     * @param {Array.<Entity>} entities - New entity array.
     * @returns {Vector} - Returns layer instance.
     */
    setEntities(entities) {
        let temp = new Array(entities.length);
        for (let i = 0, len = entities.length; i < len; i++) {
            temp[i] = entities[i];
        }
        this.clear();
        this._entities = new Array(temp.length);
        let entitiesForTree = [];
        for (let i = 0; i < temp.length; i++) {
            let ei = temp[i];
            ei._layer = this;
            ei._layerIndex = i;
            let isEmpty = !(ei.strip || ei.polyline || ei.ray || ei.geoObject || ei.billboard || ei.label);
            if (ei.strip) {
                this._stripEntityCollection.add(ei);
            }
            else if (ei.polyline || ei.ray) {
                this._polylineEntityCollection.add(ei);
            }
            else if (ei.geoObject || isEmpty) {
                this._geoObjectEntityCollection.add(ei);
            }
            else if (ei.billboard || ei.label) {
                entitiesForTree.push(ei);
            }
            if (ei.geometry) {
                this._hasImageryTiles = true;
                if (this._planet) {
                    this._planet.renderer.assignPickingColor(ei);
                    this._geometryHandler.add(ei.geometry);
                }
            }
            this._entities[i] = ei;
        }
        this._createEntityCollectionsTree(entitiesForTree);
        return this;
    }
    _createEntityCollectionsTree(entitiesForTree) {
        if (this._planet) {
            this._entityCollectionsTreeStrategy = this._planet.quadTreeStrategy.createEntitiCollectionsTreeStrategy(this, this._nodeCapacity);
            this._entityCollectionsTreeStrategy.insertEntities(entitiesForTree);
        }
    }
    /**
     * @todo (refactoring) could be used in something like bindEntityCollectionQuad(...)
     * @param entityCollection
     */
    _bindEventsDefault(entityCollection) {
        let ve = this.events;
        //
        // @todo: replace with arrow functions and '...e'
        //
        // entityCollection.events.on("entitymove", (e: any) => {
        //     ve.dispatch(ve.entitymove, e);
        // });
        entityCollection.events.on("mousemove", (e) => {
            ve.dispatch(ve.mousemove, e);
        });
        entityCollection.events.on("mouseenter", (e) => {
            ve.dispatch(ve.mouseenter, e);
        });
        entityCollection.events.on("mouseleave", (e) => {
            ve.dispatch(ve.mouseleave, e);
        });
        entityCollection.events.on("lclick", (e) => {
            ve.dispatch(ve.lclick, e);
        });
        entityCollection.events.on("rclick", (e) => {
            ve.dispatch(ve.rclick, e);
        });
        entityCollection.events.on("mclick", (e) => {
            ve.dispatch(ve.mclick, e);
        });
        entityCollection.events.on("ldblclick", (e) => {
            ve.dispatch(ve.ldblclick, e);
        });
        entityCollection.events.on("rdblclick", (e) => {
            ve.dispatch(ve.rdblclick, e);
        });
        entityCollection.events.on("mdblclick", (e) => {
            ve.dispatch(ve.mdblclick, e);
        });
        entityCollection.events.on("lup", (e) => {
            ve.dispatch(ve.lup, e);
        });
        entityCollection.events.on("rup", (e) => {
            ve.dispatch(ve.rup, e);
        });
        entityCollection.events.on("mup", (e) => {
            ve.dispatch(ve.mup, e);
        });
        entityCollection.events.on("ldown", (e) => {
            ve.dispatch(ve.ldown, e);
        });
        entityCollection.events.on("rdown", (e) => {
            ve.dispatch(ve.rdown, e);
        });
        entityCollection.events.on("mdown", (e) => {
            ve.dispatch(ve.mdown, e);
        });
        entityCollection.events.on("lhold", (e) => {
            ve.dispatch(ve.lhold, e);
        });
        entityCollection.events.on("rhold", (e) => {
            ve.dispatch(ve.rhold, e);
        });
        entityCollection.events.on("mhold", (e) => {
            ve.dispatch(ve.mhold, e);
        });
        entityCollection.events.on("mousewheel", (e) => {
            ve.dispatch(ve.mousewheel, e);
        });
        entityCollection.events.on("touchmove", (e) => {
            ve.dispatch(ve.touchmove, e);
        });
        entityCollection.events.on("touchstart", (e) => {
            ve.dispatch(ve.touchstart, e);
        });
        entityCollection.events.on("touchend", (e) => {
            ve.dispatch(ve.touchend, e);
        });
        entityCollection.events.on("doubletouch", (e) => {
            ve.dispatch(ve.doubletouch, e);
        });
        entityCollection.events.on("touchleave", (e) => {
            ve.dispatch(ve.touchleave, e);
        });
        entityCollection.events.on("touchenter", (e) => {
            ve.dispatch(ve.touchenter, e);
        });
    }
    _collectStripCollectionPASS(outArr) {
        let ec = this._stripEntityCollection;
        ec._fadingOpacity = this._fadingOpacity;
        ec.scaleByDistance = this.scaleByDistance;
        ec.pickingScale = this.pickingScale;
        ec.polygonOffsetUnits = this.polygonOffsetUnits;
        outArr.push(ec);
    }
    _collectPolylineCollectionPASS(outArr) {
        let ec = this._polylineEntityCollection;
        ec._fadingOpacity = this._fadingOpacity;
        ec.scaleByDistance = this.scaleByDistance;
        ec.pickingScale = this.pickingScale;
        ec.polygonOffsetUnits = this.polygonOffsetUnits;
        outArr.push(ec);
        if (this.clampToGround || this.relativeToGround) {
            let rtg = Number(this.relativeToGround);
            const nodes = this._planet._renderedNodes;
            const visibleExtent = this._planet.getViewExtent();
            let e = ec._entities;
            let e_i = e.length;
            let res = new Vec3();
            while (e_i--) {
                let p = e[e_i].polyline;
                if (p && visibleExtent.overlaps(p._extent)) {
                    // TODO:this works only for mercator area.
                    // needs to be working on poles.
                    let coords = p._pathLonLatMerc, c_j = coords.length;
                    while (c_j--) {
                        let c_j_h = coords[c_j].length;
                        while (c_j_h--) {
                            let ll = coords[c_j][c_j_h], n_k = nodes.length;
                            while (n_k--) {
                                let seg = nodes[n_k].segment;
                                if (seg._extent.isInside(ll)) {
                                    let cart = p._path3v[c_j][c_j_h];
                                    seg.getTerrainPoint(cart, ll, res);
                                    let alt = (rtg && p.altitude) || 0.0;
                                    if (alt) {
                                        let n = this._planet.ellipsoid.getSurfaceNormal3v(res);
                                        p.setPoint3v(res.addA(n.scale(alt)), c_j_h, c_j, true);
                                    }
                                    else {
                                        p.setPoint3v(res, c_j_h, c_j, true);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    _collectGeoObjectCollectionPASS(outArr) {
        let ec = this._geoObjectEntityCollection;
        ec._fadingOpacity = this._fadingOpacity;
        ec.scaleByDistance = this.scaleByDistance;
        ec.pickingScale = this.pickingScale;
        ec.polygonOffsetUnits = this.polygonOffsetUnits;
        outArr.push(ec);
        // if (this.clampToGround || this.relativeToGround) {
        //     let rtg = Number(this.relativeToGround);
        //
        //     var nodes = this._planet._renderedNodes;
        //     var visibleExtent = this._planet.getViewExtent();
        //     var e = ec._entities;
        //     var e_i = e.length;
        //     let res = new Vec3();
        //
        //     while (e_i--) {
        //         var p = e[e_i].polyline;
        //         if (visibleExtent.overlaps(p._extent)) {
        //             // TODO:this works only for mercator area.
        //             // needs to be working on poles.
        //             let coords = p._pathLonLatMerc,
        //                 c_j = coords.length;
        //             while (c_j--) {
        //                 var c_j_h = coords[c_j].length;
        //                 while (c_j_h--) {
        //                     let ll = coords[c_j][c_j_h],
        //                         n_k = nodes.length;
        //                     while (n_k--) {
        //                         var seg = nodes[n_k].segment;
        //                         if (seg._extent.isInside(ll)) {
        //                             let cart = p._path3v[c_j][c_j_h];
        //                             seg.getTerrainPoint(cart, ll, res);
        //                             p.setPoint3v(
        //                                 res.addA(res.normal().scale((rtg && p.altitude) || 0.0)),
        //                                 c_j_h,
        //                                 c_j,
        //                                 true
        //                             );
        //                             break;
        //                         }
        //                     }
        //                 }
        //             }
        //         }
        //     }
        // }
    }
    collectVisibleCollections(outArr) {
        let p = this._planet;
        if ((this._fading && this._fadingOpacity > 0.0) ||
            (this.minZoom <= p.maxCurrZoom && this.maxZoom >= p.maxCurrZoom)) {
            // Common collections first
            this._collectStripCollectionPASS(outArr);
            this._collectPolylineCollectionPASS(outArr);
            this._collectGeoObjectCollectionPASS(outArr);
            if (this._entityCollectionsTreeStrategy) {
                this._entityCollectionsTreeStrategy.collectVisibleEntityCollections(outArr);
            }
        }
    }
    /**
     * Start to load tile material.
     * @public
     * @virtual
     * @param {Material} material - Current material.
     */
    loadMaterial(material) {
        const seg = material.segment;
        if (this._isBaseLayer) {
            material.texture = seg._isNorth ? seg.planet.solidTextureOne : seg.planet.solidTextureTwo;
        }
        else {
            material.texture = seg.planet.transparentTexture;
        }
        if (this._planet.layerLock.isFree()) {
            material.isReady = false;
            material.isLoading = true;
            this._planet._vectorTileCreator.add(material);
        }
    }
    /**
     * Abort exact material loading.
     * @public
     * @override
     * @param {Material} material - Segment material.
     */
    abortMaterialLoading(material) {
        material.isLoading = false;
        material.isReady = false;
    }
    applyMaterial(material, isForced = false) {
        if (material.isReady) {
            return [0, 0, 1, 1];
        }
        else {
            !material.isLoading && this.loadMaterial(material);
            const segment = material.segment;
            let pn = segment.node, notEmpty = false;
            let mId = this.__id;
            let psegm = material;
            while (pn.parentNode) {
                if (psegm && psegm.isReady) {
                    notEmpty = true;
                    break;
                }
                pn = pn.parentNode;
                psegm = pn.segment.materials[mId];
            }
            if (notEmpty) {
                material.appliedNodeId = pn.nodeId;
                material.texture = psegm.texture;
                material.pickingMask = psegm.pickingMask;
                const dZ2 = 1.0 / (2 << (segment.tileZoom - pn.segment.tileZoom - 1));
                return [
                    segment.tileX * dZ2 - pn.segment.tileX,
                    segment.tileY * dZ2 - pn.segment.tileY,
                    dZ2,
                    dZ2
                ];
            }
            else {
                if (material.textureExists && material._updateTexture) {
                    material.texture = material._updateTexture;
                    material.pickingMask = material._updatePickingMask;
                }
                else {
                    material.texture = segment.planet.transparentTexture;
                    material.pickingMask = segment.planet.transparentTexture;
                }
                material.pickingReady = true;
                return [0, 0, 1, 1];
            }
        }
    }
    clearMaterial(material) {
        if (material.isReady) {
            const gl = material.segment.handler.gl;
            material.isReady = false;
            material.pickingReady = false;
            let t = material.texture;
            material.texture = null;
            t && !t.default && gl.deleteTexture(t);
            t = material.pickingMask;
            material.pickingMask = null;
            t && !t.default && gl.deleteTexture(t);
            t = material._updateTexture;
            material._updateTexture = null;
            t && !t.default && gl.deleteTexture(t);
            t = material._updatePickingMask;
            material._updatePickingMask = null;
            t && !t.default && gl.deleteTexture(t);
        }
        this.abortMaterialLoading(material);
        material.isLoading = false;
        material.textureExists = false;
    }
    update() {
        this._geometryHandler.update();
        this.events.dispatch(this.events.draw, this);
    }
}
const VECTOR_EVENTS = [
    // /**
    //  * Triggered when entity has moved.
    //  * @event EventsHandler<VectorEventsList>#draw
    //  */
    // "entitymove",
    /**
     * Triggered when layer begin draw.
     * @event EventsHandler<VectorEventsList>#draw
     */
    "draw",
    /**
     * Triggered when new entity added to the layer.
     * @event EventsHandler<VectorEventsList>#entityadd
     */
    "entityadd",
    /**
     * Triggered when entity removes from the collection.
     * @event EventsHandler<VectorEventsList>#entityremove
     */
    "entityremove"
];

const POLYGONDRAWINGSCENE_EVENTS = ["change", "startpoint"];
const POINTER_OBJ3D = Object3d.createCylinder(1, 1, 2.0, 20, 1, true, false, 0, -0.5, 0);
const NUM_SEGMENTS = 200;
const OUTLINE_ALT = 0.3;
const COORDINATES_COLOR = "rgb(350, 350, 0)";
const CENTER_COLOR = "rgb(0, 350, 50)";
const OUTLINE_COLOR = "rgb(0, 350, 50)";
const OUTLINE_THICKNESS = 3.5;
const CORNER_OPTIONS = {
    scale: 0.5,
    instanced: true,
    tag: "corners",
    color: COORDINATES_COLOR,
    object3d: POINTER_OBJ3D
};
const CENTER_OPTIONS = {
    scale: 0.4,
    instanced: true,
    tag: "centers",
    color: CENTER_COLOR,
    object3d: POINTER_OBJ3D
};
const OUTLINE_OPTIONS = {
    thickness: OUTLINE_THICKNESS,
    color: OUTLINE_COLOR
};
class PolygonDrawingScene extends RenderNode {
    constructor(options) {
        super(options.name);
        this._cornerDblClick = false;
        this._onChange = (e) => {
            if (e.geometryType === "POLYGON") {
                let coords = this.getCoordinates();
                let entity = new Entity({
                    'geometry': {
                        'type': e.geometryType,
                        'coordinates': [coords],
                        'style': {
                            'fillColor': "rgba(0,146,247,0.2)"
                        }
                    }
                });
                this._geometryLayer.clear();
                this._geometryLayer.add(entity);
            }
        };
        this._onCornerMouseEnter = (e) => {
            e.renderer.handler.canvas.style.cursor = "pointer";
            this.hideGhostPointer();
        };
        this._onCornerMouseLeave = (e) => {
            e.renderer.handler.canvas.style.cursor = "default";
            this.showGhostPointer();
        };
        this._onCenterMouseEnter = (e) => {
            e.renderer.handler.canvas.style.cursor = "pointer";
            this.hideGhostPointer();
        };
        this._onCenterMouseLeave = (e) => {
            e.renderer.handler.canvas.style.cursor = "default";
            if (!(this._pickedCenter || this._pickedCorner)) {
                this.showGhostPointer();
            }
        };
        this._onLup = (e) => {
            this._planet.renderer.controls.mouseNavigation.activate();
            if (this._pickedCorner || this._pickedCenter) {
                this.events.dispatch(this.events.change, this);
                this.setGhostPointerPosition(this._planet.getCartesianFromPixelTerrain(e));
                this.showGhostPointer();
                this._pickedCorner = null;
                this._pickedCenter = null;
            }
        };
        this._onCornerLdown = (e) => {
            this._pickedCorner = this._getLdown(e);
        };
        this._onCenterLdown = (e) => {
            this._pickedCenter = this._getLdown(e);
        };
        this._onMouseMove = (e) => {
            if (this._pickedCenter) {
                this._moveCenterPoint();
            }
            else if (this._pickedCorner) {
                this._moveCornerPoint(e.pos);
            }
            else {
                this.setGhostPointerPosition(this._planet.getCartesianFromPixelTerrain(e.pos));
            }
        };
        this._onCornerLdblclick = (e) => {
            this._cornerDblClick = true;
            let coords = this.getCoordinates();
            coords.splice(e.pickingObject.layerIndex, 1);
            this.setCoordinates(coords);
        };
        this._onMouseDblClick = (e) => {
            if (this._cornerDblClick) {
                this._cornerDblClick = false;
                return;
            }
            if (!this._showGhostPointer) {
                return;
            }
            let cart = this._planet.getCartesianFromPixelTerrain(e);
            if (cart) {
                this._addNew(cart);
                if (!this._isStartPoint && this._cornerLayer.getEntities().length > 2) {
                    this._isStartPoint = true;
                    this.events.dispatch(this.events.startpoint, this);
                }
                this.events.dispatch(this.events.change, this);
            }
        };
        this.events = createEvents(POLYGONDRAWINGSCENE_EVENTS);
        this._planet = null;
        this._initCoordinates = options.coordinates || [];
        this._pickedCorner = null;
        this._pickedCenter = null;
        this._startPos = null;
        this._startClick = new Vec2();
        this._geometryLayer = new Vector();
        //
        // outline vectors
        //
        this._cornerLayer = new Vector("corners", {
            pickingScale: 3,
            pickingEnabled: true,
            polygonOffsetUnits: -5,
            relativeToGround: true,
            scaleByDistance: [100, 4000000, 1.0]
        });
        this._centerLayer = new Vector("centers", {
            pickingScale: 3,
            pickingEnabled: true,
            polygonOffsetUnits: -5,
            relativeToGround: true,
            scaleByDistance: [100, 4000000, 1.0]
        });
        this._outlineLayer = new Vector("outline", {
            entities: [new Entity({
                    polyline: {
                        path3v: [],
                        isClosed: false,
                        ...OUTLINE_OPTIONS
                    }
                })],
            pickingEnabled: false,
            polygonOffsetUnits: -5,
            relativeToGround: true
        });
        this._outlineLayer.getEntities()[0].polyline.altitude = OUTLINE_ALT;
        //
        // Ghost cursor pointer
        //
        this._ghostCorner = new Entity({
            geoObject: CORNER_OPTIONS
        });
        this._ghostOutlineLayer = new Vector("ghost-pointer", {
            pickingEnabled: false,
            polygonOffsetUnits: -5,
            relativeToGround: true,
            scaleByDistance: [100, 4000000, 1.0],
            opacity: 0.5
        });
        this._showGhostPointer = false;
        this._isStartPoint = false;
        this._insertCornerIndex = -1;
    }
    get geometryType() {
        return "POLYGON";
    }
    getCoordinates() {
        let corners = this._cornerLayer.getEntities();
        if (corners.length > 0) {
            return corners.map((c) => {
                let ll = c.getLonLat();
                return [ll.lon, ll.lat, ll.height];
            });
        }
        else {
            return this._initCoordinates;
        }
    }
    bindPlanet(planet) {
        this._planet = planet;
    }
    init() {
        this._initEvents();
        this._initGhostLayerPointer();
        if (this._initCoordinates.length) {
            this.setCoordinates(this._initCoordinates);
        }
        this._planet.addLayer(this._outlineLayer);
        this._planet.addLayer(this._cornerLayer);
        this._planet.addLayer(this._centerLayer);
        this.showGhostPointer();
        this.startNewPoint();
        this._planet.renderer.controls.mouseNavigation.deactivateDoubleClickZoom();
        this._geometryLayer.addTo(this._planet);
        this.events.on("change", this._onChange, this);
    }
    onremove() {
        this._clearEvents();
        this.hideGhostPointer();
        this.stopNewPoint();
        this.clear();
        this._geometryLayer.remove();
    }
    clear() {
        this._geometryLayer.clear();
        let corners = this._cornerLayer.getEntities();
        let i = corners.length;
        while (i--) {
            corners[i].remove();
        }
        let centers = this._centerLayer.getEntities();
        i = centers.length;
        while (i--) {
            centers[i].remove();
        }
        let entities = this._outlineLayer.getEntities();
        i = entities.length;
        while (i--) {
            entities[i].polyline.clear();
            if (i > 0) {
                entities[i].remove();
            }
        }
        this._clearGhostPointer();
    }
    setCoordinates(coords) {
        this.clear();
        for (let i = 0; i < coords.length; i++) {
            let ci = coords[i];
            let cart = this._planet.ellipsoid.lonLatToCartesian(new LonLat(ci[0], ci[1], ci[2]));
            this._appendCart(cart);
        }
        this.events.dispatch(this.events.change, this);
    }
    stopNewPoint() {
        if (this.renderer) {
            this.renderer.events.off("ldblclick", this._onMouseDblClick);
        }
    }
    startNewPoint() {
        this.renderer.events.on("ldblclick", this._onMouseDblClick, this);
    }
    showGhostPointer() {
        this._showGhostPointer = true;
        this._planet.addLayer(this._ghostOutlineLayer);
        this._insertCornerIndex = this._cornerLayer.getEntities().length;
    }
    hideGhostPointer() {
        this._showGhostPointer = false;
        this._ghostOutlineLayer.remove();
        this._insertCornerIndex = -1;
    }
    setGhostPointerPosition(groundPos) {
        if (groundPos) {
            this._ghostCorner.setCartesian3v(groundPos);
            this._updateGhostOutlinePointer(groundPos);
        }
    }
    _getLdown(e) {
        this._planet.renderer.controls.mouseNavigation.deactivate();
        this._startClick.set(e.x, e.y);
        let coords = e.pickingObject.getCartesian();
        this._startPos = this._planet.getPixelFromCartesian(coords);
        return e.pickingObject;
    }
    _initEvents() {
        this._cornerLayer.events.on("ldblclick", this._onCornerLdblclick, this);
        this._cornerLayer.events.on("ldown", this._onCornerLdown, this);
        this._centerLayer.events.on("ldown", this._onCenterLdown, this);
        this.renderer.events.on("lup", this._onLup, this);
        this.renderer.events.on("mousemove", this._onMouseMove, this);
        this._cornerLayer.events.on("mouseenter", this._onCornerMouseEnter, this);
        this._cornerLayer.events.on("mouseleave", this._onCornerMouseLeave, this);
        this._centerLayer.events.on("mouseenter", this._onCenterMouseEnter, this);
        this._centerLayer.events.on("mouseleave", this._onCenterMouseLeave, this);
    }
    _clearEvents() {
        this._cornerLayer.events.off("ldblclick", this._onCornerLdblclick);
        this._cornerLayer.events.off("ldown", this._onCornerLdown);
        this._centerLayer.events.off("ldown", this._onCenterLdown);
        this.renderer.events.off("lup", this._onLup);
        this.renderer.events.off("mousemove", this._onMouseMove);
        this._cornerLayer.events.off("mouseenter", this._onCornerMouseEnter);
        this._cornerLayer.events.off("mouseleave", this._onCornerMouseLeave);
        this._centerLayer.events.off("mouseenter", this._onCenterMouseEnter);
        this._centerLayer.events.off("mouseleave", this._onCenterMouseLeave);
    }
    _drawCorners() {
        let corners = this._cornerLayer.getEntities();
        for (let i = 0; i < corners.length; i++) {
            let ai = corners[i];
            this._checkTerrainCollision(ai);
        }
    }
    _drawCenters() {
        let centers = this._centerLayer.getEntities();
        for (let i = 0; i < centers.length; i++) {
            let ai = centers[i];
            this._checkTerrainCollision(ai);
        }
    }
    _drawGhostCorner() {
        if (this._showGhostPointer) {
            this._checkTerrainCollision(this._ghostCorner);
        }
    }
    frame() {
        this._drawCorners();
        this._drawCenters();
        this._drawGhostCorner();
    }
    _checkTerrainCollision(entity) {
        let _tempTerrPoint = new Vec3();
        let nodes = this._planet._renderedNodes;
        for (let j = 0; j < nodes.length; j++) {
            let seg = nodes[j].segment;
            if (seg && seg._extentLonLat.isInside(entity.getLonLat())) {
                seg.getEntityTerrainPoint(entity, _tempTerrPoint);
                entity.setCartesian3v(_tempTerrPoint);
                break;
            }
        }
    }
    _moveCenterPoint() {
        let coords = this.getCoordinates(), index = this._pickedCenter.layerIndex + 1, ll = this._pickedCenter.getLonLat();
        let newCorner = [ll.lon, ll.lat, ll.height];
        coords.splice(index, 0, newCorner);
        this.setCoordinates(coords);
        this._pickedCenter = null;
        this._pickedCorner = this._cornerLayer.getEntities()[index];
    }
    _addNew(cart) {
        if (this._insertCornerIndex === -1 || this._cornerLayer.getEntities().length < 2) {
            this._appendCart(cart);
        }
        else {
            let area = this.getCoordinates(), index = this._insertCornerIndex;
            let ll = this._planet.ellipsoid.cartesianToLonLat(cart);
            let newCorner = [ll.lon, ll.lat, ll.height];
            area.splice(index, 0, newCorner);
            this.clear();
            this.setCoordinates(area);
        }
    }
    _appendCart(cart) {
        let corners = this._cornerLayer.getEntities();
        let segNum = corners.length - 1;
        let prevCorn = corners[segNum];
        let corner = new Entity({
            geoObject: CORNER_OPTIONS,
        });
        corner.setCartesian3v(cart);
        corner.addTo(this._cornerLayer);
        this._checkTerrainCollision(corner);
        if (prevCorn) {
            let firstCart = corners[0].getCartesian(), prevCart = prevCorn.getCartesian();
            let vecPrev = corner.getCartesian().sub(prevCart), vecFirst = corner.getCartesian().sub(firstCart);
            let distPrev = vecPrev.length(), distFirst = vecFirst.length();
            vecPrev.normalize();
            vecFirst.normalize();
            let prevPath = [], firstPath = [];
            for (let i = 0; i <= NUM_SEGMENTS; i++) {
                let p = vecPrev.scaleTo(i * distPrev / NUM_SEGMENTS).addA(prevCart);
                prevPath.push(p);
                let f = vecFirst.scaleTo(i * distFirst / NUM_SEGMENTS).addA(firstCart);
                firstPath.push(f);
            }
            this._outlineLayer.getEntities()[0].polyline.setPath3v([firstPath]);
            let entity = new Entity({
                polyline: {
                    path3v: [prevPath],
                    isClosed: false,
                    ...OUTLINE_OPTIONS
                }
            });
            entity.polyline.altitude = OUTLINE_ALT;
            this._outlineLayer.add(entity);
            let centers = this._centerLayer.getEntities();
            let firstCenter = centers[centers.length - 1];
            let prevCenterCart = vecPrev.scaleTo(distPrev * 0.5).addA(prevCart), firstCenterCart = vecFirst.scaleTo(distFirst * 0.5).addA(firstCart);
            let center = new Entity({
                geoObject: CENTER_OPTIONS,
            });
            center.setCartesian3v(prevCenterCart);
            center.addTo(this._centerLayer);
            this._checkTerrainCollision(center);
            //moveToEnd
            firstCenter.remove();
            firstCenter.addTo(this._centerLayer);
            firstCenter.setCartesian3v(firstCenterCart);
        }
        else {
            let center = new Entity({
                geoObject: CENTER_OPTIONS,
            });
            center.addTo(this._centerLayer);
        }
    }
    _clearGhostPointer() {
        const g = this._ghostOutlineLayer;
        g.getEntities()[0].polyline.clear();
        g.getEntities()[1].polyline.clear();
    }
    _moveCornerPoint(e) {
        let d = new Vec2(e.x, e.y).sub(this._startClick), p = this._startPos.add(d);
        let groundCoords = this._planet.getCartesianFromPixelTerrain(p);
        if (groundCoords) {
            this._pickedCorner.setCartesian3v(groundCoords);
            let corners = this._cornerLayer.getEntities();
            if (corners.length) {
                let ind = this._pickedCorner.layerIndex;
                let size = corners.length;
                let cartPrev = corners[ind === 0 ? (size - 1) : (ind - 1)].getCartesian(), cartNext = corners[(ind + 1) % size].getCartesian();
                let vecPrev = this._pickedCorner.getCartesian().sub(cartPrev), vecNext = this._pickedCorner.getCartesian().sub(cartNext);
                let distPrev = vecPrev.length(), distNext = vecNext.length();
                vecPrev.normalize();
                vecNext.normalize();
                let pathPrev = [], pathNext = [];
                for (let i = 0; i <= NUM_SEGMENTS; i++) {
                    let p = vecPrev.scaleTo(i * distPrev / NUM_SEGMENTS).addA(cartPrev);
                    pathPrev.push(p);
                    let f = vecNext.scaleTo(i * distNext / NUM_SEGMENTS).addA(cartNext);
                    pathNext.push(f);
                }
                let entities = this._outlineLayer.getEntities();
                let prevPolyline = entities[ind].polyline, nextPolyline = entities[(ind + 1) % size].polyline;
                prevPolyline?.setPath3v([pathPrev]);
                nextPolyline?.setPath3v([pathNext]);
                //
                // Move center points
                let centers = this._centerLayer.getEntities();
                let prevCenter = centers[ind === 0 ? (size - 1) : (ind - 1)], nextCenter = centers[ind];
                let prevCenterCart = vecPrev.scaleTo(distPrev * 0.5).addA(cartPrev), nextCenterCart = vecNext.scaleTo(distNext * 0.5).addA(cartNext);
                prevCenter.setCartesian3v(prevCenterCart);
                this._checkTerrainCollision(prevCenter);
                nextCenter.setCartesian3v(nextCenterCart);
                this._checkTerrainCollision(nextCenter);
            }
        }
    }
    _updateGhostOutlinePointer(groundPos) {
        let corners = this._cornerLayer.getEntities();
        let size = corners.length;
        if (size > 0) {
            let ind = 0;
            let minDist = MAX;
            for (let i = 0; i < size; i++) {
                let ci = corners[i];
                let dist = ci.getCartesian().distance(groundPos);
                if (dist < minDist) {
                    minDist = dist;
                    ind = i;
                }
            }
            let cCurr = corners[ind].getCartesian(), cNext = corners[(ind + 1) % size].getCartesian(), cPrev = corners[ind === 0 ? (size - 1) : (ind - 1)].getCartesian();
            let nPrev = cPrev.sub(cCurr).normalize(), nNext = cNext.sub(cCurr).normalize(), nGround = groundPos.sub(cCurr).normalize();
            let midVec = nPrev.add(nNext).normalize();
            let toMid = nGround.cross(midVec), up = nPrev.cross(nNext);
            if (toMid.dot(up) > 0) {
                ind--;
                if (ind < 0) {
                    ind = size - 1;
                }
            }
            let temp = new Vec3();
            for (let i = 0; i < size; i++) {
                let side = new Line3(corners[i].getCartesian(), corners[(i + 1) % size].getCartesian());
                let u = side.getNearestDistancePoint(groundPos, temp);
                if (u) {
                    let dist = temp.distance(groundPos);
                    if (dist < minDist) {
                        minDist = dist;
                        ind = i;
                    }
                }
            }
            this._insertCornerIndex = (ind + 1) % size;
            let cartPrev = corners[ind % size].getCartesian(), cartNext = corners[(ind + 1) % size].getCartesian();
            let vecPrev = this._ghostCorner.getCartesian().sub(cartPrev), vecNext = this._ghostCorner.getCartesian().sub(cartNext);
            let distPrev = vecPrev.length(), distNext = vecNext.length();
            vecPrev.normalize();
            vecNext.normalize();
            let pathPrev = [], pathNext = [];
            for (let i = 0; i <= NUM_SEGMENTS; i++) {
                let p = vecPrev.scaleTo(i * distPrev / NUM_SEGMENTS).addA(cartPrev);
                pathPrev.push(p);
                let f = vecNext.scaleTo(i * distNext / NUM_SEGMENTS).addA(cartNext);
                pathNext.push(f);
            }
            let entities = this._ghostOutlineLayer.getEntities();
            let prevPolyline = entities[0].polyline, nextPolyline = entities[1].polyline;
            prevPolyline?.setPath3v([pathPrev]);
            nextPolyline?.setPath3v([pathNext]);
        }
    }
    _initGhostLayerPointer() {
        this._ghostOutlineLayer.setEntities([
            new Entity({
                polyline: {
                    path3v: [],
                    isClosed: false,
                    ...OUTLINE_OPTIONS
                }
            }), new Entity({
                polyline: {
                    path3v: [],
                    isClosed: false,
                    ...OUTLINE_OPTIONS
                }
            }),
            this._ghostCorner
        ]);
        const g = this._ghostOutlineLayer;
        g.getEntities()[0].polyline.altitude = g.getEntities()[1].polyline.altitude = OUTLINE_ALT;
    }
}

class LineStringDrawingScene extends PolygonDrawingScene {
    constructor(props) {
        super(props);
    }
    get geometryType() {
        return "LineString";
    }
    _addNew(cart) {
        this._appendCart(cart);
    }
    _appendCart(cart) {
        let corners = this._cornerLayer.getEntities();
        let segNum = corners.length - 1;
        let prevCorn = corners[segNum];
        let corner = new Entity({
            geoObject: CORNER_OPTIONS,
        });
        corner.setCartesian3v(cart);
        corner.addTo(this._cornerLayer);
        this._checkTerrainCollision(corner);
        if (prevCorn) {
            let prevCart = prevCorn.getCartesian();
            let vecPrev = corner.getCartesian().sub(prevCart);
            let distPrev = vecPrev.length();
            vecPrev.normalize();
            let prevPath = [];
            for (let i = 0; i <= NUM_SEGMENTS; i++) {
                let p = vecPrev.scaleTo(i * distPrev / NUM_SEGMENTS).addA(prevCart);
                prevPath.push(p);
            }
            let entity = new Entity({
                polyline: {
                    path3v: [prevPath],
                    isClosed: false,
                    ...OUTLINE_OPTIONS
                }
            });
            entity.polyline.altitude = OUTLINE_ALT;
            this._outlineLayer.add(entity);
            let prevCenterCart = vecPrev.scaleTo(distPrev * 0.5).addA(prevCart);
            let center = new Entity({
                geoObject: CENTER_OPTIONS,
            });
            center.setCartesian3v(prevCenterCart);
            center.addTo(this._centerLayer);
            this._checkTerrainCollision(center);
        }
    }
    _clearGhostPointer() {
        this._ghostOutlineLayer.getEntities()[0].polyline.clear();
    }
    _moveCorner(indexCurrent, indexPrev, indexCenter) {
        let corners = this._cornerLayer.getEntities();
        if (corners.length == 0)
            return;
        if (corners.length == 1) {
            indexCurrent = indexPrev = indexCenter = 0;
        }
        let cartCurr = corners[indexCurrent].getCartesian();
        let vecCurr = this._pickedCorner.getCartesian().sub(cartCurr);
        let distCurr = vecCurr.length();
        vecCurr.normalize();
        let path = [];
        for (let i = 0; i <= NUM_SEGMENTS; i++) {
            let p = vecCurr.scaleTo(i * distCurr / NUM_SEGMENTS).addA(cartCurr);
            path.push(p);
        }
        let entities = this._outlineLayer.getEntities();
        let prevPolyline = entities[indexPrev].polyline;
        prevPolyline?.setPath3v([path]);
        //
        // Move center points
        let centers = this._centerLayer.getEntities();
        let center = centers[indexCenter];
        if (center) {
            let centerCart = vecCurr.scaleTo(distCurr * 0.5).addA(cartCurr);
            center.setCartesian3v(centerCart);
            this._checkTerrainCollision(center);
        }
    }
    _moveCornerPoint(e) {
        let d = new Vec2(e.x, e.y).sub(this._startClick), p = this._startPos.add(d);
        let groundCoords = this._planet.getCartesianFromPixelTerrain(p);
        if (groundCoords) {
            this._pickedCorner.setCartesian3v(groundCoords);
            let corners = this._cornerLayer.getEntities();
            if (corners.length) {
                let ind = this._pickedCorner.layerIndex;
                if (ind === 0) {
                    this._moveCorner(ind + 1, ind + 1, ind);
                }
                else if (ind === corners.length - 1) {
                    this._moveCorner(ind - 1, ind, ind - 1);
                }
                else {
                    this._moveCorner(ind + 1, ind + 1, ind);
                    this._moveCorner(ind - 1, ind, ind - 1);
                }
            }
        }
    }
    _updateGhostOutlinePointer(groundPos) {
        let corners = this._cornerLayer.getEntities();
        let size = corners.length;
        if (size > 0) {
            let ind = size - 1;
            this._insertCornerIndex = ind;
            let cartPrev = corners[ind].getCartesian();
            let vecPrev = this._ghostCorner.getCartesian().sub(cartPrev);
            let distPrev = vecPrev.length();
            vecPrev.normalize();
            let pathPrev = [];
            for (let i = 0; i <= NUM_SEGMENTS; i++) {
                let p = vecPrev.scaleTo(i * distPrev / NUM_SEGMENTS).addA(cartPrev);
                pathPrev.push(p);
            }
            let entities = this._ghostOutlineLayer.getEntities();
            let prevPolyline = entities[0].polyline;
            prevPolyline.setPath3v([pathPrev]);
        }
    }
    _initGhostLayerPointer() {
        this._ghostOutlineLayer.setEntities([
            new Entity({
                polyline: {
                    path3v: [],
                    isClosed: false,
                    ...OUTLINE_OPTIONS
                }
            }),
            this._ghostCorner
        ]);
        this._ghostOutlineLayer.getEntities()[0].polyline.altitude = OUTLINE_ALT;
    }
}

class DrawingControl extends Control {
    constructor(options = {}) {
        super(options);
        this._drawingScene = new LineStringDrawingScene({
            name: `drawingScene:${this.__id}`
        });
    }
    activatePolygonDrawing() {
        this.deactivate();
        this._drawingScene = new PolygonDrawingScene({
            name: `polygonDrawingScene:${this.__id}`
        });
        this.activate();
    }
    activateLineStringDrawing() {
        this.deactivate();
        this._drawingScene = new LineStringDrawingScene({
            name: `linestringDrawingScene:${this.__id}`
        });
        this.activate();
    }
    oninit() {
    }
    onactivate() {
        this.planet && this._drawingScene.bindPlanet(this.planet);
        this.renderer && this.renderer.addNode(this._drawingScene);
    }
    ondeactivate() {
        this.renderer && this.renderer.removeNode(this._drawingScene);
    }
}

const ICON_POLYGON_SVG = `<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 24.1.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" id="Layer_2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
\t viewBox="0 0 1024 1024" style="enable-background:new 0 0 1024 1024;" xml:space="preserve">
<g>
\t<path d="M926.03,321.16c-16.02,0-31.11,3.94-44.48,10.79l-263.43-191.4c2.69-8.94,4.18-18.4,4.18-28.2
\t\tc0-54.02-43.95-97.97-97.97-97.97c-54.03,0-97.98,43.95-97.98,97.97c0,9.81,1.49,19.27,4.18,28.21L155.75,340.18
\t\tc-16.22-11.91-36.16-19.03-57.78-19.03C43.95,321.16,0,365.11,0,419.13c0,52.58,41.67,95.5,93.71,97.75l102.63,315.86
\t\tc-24.28,17.85-40.13,46.52-40.13,78.9c0,54.02,43.95,97.98,97.98,97.98c37.54,0,70.18-21.25,86.62-52.34h367.26
\t\tc16.44,31.08,49.08,52.34,86.63,52.34c54.03,0,97.98-43.95,97.98-97.98c0-32.46-15.94-61.21-40.33-79.05l104.11-320.4
\t\tc39.15-12.84,67.54-49.68,67.54-93.07C1024,365.11,980.05,321.16,926.03,321.16z M828.05,911.65c0,8.5-3.3,16.19-8.55,22.09
\t\tc-6.11,6.85-14.9,11.26-24.79,11.26c-13.65,0-25.37-8.26-30.52-20.02c-1.79-4.09-2.82-8.58-2.82-13.33
\t\tc0-18.39,14.95-33.35,33.34-33.35c2.93,0,5.72,0.5,8.43,1.21c13.27,3.49,23.21,14.91,24.59,28.9
\t\tC827.83,909.5,828.05,910.54,828.05,911.65z M790.48,813.89c-45.63,1.96-83.27,35.16-91.87,78.77H350.28
\t\tc-8.62-43.69-46.38-76.93-92.11-78.79L155.59,498.19c24.41-17.84,40.36-46.59,40.36-79.06c0-8.9-1.3-17.49-3.53-25.7L468.57,192.8
\t\tc15.84,11.01,35.05,17.52,55.76,17.52c20.71,0,39.92-6.5,55.76-17.52l256.56,186.4c-5.48,12.21-8.59,25.7-8.59,39.93
\t\tc0,41.02,25.36,76.17,61.21,90.75L790.48,813.89z M254.19,945c-10.11,0-19.07-4.62-25.19-11.75c-5.01-5.84-8.15-13.32-8.15-21.6
\t\tc0-0.91,0.2-1.76,0.27-2.66c1.14-14.18,11.08-25.8,24.43-29.41c2.78-0.75,5.64-1.28,8.65-1.28c18.38,0,33.33,14.96,33.33,33.35
\t\tc0,4.74-1.03,9.24-2.82,13.33C279.55,936.74,267.83,945,254.19,945z M64.88,421.49c-0.06-0.79-0.24-1.55-0.24-2.35
\t\tc0-16.41,11.93-30.01,27.55-32.76c1.89-0.33,3.8-0.58,5.78-0.58c11.94,0,22.35,6.36,28.24,15.81c3.18,5.11,5.11,11.09,5.11,17.53
\t\tc0,15.47-10.63,28.39-24.94,32.14c-2.7,0.71-5.48,1.2-8.4,1.2C80.4,452.47,66.11,438.76,64.88,421.49z M549.41,90.62
\t\tc5.07,5.85,8.25,13.39,8.25,21.72c0,7.32-2.44,14.03-6.45,19.54c-6.07,8.33-15.82,13.81-26.88,13.81
\t\tc-11.07,0-20.83-5.48-26.89-13.81c-4.01-5.51-6.45-12.22-6.45-19.54c0-8.33,3.17-15.86,8.24-21.71
\t\tc6.12-7.07,15.04-11.64,25.1-11.64C534.38,79,543.29,83.57,549.41,90.62z M959.36,419.13c0,11.94-6.36,22.35-15.82,28.24
\t\tc-5.1,3.18-11.07,5.1-17.52,5.1c-6.08,0-11.71-1.76-16.62-4.61c-9.71-5.64-16.33-15.94-16.64-27.89c-0.01-0.29-0.09-0.56-0.09-0.85
\t\tc0-11.75,6.14-22.05,15.36-28c5.2-3.35,11.35-5.35,17.99-5.35C944.41,385.78,959.36,400.75,959.36,419.13z"/>
</g>
</svg>`;
const ICON_LINESTRING_SVG = `<?xml version="1.0" encoding="utf-8"?><!-- License: MIT. Made by Esri: https://github.com/Esri/calcite-ui-icons -->
    <svg width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 6h.046l-5.25 9h-.944L10 9.455V7H7v2.926L1.862 18H0v3h3v-2.926L8.138 10h1.01L14 15.545V18h3v-3h-.046l5.25-9H24V3h-3zM8 8h1v1H8zM2 20H1v-1h1zm14-3h-1v-1h1zm7-13v1h-1V4z"/></svg>`;
const ICON_DEFAULT_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M4 0l16 12.279-6.951 1.17 4.325 8.817-3.596 1.734-4.35-8.879-5.428 4.702z"/></svg>`;
/**
 * Activate drawing control
 */
class DrawingSwitcher extends Control {
    constructor(options = {}) {
        super({
            name: "DrawingSwitcher",
            ...options
        });
        this.drawingControl = new DrawingControl();
    }
    oninit() {
        this.planet.addControl(this.drawingControl);
        this._createMenu();
    }
    onactivate() {
        this.drawingControl.activate();
    }
    ondeactivate() {
        this.drawingControl.deactivate();
    }
    _createMenu() {
        let defaultBtn = new ToggleButton({
            classList: ["og-map-button", "og-drawing-default_button"],
            icon: ICON_DEFAULT_SVG,
            name: "default",
            isActive: true
        });
        let polyBtn = new ToggleButton({
            classList: ["og-map-button", "og-drawing-polygon_button"],
            icon: ICON_POLYGON_SVG,
            name: "polygon"
        });
        let lineBtn = new ToggleButton({
            classList: ["og-map-button", "og-drawing-linestring_button"],
            icon: ICON_LINESTRING_SVG,
            name: "linestring"
        });
        let buttons = new ButtonGroup({
            buttons: [
                defaultBtn, polyBtn, lineBtn
            ]
        });
        buttons.events.on("change", (btn) => {
            this.drawingControl.deactivate();
            switch (btn.name) {
                case "polygon":
                    this.drawingControl.activatePolygonDrawing();
                    break;
                case "linestring":
                    this.drawingControl.activateLineStringDrawing();
                    break;
            }
        });
        defaultBtn.appendTo(this.renderer.div);
        polyBtn.appendTo(this.renderer.div);
        lineBtn.appendTo(this.renderer.div);
    }
}

const ELL = 0;
const MSL = 1;
const GND = 2;
const heightMode = {
    "ell": ELL,
    "msl": MSL,
    "gnd": GND
};
const KM_to_M = 1000.0;
const M_to_KM = 1.0 / KM_to_M;
const FT_to_M = 0.3048;
const M_to_FT = 1.0 / FT_to_M;
const MS_to_KMH = 3.6;
const KMH_to_MS = 1.0 / MS_to_KMH;
const MS_to_FTS = 3.28084;
const FT_to_KM = FT_to_M * M_to_KM;
const KM_to_FT = 1.0 / FT_to_KM;
const m = 0;
const km = 1;
const ft = 2;
const s = 3;
const h = 4;
const ms = 5;
const kmh = 6;
const fts = 7;
const DEFAULT_NAN = "--";
const _abbr = ["m", "km", "ft", "s", "h", "m/s", "km/h", "ft/s"];
const _tenth = [0, 2, 0, 0, 0, 0, 0, 0];
let _convFn = [];
_convFn[m] = [];
_convFn[m][m] = (v) => v;
_convFn[m][km] = (v) => v * M_to_KM;
_convFn[m][ft] = (v) => v * M_to_FT;
_convFn[ft] = [];
_convFn[ft][m] = (v) => v * FT_to_M;
_convFn[ft][km] = (v) => v * FT_to_KM;
_convFn[ft][ft] = (v) => v;
_convFn[km] = [];
_convFn[km][m] = (v) => v * KM_to_M;
_convFn[km][km] = (v) => v;
_convFn[km][ft] = (v) => v * KM_to_FT;
_convFn[ms] = [];
_convFn[ms][ms] = (v) => v;
_convFn[ms][kmh] = (v) => v * MS_to_KMH;
_convFn[ms][fts] = (v) => v * MS_to_FTS;
_convFn[kmh] = [];
_convFn[kmh][ms] = (v) => v * KMH_to_MS;
_convFn[kmh][kmh] = (v) => v;
//_convFn[kmh][fts] = (v) => v * KMH_to_FTS;
function convert(from, to, val) {
    return _convFn[from][to](val);
}
function convertExt(isNotNaN, unitFrom, unitTo, val, fixed) {
    if (isNotNaN) {
        return convert(unitFrom, unitTo, val).toFixed(fixed || _tenth[unitTo]);
    }
    return DEFAULT_NAN;
}
function toString(u) {
    return _abbr[u];
}

var units = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ELL: ELL,
    GND: GND,
    MSL: MSL,
    _tenth: _tenth,
    convert: convert,
    convertExt: convertExt,
    ft: ft,
    fts: fts,
    h: h,
    heightMode: heightMode,
    km: km,
    kmh: kmh,
    m: m,
    ms: ms,
    s: s,
    toString: toString
});

const DECIMAL_TEMPLATE = `<div class="og-lat-side"></div><div class="og-lat-val"></div>
    <div class="og-lon-side"></div><div class="og-lon-val"></div>
    <div class="og-height"></div>
    <div class="og-units-height"></div>`;
const DEGREE_TEMPLATE = `<div class="og-lat-side"></div><div class="og-lat-val"></div>
    <div class="og-lon-side"></div><div class="og-lon-val"></div>
    <div class="og-height"></div>
    <div class="og-units-height"></div>`;
const CENTER_SVG = '<svg width="12" height="12"><g><path stroke-width="1" stroke-opacity="1" d="M6 0L6 12M0 6L12 6" stroke="#337ab7"></path></g></svg>';
const TYPE_HTML = [DECIMAL_TEMPLATE, DEGREE_TEMPLATE];
/**
 * Control displays mouse or screen center Earth coordinates.
 * @param {Boolean} [options.center] - Earth coordinates by screen center otherwise mouse pointer. False is default.
 * @param {Boolean} [options.type] - Coordinates shown: 0 - is decimal degrees, 1 - degrees, 2 - mercator geodetic coordinates.
 */
class EarthCoordinates extends Control {
    constructor(options = {}) {
        super(options);
        this._type = options.type || 0;
        this._TYPE_FUNC = [this._SHOW_DECIMAL, this._SHOW_DEGREE];
        this._showFn = null;
        this._el = null;
        this._latSideEl = null;
        this._lonSideEl = null;
        this._latValEl = null;
        this._lonValEl = null;
        this._heightEl = null;
        this._altUnitVal = options.altitudeUnit || "m";
        this._heightModeVal = options.heightMode || "ell";
        this._altUnit = units[this._altUnitVal];
        this._heightMode = heightMode[this._heightModeVal];
        this._lonLat = null;
        this._centerMode = options.centerMode != undefined ? options.centerMode : true;
    }
    _SHOW_DECIMAL(ll) {
        if (ll) {
            let lat = ll.lat, lon = ll.lon;
            if (lat >= 0) {
                this._latSideEl.innerHTML = 'N';
            }
            else {
                this._latSideEl.innerHTML = 'S';
            }
            if (lon >= 0) {
                this._lonSideEl.innerHTML = 'E';
            }
            else {
                this._lonSideEl.innerHTML = 'W';
            }
            this._latValEl.innerHTML = Math.abs(lat).toFixed(7) + '¬∞';
            this._lonValEl.innerHTML = Math.abs(lon).toFixed(7) + '¬∞';
        }
    }
    _SHOW_DEGREE(ll) {
        if (ll) {
            let lat = ll.lat, lon = ll.lon;
            if (lat >= 0) {
                this._latSideEl.innerHTML = 'N';
            }
            else {
                this._latSideEl.innerHTML = 'S';
            }
            if (lon >= 0) {
                this._lonSideEl.innerHTML = 'E';
            }
            else {
                this._lonSideEl.innerHTML = 'W';
            }
            let t = 0;
            let deg = lat < 0 ? Math.ceil(lat) : Math.floor(lat);
            let min = Math.floor(t = Math.abs((lat - deg)) * 60);
            let sec = Math.floor((t - min) * 6000) / 100.0;
            this._latValEl.innerHTML = Math.abs(deg) + '¬∞' + min + "'" + sec.toFixed(0) + '"';
            deg = lon < 0 ? Math.ceil(lon) : Math.floor(lon);
            min = Math.floor(t = Math.abs((lon - deg)) * 60);
            sec = Math.floor((t - min) * 6000) / 100.0;
            this._lonValEl.innerHTML = Math.abs(deg) + '¬∞' + min + "'" + sec.toFixed(0) + '"';
        }
    }
    _createCenterEl() {
        let el = document.createElement('div');
        el.className = 'og-center-icon';
        el.innerHTML = CENTER_SVG;
        return el;
    }
    _updateUnits() {
        this._heightMode = heightMode[this._heightModeVal];
        this._altUnit = units[this._altUnitVal];
        this._el.querySelector(".og-units-height").innerHTML = toString(this._altUnit);
        this._showHeight();
    }
    _refreshCoordinates() {
        if (this._type >= this._TYPE_FUNC.length) {
            this._type = 0;
        }
        let el = this._el;
        el.innerHTML = TYPE_HTML[this._type];
        this._latSideEl = el.querySelector(".og-lat-side");
        this._lonSideEl = el.querySelector(".og-lon-side");
        this._latValEl = el.querySelector(".og-lat-val");
        this._lonValEl = el.querySelector(".og-lon-val");
        this._heightEl = el.querySelector(".og-height");
        this._showFn = this._TYPE_FUNC[this._type];
        this._showFn(this._lonLat);
    }
    oninit() {
        this._el = document.createElement('div');
        this._el.classList.add("og-coordinates");
        this.renderer.div.appendChild(this._el);
        this._el.addEventListener("click", () => {
            this._type++;
            this._refreshCoordinates();
            this._updateUnits();
            this._showHeight();
        });
        if (this._centerMode) {
            this.renderer.div.appendChild(this._createCenterEl());
            this.planet.camera.events.on("moveend", this._grabCoordinates, this);
            this.planet.camera.events.on("moveend", throttle(() => this._showHeight(), 400, true), this);
        }
        else {
            this.renderer.events.on("mousemove", this._grabCoordinates, this);
            this.renderer.events.on("mousestop", throttle(() => this._showHeight(), 400, true), this);
        }
        this._refreshCoordinates();
        this._updateUnits();
    }
    _grabCoordinates(e) {
        let px = e.pos;
        let scrPx;
        let r = this.renderer;
        if (this._centerMode) {
            scrPx = r.handler.getCenter();
        }
        else {
            scrPx = px;
        }
        this._lonLat = this.planet.getLonLatFromPixelTerrain(scrPx) || null;
        this._showFn(this._lonLat);
    }
    async _showHeight() {
        if (this._lonLat && this.planet) {
            let alt = 0;
            this._heightEl.style.opacity = "0.7";
            if (this._heightMode === heightMode.ell) {
                alt = await this.planet.getHeightAboveELL(this._lonLat);
                alt = Number(convertExt(true, m, this._altUnit, alt));
            }
            else if (this._heightMode === heightMode.msl) {
                alt = await this.planet.getHeightDefault(this._lonLat);
                alt = Number(convertExt(true, m, this._altUnit, alt));
            }
            this._heightEl.style.opacity = "1.0";
            this._heightEl.innerHTML = alt.toString();
        }
    }
}

let TouchExt$1 = class TouchExt {
    constructor() {
        this.x = 0;
        this.y = 0;
        this.prev_x = 0;
        this.prev_y = 0;
        this.grabbedPoint = new Vec3();
        this.grabbedSpheroid = new Sphere();
    }
    dX() {
        return this.x - this.prev_x;
    }
    dY() {
        return this.y - this.prev_y;
    }
};
class EarthNavigation extends Control {
    constructor(options = {}) {
        super(options);
        this.grabbedPoint = new Vec3();
        this.grabbedDir = new Vec3();
        this.inertia = 0.007;
        this.grabbedSpheroid = new Sphere();
        this.planet = null;
        this._vRot = new Quat();
        this._hRot = new Quat();
        this._a = 0.0;
        this.scaleRot = 0;
        this.currState = 0;
        this.positionState = [
            { h: 17119745.303455353, max: 0.98, min: -0.98 },
            { h: 6866011, max: 0.98, min: -0.98 },
            { h: 3000000, max: 0.98, min: -0.98 },
            { h: 1000000, max: 0.98, min: -0.98 },
            { h: 500000, max: 0.98, min: -0.98 }
        ];
        this.touches = [new TouchExt$1(), new TouchExt$1()];
    }
    switchZoomState(wheelDelta) {
        this.stopRotation();
        if (wheelDelta > 0) {
            this.currState++;
        }
        else {
            this.currState--;
        }
        if (this.currState <= 0)
            this.currState = 0;
        if (this.currState >= this.positionState.length) {
            this.currState = this.positionState.length - 1;
        }
        this.planet.stopFlying();
        const ll = this.planet.camera._lonLat;
        this.planet.flyLonLat(new LonLat(ll.lon, ll.lat, this.positionState[this.currState].h));
    }
    onMouseWheel(event) {
        this.switchZoomState(event.wheelDelta);
    }
    oninit() {
        this.activate();
    }
    onactivate() {
        let r = this.renderer;
        r.events.on("mousewheel", this.onMouseWheel, this);
        r.events.on("lhold", this.onMouseLeftButtonDown, this);
        r.events.on("ldown", this.onMouseLeftButtonClick, this);
        r.events.on("lup", this.onMouseLeftButtonUp, this);
        r.events.on("touchstart", this.onTouchStart, this);
        r.events.on("touchend", this.onTouchEnd, this);
        r.events.on("touchmove", this.onTouchMove, this);
        r.events.on("draw", this.onDraw, this);
    }
    onTouchStart(e) {
        if (e.sys.touches.length == 1) {
            const t = this.touches[0];
            t.x = e.sys.touches.item(0).pageX - e.sys.offsetLeft;
            t.y = e.sys.touches.item(0).pageY - e.sys.offsetTop;
            t.prev_x = e.sys.touches.item(0).pageX - e.sys.offsetLeft;
            t.prev_y = e.sys.touches.item(0).pageY - e.sys.offsetTop;
            // t.grabbedPoint = this.planet!.getCartesianFromPixelTerrain(t, true);
            t.grabbedPoint = this.planet.getCartesianFromPixelTerrain(new Vec2(t.x, t.y)) || null;
            if (t.grabbedPoint) {
                t.grabbedSpheroid.radius = t.grabbedPoint.length();
                this.stopRotation();
            }
        }
    }
    onTouchEnd(e) {
        if (e.sys.touches.length == 0) {
            this.scaleRot = 1;
            if (Math.abs(this.touches[0].x - this.touches[0].prev_x) < 3 &&
                Math.abs(this.touches[0].y - this.touches[0].prev_y) < 3)
                this.stopRotation();
        }
    }
    onTouchMove(e) {
        if (e.sys.touches.length == 1) {
            let cam = this.planet.camera;
            let t = this.touches[0];
            t.prev_x = t.x;
            t.prev_y = t.y;
            t.x = e.sys.touches.item(0).pageX - e.sys.offsetLeft;
            t.y = e.sys.touches.item(0).pageY - e.sys.offsetTop;
            if (!t.grabbedPoint)
                return;
            let direction = cam.unproject(t.x, t.y);
            let targetPoint = new Ray$1(cam.eye, direction).hitSphere(t.grabbedSpheroid);
            if (targetPoint) {
                this._a =
                    Math.acos(t.grabbedPoint.y / t.grabbedSpheroid.radius) -
                        Math.acos(targetPoint.y / t.grabbedSpheroid.radius);
                this._vRot = Quat.axisAngleToQuat(cam._u, this._a);
                this._hRot = Quat.getRotationBetweenVectors(new Vec3(targetPoint.x, 0.0, targetPoint.z).normal(), new Vec3(t.grabbedPoint.x, 0.0, t.grabbedPoint.z).normal());
                let rot = this._hRot.mul(this._vRot);
                let state = this.positionState[this.currState];
                let lim = rot.mulVec3(cam.eye).normal().dot(Vec3.NORTH);
                if (lim > state.max || lim < state.min) {
                    rot = Quat.yRotation(rot.getYaw());
                }
                cam.set(rot.mulVec3(cam.eye), Vec3.ZERO, Vec3.NORTH);
                cam.update();
            }
        }
    }
    onMouseLeftButtonClick(e) {
        this.renderer.handler.canvas.classList.add("ogGrabbingPoiner");
        this.grabbedPoint = this.planet.getCartesianFromMouseTerrain() || null;
        this.grabbedDir.copy(e.direction);
        if (this.grabbedPoint) {
            this.grabbedSpheroid.radius = this.grabbedPoint.length();
            this.stopRotation();
        }
    }
    stopRotation() {
        this.scaleRot = 0.0;
        this._a = 0.0;
        this._vRot.clear();
        this._hRot.clear();
    }
    onMouseLeftButtonUp(e) {
        this.scaleRot = 1;
        this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
        if (Math.abs(e.x - e.prev_x) < 3 && Math.abs(e.y - e.prev_y) < 3)
            this.stopRotation();
    }
    onMouseLeftButtonDown(e) {
        let cam = this.planet.camera;
        if (!this.grabbedPoint || cam.isFlying())
            return;
        if (this.renderer.events.mouseState.moving) {
            let targetPoint = new Ray$1(cam.eye, e.direction).hitSphere(this.grabbedSpheroid);
            if (targetPoint) {
                this._a = Math.acos(this.grabbedPoint.y / this.grabbedSpheroid.radius) -
                    Math.acos(targetPoint.y / this.grabbedSpheroid.radius);
                let rot = this._vRot = Quat.axisAngleToQuat(cam._u, this._a);
                cam.set(rot.mulVec3(cam.eye), Vec3.ZERO, rot.mulVec3(cam.getUp()));
                this._hRot = Quat.getRotationBetweenVectors(new Vec3(targetPoint.x, 0.0, targetPoint.z).normal(), new Vec3(this.grabbedPoint.x, 0.0, this.grabbedPoint.z).normal());
                rot = this._hRot;
                cam.set(rot.mulVec3(cam.eye), Vec3.ZERO, rot.mulVec3(cam.getUp()));
                cam.update();
            }
        }
        else {
            this.scaleRot = 0;
        }
    }
    onDraw() {
        let r = this.renderer;
        let cam = this.planet.camera;
        if (r.events.mouseState.leftButtonDown || !this.scaleRot || cam.isFlying())
            return;
        this.scaleRot -= this.inertia;
        if (this.scaleRot <= 0) {
            this.scaleRot = 0;
        }
        else {
            this._vRot = Quat.axisAngleToQuat(cam._u, this._a);
            let rot = this._vRot.mul(this._hRot);
            let lim = rot.mulVec3(cam.eye).normal().dot(Vec3.NORTH);
            let state = this.positionState[this.currState];
            if (lim > state.max || lim < state.min) {
                rot = Quat.yRotation(rot.getYaw());
            }
            r.controlsBag.scaleRot = this.scaleRot;
            rot = rot
                .slerp(Quat.IDENTITY, 1 - this.scaleRot * this.scaleRot * this.scaleRot)
                .normalize();
            if (!(rot.x || rot.y || rot.z)) {
                this.scaleRot = 0;
            }
            cam.set(rot.mulVec3(cam.eye), Vec3.ZERO, Vec3.NORTH);
            cam.update();
        }
    }
}

const BASEGEOIMAGE_EVENTS = [
    /**
     * Triggered when image data is loaded
     * @event EventsHandler<BaseGeoImageEventsList>#loadend
     */
    "loadend"
];
/**
 * BaseGeoImage layer represents square imagery layer that
 * could be a static image, or animated video or webgl buffer
 * object displayed on the globe.
 * @class
 * @extends {Layer}
 */
class BaseGeoImage extends Layer {
    constructor(name, options = {}) {
        super(name, options);
        // @ts-ignore
        this.events = this.events.registerNames(BASEGEOIMAGE_EVENTS);
        this._projType = 0;
        this._frameWidth = 256;
        this._frameHeight = 256;
        this._sourceReady = false;
        this._sourceTexture = null;
        this._materialTexture = null;
        this._gridBufferLow = null;
        this._gridBufferHigh = null;
        this._extentWgs84ParamsHigh = new Float32Array(4);
        this._extentWgs84ParamsLow = new Float32Array(4);
        this._extentMercParamsHigh = new Float32Array(4);
        this._extentMercParamsLow = new Float32Array(4);
        this._refreshFrame = true;
        this._frameCreated = false;
        this._sourceCreated = false;
        this._animate = false;
        this._ready = false;
        this._creationProceeding = false;
        this._isRendering = false;
        this._extentWgs84 = new Extent();
        this._cornersWgs84 = [];
        this._cornersMerc = [];
        this._isFullExtent = options.fullExtent ? 1 : 0;
        /**
         * rendering function pointer
         */
        this.rendering = this._renderingProjType0.bind(this);
        this._onLoadend_ = null;
        options.corners && this.setCorners(options.corners);
    }
    get isIdle() {
        return super.isIdle && this._ready;
    }
    addTo(planet) {
        this._onLoadend_ = this._onLoadend.bind(this);
        this.events.on("loadend", this._onLoadend_, this);
        return super.addTo(planet);
    }
    _onLoadend() {
        if (this._planet) {
            this._planet.events.dispatch(this._planet.events.layerloadend, this);
        }
    }
    remove() {
        this.events.off("loadend", this._onLoadend_);
        this._onLoadend_ = null;
        return super.remove();
    }
    get instanceName() {
        return "BaseGeoImage";
    }
    /**
     * Gets corners coordinates.
     * @public
     * @return {Array.<LonLat>} - (exactly 4 entries)
     */
    getCornersLonLat() {
        let c = this._cornersWgs84;
        return [
            new LonLat(c[0].lon, c[0].lat),
            new LonLat(c[1].lon, c[1].lat),
            new LonLat(c[2].lon, c[2].lat),
            new LonLat(c[3].lon, c[3].lat)
        ];
    }
    /**
     * Gets corners coordinates.
     * @public
     * @return {Array.<Array<number>>} - (exactly 3 entries)
     */
    getCorners() {
        let c = this._cornersWgs84;
        return [
            [c[0].lon, c[0].lat],
            [c[1].lon, c[1].lat],
            [c[2].lon, c[2].lat],
            [c[3].lon, c[3].lat]
        ];
    }
    /**
     * Sets geoImage geographical corners coordinates.
     * @public
     * @param {Array.<Array.<number>>} corners - GeoImage corners coordinates. Where first coordinate (exactly 3 entries)
     * coincedents to the left top image corner, secont to the right top image corner, third to the right bottom
     * and fourth - left bottom image corner.
     */
    setCorners(corners) {
        this.setCornersLonLat(LonLat.join(corners));
    }
    /**
     * Sets geoImage geographical corners coordinates.
     * @public
     * @param {Array.<LonLat>} corners - GeoImage corners coordinates. Where first coordinate
     * coincedents to the left top image corner, secont to the right top image corner, third to the right bottom
     * and fourth - left bottom image corner. (exactly 4 entries)
     */
    setCornersLonLat(corners) {
        this._refreshFrame = true;
        this._cornersWgs84 = [
            corners[0].clone(),
            corners[1].clone(),
            corners[2].clone(),
            corners[3].clone()
        ];
        for (let i = 0; i < this._cornersWgs84.length; i++) {
            if (this._cornersWgs84[i].lat >= 89.9) {
                this._cornersWgs84[i].lat = 89.9;
            }
            if (this._cornersWgs84[i].lat <= -89.9) {
                this._cornersWgs84[i].lat = -89.9;
            }
        }
        this._extent.setByCoordinates(this._cornersWgs84);
        let me = this._extent;
        if (me.southWest.lat > MAX_LAT || me.northEast.lat < MIN_LAT) {
            this._projType = 0;
            this.rendering = this._renderingProjType0;
        }
        else {
            this._projType = 1;
            this.rendering = this._renderingProjType1;
        }
        if (this._ready && !this._creationProceeding) {
            this._planet._geoImageCreator.add(this);
        }
    }
    /**
     * Creates geoImage frame.
     * @protected
     */
    _createFrame() {
        this._extentWgs84 = this._extent.clone();
        this._cornersMerc = [
            this._cornersWgs84[0].forwardMercatorEPS01(),
            this._cornersWgs84[1].forwardMercatorEPS01(),
            this._cornersWgs84[2].forwardMercatorEPS01(),
            this._cornersWgs84[3].forwardMercatorEPS01()
        ];
        this._extentMerc = new Extent(this._extentWgs84.southWest.forwardMercatorEPS01(), this._extentWgs84.northEast.forwardMercatorEPS01());
        let tempArr = new Float32Array(2);
        if (this._projType === 0) {
            doubleToTwoFloats2(this._extentWgs84.southWest.lon, tempArr);
            this._extentWgs84ParamsHigh[0] = tempArr[0];
            this._extentWgs84ParamsLow[0] = tempArr[1];
            doubleToTwoFloats2(this._extentWgs84.southWest.lat, tempArr);
            this._extentWgs84ParamsHigh[1] = tempArr[0];
            this._extentWgs84ParamsLow[1] = tempArr[1];
            this._extentWgs84ParamsHigh[2] = 2.0 / this._extentWgs84.getWidth();
            this._extentWgs84ParamsHigh[3] = 2.0 / this._extentWgs84.getHeight();
        }
        else {
            doubleToTwoFloats2(this._extentMerc.southWest.lon, tempArr);
            this._extentMercParamsHigh[0] = tempArr[0];
            this._extentMercParamsLow[0] = tempArr[1];
            doubleToTwoFloats2(this._extentMerc.southWest.lat, tempArr);
            this._extentMercParamsHigh[1] = tempArr[0];
            this._extentMercParamsLow[1] = tempArr[1];
            this._extentMercParamsHigh[2] = 2.0 / this._extentMerc.getWidth();
            this._extentMercParamsHigh[3] = 2.0 / this._extentMerc.getHeight();
        }
        // creates material frame textures
        if (this._planet) {
            let p = this._planet, h = p.renderer.handler, gl = h.gl;
            gl.deleteTexture(this._materialTexture);
            this._materialTexture = h.createEmptyTexture_l(this._frameWidth, this._frameHeight);
            let gridBufferArr = this._planet._geoImageCreator.createGridBuffer(this._cornersWgs84, this._projType === 1);
            this._gridBufferHigh = gridBufferArr[0];
            this._gridBufferLow = gridBufferArr[1];
            this._refreshFrame = false;
        }
    }
    /**
     * @public
     * @override
     * @param {Material} material - GeoImage material.
     */
    abortMaterialLoading(material) {
        this._creationProceeding = false;
        material.isLoading = false;
        material.isReady = false;
    }
    /**
     * Clear layer material.
     * @public
     * @override
     */
    clear() {
        let p = this._planet;
        if (p) {
            let gl = p.renderer.handler.gl;
            this._creationProceeding && p._geoImageCreator.remove(this);
            p._clearLayerMaterial(this);
            if (gl) {
                gl.deleteBuffer(this._gridBufferHigh);
                gl.deleteBuffer(this._gridBufferLow);
                gl.deleteTexture(this._sourceTexture);
                this._materialTexture && !this._materialTexture.default && gl.deleteTexture(this._materialTexture);
            }
        }
        this._sourceTexture = null;
        this._materialTexture = null;
        this._gridBufferHigh = null;
        this._gridBufferLow = null;
        this._refreshFrame = true;
        this._sourceCreated = false;
        this._ready = false;
        this._creationProceeding = false;
    }
    /**
     * Sets layer visibility.
     * @public
     * @override
     * @param {boolean} visibility - GeoImage visibility.
     */
    setVisibility(visibility) {
        if (visibility !== this._visibility) {
            super.setVisibility(visibility);
            // remove from creator
            if (this._planet && this._sourceReady) {
                if (visibility) {
                    this._planet._geoImageCreator.add(this);
                }
                else {
                    this._planet._geoImageCreator.remove(this);
                }
            }
        }
    }
    /**
     * @public
     * @param {Material} material - GeoImage material.
     */
    clearMaterial(material) {
        material.texture = null;
        material.isLoading = false;
        material.isReady = false;
    }
    /**
     * @public
     * @override
     * @returns {Array<number>} -
     */
    applyMaterial(material) {
        let segment = material.segment;
        if (this._ready) {
            material.applyTexture(this._materialTexture);
        }
        else {
            material.texture = this._planet.transparentTexture;
            !this._creationProceeding && this.loadMaterial(material);
        }
        let v0s, v0t;
        if (this._projType === 0) {
            v0s = this._extentWgs84;
            v0t = segment._extent;
        }
        else {
            v0s = this._extentMerc;
            v0t = segment.getExtentMerc();
        }
        let sSize_x = v0s.northEast.lon - v0s.southWest.lon;
        let sSize_y = v0s.northEast.lat - v0s.southWest.lat;
        let dV0s_x = (v0t.southWest.lon - v0s.southWest.lon) / sSize_x;
        let dV0s_y = (v0s.northEast.lat - v0t.northEast.lat) / sSize_y;
        let dSize_x = (v0t.northEast.lon - v0t.southWest.lon) / sSize_x;
        let dSize_y = (v0t.northEast.lat - v0t.southWest.lat) / sSize_y;
        return [dV0s_x, dV0s_y, dSize_x, dSize_y];
    }
    /**
     * Gets frame width size in pixels.
     * @public
     * @returns {Number} Frame width.
     */
    get getFrameWidth() {
        return this._frameWidth;
    }
    /**
     * Gets frame height size in pixels.
     * @public
     * @returns {Number} Frame height.
     */
    get getFrameHeight() {
        return this._frameHeight;
    }
    /**
     * Method depends on GeoImage instance
     * @protected
     */
    _createSourceTexture() {
        //empty
    }
    _renderingProjType1() {
        let p = this._planet, h = p.renderer.handler, gl = h.gl, creator = p._geoImageCreator;
        this._refreshFrame && this._createFrame();
        this._createSourceTexture();
        let f = creator._framebuffer;
        f.setSize(this._frameWidth, this._frameHeight);
        f.activate();
        h.programs.geoImageTransform.activate();
        let sh = h.programs.geoImageTransform._program;
        let sha = sh.attributes, shu = sh.uniforms;
        gl.disable(gl.CULL_FACE);
        f.bindOutputTexture(this._materialTexture);
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform1i(shu.isFullExtent, this._isFullExtent);
        gl.bindBuffer(gl.ARRAY_BUFFER, creator._texCoordsBuffer);
        gl.vertexAttribPointer(sha.texCoords, 2, gl.UNSIGNED_SHORT, true, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._gridBufferHigh);
        gl.vertexAttribPointer(sha.cornersHigh, this._gridBufferHigh.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._gridBufferLow);
        gl.vertexAttribPointer(sha.cornersLow, this._gridBufferLow.itemSize, gl.FLOAT, false, 0, 0);
        gl.uniform4fv(shu.extentParamsHigh, this._extentMercParamsHigh);
        gl.uniform4fv(shu.extentParamsLow, this._extentMercParamsLow);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
        gl.uniform1i(shu.sourceTexture, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, creator._indexBuffer);
        gl.drawElements(gl.TRIANGLE_STRIP, creator._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
        f.deactivate();
        gl.enable(gl.CULL_FACE);
        this._ready = true;
        this._creationProceeding = false;
    }
    _renderingProjType0() {
        let p = this._planet, h = p.renderer.handler, gl = h.gl, creator = p._geoImageCreator;
        this._refreshFrame && this._createFrame();
        this._createSourceTexture();
        let f = creator._framebuffer;
        f.setSize(this._frameWidth, this._frameHeight);
        f.activate();
        h.programs.geoImageTransform.activate();
        let sh = h.programs.geoImageTransform._program;
        let sha = sh.attributes, shu = sh.uniforms;
        gl.disable(gl.CULL_FACE);
        f.bindOutputTexture(this._materialTexture);
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindBuffer(gl.ARRAY_BUFFER, creator._texCoordsBuffer);
        gl.vertexAttribPointer(sha.texCoords, 2, gl.UNSIGNED_SHORT, true, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._gridBufferHigh);
        gl.vertexAttribPointer(sha.cornersHigh, this._gridBufferHigh.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._gridBufferLow);
        gl.vertexAttribPointer(sha.cornersLow, this._gridBufferLow.itemSize, gl.FLOAT, false, 0, 0);
        gl.uniform4fv(shu.extentParamsHigh, this._extentWgs84ParamsHigh);
        gl.uniform4fv(shu.extentParamsLow, this._extentWgs84ParamsLow);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
        gl.uniform1i(shu.sourceTexture, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, creator._indexBuffer);
        gl.drawElements(gl.TRIANGLE_STRIP, creator._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
        f.deactivate();
        gl.enable(gl.CULL_FACE);
        this._ready = true;
        this._creationProceeding = false;
    }
}

const ICON_BUTTON_SVG$7 = `<?xml version="1.0" encoding="UTF-8" standalone="no"?> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M16 13l6.964 4.062-2.973.85 2.125 3.681-1.732 1-2.125-3.68-2.223 2.15L16 13zm-2-7h2v2h5a1 1 0 0 1 1 1v4h-2v-3H10v10h4v2H9a1 1 0 0 1-1-1v-5H6v-2h2V9a1 1 0 0 1 1-1h5V6zM4 14v2H2v-2h2zm0-4v2H2v-2h2zm0-4v2H2V6h2zm0-4v2H2V2h2zm4 0v2H6V2h2zm4 0v2h-2V2h2zm4 0v2h-2V2h2z" fill="#000"/></svg>`;
class GeoImageDragControl extends Control {
    constructor(options = {}) {
        super(options);
        this._cornerIndex = -1;
        this._catchCorner = false;
        this._toggleBtn = new ToggleButton({
            classList: ["og-map-button", "og-geoimagegrag_button"],
            icon: ICON_BUTTON_SVG$7
        });
    }
    oninit() {
        this._toggleBtn.appendTo(this.renderer.div);
        this.planet.events.on('layeradd', (e) => {
            if (this.isActive()) {
                this._bindLayer(e);
            }
        }, this);
        this._toggleBtn.events.on("change", (isActive) => {
            if (isActive) {
                this.activate();
            }
            else {
                this.deactivate();
            }
        });
    }
    onactivate() {
        super.onactivate();
        const p = this.planet;
        for (let i = 0; i < p.layers.length; i++) {
            this._bindLayer(p.layers[i]);
        }
    }
    ondeactivate() {
        super.ondeactivate();
        const p = this.planet;
        for (let i = 0; i < p.layers.length; i++) {
            this._unbindLayer(p.layers[i]);
        }
    }
    _bindLayer(layer) {
        if (layer instanceof BaseGeoImage) {
            layer.events.on('mousemove', this._onMouseMove, this);
            layer.events.on("mouseleave", this._onMouseLeave, this);
            layer.events.on('ldown', this._onLDown, this);
            layer.events.on('lup', this._onLUp, this);
        }
    }
    _unbindLayer(layer) {
        if (layer instanceof BaseGeoImage) {
            layer.events.off('mousemove', this._onMouseMove);
            layer.events.off("mouseleave", this._onMouseLeave);
            layer.events.off('ldown', this._onLDown);
            layer.events.off('lup', this._onLUp);
        }
    }
    _onLUp(ms) {
        this._catchCorner = false;
        ms.renderer.controls.mouseNavigation.activate();
    }
    _onLDown(ms) {
        if (this._cornerIndex !== -1) {
            this._catchCorner = true;
            ms.renderer.controls.mouseNavigation.deactivate();
        }
    }
    _onMouseLeave() {
        document.body.style.cursor = 'auto';
    }
    _onMouseMove(ms) {
        let layer = ms.pickingObject;
        const p = this.planet;
        if (this._catchCorner) { // mouse is catching a corner
            let corners = layer.getCornersLonLat();
            // corners[this._cornerIndex] = p.getLonLatFromPixelTerrain(ms, true);
            corners[this._cornerIndex] = p.getLonLatFromPixelTerrain(ms);
            layer.setCornersLonLat(corners);
        }
        else { // mouse isn't catching
            this._cornerIndex = -1;
            for (let i = 0; i < layer._cornersWgs84.length; i++) {
                // let ground = p.getLonLatFromPixelTerrain(ms, true);
                let ground = p.getLonLatFromPixelTerrain(ms);
                // mouse is near
                //if (ground && p.ellipsoid.getGreatCircleDistance(layer._cornersWgs84[i], ground) / p.getDistanceFromPixel(ms, true) <= 0.05) {
                if (ground && p.ellipsoid.getGreatCircleDistance(layer._cornersWgs84[i], ground) / p.getDistanceFromPixel(ms) <= 0.05) {
                    this._cornerIndex = i;
                    document.body.style.cursor = 'move';
                    break;
                    // mouse is far
                }
                else {
                    document.body.style.cursor = 'auto';
                }
            }
        }
    }
}

const input = {
    MB_LEFT: 0,
    MB_RIGHT: 2,
    MB_MIDDLE: 1,
    KEY_CTRL: 17,
    KEY_ALT: 18,
    KEY_SHIFT: 16,
    KEY_SPACE: 32,
    KEY_PGUP: 33,
    KEY_PGDN: 34,
    KEY_LEFT: 37,
    KEY_UP: 38,
    KEY_RIGHT: 39,
    KEY_DOWN: 40,
    KEY_PRINTSCREEN: 44,
    KEY_EQUALS: 61,
    KEY_A: 65,
    KEY_C: 67,
    KEY_D: 68,
    KEY_E: 69,
    KEY_F: 70,
    KEY_H: 72,
    KEY_I: 73,
    KEY_K: 75,
    KEY_L: 76,
    KEY_N: 78,
    KEY_O: 79,
    KEY_P: 80,
    KEY_Q: 81,
    KEY_R: 82,
    KEY_S: 83,
    KEY_V: 86,
    KEY_W: 87,
    KEY_X: 88,
    KEY_Z: 90,
    KEY_PLUS: 107,
    KEY_F1: 112,
    KEY_MINUS: 173,
    KEY_APOSTROPHE: 192,
    KEY_BACK_SLASH: 220,
    KEY_MORE: 190,
    KEY_SLASH: 191,
    KEY_LESS: 188,
    KEY_LEFT_SQUARE_BRACKET: 219,
    KEY_RIGHT_SQUARE_BRACKET: 221,
    KEY_SINGLE_QUOTE: 222
};

/**
 * Planet camera keyboard navigation. Use W,S,A,D and left shift key for fly around a planet.
 */
class KeyboardNavigation extends Control {
    constructor(options = {}) {
        options = options || {};
        super({ name: "KeyboardNavigation", ...options });
        this.step = options.step || 250;
    }
    onactivate() {
        let r = this.renderer;
        r.events.on("keypress", input.KEY_PGUP, this.onCameraMoveForward, this);
        r.events.on("keypress", input.KEY_PGDN, this.onCameraMoveBackward, this);
        r.events.on("keypress", input.KEY_PLUS, this.onCameraMoveForward, this);
        r.events.on("keypress", input.KEY_EQUALS, this.onCameraMoveForward, this);
        r.events.on("keypress", input.KEY_MINUS, this.onCameraMoveBackward, this);
        r.events.on("keypress", input.KEY_W, this.onCameraMoveForward, this);
        r.events.on("keypress", input.KEY_S, this.onCameraMoveBackward, this);
        r.events.on("keypress", input.KEY_A, this.onCameraStrifeLeft, this);
        r.events.on("keypress", input.KEY_D, this.onCameraStrifeRight, this);
        r.events.on("keypress", input.KEY_UP, this.onCameraLookUp, this);
        r.events.on("keypress", input.KEY_DOWN, this.onCameraLookDown, this);
        r.events.on("keypress", input.KEY_LEFT, this.onCameraLookLeft, this);
        r.events.on("keypress", input.KEY_RIGHT, this.onCameraLookRight, this);
        r.events.on("keypress", input.KEY_Q, this.onCameraRollLeft, this);
        r.events.on("keypress", input.KEY_E, this.onCameraRollRight, this);
        r.events.on("keypress", input.KEY_N, this.onCameraRollNorth, this);
    }
    ondeactivate() {
        let r = this.renderer;
        r.events.off("keypress", input.KEY_PGUP, this.onCameraMoveForward);
        r.events.off("keypress", input.KEY_PGDN, this.onCameraMoveBackward);
        r.events.off("keypress", input.KEY_PLUS, this.onCameraMoveForward);
        r.events.off("keypress", input.KEY_EQUALS, this.onCameraMoveForward);
        r.events.off("keypress", input.KEY_MINUS, this.onCameraMoveBackward);
        r.events.off("keypress", input.KEY_W, this.onCameraMoveForward);
        r.events.off("keypress", input.KEY_S, this.onCameraMoveBackward);
        r.events.off("keypress", input.KEY_A, this.onCameraStrifeLeft);
        r.events.off("keypress", input.KEY_D, this.onCameraStrifeRight);
        r.events.off("keypress", input.KEY_UP, this.onCameraLookUp);
        r.events.off("keypress", input.KEY_DOWN, this.onCameraLookDown);
        r.events.off("keypress", input.KEY_LEFT, this.onCameraLookLeft);
        r.events.off("keypress", input.KEY_RIGHT, this.onCameraLookRight);
        r.events.off("keypress", input.KEY_Q, this.onCameraRollLeft);
        r.events.off("keypress", input.KEY_E, this.onCameraRollRight);
        r.events.off("keypress", input.KEY_N, this.onCameraRollNorth);
    }
    oninit() {
        this.activate();
    }
    onCameraMoveForward() {
        let cam = this.planet.camera;
        cam.slide(0, 0, -cam.getAltitude() / this.step);
    }
    onCameraMoveBackward() {
        let cam = this.planet.camera;
        cam.slide(0, 0, cam.getAltitude() / this.step);
    }
    onCameraStrifeLeft() {
        let cam = this.planet.camera;
        cam.slide(-cam.getAltitude() / this.step, 0, 0);
    }
    onCameraStrifeRight() {
        let cam = this.planet.camera;
        cam.slide(cam.getAltitude() / this.step, 0, 0);
    }
    onCameraLookUp() {
        let cam = this.planet.camera;
        if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
            cam.pitch(15 / this.renderer.handler.deltaTime);
        }
        else {
            cam.rotateVertical((cam.getAltitude() / 3000000) * RADIANS, Vec3.ZERO);
        }
    }
    onCameraLookDown() {
        let cam = this.planet.camera;
        if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
            cam.pitch(-15 / this.renderer.handler.deltaTime);
        }
        else {
            cam.rotateVertical((-cam.getAltitude() / 3000000) * RADIANS, Vec3.ZERO);
        }
    }
    onCameraLookLeft() {
        let cam = this.planet.camera;
        if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
            cam.roll(15 / this.renderer.handler.deltaTime);
        }
        else {
            cam.rotateHorizontal((cam.getAltitude() / 3000000) * RADIANS);
        }
    }
    onCameraLookRight() {
        let cam = this.planet.camera;
        if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
            cam.roll(-15 / this.renderer.handler.deltaTime);
        }
        else {
            cam.rotateHorizontal((-cam.getAltitude() / 3000000) * RADIANS);
        }
    }
    onCameraTurnLeft() {
        let cam = this.planet.camera;
        if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
            cam.yaw(15 / this.renderer.handler.deltaTime);
        }
        else {
            cam.rotateHorizontal((cam.getAltitude() / 3000000) * RADIANS);
        }
    }
    onCameraTurnRight() {
        let cam = this.planet.camera;
        if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
            cam.yaw(-15 / this.renderer.handler.deltaTime);
        }
        else {
            cam.rotateHorizontal((-cam.getAltitude() / 3000000) * RADIANS, false, Vec3.ZERO);
        }
    }
    // from CompassButton._onClick()
    onCameraRollNorth() {
        let c = this.planet.getCartesianFromPixelTerrain(this.renderer.handler.getCenter());
        if (c) {
            this.planet.flyCartesian(c.normal().scaleTo(c.length() + c.distance(this.planet.camera.eye)), null, null, 0, null, null, () => {
                this.planet.camera.look;
            });
        }
        else {
            this.planet.flyCartesian(this.planet.camera.eye);
        }
    }
    onCameraRollLeft() {
        this.planet.camera.roll(-15 / this.renderer.handler.deltaTime);
    }
    onCameraRollRight() {
        this.planet.camera.roll(15 / this.renderer.handler.deltaTime);
    }
}

const LAYERANIMATION_EVENTS = ["change", "idle", "play", "pause", "stop"];
class LayerAnimation extends Control {
    constructor(options = {}) {
        super(options);
        this._currVisibleIndex = 0;
        this._onViewchange = () => {
            this._timeoutStart = performance.now();
        };
        this._onVisibilityChange = (isVisible) => {
            if (!isVisible) {
                this.pause();
            }
        };
        /**
         * Waiting for the current index layer loadend and make it non-transparent,
         * and make prev layer transparent, also check previous frame index to clean up.
         */
        this._onLayerLoadend = (layer) => {
            let currLayer = this._layersArr[this._currentIndex];
            if (currLayer && currLayer.isEqual(layer)) {
                // BRUTE
                let currFrame = this._getFrameIndex(this._currentIndex);
                let from = currFrame * this._frameSize, to = this._currentIndex;
                for (let i = from; i < to; i++) {
                    let li = this._layersArr[i];
                    li.opacity = 0;
                    li.setVisibility(false);
                }
                // * Make CURRENT Layer VISIBLE *
                currLayer.opacity = 1.0;
                let currVisibleLayer = this._layersArr[this._currVisibleIndex];
                if (currVisibleLayer) {
                    currVisibleLayer.opacity = 0.0;
                    currVisibleLayer.setVisibility(false);
                    // If frame is changed - remove it from the planet
                    let prevFrame = this._getFrameIndex(this._currVisibleIndex);
                    if (this._getFrameIndex(this._currentIndex) !== prevFrame) {
                        this._removeFrameFromPlanet(prevFrame);
                    }
                }
                this.events.dispatch(this.events.idle, currLayer);
            }
        };
        this.events = createEvents(LAYERANIMATION_EVENTS);
        this._name = options.name || `layerAnimation-${this.__id}`;
        this._layersArr = options.layers ? [].concat(options.layers) : [];
        this._currentIndex = -1;
        this._playInterval = options.playInterval || 120;
        this._playIntervalHandler = -1;
        this._playIndex = 0;
        this._frameSize = options.frameSize || 50;
        this.repeat = options.repeat != undefined ? options.repeat : true;
        this.skipTimeout = options.skipTimeout || 5000;
        this._timeoutStart = 0;
    }
    _getFramesNum() {
        return Math.ceil(this._layersArr.length / this._frameSize);
    }
    _setFrame(frameIndex) {
        for (let i = 0, len = this._getFramesNum(); i < len; i++) {
            if (i !== frameIndex) {
                this._removeFrameFromPlanet(i);
            }
            else {
                this._appendFrameToPlanet(i);
            }
        }
    }
    _getFrameIndex(layerIndex) {
        return Math.floor(layerIndex / this._frameSize);
    }
    _appendFrameToPlanet(frameIndex) {
        if (this.planet) {
            let minIndex = frameIndex * this._frameSize;
            let maxIndex = minIndex + this._frameSize;
            for (let i = minIndex, len = maxIndex > this._layersArr.length ? this._layersArr.length : maxIndex; i < len; i++) {
                this.planet.addLayer(this._layersArr[i]);
            }
        }
    }
    _removeFrameFromPlanet(frameIndex) {
        if (this.planet) {
            let minIndex = frameIndex * this._frameSize;
            let maxIndex = minIndex + this._frameSize;
            for (let i = minIndex, len = maxIndex > this._layersArr.length ? this._layersArr.length : maxIndex; i < len; i++) {
                this._layersArr[i].abortLoading();
                this._layersArr[i].remove();
                this._layersArr[i].setVisibility(false);
            }
        }
    }
    oninit() {
        super.oninit();
        this.onactivate();
        this._initLayers();
        this.planet.events.on("layerloadend", this._onLayerLoadend);
        this._setCurrentIndexAsync(0, false, true);
    }
    onactivate() {
        super.onactivate();
        this.planet.camera.events.on("viewchange", this._onViewchange);
        this.planet.renderer.handler.events.on("visibilitychange", this._onVisibilityChange);
    }
    ondeactivate() {
        super.ondeactivate();
        this.planet.camera.events.off("viewchange", this._onViewchange);
        for (let i = 0; i < this._layersArr.length; i++) {
            this._layersArr[i].setVisibility(false);
        }
        this.planet.events.off("layerloadend", this._onLayerLoadend);
        this.planet.renderer.handler.events.off("visibilitychange", this._onVisibilityChange);
    }
    clear() {
        this.stop();
        this._currentIndex = -1;
        this._currVisibleIndex = -1;
        let layersToRemove = this._layersArr;
        this._layersArr = [];
        for (let i = 0; i < layersToRemove.length; i++) {
            layersToRemove[i].remove();
        }
    }
    _initLayers() {
        if (this.planet) {
            for (let i = 0, len = this._layersArr.length; i < len; i++) {
                let li = this._layersArr[i];
                li.setVisibility(false);
                li.setBaseLayer(false);
                li.opacity = 0.0;
            }
            this._appendFrameToPlanet(0);
        }
    }
    setLayers(layers) {
        this.clear();
        this._layersArr = [].concat(layers);
        this._initLayers();
    }
    appendLayer(layer) {
        this._layersArr.push(layer);
        layer.setVisibility(false);
        layer.setBaseLayer(false);
        layer.opacity = 0.0;
        //check current frame
        this.planet?.addLayer(layer);
    }
    /**
     * warning: Use XYZ.isIdle in requestAnimationFrame(after setVisibility)
     * @returns Returns true if current layer is idle
     */
    get isIdle() {
        let currLayer = this._layersArr[this._currentIndex];
        return currLayer && currLayer.isIdle || !currLayer;
    }
    get playInterval() {
        return this._playInterval;
    }
    set playInterval(val) {
        if (val !== this._playInterval) {
            this._playInterval = val;
            if (this.isPlaying) {
                this.pause();
                this.play();
            }
        }
    }
    get isPlaying() {
        return this._playIntervalHandler !== -1;
    }
    get layers() {
        return this._layersArr;
    }
    _checkEnd() {
        if (this._playIndex > this._layersArr.length) {
            if (this.repeat) {
                this._playIndex = 0;
            }
            else {
                this.pause();
            }
        }
    }
    play() {
        if (!this.isPlaying) {
            if (this._currentIndex >= this._layersArr.length - 1) {
                this.stop();
            }
            this._timeoutStart = performance.now();
            this._playIntervalHandler = setInterval(() => {
                this._checkEnd();
                this._setCurrentIndexAsync(this._playIndex, false, false);
                requestAnimationFrame(() => {
                    if (this.isIdle || (performance.now() - this._timeoutStart > this.skipTimeout)) {
                        this._playIndex++;
                        this._timeoutStart = performance.now();
                    }
                });
            }, this._playInterval);
            this.events.dispatch(this.events.play);
        }
    }
    stop() {
        if (this._playIndex > 0) {
            this._clearInterval();
            this._playIndex = 0;
            this.setCurrentIndex(0);
            this.events.dispatch(this.events.stop);
        }
    }
    pause() {
        if (this.isPlaying) {
            this._clearInterval();
            this.events.dispatch(this.events.pause);
        }
    }
    _clearInterval() {
        clearInterval(this._playIntervalHandler);
        this._playIntervalHandler = -1;
    }
    /**
     * Function sets layer index visible.
     * @param {number} index
     * @param {boolean} [stopPropagation=false]
     */
    setCurrentIndex(index, stopPropagation = false) {
        this._setCurrentIndexAsync(index, true, stopPropagation);
    }
    /**
     * Function sets layer index visible. If the layer is idle (all visible tiles loaded), sets opacity to one,
     * otherwise to ZERO it means that when all visible tiles will be loaded the opacity becomes ONE. So, previous
     * layer remains not transparent (opacity = 1) till current layer is loading.
     */
    _setCurrentIndexAsync(index, forceVisibility = false, stopPropagation = false) {
        if (index != this._currentIndex && index >= 0 && index < this._layersArr.length) {
            let prevCurrIndex = this._currentIndex;
            this._currentIndex = index;
            this._playIndex = index;
            let prevCurrFrame = this._getFrameIndex(prevCurrIndex);
            let currFrame = this._getFrameIndex(this._currentIndex);
            let prevCurrLayer = this._layersArr[prevCurrIndex], currLayer = this._layersArr[index];
            let frameChanged = currFrame != prevCurrFrame;
            if (frameChanged) {
                this._appendFrameToPlanet(currFrame);
            }
            if (prevCurrLayer) {
                if (prevCurrLayer.isIdle) {
                    this._currVisibleIndex = prevCurrIndex;
                }
                else {
                    prevCurrLayer.opacity = 0;
                    prevCurrLayer.setVisibility(false);
                }
            }
            if (currLayer) {
                currLayer.opacity = 0.0;
                currLayer.setVisibility(true);
                requestAnimationFrame(() => {
                    if (currLayer.isIdle || forceVisibility) {
                        currLayer.opacity = 1.0;
                        // If frame is changed - remove it from the planet
                        if (frameChanged) {
                            this._removeFrameFromPlanet(prevCurrFrame);
                        }
                        if (prevCurrLayer) {
                            prevCurrLayer.opacity = 0.0;
                            prevCurrLayer.setVisibility(false);
                        }
                        let currVisibleLayer = this._layersArr[this._currVisibleIndex];
                        if (currVisibleLayer) {
                            currVisibleLayer.opacity = 0.0;
                            currVisibleLayer.setVisibility(false);
                        }
                    }
                });
                if (!stopPropagation) {
                    this.events.dispatch(this.events.change, this._currentIndex, prevCurrIndex);
                }
            }
        }
    }
}

const ICON_BUTTON_SVG$6 = `<?xml version="1.0" encoding="utf-8"?>
<!-- Svg Vector Icons : http://www.onlinewebfonts.com/icon -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 1000 1000" enable-background="new 0 0 1000 1000" xml:space="preserve">
<metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>
<g><path d="M500,573.5c-3.2,0-6.5-0.6-9.5-1.9L25,375.6c-9.1-3.8-15-12.7-15-22.6s5.9-18.8,15-22.6l465.5-196c6.1-2.5,12.9-2.5,19,0l465.5,196c9.1,3.8,15,12.7,15,22.6s-5.9,18.8-15,22.6l-465.5,196C506.5,572.9,503.2,573.5,500,573.5L500,573.5z M97.6,353L500,522.4L902.4,353L500,183.6L97.6,353L97.6,353z"/><path d="M500,720.5c-3.2,0-6.5-0.6-9.5-1.9L25,522.6c-12.4-5.2-18.3-19.6-13.1-32.1c5.2-12.5,19.6-18.3,32.1-13.1l456,192l456-192c12.4-5.2,26.9,0.6,32.1,13.1s-0.6,26.9-13.1,32.1l-465.5,196C506.5,719.9,503.2,720.5,500,720.5L500,720.5z"/><path d="M500,867.5c-3.2,0-6.5-0.6-9.5-1.9L25,669.6c-12.4-5.2-18.3-19.6-13.1-32.1c5.2-12.5,19.6-18.3,32.1-13.1l456,192l456-192c12.4-5.2,26.9,0.6,32.1,13.1c5.2,12.5-0.6,26.8-13.1,32.1l-465.5,196C506.5,866.9,503.2,867.5,500,867.5L500,867.5z"/></g>
</svg>`;
const TEMPLATE$b = `<div class="og-layerSwitcher">
      <div class="og-layerSwitcher__title">Base Layers</div>
      <div class="og-layerSwitcher__list og-layerSwitcher__baseLayers"></div>        
        
      <div class="og-layerSwitcher__title">Overlays</div>
      <div class="og-layerSwitcher__list og-layerSwitcher__overlays"></div>
         
    </div>`;
const LAYER_BUTTON_TEMPLATE = `<button title={title} class="og-layerSwitcher__layerButton">{icon}<div class="og-layerSwitcher__name">{name}</div></button>`;
class LayerButtonView extends View {
    constructor(params) {
        super({
            template: stringTemplate(LAYER_BUTTON_TEMPLATE, {
                title: params.model.name,
                name: params.model.name,
                icon: params.model.iconSrc ? `<img src="${params.model.iconSrc}" />` : ""
            }),
            ...params
        });
        this._onVisibilityChange = (layer) => {
            if (this.el) {
                if (this.model.getVisibility()) {
                    this.el.classList.add("og-layerSwitcher__visible");
                }
                else {
                    this.el.classList.remove("og-layerSwitcher__visible");
                }
            }
        };
        this._onClick = () => {
            if (this.model.isBaseLayer()) {
                this.model.setVisibility(true);
            }
            else {
                this.model.setVisibility(!this.model.getVisibility());
            }
        };
        this._onDblClick = () => {
            this.model.flyExtent();
        };
    }
    render(params) {
        super.render(params);
        this.model.events.on("visibilitychange", this._onVisibilityChange);
        this._onVisibilityChange(this.model);
        this.el.addEventListener("click", this._onClick);
        this.el.addEventListener("dblclick", this._onDblClick);
        return this;
    }
    remove() {
        super.remove();
        this.model.events.off("visibilitychange", this._onVisibilityChange);
    }
}
/**
 * Advanced :) layer switcher, includes base layers, overlays, geo images etc. groups.
 * Double click for zoom, drag-and-drop to change zIndex
 */
class LayerSwitcher extends Control {
    constructor(options = {}) {
        super({
            name: "LayerSwitcher",
            ...options
        });
        this.addLayer = (layer) => {
            if (!layer.hideInLayerSwitcher) {
                let layerView = this._createLayerButton(layer);
                this._layerViews.push(layerView);
                if (layer.isBaseLayer()) {
                    layerView.appendTo(this.$baseLayers);
                }
                else {
                    layerView.appendTo(this.$overlays);
                }
            }
        };
        this.removeLayer = (layer) => {
            for (let i = 0; i < this._layerViews.length; i++) {
                let li = this._layerViews[i];
                if (li.model.isEqual(layer)) {
                    li.remove();
                    this._layerViews.splice(i, 1);
                    break;
                }
            }
        };
        this._dialog = new Dialog({
            title: "Layer Switcher",
            top: 15,
            useHide: true,
            visible: false,
            width: 300,
            maxHeight: 500
        });
        this._panel = new View({
            template: TEMPLATE$b
        });
        this._toggleBtn = new ToggleButton({
            classList: ["og-map-button", "og-layerSwitcher_button"],
            icon: ICON_BUTTON_SVG$6
        });
        this.$baseLayers = null;
        this.$overlays = null;
        this._layerViews = [];
    }
    oninit() {
        this._toggleBtn.appendTo(this.renderer.div);
        this._dialog.appendTo(this.planet.renderer.div);
        this._panel.appendTo(this._dialog.container);
        this.$baseLayers = this._panel.el.querySelector(".og-layerSwitcher__baseLayers");
        this.$overlays = this._panel.el.querySelector(".og-layerSwitcher__overlays");
        this._dialog.setPosition(this.planet.renderer.div.clientWidth - this._dialog.width - 67);
        this._dialog.events.on("visibility", (v) => {
            this._toggleBtn.setActive(v);
        });
        this._toggleBtn.events.on("change", (isActive) => {
            this._dialog.setVisibility(isActive);
        });
        this.planet.events.on("layeradd", this.addLayer, this);
        this.planet.events.on("layerremove", this.removeLayer, this);
        this._initLayers();
    }
    _initLayers() {
        let layers = this.planet.layers;
        for (let i = 0; i < layers.length; i++) {
            this.addLayer(layers[i]);
        }
    }
    _createLayerButton(layer) {
        return new LayerButtonView({
            model: layer
        });
    }
    onactivate() {
    }
    ondeactivate() {
        this._dialog.hide();
    }
}

const SLIDER_EVENTS = ["change"];
const TEMPLATE$a = `<div class="og-slider">
      <div class="og-slider-label">{label}</div>
      <div class="og-slider-panel">
        <div class="og-slider-progress"></div>      
        <div class="og-slider-pointer"></div>
      </div>
      <input type="number"/>
    </div>`;
class Slider extends View {
    constructor(options = {}) {
        super({
            template: stringTemplate(TEMPLATE$a, {
                label: options.label || ""
            })
        });
        this._onResize = () => {
            this._setOffset((this._value - this._min) * this.$panel.clientWidth / (this._max - this._min));
        };
        this._onMouseWheel = (e) => {
            //@ts-ignore
            e = e || window.event;
            e.preventDefault();
            e.stopPropagation();
            //@ts-ignore
            this.value = this._value + Math.sign(e.wheelDelta) * (this._max - this._min) / 100.0;
        };
        this._onMouseWheelFF = (e) => {
            this._onMouseWheel(e);
        };
        this._onInput = (e) => {
            //@ts-ignore
            e = e || window.event;
            e.preventDefault();
            e.stopPropagation();
            //@ts-ignore
            this.value = parseFloat(e.target.value);
        };
        this._onMouseDown = (e) => {
            //@ts-ignore
            e = e || window.event;
            e.preventDefault();
            this._startPosX = e.clientX;
            this.value = this._min + (this._max - this._min) * (e.offsetX / this.$panel.clientWidth);
            document.addEventListener("mousemove", this._onMouseMove);
            document.addEventListener("mouseup", this._onMouseUp);
        };
        this._onMouseMove = (e) => {
            //@ts-ignore
            e = e || window.event;
            e.preventDefault();
            e.stopPropagation();
            let rect = this.$panel.getBoundingClientRect();
            let clientX = clamp(e.clientX, rect.left, rect.right);
            let dx = this._startPosX - clientX;
            this._startPosX = clientX;
            this.value = this._value - dx * (this._max - this._min) / this.$panel.clientWidth;
        };
        this._onMouseUp = () => {
            document.removeEventListener("mouseup", this._onMouseUp);
            document.removeEventListener("mousemove", this._onMouseMove);
        };
        //@ts-ignore
        this.events = this.events.registerNames(SLIDER_EVENTS);
        this._value = options.value || 0.0;
        this._min = options.min || 0.0;
        this._max = options.max || 1.0;
        //this._step = options.step || ((this._max - this._min) / 10.0);
        this._resizeObserver = new ResizeObserver(this._onResize);
        this._startPosX = 0;
        this.$label = null;
        this.$pointer = null;
        this.$progress = null;
        this.$input = null;
        this.$panel = null;
    }
    render(params) {
        super.render(params);
        this.$label = this.select(".og-slider-label");
        if (this.$label.innerHTML === "") {
            this.$label.style.display = "none";
        }
        this.$pointer = this.select(".og-slider-pointer");
        this.$progress = this.select(".og-slider-progress");
        this.$panel = this.select(".og-slider-panel");
        this.$input = this.select("input");
        this._resizeObserver.observe(this.el);
        this._initEvents();
        return this;
    }
    set value(val) {
        if (val !== this._value) {
            this._value = clamp(val, this._min, this._max);
            this.$input.value = this._value.toString();
            this._setOffset((this._value - this._min) * this.$panel.clientWidth / (this._max - this._min));
            this.events.dispatch(this.events.change, this._value, this);
        }
    }
    get value() {
        return this._value;
    }
    _initEvents() {
        this.$panel.addEventListener("mousedown", this._onMouseDown);
        //@ts-ignore
        this.$panel.addEventListener("mousewheel", this._onMouseWheel);
        this.$panel.addEventListener("wheel", this._onMouseWheelFF);
        this.$input.addEventListener("input", this._onInput);
    }
    _clearEvents() {
        this.$panel.removeEventListener("mousedown", this._onMouseDown);
        //@ts-ignore
        this.$panel.removeEventListener("mousewheel", this._onMouseWheel);
        this.$panel.removeEventListener("wheel", this._onMouseWheelFF);
        this.$input.removeEventListener("input", this._onInput);
    }
    _setOffset(x) {
        if (x >= 0 && x <= this.$panel.clientWidth) {
            this.$pointer.style.left = this.$progress.style.width = `${x * 100 / this.$panel.clientWidth}%`;
        }
    }
    remove() {
        this._clearEvents();
        super.remove();
    }
}

const COLOR_EVENTS = ["input"];
const TEMPLATE$9 = `<div class="og-color">
      <label for="{id}" class="og-color-label">{label}</label>
      <input type="color" name="{id}" value="{value}"/>
    </div>`;
let __labelCounter__ = 0;
class Color extends View {
    constructor(options = {}) {
        super({
            template: stringTemplate(TEMPLATE$9, {
                id: `color-${__labelCounter__++}`,
                label: options.label || ""
            })
        });
        this._onInput = (e) => {
            //@ts-ignore
            this.value = e.target.value;
        };
        //@ts-ignore
        this.events = this.events.registerNames(COLOR_EVENTS);
        this._value = options.value || "blue";
        this.$label = null;
        this.$input = null;
    }
    render(params) {
        super.render(params);
        this.$label = this.select(".og-color-label");
        if (this.$label.innerHTML === "") {
            this.$label.style.display = "none";
        }
        this.$input = this.select("input");
        this._initEvents();
        return this;
    }
    set value(val) {
        if (val !== this._value) {
            this._value = val;
            this.$input.value = this._value;
            this.events.dispatch(this.events.input, this._value, this);
        }
    }
    get value() {
        return this._value;
    }
    _initEvents() {
        this.$input.addEventListener("input", this._onInput);
    }
    _clearEvents() {
        this.$input.removeEventListener("input", this._onInput);
    }
    remove() {
        this._clearEvents();
        super.remove();
    }
}

const SUN_STOP_SVG_ICON = `<?xml version="1.0" encoding="utf-8"?><svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 122.88 70.41" style="enable-background:new 0 0 122.88 70.41" xml:space="preserve"><g><path d="M60.91,19.12c6.95,0,13.24,2.95,17.8,7.72c4.55,4.77,7.37,11.37,7.37,18.64c0,1.94-0.2,3.83-0.58,5.65h31.61 c2.1,0,2.62,1.16,2.62,2.59c0,1.43-0.52,2.59-2.62,2.59H7.09c-2.1,0-2.62-1.16-2.62-2.59c0-1.43,0.52-2.59,2.62-2.59h29.23 c-0.38-1.82-0.58-3.71-0.58-5.65c0-7.28,2.82-13.87,7.37-18.64C47.67,22.08,53.96,19.12,60.91,19.12L60.91,19.12L60.91,19.12z M63.4,70.41c-2.1,0-2.62-1.16-2.62-2.59s0.52-2.59,2.62-2.59h56.86c2.1,0,2.62,1.16,2.62,2.59s-0.52,2.59-2.62,2.59H63.4 L63.4,70.41z M2.62,70.41c-2.1,0-2.62-1.16-2.62-2.59s0.52-2.59,2.62-2.59h29.51c2.1,0,2.62,1.16,2.62,2.59s-0.52,2.59-2.62,2.59 H2.62L2.62,70.41z M38.39,9.46c-0.78-1.35-0.32-3.07,1.03-3.85c1.35-0.78,3.07-0.32,3.85,1.03l3.62,6.27 c0.78,1.35,0.32,3.07-1.03,3.85c-1.35,0.78-3.07,0.32-3.85-1.03L38.39,9.46L38.39,9.46L38.39,9.46z M58.67,2.83 c0-1.56,1.27-2.83,2.83-2.83c1.56,0,2.83,1.27,2.83,2.83v7.24c0,1.56-1.27,2.83-2.83,2.83c-1.56,0-2.83-1.26-2.83-2.83V2.83 L58.67,2.83L58.67,2.83z M79.56,7.23c0.77-1.35,2.49-1.81,3.84-1.04c1.35,0.77,1.81,2.49,1.04,3.84l-3.62,6.27 c-0.77,1.35-2.49,1.81-3.84,1.04c-1.35-0.77-1.81-2.49-1.04-3.84L79.56,7.23L79.56,7.23L79.56,7.23z M95.45,21.48 c1.35-0.78,3.07-0.32,3.85,1.03c0.78,1.35,0.32,3.07-1.03,3.85L92,29.98c-1.35,0.78-3.07,0.32-3.85-1.03 c-0.78-1.35-0.32-3.07,1.03-3.85L95.45,21.48L95.45,21.48L95.45,21.48z M102.08,41.76c1.56,0,2.83,1.27,2.83,2.83 c0,1.56-1.27,2.83-2.83,2.83h-7.24c-1.56,0-2.83-1.26-2.83-2.83s1.26-2.83,2.83-2.83H102.08L102.08,41.76L102.08,41.76z M19.74,46.25c-1.56,0-2.83-1.27-2.83-2.83c0-1.56,1.27-2.83,2.83-2.83h7.24c1.56,0,2.83,1.26,2.83,2.83s-1.27,2.83-2.83,2.83 H19.74L19.74,46.25L19.74,46.25z M24.14,25.35c-1.35-0.77-1.81-2.49-1.04-3.84c0.77-1.35,2.49-1.81,3.84-1.04l6.27,3.62 c1.35,0.77,1.81,2.49,1.04,3.84c-0.77,1.35-2.49,1.81-3.84,1.04L24.14,25.35L24.14,25.35L24.14,25.35z"/></g></svg>`;
const SUN_ACTIVE_SVG_ICON = `<?xml version="1.0"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
    <path style="text-indent:0;text-align:start;line-height:normal;text-transform:none;block-progression:tb;-inkscape-font-specification:Sans" d="M 16 4 C 9.3844277 4 4 9.3844277 4 16 C 4 22.615572 9.3844277 28 16 28 C 22.615572 28 28 22.615572 28 16 C 28 9.3844277 22.615572 4 16 4 z M 16 6 C 16.389823 6 16.778223 6.0506339 17.15625 6.09375 C 18.631659 7.6568432 21 10.9245 21 16 C 21 21.0755 18.631659 24.343157 17.15625 25.90625 C 16.778223 25.949366 16.389823 26 16 26 C 10.465308 26 6 21.534692 6 16 C 6 10.465308 10.465308 6 16 6 z" overflow="visible" font-family="Sans"/>
</svg>
`;
const LIGHTING_ENABLED_SVG_ICON = `<?xml version="1.0" encoding="utf-8"?>
<!-- Generated by IcoMoon.io -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="512" height="512" viewBox="0 0 512 512">
<g>
</g>
\t<path d="M257.894 156.948c-53.258 0-96.42 43.561-96.42 97.26 0 53.719 43.161 97.249 96.42 97.249 53.197 0 96.379-43.53 96.379-97.25 0-53.698-43.182-97.26-96.379-97.26zM257.894 309.873c-30.464 0-55.163-24.945-55.163-55.665s24.699-55.624 55.163-55.624c30.423 0 55.101 24.904 55.101 55.624s-24.688 55.665-55.101 55.665z" fill="#000000" />
\t<path d="M241.808 43.499h32.144v79.575h-32.144v-79.575z" fill="#000000" />
\t<path d="M417.209 115.897l-22.723-22.917-55.757 56.279 22.723 22.907z" fill="#000000" />
\t<path d="M389.468 238.407h78.899v32.389h-78.899v-32.389z" fill="#000000" />
\t<path d="M396.012 416.86l22.723-22.917-55.767-56.259-22.712 22.897z" fill="#000000" />
\t<path d="M242.473 388.915h32.144v79.575h-32.144v-79.575z" fill="#000000" />
\t<path d="M96.266 396.073l22.722 22.938 55.778-56.289-22.692-22.928z" fill="#000000" />
\t<path d="M43.633 240.537h78.879v32.43h-78.879v-32.43z" fill="#000000" />
\t<path d="M115.394 93.051l-22.681 22.907 55.757 56.258 22.702-22.917z" fill="#000000" />
</svg>`;
const ATMOSPHERE_SVG_ICON = `<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path fill="#000000" d="M135.688 18.5c-6.798 74.842-23.842 85.39-107.907 59.656 84.85 52.022 73.57 64.954-6.843 96.938 87.743-10.27 103.29 4.89 70.75 87.594 17.805-27.56 32.5-44.498 46.282-54.47-11.813 28.26-18.345 59.274-18.345 91.813 0 84.184 43.71 157.96 109.656 200.376-41.624-43.834-67.686-102.7-67.686-167.875 0-134.923 109.45-244.405 244.375-244.405 30.92 0 60.76 5.762 88 16.25-38.584-26.87-85.517-42.625-136.064-42.625-55.257 0-106.14 18.802-146.562 50.375 4.627-18.783 17.39-38.073 41.03-60.906C190.18 90.942 153.53 95.634 135.69 18.5zm10.03 77.188c5.67.002 11.428 1.247 16.876 3.874 14.506 6.998 22.72 21.81 22 36.938-10.26 10.87-19.507 22.696-27.594 35.344-9.035 2.753-19.075 2.27-28.25-2.156-19.37-9.343-27.5-32.6-18.156-51.97 6.715-13.92 20.638-22.036 35.125-22.03z"/></svg>`;
const TEMPLATE$8 = `<div class="og-lighing og-options-container">

         <div class="og-option">
           <div class="og-suncontrol"></div>
         </div>        
         
         <div class="og-option og-atmosphere-opacity">
         </div>
         
         <div class="og-option og-simpleskybackground">
         </div>
         
        <div class="og-lighting-emptyline"></div>

         <div class="og-option og-gamma"></div>         
         <div class="og-option og-exposure"></div>
       
        <div class="og-lighting-emptyline"></div>

         <div class="og-option">
         <div class="og-layers">
           <div class="og-caption">Select layer:</div>
           <select id="layers"></select>
         </div>
         </div>

         <div class="og-option og-opacity">
         </div>
         
         <div class="og-option og-night">
         </div>
         
         <div class="og-lighting-emptyline"></div>

         <div class="og-option og-diffuse">
         </div>
      
         <div class="og-option og-ambient">
         </div>

         <div class="og-option og-specular">
         </div>        

    </div>`;
const ICON_BUTTON_SVG$5 = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="256" height="256" viewBox="0 0 256 256" xml:space="preserve">

<defs>
</defs>
<g style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; opacity: 1;" transform="translate(1.4065934065934016 1.4065934065934016) scale(2.81 2.81)" >
\t<path d="M 45 68 c -12.682 0 -23 -10.317 -23 -23 c 0 -12.682 10.318 -23 23 -23 c 12.683 0 23 10.318 23 23 C 68 57.683 57.683 68 45 68 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
\t<path d="M 45 17.556 c -1.657 0 -3 -1.343 -3 -3 V 3 c 0 -1.657 1.343 -3 3 -3 c 1.657 0 3 1.343 3 3 v 11.556 C 48 16.212 46.657 17.556 45 17.556 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
\t<path d="M 45 90 c -1.657 0 -3 -1.343 -3 -3 V 75.444 c 0 -1.657 1.343 -3 3 -3 c 1.657 0 3 1.343 3 3 V 87 C 48 88.657 46.657 90 45 90 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
\t<path d="M 14.556 48 H 3 c -1.657 0 -3 -1.343 -3 -3 c 0 -1.657 1.343 -3 3 -3 h 11.556 c 1.657 0 3 1.343 3 3 C 17.556 46.657 16.212 48 14.556 48 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
\t<path d="M 87 48 H 75.444 c -1.657 0 -3 -1.343 -3 -3 c 0 -1.657 1.343 -3 3 -3 H 87 c 1.657 0 3 1.343 3 3 C 90 46.657 88.657 48 87 48 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
\t<path d="M 66.527 26.473 c -0.768 0 -1.535 -0.293 -2.121 -0.878 c -1.172 -1.172 -1.172 -3.071 0 -4.243 l 8.171 -8.171 c 1.172 -1.172 3.07 -1.171 4.242 0 c 1.172 1.172 1.172 3.071 0 4.243 l -8.171 8.171 C 68.063 26.18 67.295 26.473 66.527 26.473 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
\t<path d="M 15.302 77.698 c -0.768 0 -1.536 -0.293 -2.121 -0.879 c -1.172 -1.171 -1.172 -3.071 0 -4.242 l 8.171 -8.171 c 1.171 -1.172 3.071 -1.172 4.242 0 c 1.172 1.171 1.172 3.071 0 4.242 l -8.171 8.171 C 16.837 77.405 16.069 77.698 15.302 77.698 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
\t<path d="M 23.473 26.473 c -0.768 0 -1.536 -0.293 -2.121 -0.878 l -8.171 -8.171 c -1.172 -1.172 -1.172 -3.071 0 -4.243 c 1.172 -1.172 3.072 -1.171 4.243 0 l 8.171 8.171 c 1.172 1.172 1.172 3.071 0 4.243 C 25.008 26.18 24.24 26.473 23.473 26.473 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
\t<path d="M 74.698 77.698 c -0.768 0 -1.535 -0.293 -2.121 -0.879 l -8.171 -8.171 c -1.172 -1.171 -1.172 -3.071 0 -4.242 c 1.172 -1.172 3.07 -1.172 4.242 0 l 8.171 8.171 c 1.172 1.171 1.172 3.071 0 4.242 C 76.233 77.405 75.466 77.698 74.698 77.698 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
</g>
</svg>`;
const MAX_COLOR = 5;
/**
 * Helps to set up lighting.
 */
class Lighting extends Control {
    constructor(options = {}) {
        super(options);
        this._selectedLayer = null;
        this._toggleBtn = new ToggleButton({
            classList: ["og-map-button", "og-lighting_button"],
            icon: ICON_BUTTON_SVG$5
        });
        this._dialog = new Dialog({
            title: "Lighting Parameters",
            visible: false,
            useHide: true,
            top: 60,
            left: 60,
            width: 600
        });
        this._dialog.events.on("visibility", (v) => {
            this._toggleBtn.setActive(v);
        });
        this._panel = new View({
            template: TEMPLATE$8
        });
        this.$gamma = null;
        this.$exposure = null;
        this.$night = null;
        this.$opacity = null;
        this.$diffuse = null;
        this.$ambient = null;
        this.$specular = null;
        this.$atmosphereOpacity = null;
        this.$simpleSkyBackground = null;
        this._atmosphereMaxOpacity = new Slider({
            label: "Max.opacity",
            max: 5
        });
        this._atmosphereMinOpacity = new Slider({
            label: "Min.opacity",
            max: 5
        });
        this._simpleSkyBackgroundColorOne = new Color({
            label: "Color One"
        });
        this._simpleSkyBackgroundColorTwo = new Color({
            label: "Color Two"
        });
        this._gamma = new Slider({
            label: "Gamma",
            max: 5
        });
        this._exposure = new Slider({
            label: "Exposure",
            max: 5
        });
        this._night = new Slider({
            label: "Nightlight",
            max: 5
        });
        this._opacity = new Slider({
            label: "Opacity",
            max: 1
        });
        //
        // Diffuse sliders
        //
        this._diffuse_r = new Slider({
            label: "Diffuse R",
            max: MAX_COLOR
        });
        this._diffuse_g = new Slider({
            label: "Diffuse G",
            max: MAX_COLOR
        });
        this._diffuse_b = new Slider({
            label: "Diffuse B",
            max: MAX_COLOR
        });
        //
        // Ambient sliders
        //
        this._ambient_r = new Slider({
            label: "Ambient R",
            max: MAX_COLOR
        });
        this._ambient_g = new Slider({
            label: "Ambient G",
            max: MAX_COLOR
        });
        this._ambient_b = new Slider({
            label: "Ambient B",
            max: MAX_COLOR
        });
        //
        // Specular sliders
        //
        this._specular_r = new Slider({
            label: "Specular R",
            max: 0.2
        });
        this._specular_g = new Slider({
            label: "Specular G",
            max: 0.2
        });
        this._specular_b = new Slider({
            label: "Specular B",
            max: 0.2
        });
        this._shininess = new Slider({
            label: "Shininess",
            max: 100
        });
    }
    bindLayer(layer) {
        this._selectedLayer = layer;
        this._opacity.value = layer.opacity;
        this._update();
    }
    oninit() {
        this._toggleBtn.appendTo(this.renderer.div);
        this._dialog.appendTo(this.renderer.div);
        this._panel.appendTo(this._dialog.container);
        if (this._panel.el) {
            this.$atmosphereOpacity = this._panel.el.querySelector(".og-atmosphere-opacity");
            this.$simpleSkyBackground = this._panel.el.querySelector(".og-simpleskybackground");
            this.$gamma = this._panel.el.querySelector(".og-option.og-gamma");
            this.$exposure = this._panel.el.querySelector(".og-option.og-exposure");
            this.$opacity = this._panel.el.querySelector(".og-option.og-opacity");
            this.$diffuse = this._panel.el.querySelector(".og-option.og-diffuse");
            this.$ambient = this._panel.el.querySelector(".og-option.og-ambient");
            this.$specular = this._panel.el.querySelector(".og-option.og-specular");
            this.$night = this._panel.el.querySelector(".og-option.og-night");
        }
        this._toggleBtn.events.on("change", (isActive) => {
            this._dialog.setVisibility(isActive);
        });
        let $suncontrol = this._dialog.select(".og-suncontrol");
        let sunStopBtn = new ToggleButton({
            classList: ["og-suncontrol-button"],
            isActive: true,
            icon: SUN_STOP_SVG_ICON,
            title: "Star/stop the Sun from following the camera"
        });
        sunStopBtn.appendTo($suncontrol);
        let sunActiveBtn = new ToggleButton({
            classList: ["og-suncontrol-button"],
            isActive: true,
            icon: SUN_ACTIVE_SVG_ICON,
            title: "Activate/deactivate the Sun current time positioning"
        });
        sunActiveBtn.appendTo($suncontrol);
        sunStopBtn.events.on("change", (isActive) => {
            const sun = this.planet.renderer.controls.sun;
            if (isActive) {
                sun.start();
            }
            else {
                sun.stop();
            }
        });
        sunActiveBtn.events.on("change", (isActive) => {
            const sun = this.planet.renderer.controls.sun;
            if (isActive) {
                sun.activate();
            }
            else {
                sun.deactivate();
            }
        });
        let lightingEnabledBtn = new ToggleButton({
            classList: ["og-suncontrol-button"],
            isActive: this.planet.lightEnabled,
            icon: LIGHTING_ENABLED_SVG_ICON,
            title: "Enable/disable planet lighting"
        });
        lightingEnabledBtn.appendTo($suncontrol);
        lightingEnabledBtn.events.on("change", (isActive) => {
            this.planet.lightEnabled = isActive;
        });
        let atmosphereEnabledBtn = new ToggleButton({
            classList: ["og-suncontrol-button"],
            isActive: this.planet.atmosphereEnabled,
            icon: ATMOSPHERE_SVG_ICON,
            title: "Enable/disable atmosphere scattering"
        });
        atmosphereEnabledBtn.appendTo($suncontrol);
        if (this.planet.atmosphereEnabled) {
            this.$atmosphereOpacity.style.display = "block";
            this.$simpleSkyBackground.style.display = "none";
        }
        else {
            this.$atmosphereOpacity.style.display = "none";
            this.$simpleSkyBackground.style.display = "flex";
        }
        atmosphereEnabledBtn.events.on("change", (isActive) => {
            this.planet.atmosphereEnabled = isActive;
            if (this.planet.atmosphereEnabled) {
                this.$atmosphereOpacity.style.display = "block";
                this.$simpleSkyBackground.style.display = "none";
            }
            else {
                this.$atmosphereOpacity.style.display = "none";
                this.$simpleSkyBackground.style.display = "flex";
            }
        });
        this._atmosphereMaxOpacity.appendTo(this.$atmosphereOpacity);
        this._atmosphereMinOpacity.appendTo(this.$atmosphereOpacity);
        this._simpleSkyBackgroundColorOne.appendTo(this.$simpleSkyBackground);
        this._simpleSkyBackgroundColorTwo.appendTo(this.$simpleSkyBackground);
        this._gamma.appendTo(this.$gamma);
        this._exposure.appendTo(this.$exposure);
        this._night.appendTo(this.$night);
        this._opacity.appendTo(this.$opacity);
        this._diffuse_r.appendTo(this.$diffuse);
        this._diffuse_g.appendTo(this.$diffuse);
        this._diffuse_b.appendTo(this.$diffuse);
        this._ambient_r.appendTo(this.$ambient);
        this._ambient_g.appendTo(this.$ambient);
        this._ambient_b.appendTo(this.$ambient);
        this._specular_r.appendTo(this.$specular);
        this._specular_g.appendTo(this.$specular);
        this._specular_b.appendTo(this.$specular);
        this._shininess.appendTo(this.$specular);
        //
        // Screen options
        //
        this._gamma.value = this.planet.renderer.gamma;
        this._gamma.events.on("change", (val) => {
            this.planet.renderer.gamma = val;
        });
        this._exposure.value = this.planet.renderer.exposure;
        this._exposure.events.on("change", (val) => {
            this.planet.renderer.exposure = val;
        });
        //
        // Atmosphere parameters
        //
        this._atmosphereMinOpacity.value = this.planet.atmosphereMinOpacity;
        this._atmosphereMinOpacity.events.on("change", (val) => {
            this.planet.atmosphereMinOpacity = val;
        });
        this._atmosphereMaxOpacity.value = this.planet.atmosphereMaxOpacity;
        this._atmosphereMaxOpacity.events.on("change", (val) => {
            this.planet.atmosphereMaxOpacity = val;
            let atmos = this.planet.renderer.controls.Atmosphere;
            atmos.opacity = val;
        });
        //
        // Simple Sky Background parameters
        //
        let simpleSkyBackgroundControl = this.planet.renderer.controls.SimpleSkyBackground;
        if (simpleSkyBackgroundControl) {
            this._simpleSkyBackgroundColorOne.value = simpleSkyBackgroundControl.colorOne;
            this._simpleSkyBackgroundColorTwo.value = simpleSkyBackgroundControl.colorTwo;
        }
        this._simpleSkyBackgroundColorOne.events.on("input", (val) => {
            let simpleSkyBackgroundControl = this.planet.renderer.controls.SimpleSkyBackground;
            if (simpleSkyBackgroundControl) {
                simpleSkyBackgroundControl.colorOne = val;
            }
        });
        this._simpleSkyBackgroundColorTwo.events.on("input", (val) => {
            let simpleSkyBackgroundControl = this.planet.renderer.controls.SimpleSkyBackground;
            if (simpleSkyBackgroundControl) {
                simpleSkyBackgroundControl.colorTwo = val;
            }
        });
        //
        // Planet options
        //
        this._panel.el.querySelector("#layers").addEventListener("change", (e) => {
            const l = this.planet.getLayerByName(e.target.value);
            if (l) {
                this.bindLayer(l);
            }
        });
        this._night.events.on("change", (val) => {
            if (this._selectedLayer) {
                this._selectedLayer.nightTextureCoefficient = val;
            }
        });
        this._opacity.events.on("change", (val) => {
            if (this._selectedLayer)
                this._selectedLayer.opacity = val;
        });
        this._ambient_r.events.on("change", (val) => {
            if (this._selectedLayer && this._selectedLayer._ambient)
                this._selectedLayer._ambient[0] = val;
        });
        this._ambient_g.events.on("change", (val) => {
            if (this._selectedLayer && this._selectedLayer._ambient)
                this._selectedLayer._ambient[1] = val;
        });
        this._ambient_b.events.on("change", (val) => {
            if (this._selectedLayer && this._selectedLayer._ambient)
                this._selectedLayer._ambient[2] = val;
        });
        this._diffuse_r.events.on("change", (val) => {
            if (this._selectedLayer && this._selectedLayer._diffuse)
                this._selectedLayer._diffuse[0] = val;
        });
        this._diffuse_g.events.on("change", (val) => {
            if (this._selectedLayer && this._selectedLayer._diffuse)
                this._selectedLayer._diffuse[1] = val;
        });
        this._diffuse_b.events.on("change", (val) => {
            if (this._selectedLayer && this._selectedLayer._diffuse)
                this._selectedLayer._diffuse[2] = val;
        });
        this._specular_r.events.on("change", (val) => {
            if (this._selectedLayer && this._selectedLayer._specular)
                this._selectedLayer._specular[0] = val;
        });
        this._specular_g.events.on("change", (val) => {
            if (this._selectedLayer && this._selectedLayer._specular)
                this._selectedLayer._specular[1] = val;
        });
        this._specular_b.events.on("change", (val) => {
            if (this._selectedLayer && this._selectedLayer._specular)
                this._selectedLayer._specular[2] = val;
        });
        this._shininess.events.on("change", (val) => {
            if (this._selectedLayer && this._selectedLayer._specular)
                this._selectedLayer._specular[3] = val;
        });
        if (this.planet) {
            this.planet.events.on("layeradd", this._onLayerAdd, this);
            this.planet.events.on("layerremove", this._onLayerRemove, this);
        }
        this._fetchLayers();
    }
    _update() {
        let l = this._selectedLayer;
        this._opacity.value = l && l.opacity ? l.opacity : 0.0;
        this._night.value = l && l.nightTextureCoefficient ? l.nightTextureCoefficient : this.planet.nightTextureCoefficient;
        let a = l && l._ambient ? l._ambient : this.planet._ambient;
        this._ambient_r.value = a[0];
        this._ambient_g.value = a[1];
        this._ambient_b.value = a[2];
        let d = l && l._diffuse ? l._diffuse : this.planet._diffuse;
        this._diffuse_r.value = d[0];
        this._diffuse_g.value = d[1];
        this._diffuse_b.value = d[2];
        let s = l && l._specular ? l._specular : this.planet._specular;
        this._specular_r.value = s[0];
        this._specular_g.value = s[1];
        this._specular_b.value = s[2];
        this._shininess.value = s[3];
    }
    _fetchLayers() {
        if (this.planet) {
            for (let i = 0; i < this.planet.layers.length; i++) {
                this._onLayerAdd(this.planet.layers[i]);
            }
        }
    }
    _onLayerAdd(e) {
        this.bindLayer(e);
        let opt = document.createElement("option");
        opt.value = e.name;
        opt.innerText = e.name;
        this._panel.el.querySelector("#layers").appendChild(opt);
        this._panel.el.querySelector("#layers").value = e.name;
    }
    _onLayerRemove(e) {
    }
}

class Lock {
    constructor() {
        this._lock = 0;
    }
    lock(key) {
        this._lock |= (1 << key.id);
    }
    free(key) {
        this._lock &= ~(1 << key.id);
    }
    isFree() {
        return this._lock === 0;
    }
    isLocked() {
        return this._lock !== 0;
    }
}
class Key {
    constructor() {
        this.__id = Key.__counter__++;
    }
    get id() {
        return this.__id;
    }
}
Key.__counter__ = 0;

/**
 * Mouse planet camera dragging control.
 */
class MouseNavigation extends Control {
    constructor(options = {}) {
        super(options);
        this._deactivate = false;
        this._shiftBusy = false;
        this._name = "mouseNavigation";
        this.grabbedPoint = new Vec3();
        this._eye0 = new Vec3();
        this.pointOnEarth = new Vec3();
        this.earthUp = new Vec3();
        this.inertia = 0.007;
        this.grabbedSpheroid = new Sphere();
        this.qRot = new Quat();
        this.scaleRot = 0.0;
        this.distDiff = 0.3;
        this.stepsCount = 8;
        this.stepsForward = null;
        this.stepIndex = 0;
        this._lmbDoubleClickActive = true;
        this.minSlope = options.minSlope || 0.1;
        this._wheelDirection = +1;
        this._keyLock = new Key();
    }
    static getMovePointsFromPixelTerrain(cam, planet, stepsCount, delta, point, forward, dir) {
        const steps = [];
        let eye = cam.eye.clone(), n = cam._b.clone(), u = cam._r.clone(), v = cam._u.clone();
        let a = planet.getCartesianFromPixelTerrain(point);
        if (!a) {
            a = planet.getCartesianFromPixelTerrain(planet.renderer.handler.getCenter());
        }
        if (a) {
            if (!dir) {
                dir = Vec3.sub(a, cam.eye).normalize();
            }
            let d = (delta * cam.eye.distance(a)) / stepsCount;
            if (forward) {
                d = -1.25 * d;
            }
            else {
                d *= 2;
            }
            const scaled_n = n.scaleTo(d);
            const slope = dir.dot(cam.eye.normal().negate());
            if (slope >= 0.1) {
                const grabbedSpheroid = new Sphere();
                grabbedSpheroid.radius = a.length();
                let rotArr = [], eyeArr = [];
                let breaked = false;
                for (let i = 0; i < stepsCount; i++) {
                    eye.addA(scaled_n);
                    const b = new Ray$1(eye, dir).hitSphere(grabbedSpheroid);
                    eyeArr[i] = eye.clone();
                    if (b) {
                        rotArr[i] = new Mat4().rotateBetweenVectors(a.normal(), b.normal());
                    }
                    else {
                        breaked = true;
                        break;
                    }
                }
                if (!breaked) {
                    for (let i = 0; i < stepsCount; i++) {
                        let rot = rotArr[i];
                        steps[i] = {
                            eye: rot.mulVec3(eyeArr[i]),
                            v: rot.mulVec3(v),
                            u: rot.mulVec3(u),
                            n: rot.mulVec3(n)
                        };
                    }
                }
                else {
                    eye = cam.eye.clone();
                    for (let i = 0; i < stepsCount; i++) {
                        steps[i] = {
                            eye: eye.addA(scaled_n).clone(),
                            v: v,
                            u: u,
                            n: n,
                        };
                    }
                }
            }
            else {
                for (let i = 0; i < stepsCount; i++) {
                    steps[i] = {
                        eye: eye.addA(dir.scaleTo(-d)).clone(),
                        v: v,
                        u: u,
                        n: n,
                    };
                }
            }
            return steps;
        }
    }
    onactivate() {
        if (this.renderer) {
            this.renderer.events.on("mousewheel", this.onMouseWheel, this);
            this.renderer.events.on("lhold", this.onMouseLeftButtonDown, this);
            this.renderer.events.on("rhold", this.onMouseRightButtonDown, this);
            this.renderer.events.on("ldown", this.onMouseLeftButtonClick, this);
            this.renderer.events.on("lup", this.onMouseLeftButtonUp, this);
            this.renderer.events.on("rdown", this.onMouseRightButtonClick, this);
            this.renderer.events.on("draw", this.onDraw, this, -1000);
            this.renderer.events.on("mousemove", this.onMouseMove, this);
            this.renderer.events.on("mouseleave", this.onMouseLeave, this);
            this.renderer.events.on("mouseenter", this.onMouseEnter, this);
            if (this._lmbDoubleClickActive) {
                this.renderer.events.on("ldblclick", this.onMouseLeftButtonDoubleClick, this);
            }
        }
    }
    ondeactivate() {
        if (this.renderer) {
            this.renderer.events.off("mousewheel", this.onMouseWheel);
            this.renderer.events.off("lhold", this.onMouseLeftButtonDown);
            this.renderer.events.off("rhold", this.onMouseRightButtonDown);
            this.renderer.events.off("ldown", this.onMouseLeftButtonClick);
            this.renderer.events.off("lup", this.onMouseLeftButtonUp);
            this.renderer.events.off("rdown", this.onMouseRightButtonClick);
            this.renderer.events.off("draw", this.onDraw);
            this.renderer.events.off("ldblclick", this.onMouseLeftButtonDoubleClick);
            this.renderer.events.off("mouseleave", this.onMouseLeave);
            this.renderer.events.off("mouseenter", this.onMouseEnter);
        }
    }
    activateDoubleClickZoom() {
        if (!this._lmbDoubleClickActive) {
            this._lmbDoubleClickActive = true;
            this.renderer && this.renderer.events.on("ldblclick", this.onMouseLeftButtonDoubleClick, this);
        }
    }
    deactivateDoubleClickZoom() {
        if (this._lmbDoubleClickActive) {
            this._lmbDoubleClickActive = false;
            this.renderer && this.renderer.events.off("ldblclick", this.onMouseLeftButtonDoubleClick);
        }
    }
    onMouseEnter(e) {
        const renderEvents = this.renderer.events;
        if (renderEvents.isKeyPressed(input.KEY_ALT)) {
            renderEvents.releaseKeys();
        }
        renderEvents.updateButtonsStates(e.sys.buttons);
        if (renderEvents.mouseState.leftButtonDown) {
            this.renderer.handler.canvas.classList.add("ogGrabbingPoiner");
        }
        else {
            this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
        }
    }
    onMouseLeave() {
        if (this.renderer.events.mouseState.leftButtonDown) {
            this.scaleRot = 0;
        }
        this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
    }
    onMouseWheel(e) {
        if (this.stepIndex) {
            return;
        }
        this.planet.stopFlying();
        this.stopRotation();
        this._deactivate = true;
        this.lockPlanet(true);
        this.stepsForward = MouseNavigation.getMovePointsFromPixelTerrain(this.planet.camera, this.planet, this.stepsCount, this.distDiff, e.pos, e.wheelDelta > 0, e.direction) || null;
        this._wheelDirection = e.wheelDelta;
        if (this.stepsForward) {
            this.stepIndex = this.stepsCount;
        }
    }
    oninit() {
        this.activate();
        if (this.renderer) {
            this.renderer.events.on("keyfree", input.KEY_ALT, this.onShiftFree, this);
            this.renderer.events.on("keyfree", input.KEY_PRINTSCREEN, this.onShiftFree, this);
        }
    }
    onMouseLeftButtonDoubleClick(e) {
        this.planet.stopFlying();
        this.stopRotation();
        const p = this.planet.getCartesianFromPixelTerrain(e.pos);
        if (p) {
            const cam = this.planet.camera;
            let maxAlt = cam.maxAltitude + this.planet.ellipsoid.polarSize;
            let minAlt = cam.minAltitude + this.planet.ellipsoid.polarSize;
            const camAlt = cam.eye.length();
            const g = this.planet.ellipsoid.cartesianToLonLat(p);
            if (camAlt > maxAlt || camAlt < minAlt) {
                this.planet.flyLonLat(new LonLat(g.lon, g.lat));
                return;
            }
            if (this.renderer.events.isKeyPressed(input.KEY_ALT)) {
                this.planet.flyLonLat(new LonLat(g.lon, g.lat, cam.eye.distance(p) * 2.0));
            }
            else {
                this.planet.flyLonLat(new LonLat(g.lon, g.lat, cam.eye.distance(p) * 0.57));
            }
        }
    }
    onMouseLeftButtonClick() {
        if (this._active) {
            this.renderer.handler.canvas.classList.add("ogGrabbingPoiner");
            this.grabbedPoint = this.planet.getCartesianFromMouseTerrain();
            if (this.grabbedPoint) {
                this._eye0.copy(this.planet.camera.eye);
                this.grabbedSpheroid.radius = this.grabbedPoint.length();
                this.stopRotation();
            }
        }
    }
    stopRotation() {
        this.qRot.clear();
        this.freePlanet();
    }
    onMouseLeftButtonUp(e) {
        this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
        if (e.x === e.prev_x && e.y === e.prev_y) {
            this.scaleRot = 0.0;
        }
    }
    onMouseLeftButtonDown(e) {
        if (this._active) {
            if (!this.grabbedPoint) {
                return;
            }
            this.planet.stopFlying();
            if (e.moving) {
                let cam = this.planet.camera;
                if (cam.slope > 0.2) {
                    const targetPoint = new Ray$1(cam.eye, e.direction).hitSphere(this.grabbedSpheroid);
                    if (targetPoint) {
                        this.scaleRot = 1.0;
                        this.qRot = Quat.getRotationBetweenVectors(targetPoint.normal(), this.grabbedPoint.normal());
                        let rot = this.qRot;
                        cam.eye = rot.mulVec3(cam.eye);
                        cam._u = rot.mulVec3(cam._u);
                        cam._r = rot.mulVec3(cam._r);
                        cam._b = rot.mulVec3(cam._b);
                    }
                }
                else {
                    let p0 = this.grabbedPoint, p1 = Vec3.add(p0, cam._r), p2 = Vec3.add(p0, p0.normal());
                    let px = new Vec3();
                    if (new Ray$1(cam.eye, e.direction).hitPlane(p0, p1, p2, px) === Ray$1.INSIDE) {
                        cam.eye = this._eye0.addA(px.subA(p0).negate());
                    }
                }
            }
        }
    }
    onMouseRightButtonClick(e) {
        this.stopRotation();
        this.planet.stopFlying();
        this.pointOnEarth = this.planet.getCartesianFromPixelTerrain(e.pos);
        if (this.pointOnEarth) {
            this.earthUp = this.pointOnEarth.normal();
        }
    }
    onMouseRightButtonDown(e) {
        const cam = this.planet.camera;
        if (this.pointOnEarth && e.moving) {
            this.renderer.controlsBag.scaleRot = 1.0;
            let l = (0.5 / cam.eye.distance(this.pointOnEarth)) * cam._lonLat.height * RADIANS;
            if (l > 0.007) {
                l = 0.007;
            }
            else if (l < 0.003) {
                l = 0.003;
            }
            cam.rotateHorizontal(l * (e.x - e.prev_x), false, this.pointOnEarth, this.earthUp);
            cam.rotateVertical(l * (e.y - e.prev_y), this.pointOnEarth, this.minSlope);
        }
    }
    onShiftFree() {
        this._shiftBusy = false;
    }
    onMouseMove(e) {
        if (this._active && this.renderer.events.isKeyPressed(input.KEY_ALT)) {
            if (!this._shiftBusy) {
                this._shiftBusy = true;
                this.onMouseRightButtonClick(e);
            }
            this.onMouseRightButtonDown(e);
        }
    }
    onDraw() {
        if (this._active) {
            const r = this.renderer;
            const cam = this.planet.camera;
            let prevEye = cam.eye.clone();
            if (this.stepIndex) {
                r.controlsBag.scaleRot = 1.0;
                const sf = this.stepsForward[this.stepsCount - this.stepIndex--];
                cam.eye = sf.eye;
                cam._u = sf.v;
                cam._r = sf.u;
                cam._b = sf.n;
            }
            else {
                if (this._deactivate) {
                    this._deactivate = false;
                    this.freePlanet();
                }
            }
            if (r.events.mouseState.leftButtonDown || !this.scaleRot) {
                return;
            }
            this.scaleRot -= this.inertia;
            if (this.scaleRot <= 0.0) {
                this.scaleRot = 0.0;
            }
            else {
                r.controlsBag.scaleRot = this.scaleRot;
                let rot = this.qRot
                    .slerp(Quat.IDENTITY, 1.0 - this.scaleRot * this.scaleRot * this.scaleRot)
                    .normalize();
                if (!(rot.x || rot.y || rot.z)) {
                    this.scaleRot = 0.0;
                }
                cam.eye = rot.mulVec3(cam.eye);
                cam._u = rot.mulVec3(cam._u);
                cam._r = rot.mulVec3(cam._r);
                cam._b = rot.mulVec3(cam._b);
            }
            if (cam.eye.distance(prevEye) / cam.getAltitude() > 0.01) {
                this.lockPlanet();
            }
            else {
                this.freePlanet();
            }
        }
    }
    lockPlanet(skipTerrain) {
        this.planet.layerLock.lock(this._keyLock);
        !skipTerrain && this.planet.terrainLock.lock(this._keyLock);
        this.planet._normalMapCreator.lock(this._keyLock);
    }
    freePlanet() {
        this.planet.layerLock.free(this._keyLock);
        this.planet.terrainLock.free(this._keyLock);
        this.planet._normalMapCreator.free(this._keyLock);
    }
}

class MouseWheelZoomControl extends Control {
    constructor(options = {}) {
        super(options);
        this._name = "MouseWheelZoomControl";
        this.grabbedPoint = new Vec3();
        this._eye0 = new Vec3();
        this.pointOnEarth = new Vec3();
        this.earthUp = new Vec3();
        this.inertia = 0.007;
        this.grabbedSpheroid = new Sphere();
        this.planet = null;
        this.qRot = new Quat();
        this.scaleRot = 0.0;
        this.distDiff = 0.3;
        this.stepsCount = 8;
        this.stepsForward = null;
        this.stepIndex = 0;
        this._lmbDoubleClickActive = true;
        this.minSlope = options.minSlope || 0.1;
        this._keyLock = new Key();
        this._deactivate = false;
        this._move = 0;
    }
    oninit() {
        let zoomDiv = document.createElement("div"), btnZoomIn = document.createElement("button"), btnZoomOut = document.createElement("button");
        zoomDiv.className = "ogZoomControl";
        btnZoomIn.className = "ogZoomButton ogZoomIn";
        btnZoomOut.className = "ogZoomButton ogZoomOut";
        zoomDiv.appendChild(btnZoomIn);
        zoomDiv.appendChild(btnZoomOut);
        this.renderer.div.appendChild(zoomDiv);
        btnZoomIn.addEventListener("mousedown", () => this.zoomIn());
        btnZoomIn.addEventListener("mouseup", () => this.stopZoom());
        btnZoomOut.addEventListener("mousedown", () => this.zoomOut());
        btnZoomOut.addEventListener("mouseup", () => this.stopZoom());
        btnZoomIn.addEventListener("touchstart", (e) => {
            e.preventDefault();
            this.zoomIn();
        });
        btnZoomIn.addEventListener("touchend", (e) => {
            e.preventDefault();
            this.stopZoom();
        });
        btnZoomIn.addEventListener("touchcancel", (e) => {
            e.preventDefault();
            this.stopZoom();
        });
        btnZoomOut.addEventListener("touchstart", (e) => {
            e.preventDefault();
            this.zoomOut();
        });
        btnZoomOut.addEventListener("touchend", (e) => {
            e.preventDefault();
            this.stopZoom();
        });
        btnZoomOut.addEventListener("touchcancel", (e) => {
            e.preventDefault();
            this.stopZoom();
        });
        this.renderer.events.on("draw", this._draw, this);
    }
    /**
     * Planet zoom in.
     * @public
     */
    zoomIn() {
        if (this.stepIndex) {
            return;
        }
        this.planet.stopFlying();
        this.stopRotation();
        this._deactivate = true;
        this.planet.layerLock.lock(this._keyLock);
        this.planet.terrainLock.lock(this._keyLock);
        this.planet._normalMapCreator.lock(this._keyLock);
        this.stepsForward = MouseNavigation.getMovePointsFromPixelTerrain(this.planet.camera, this.planet, this.stepsCount, this.distDiff, this.renderer.handler.getCenter(), true, null) || null;
        if (this.stepsForward) {
            this.stepIndex = this.stepsCount;
        }
    }
    /**
     * Planet zoom out.
     * @public
     */
    zoomOut() {
        if (this.stepIndex) {
            return;
        }
        this.planet.stopFlying();
        this.stopRotation();
        this._deactivate = true;
        this.planet.layerLock.lock(this._keyLock);
        this.planet.terrainLock.lock(this._keyLock);
        this.planet._normalMapCreator.lock(this._keyLock);
        this.stepsForward = MouseNavigation.getMovePointsFromPixelTerrain(this.planet.camera, this.planet, this.stepsCount, this.distDiff, this.renderer.handler.getCenter(), false, null) || null;
        if (this.stepsForward) {
            this.stepIndex = this.stepsCount;
        }
    }
    stopRotation() {
        this.qRot.clear();
        this.planet.layerLock.free(this._keyLock);
        this.planet.terrainLock.free(this._keyLock);
        this.planet._normalMapCreator.free(this._keyLock);
    }
    stopZoom() {
        this._move = 0;
        this.planet.layerLock.free(this._keyLock);
        this.planet.terrainLock.free(this._keyLock);
        this.planet._normalMapCreator.free(this._keyLock);
    }
    _draw() {
        if (this._active) {
            let r = this.renderer;
            let cam = this.planet.camera;
            let prevEye = cam.eye.clone();
            if (this.stepIndex) {
                r.controlsBag.scaleRot = 1.0;
                let sf = this.stepsForward[this.stepsCount - this.stepIndex--];
                let maxAlt = cam.maxAltitude + this.planet.ellipsoid.equatorialSize;
                let minAlt = cam.minAltitude + this.planet.ellipsoid.equatorialSize;
                const camAlt = sf.eye.length();
                if (camAlt > maxAlt || camAlt < minAlt) {
                    return;
                }
                cam.eye = sf.eye;
                cam._u = sf.v;
                cam._r = sf.u;
                cam._b = sf.n;
                cam.checkTerrainCollision();
                cam.update();
            }
            else {
                if (this._deactivate) {
                    this._deactivate = false;
                    this.planet.layerLock.free(this._keyLock);
                    this.planet.terrainLock.free(this._keyLock);
                    this.planet._normalMapCreator.free(this._keyLock);
                }
            }
            if (r.events.mouseState.leftButtonDown || !this.scaleRot) {
                return;
            }
            this.scaleRot -= this.inertia;
            if (this.scaleRot <= 0.0) {
                this.scaleRot = 0.0;
            }
            else {
                r.controlsBag.scaleRot = this.scaleRot;
                let rot = this.qRot
                    .slerp(Quat.IDENTITY, 1.0 - this.scaleRot * this.scaleRot * this.scaleRot)
                    .normalize();
                if (!(rot.x || rot.y || rot.z)) {
                    this.scaleRot = 0.0;
                }
                cam.eye = rot.mulVec3(cam.eye);
                cam._u = rot.mulVec3(cam._u);
                cam._r = rot.mulVec3(cam._r);
                cam._b = rot.mulVec3(cam._b);
                cam.checkTerrainCollision();
                cam.update();
            }
            if (cam.eye.distance(prevEye) / cam.getAltitude() > 0.01) {
                this.planet.layerLock.lock(this._keyLock);
                this.planet.terrainLock.lock(this._keyLock);
                this.planet._normalMapCreator.lock(this._keyLock);
            }
            else {
                this.planet.layerLock.free(this._keyLock);
                this.planet.terrainLock.free(this._keyLock);
                this.planet._normalMapCreator.free(this._keyLock);
            }
        }
    }
}

const OUTLINE_COUNT$1 = 120;
const distanceFormat$1 = (v) => {
    if (v > 1000) {
        return `${(v / 1000).toFixed(1)} km`;
    }
    else if (v > 9) {
        return `${Math.round(v)} m`;
    }
    else {
        return `${v.toFixed(1)} m`;
    }
};
let obj3d$1 = Object3d.createCylinder(1.1, 0, 2.7, 20, 1, true, false, 0, 0, 0);
const LABEL_OPTIONS$2 = {
    text: "",
    size: 11,
    color: "rgba(455,455,455,1.0)",
    outlineColor: "rgba(0,0,0,0.34)",
    outline: 0.23,
    align: "center",
    offset: [0, 20, 0]
};
const RULER_CORNER_OPTIONS$1 = {
    scale: 1,
    instanced: true,
    tag: "ruler",
    color: "rgb(0,305,0)",
    object3d: obj3d$1
};
class RulerScene extends RenderNode {
    constructor(options = {}) {
        super(options.name);
        this._onCornerLdown = (e) => {
            if (!this._startLonLat) {
                this.renderer?.controls.mouseNavigation?.deactivate();
                this._startClick.set(e.x, e.y);
                let coords = e.pickingObject.getCartesian();
                this._startPos = this._planet.getPixelFromCartesian(coords);
                this._pickedCorner = e.pickingObject;
                if (e.pickingObject.properties.name == "start") {
                    this._anchorLonLat = this._cornerEntity[1].getLonLat().clone();
                }
                else {
                    this._anchorLonLat = this._cornerEntity[0].getLonLat().clone();
                }
            }
        };
        this._onLUp = () => {
            if (this._pickedCorner) {
                this.renderer.controls.mouseNavigation?.activate();
                this._pickedCorner = null;
                this._anchorLonLat = null;
            }
        };
        this._onCornerLup = () => {
            this._onLUp();
        };
        this._onCornerEnter = (e) => {
            e.renderer.handler.canvas.style.cursor = "pointer";
        };
        this._onCornerLeave = (e) => {
            e.renderer.handler.canvas.style.cursor = "default";
        };
        this._onLdblclick = () => {
            this._preventClick = true;
        };
        this._onLclick = (e) => {
            let startLonLat = this._planet.getLonLatFromPixelTerrain(e.pos);
            if (!startLonLat)
                return;
            this._timeout = setTimeout(() => {
                if (!this._preventClick) {
                    if (!this._startLonLat) {
                        this.setVisibility(true);
                        this._stopDrawing = false;
                        this._startLonLat = startLonLat;
                    }
                    else {
                        this._startLonLat = null;
                    }
                }
                this._preventClick = false;
                this._stopDrawing = false;
                clearTimeout(this._timeout);
            }, 200);
            if (this._startLonLat) {
                this._stopDrawing = true;
            }
        };
        this._onMouseMove = (e) => {
            if (this._startLonLat && !this._stopDrawing) {
                this._propsLabel.label.setVisibility(true);
                let endLonLat = this._planet.getLonLatFromPixelTerrain(e.pos);
                if (!endLonLat)
                    return;
                this._drawLine(this._startLonLat, endLonLat);
            }
            else if (this._pickedCorner) {
                let newLonLat = this._planet.getLonLatFromPixelTerrain(e.pos);
                if (newLonLat) {
                    if (this._pickedCorner.properties.name === "start") {
                        this._drawLine(newLonLat, this._anchorLonLat);
                    }
                    else {
                        this._drawLine(this._anchorLonLat, newLonLat);
                    }
                }
            }
        };
        this.events = createEvents(RULERSCENE_EVENTS);
        this._ignoreTerrain = options.ignoreTerrain != undefined ? options.ignoreTerrain : true;
        this._planet = options.planet || null;
        this._startLonLat = null;
        this._preventClick = false;
        this._stopDrawing = false;
        this._pickedCorner = null;
        this._startPos = null;
        this._startClick = new Vec2();
        this._anchorLonLat = null;
        this._heading = 0;
        this._trackLayer = new Vector("track", {
            entities: [],
            pickingEnabled: false,
            polygonOffsetUnits: -1.0,
            relativeToGround: true,
            hideInLayerSwitcher: true
        });
        this._labelLayer = new Vector("ruler-label", {
            entities: [],
            pickingEnabled: false,
            polygonOffsetUnits: -100.0,
            relativeToGround: true,
            hideInLayerSwitcher: true
        });
        this._cornersLayer = new Vector("corners", {
            entities: [],
            pickingEnabled: true,
            hideInLayerSwitcher: true,
            scaleByDistance: [100, 4000000, 1.0],
            pickingScale: 2
        });
        this._propsLabel = new Entity({
            name: 'propsLabel',
            label: LABEL_OPTIONS$2
        });
        this._trackEntity = new Entity({
            polyline: {
                path3v: [],
                thickness: 4.8,
                color: "rgb(255,131,0)",
                isClosed: false
            }
        });
        this._trackEntity.polyline.altitude = 0.01;
        this._cornerEntity = [
            new Entity({
                geoObject: RULER_CORNER_OPTIONS$1,
                properties: {
                    name: "start"
                }
            }),
            new Entity({
                geoObject: RULER_CORNER_OPTIONS$1,
                properties: {
                    name: "end"
                }
            })
        ];
    }
    set ignoreTerrain(v) {
        this._ignoreTerrain = v;
    }
    bindPlanet(planet) {
        this._planet = planet;
    }
    _createCorners() {
        this._cornersLayer.addEntities(this._cornerEntity);
    }
    init() {
        this._createCorners();
        this._trackLayer.addEntities([this._trackEntity]);
        this._labelLayer.addEntities([this._propsLabel]);
        this._planet.addLayer(this._labelLayer);
        this._planet.addLayer(this._trackLayer);
        this._planet.addLayer(this._cornersLayer);
        this._activate();
    }
    onremove() {
        this._deactivate();
    }
    _activate() {
        this._propsLabel.label.setVisibility(false);
        this.setVisibility(false);
        this.renderer.events.on("lclick", this._onLclick, this);
        this.renderer.events.on("mousemove", this._onMouseMove, this);
        this.renderer.events.on("ldblclick", this._onLdblclick, this);
        this.renderer.events.on("lup", this._onLUp, this);
        this._cornersLayer.events.on("mouseenter", this._onCornerEnter, this);
        this._cornersLayer.events.on("mouseleave", this._onCornerLeave, this);
        this._cornersLayer.events.on("ldown", this._onCornerLdown, this);
        this._cornersLayer.events.on("lup", this._onCornerLup, this);
    }
    _deactivate() {
        this._startLonLat = null;
        this._preventClick = false;
        this._stopDrawing = false;
        this._pickedCorner = null;
        // this._trackLayer.remove();
        // this._cornersLayer.remove();
        this.renderer.events.off("lclick", this._onLclick);
        this.renderer.events.off("mousemove", this._onMouseMove);
        this.renderer.events.off("lup", this._onLUp);
        this._cornersLayer.events.off("mouseenter", this._onCornerEnter);
        this._cornersLayer.events.off("mouseleave", this._onCornerLeave);
        this._cornersLayer.events.off("ldown", this._onCornerLdown);
        this._cornersLayer.events.off("lup", this._onCornerLup);
        this.clear();
    }
    setVisibility(visibility) {
        this._cornersLayer.setVisibility(visibility);
        this._trackLayer.setVisibility(visibility);
        this._labelLayer.setVisibility(visibility);
    }
    _drawLine(startLonLat, endLonLat, startPos) {
        if (!startPos) {
            startPos = this._planet.ellipsoid.lonLatToCartesian(startLonLat);
        }
        let endPos = this._planet.ellipsoid.lonLatToCartesian(endLonLat);
        let res = this._planet.ellipsoid.inverse(startLonLat, endLonLat);
        let length = res.distance;
        this._heading = res.initialAzimuth;
        let path = [];
        let dir = endPos.sub(startPos);
        let dist = dir.length();
        dir.normalize();
        for (let i = 0; i < OUTLINE_COUNT$1; i++) {
            let f = dir.scaleTo(i * dist / OUTLINE_COUNT$1).addA(startPos);
            path.push(f);
        }
        path.push(endPos);
        this._trackEntity.polyline.setPath3v([path]);
        if (this._ignoreTerrain) {
            this._propsLabel.setCartesian3v(path[Math.floor(path.length / 2)]);
            this._propsLabel.label.setText(`${distanceFormat$1(length)}, ${Math.round(this._heading)} deg`);
        }
    }
    clear() {
        this._trackEntity.remove();
        this._cornerEntity[0].remove();
        this._cornerEntity[1].remove();
        this._propsLabel.remove();
        this._planet.removeLayer(this._trackLayer);
        this._planet.removeLayer(this._cornersLayer);
    }
    isCornersPositionChanged() {
        let t = this._trackEntity.polyline.getPath3v()[0];
        if (t) {
            const startPos = t[0].clone(), endPos = t[t.length - 1].clone();
            return this._cornerEntity[0].getCartesian().equal(startPos) &&
                this._cornerEntity[1].getCartesian().equal(endPos);
        }
        return false;
    }
    frame() {
        let t = this._trackEntity.polyline.getPath3v()[0];
        if (t) {
            const startPos = t[0].clone(), endPos = t[t.length - 1].clone();
            if (!this.isCornersPositionChanged()) {
                this._cornerEntity[0].setCartesian3v(startPos);
                this._cornerEntity[1].setCartesian3v(endPos);
                if (!this._ignoreTerrain) {
                    let res = 0;
                    for (let i = 0, len = t.length - 1; i < len; i++) {
                        res += t[i + 1].distance(t[i]);
                    }
                    this._propsLabel.setCartesian3v(t[Math.floor(t.length / 2)]);
                    this._propsLabel.label.setText(`${distanceFormat$1(res)}, ${Math.round(this._heading)} deg`);
                }
            }
        }
    }
    get ellipsoid() {
        return this._planet ? this._planet.ellipsoid : null;
    }
}
const RULERSCENE_EVENTS = [
    "add",
    "remove",
    "mousemove",
    "mouseenter",
    "mouseleave",
    "lclick",
    "rclick",
    "mclick",
    "ldblclick",
    "rdblclick",
    "mdblclick",
    "lup",
    "rup",
    "mup",
    "ldown",
    "rdown",
    "mdown",
    "lhold",
    "rhold",
    "mhold",
    "mousewheel",
    "touchmove",
    "touchstart",
    "touchend",
    "doubletouch",
    "touchleave",
    "touchenter"
];

class Ruler extends Control {
    constructor(options = {}) {
        super(options);
        this._rulerScene = new RulerScene({
            name: `rulerScene:${this.__id}`,
            ignoreTerrain: options.ignoreTerrain
        });
    }
    set ignoreTerrain(v) {
        this._rulerScene.ignoreTerrain = v;
    }
    oninit() {
        this._rulerScene.bindPlanet(this.planet);
    }
    onactivate() {
        this.renderer && this.renderer.addNode(this._rulerScene);
    }
    ondeactivate() {
        this.renderer && this.renderer.removeNode(this._rulerScene);
    }
}

let obj3d = Object3d.createCylinder(1.1, 0, 2, 6, 1, true, true, 0, 0, 0);
const RAYS_OPTIONS = {
    startColor: "rgb(255,131,0)",
    endColor: "rgb(255,131,0)",
    thickness: 5
};
const LABEL_OPTIONS$1 = {
    text: "",
    size: 11,
    color: "rgba(455,455,455,1.0)",
    outlineColor: "rgba(0,0,0,0.34)",
    outline: 0.23,
    align: "center",
    offset: [0, 18, 0]
};
const RULER_CORNER_OPTIONS = {
    scale: 1,
    instanced: true,
    tag: "height-ruler",
    color: "rgb(255,131,0)",
    object3d: obj3d
};
class HeightRulerScene extends RulerScene {
    constructor(options = {}) {
        super(options);
        this._geoRulerLayer = new Vector("rayHeightRuler", {
            entities: [],
            pickingEnabled: false,
            polygonOffsetUnits: -2.0,
            relativeToGround: false,
            hideInLayerSwitcher: true
        });
        this._rayV = new Entity({
            name: 'verticalRay',
            ray: RAYS_OPTIONS
        });
        this._rayH = new Entity({
            name: 'heightRay',
            ray: RAYS_OPTIONS
        });
        this._heightLabels = [
            new Entity({
                name: 'startCornerLabel',
                label: {
                    ...LABEL_OPTIONS$1
                }
            }),
            new Entity({
                name: 'endCornerLabel',
                label: {
                    ...LABEL_OPTIONS$1
                }
            }),
            new Entity({
                name: 'deltaLabel',
                label: {
                    ...LABEL_OPTIONS$1
                }
            })
        ];
    }
    setVisibility(visibility) {
        super.setVisibility(visibility);
        this._geoRulerLayer.setVisibility(visibility);
    }
    get deltaLabel() {
        return this._heightLabels[2];
    }
    get startLabel() {
        return this._heightLabels[0];
    }
    get endLabel() {
        return this._heightLabels[1];
    }
    get corners() {
        return this._cornerEntity;
    }
    get startCorner() {
        return this.corners[0];
    }
    get endCorner() {
        return this.corners[1];
    }
    get startCornerLonLat() {
        return this.startCorner.getLonLat();
    }
    get startCornerHeight() {
        return this.startCornerLonLat.height;
    }
    get endCornerLonLat() {
        return this.endCorner.getLonLat();
    }
    get endCornerHeight() {
        return this.endCornerLonLat.height;
    }
    get maxHeightCornerLonLat() {
        if (this.startCornerHeight <= this.endCornerHeight) {
            return this.endCornerLonLat;
        }
        else {
            return this.startCornerLonLat;
        }
    }
    get minHeightCornerLonLat() {
        if (this.startCornerHeight > this.endCornerHeight) {
            return this.endCornerLonLat;
        }
        else {
            return this.startCornerLonLat;
        }
    }
    get deltaHeight() {
        return Math.abs(this.startCornerHeight - this.endCornerHeight);
    }
    _drawLine(startLonLat, endLonLat, startPos) {
        super._drawLine(startLonLat, endLonLat, startPos);
        this._updateHeightRaysAndLabels();
    }
    async _updateHeightRaysAndLabels() {
        const middleLonLat = this.minHeightCornerLonLat.clone();
        middleLonLat.height = this.maxHeightCornerLonLat.height;
        this._rayH.ray.setStartPosition3v(this._planet.ellipsoid.lonLatToCartesian(this.maxHeightCornerLonLat));
        this._rayH.ray.setEndPosition3v(this._planet.ellipsoid.lonLatToCartesian(middleLonLat));
        this._rayV.ray.setStartPosition3v(this._planet.ellipsoid.lonLatToCartesian(this.minHeightCornerLonLat));
        this._rayV.ray.setEndPosition3v(this._planet.ellipsoid.lonLatToCartesian(middleLonLat));
        middleLonLat.height = this.minHeightCornerLonLat.height + this.deltaHeight / 2;
        this.deltaLabel.setLonLat(middleLonLat);
        this.startLabel.setLonLat(this.startCornerLonLat);
        this.endLabel.setLonLat(this.endCornerLonLat);
        const startHeight = await this._planet.getHeightDefault(this.startCornerLonLat), endHeight = await this._planet.getHeightDefault(this.endCornerLonLat);
        this.deltaLabel.label.setText(`\u0394 ${Math.abs(startHeight - endHeight).toFixed(1)} m`);
        this.startLabel.label.setText(`P1 ${startHeight.toFixed(1)} m`);
        this.endLabel.label.setText(`P2 ${endHeight.toFixed(1)} m`);
    }
    clear() {
        this._rayH.remove();
        this._rayV.remove();
        this.startCorner.remove();
        this.endCorner.remove();
        this.startLabel.remove();
        this.endLabel.remove();
        this.deltaLabel.remove();
        super.clear();
        // this._rayH = null;
        // this._rayV = null;
        this._planet.removeLayer(this._geoRulerLayer);
    }
    _createCorners() {
        this._cornerEntity = [
            new Entity({
                geoObject: RULER_CORNER_OPTIONS,
                properties: {
                    name: "start"
                }
            }),
            new Entity({
                geoObject: RULER_CORNER_OPTIONS,
                properties: {
                    name: "end"
                }
            })
        ];
        this._cornersLayer.setEntities(this._cornerEntity);
    }
    init() {
        super.init();
        this._createCorners();
        this._labelLayer.addEntities(this._heightLabels);
        this._geoRulerLayer.addEntities([this._rayH, this._rayV]);
        this._planet.addLayer(this._geoRulerLayer);
    }
    frame() {
        super.frame();
        this._updateHeightRaysAndLabels();
    }
}

class HeightRuler extends Ruler {
    constructor(options = {}) {
        super(options);
        this._rulerScene = new HeightRulerScene({
            name: `heightRulerScene:${this.__id}`,
            ignoreTerrain: false
        });
    }
}

const ICON_BUTTON_SVG$4 = `<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg fill="#000000" height="800px" width="800px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
\t viewBox="0 0 512 512" xml:space="preserve">
<g>
\t<g>
\t\t<path d="M369.151,0L0.001,369.15L142.85,512l369.149-369.15L369.151,0z M47.286,369.15l10.908-10.908l47.782,47.782l23.642-23.642
\t\t\tL81.837,334.6l10.909-10.909l23.711,23.711L140.1,323.76l-23.711-23.711l10.909-10.909l23.711,23.711l23.642-23.642
\t\t\tl-23.711-23.711l10.909-10.909l47.782,47.782l23.642-23.642l-47.782-47.782l10.908-10.908l23.71,23.71l23.642-23.642l-23.71-23.71
\t\t\tl10.908-10.908l23.711,23.711l23.642-23.642l-23.711-23.711l10.909-10.909l47.782,47.782l23.642-23.642l-47.782-47.782
\t\t\tl10.908-10.908l23.71,23.711l23.642-23.642l-23.711-23.71L334.6,81.837l23.711,23.71l23.642-23.642l-23.711-23.712l10.908-10.908
\t\t\tl95.564,95.564L142.85,464.714L47.286,369.15z"/>
\t</g>
</g>
</svg>`;
/**
 * Activate ruler
 */
class RulerSwitcher extends Control {
    constructor(options = {}) {
        super({
            name: "RulerSwitcher",
            ...options
        });
        this.ruler = new HeightRuler({
            ignoreTerrain: options.ignoreTerrain
        });
    }
    oninit() {
        this.planet.addControl(this.ruler);
        this._createMenuBtn();
    }
    onactivate() {
        this.ruler.activate();
    }
    ondeactivate() {
        this.ruler.deactivate();
    }
    _createMenuBtn() {
        let btn = new ToggleButton({
            classList: ["og-map-button", "og-ruler_button"],
            icon: ICON_BUTTON_SVG$4
        });
        btn.appendTo(this.renderer.div);
        btn.events.on("change", (isActive) => {
            if (isActive) {
                this.onactivate();
            }
            else {
                this.ondeactivate();
            }
        });
    }
}

const scale = [
    1, 2, 3, 5, 10, 20, 30, 50, 100, 200, 300, 500, 1e3, 2e3, 3e3, 5e3, 10e3, 20e3, 30e3, 50e3,
    100e3, 200e3, 300e3, 500e3, 1000e3, 2000e3, 3000e3, 5000e3, 10000e3
];
const TEMPLATE$7 = `<div class="og-scale-container">
      <div class="og-scale-label"></div>
      <div class="og-scale-ruler"></div>
    </div>`;
/**
 * Planet zoom buttons control.
 */
class ScaleControl extends Control {
    constructor(options = {}) {
        if (!options.name || options.name === "") {
            options.name = "scaleControl";
        }
        super(options);
        this._template = TEMPLATE$7;
        this._minWidth = 100;
        this._maxWidth = 150;
        this._isCenter = options.isCenter != undefined ? options.isCenter : true;
        this._mPx = 0;
        this.currWidth = 0;
        this._metersInMinSize = 0;
        this.el = null;
        this._scaleLabelEl = null;
    }
    _renderTemplate() {
        return parseHTML(this._template)[0];
    }
    oninit() {
        this.el = this._renderTemplate();
        this._scaleLabelEl = this.el.querySelector(".og-scale-label");
        this.renderer.div.appendChild(this.el);
        if (this._isCenter) {
            this.planet.camera.events.on("moveend", () => {
                this._drawScreen(this.planet.renderer.handler.getCenter());
            });
            !this.planet.terrain.isEmpty && this.planet.terrain.events.on("loadend", () => {
                this._drawScreen(this.planet.renderer.handler.getCenter());
            });
        }
        else {
            this.renderer.events.on("mousemove", (e) => {
                if (!e.leftButtonHold && !e.rightButtonHold) {
                    this._drawScreen(e.pos);
                }
            });
            this.planet.camera.events.on("moveend", () => {
                let ms = this.renderer.events.mouseState;
                if (!ms.leftButtonHold && !ms.rightButtonHold) {
                    this._drawScreen(ms.pos);
                }
            });
        }
    }
    _drawScreen(px) {
        let cam = this.planet.camera;
        let s0 = px;
        let dist = this.planet.getDistanceFromPixel(s0) || 0;
        if (dist === 0) {
            s0 = cam.project(Vec3.ZERO);
            dist = this.planet.getDistanceFromPixel(s0) || 0;
        }
        let p0 = cam.getForward().scaleTo(dist).addA(cam.eye);
        let tempSize = dist * Math.tan(cam.viewAngle * RADIANS);
        let p1 = p0.add(cam.getRight().scaleTo(tempSize));
        let s1 = cam.project(p1);
        this._mPx = tempSize / s1.distance(s0);
        let metersInMinSize = this._mPx * this._minWidth;
        let index = binarySearch(scale, metersInMinSize, (a, b) => a - b);
        if (index < 0) {
            index = ~index;
        }
        let minMeters = scale[index], maxMeters = scale[index + 1];
        let t = (minMeters - metersInMinSize) / (maxMeters - minMeters);
        this.currWidth = this._minWidth + t * (this._maxWidth - this._minWidth);
        if (minMeters > 1000) {
            this._scaleLabelEl.innerText = `${minMeters / 1000} km`;
        }
        else {
            this._scaleLabelEl.innerText = `${minMeters} m`;
        }
        this._metersInMinSize = metersInMinSize;
        this.el.style.width = this.currWidth + "px";
    }
}

/**
 * Frame per second(FPS) display control.
 */
class ShowFps extends Control {
    constructor(options) {
        super(options);
    }
    oninit() {
        let d = document.createElement("div");
        d.className = "defaultText ";
        d.id = "ogShowFpsControl";
        document.body.appendChild(d);
        this.renderer.events.on("draw", this._draw, this);
    }
    _draw() {
        print2d("ogShowFpsControl", (1000.0 / this.renderer.handler.deltaTime).toFixed(1), this.renderer.handler.canvas.clientWidth - 60, 0);
    }
}

/**
 * Simple keyboard camera navigation with W,S,A,D and shift keys to fly around the scene.
 */
class SimpleNavigation extends Control {
    constructor(options = {}) {
        super({
            name: "SimpleNavigation",
            autoActivate: true, ...options
        });
        this.speed = options.speed || 1.0;
    }
    oninit() {
    }
    onactivate() {
        super.onactivate();
        let r = this.renderer;
        r.events.on("keypress", input.KEY_W, this.onCameraMoveForward, this);
        r.events.on("keypress", input.KEY_S, this.onCameraMoveBackward, this);
        r.events.on("keypress", input.KEY_A, this.onCameraStrifeLeft, this);
        r.events.on("keypress", input.KEY_D, this.onCameraStrifeRight, this);
        r.events.on("keypress", input.KEY_UP, this.onCameraLookUp, this);
        r.events.on("keypress", input.KEY_DOWN, this.onCameraLookDown, this);
        r.events.on("keypress", input.KEY_LEFT, this.onCameraTurnLeft, this);
        r.events.on("keypress", input.KEY_RIGHT, this.onCameraTurnRight, this);
        r.events.on("keypress", input.KEY_Q, this.onCameraRollLeft, this);
        r.events.on("keypress", input.KEY_E, this.onCameraRollRight, this);
    }
    ondeactivate() {
        super.ondeactivate();
        let r = this.renderer;
        r.events.off("keypress", input.KEY_W, this.onCameraMoveForward);
        r.events.off("keypress", input.KEY_S, this.onCameraMoveBackward);
        r.events.off("keypress", input.KEY_A, this.onCameraStrifeLeft);
        r.events.off("keypress", input.KEY_D, this.onCameraStrifeRight);
        r.events.off("keypress", input.KEY_UP, this.onCameraLookUp);
        r.events.off("keypress", input.KEY_DOWN, this.onCameraLookDown);
        r.events.off("keypress", input.KEY_LEFT, this.onCameraTurnLeft);
        r.events.off("keypress", input.KEY_RIGHT, this.onCameraTurnRight);
        r.events.off("keypress", input.KEY_Q, this.onCameraRollLeft);
        r.events.off("keypress", input.KEY_E, this.onCameraRollRight);
    }
    onCameraMoveForward() {
        if (this._active) {
            let cam = this.renderer.activeCamera;
            cam.slide(0, 0, -this.speed);
            cam.update();
        }
    }
    onCameraMoveBackward() {
        let cam = this.renderer.activeCamera;
        cam.slide(0, 0, this.speed);
        cam.update();
    }
    onCameraStrifeLeft() {
        let cam = this.renderer.activeCamera;
        cam.slide(-this.speed, 0, 0);
        cam.update();
    }
    onCameraStrifeRight() {
        let cam = this.renderer.activeCamera;
        cam.slide(this.speed, 0, 0);
        cam.update();
    }
    onCameraLookUp() {
        let cam = this.renderer.activeCamera;
        cam.pitch(0.5);
        cam.update();
    }
    onCameraLookDown() {
        let cam = this.renderer.activeCamera;
        cam.pitch(-0.5);
        cam.update();
    }
    onCameraTurnLeft() {
        let cam = this.renderer.activeCamera;
        cam.yaw(0.5);
        cam.update();
    }
    onCameraTurnRight() {
        let cam = this.renderer.activeCamera;
        cam.yaw(-0.5);
        cam.update();
    }
    onCameraRollLeft() {
        let cam = this.renderer.activeCamera;
        cam.roll(-0.5);
        cam.update();
    }
    onCameraRollRight() {
        let cam = this.renderer.activeCamera;
        cam.roll(0.5);
        cam.update();
    }
}

class SimpleSkyBackground extends Control {
    constructor(options = {}) {
        super({
            name: "SimpleSkyBackground",
            ...options
        });
        this._colorOne = new Float32Array([128 / 255, 223 / 255, 255 / 255]);
        this._colorTwo = new Float32Array([10 / 255, 15 / 255, 56 / 255]);
    }
    get colorOne() {
        let c = this._colorOne;
        let arr = [Math.round(c[0] * 255), Math.round(c[1] * 255), Math.round(c[2] * 255)];
        return rgbToStringHTML(arr);
    }
    get colorTwo() {
        let c = this._colorTwo;
        let arr = [Math.round(c[0] * 255), Math.round(c[1] * 255), Math.round(c[2] * 255)];
        return rgbToStringHTML(arr);
    }
    set colorOne(htmlColor) {
        let rgb = htmlColorToRgb(htmlColor);
        this._colorOne[0] = rgb.x;
        this._colorOne[1] = rgb.y;
        this._colorOne[2] = rgb.z;
    }
    set colorTwo(htmlColor) {
        let rgb = htmlColorToRgb(htmlColor);
        this._colorTwo[0] = rgb.x;
        this._colorTwo[1] = rgb.y;
        this._colorTwo[2] = rgb.z;
    }
    oninit() {
        this.renderer.handler.addProgram(simpleSkyBackgroundShader());
        this.activate();
    }
    onactivate() {
        super.onactivate();
        this.planet.events.on("draw", this._drawBackground, this);
    }
    ondeactivate() {
        super.ondeactivate();
        this.planet.events.off("draw", this._drawBackground);
    }
    _drawBackground() {
        let h = this.renderer.handler;
        let sh = h.programs.simpleSkyBackground, p = sh._program, shu = p.uniforms, gl = h.gl;
        let cam = this.planet.camera;
        gl.disable(gl.DEPTH_TEST);
        sh.activate();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.renderer.screenFramePositionBuffer);
        gl.vertexAttribPointer(p.attributes.corners, 2, gl.FLOAT, false, 0, 0);
        gl.uniform3fv(shu.camPos, [cam.eye.x, cam.eye.y, cam.eye.z]);
        gl.uniform2fv(shu.iResolution, [h.getWidth(), h.getHeight()]);
        gl.uniform1f(shu.fov, cam.getViewAngle());
        gl.uniform1f(shu.earthRadius, this.planet.ellipsoid.getPolarSize() + 1);
        gl.uniform3fv(shu.colorOne, this._colorOne);
        gl.uniform3fv(shu.colorTwo, this._colorTwo);
        gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.enable(gl.DEPTH_TEST);
    }
}
function simpleSkyBackgroundShader() {
    return new Program("simpleSkyBackground", {
        uniforms: {
            iResolution: "vec2", fov: "float",
            camPos: "vec3",
            earthRadius: "float",
            viewMatrix: "mat4",
            colorOne: "vec3",
            colorTwo: "vec3"
        }, attributes: {
            corners: "vec3"
        },
        vertexShader: `attribute vec2 corners;
                        
            varying vec2 tc;
            
            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
                tc = corners * 0.5 + 0.5;
            }`,
        fragmentShader: `precision highp float;
            
            #define MAX 10e10
            #define PI 3.14159265359
            #define rad(x) x * PI / 180.
            #define ZERO vec3(0.0)          
           
            #define RED vec4(1.0, 0.0, 0.0, 1.0)
            #define GREEN vec4(0.0, 1.0, 0.0, 1.0)         
            
            uniform vec3 camPos;            
            uniform vec2 iResolution;
            uniform float fov;
            uniform float earthRadius;
            uniform mat4 viewMatrix;
            
            uniform vec3 colorOne;
            uniform vec3 colorTwo;
                         
            varying vec2 tc;
                        
            // compute the view ray in the camera coordinate
            vec3 computeView(vec2 uv){
                float w_h_ratio = iResolution.x / iResolution.y;   
                float h = tan(rad(fov/2.));
                return normalize(vec3(-w_h_ratio * h, -h, -1.) + vec3(uv.x * 2. * h * w_h_ratio, uv.y*2.*h, 0.));
            }

            // sphere of size ra centered at point ce
            vec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )
            {
                vec3 oc = ro - ce;
                float b = dot( oc, rd );
                float c = dot( oc, oc ) - ra * ra;
                float h = b * b - c;
                if( h < 0.0 ) return vec2(MAX); // no intersection
                h = sqrt( h );
                return vec2( -b-h, -b+h );
            }
            
            mat3 transpose(mat3 matrix) {
                vec3 row0 = matrix[0];
                vec3 row1 = matrix[1];
                vec3 row2 = matrix[2];
                mat3 result = mat3(
                    vec3(row0.x, row1.x, row2.x),
                    vec3(row0.y, row1.y, row2.y),
                    vec3(row0.z, row1.z, row2.z)
                );
                return result;
            }
            
            float det(mat2 matrix) {
                return matrix[0].x * matrix[1].y - matrix[0].y * matrix[1].x;
            }
            
            mat3 inverse(mat3 matrix) {
                vec3 row0 = matrix[0];
                vec3 row1 = matrix[1];
                vec3 row2 = matrix[2];
            
                vec3 minors0 = vec3(
                    det(mat2(row1.y, row1.z, row2.y, row2.z)),
                    det(mat2(row1.z, row1.x, row2.z, row2.x)),
                    det(mat2(row1.x, row1.y, row2.x, row2.y))
                );
                vec3 minors1 = vec3(
                    det(mat2(row2.y, row2.z, row0.y, row0.z)),
                    det(mat2(row2.z, row2.x, row0.z, row0.x)),
                    det(mat2(row2.x, row2.y, row0.x, row0.y))
                );
                vec3 minors2 = vec3(
                    det(mat2(row0.y, row0.z, row1.y, row1.z)),
                    det(mat2(row0.z, row0.x, row1.z, row1.x)),
                    det(mat2(row0.x, row0.y, row1.x, row1.y))
                );
            
                mat3 adj = transpose(mat3(minors0, minors1, minors2));
            
                return (1.0 / dot(row0, minors0)) * adj;
            }
            
            void main(void) {
            
                vec3 dir = computeView(tc);
                dir = inverse(mat3(viewMatrix)) * dir;
                
                vec2 ER = sphIntersect(camPos, dir, vec3(0.0), earthRadius);
                
                float bigRadius = earthRadius * 2.5;
                vec3 bigCenter = normalize(camPos) * bigRadius * 1.3;                
                               
                vec2 BIG = sphIntersect(camPos, dir, bigCenter, bigRadius);
                
                float Ix = distance(camPos + dir * BIG.y, ZERO);               
                
                float maxI = sqrt(bigRadius * bigRadius + bigRadius * bigRadius);
                                   
                gl_FragColor = vec4(mix(colorOne, colorTwo, Ix / maxI), 1.0);
            }`
    });
}

/**
 * Angle between J2000 mean equator and the ecliptic plane.
 * 23 deg 26' 21".448 (Seidelmann, _Explanatory Supplement to the
 * Astronomical Almanac_ (1992), eqn 3.222-1.
 * @const
 * @type{number}
 */
const J2000_OBLIQUITY = 23.4392911;
/**
 * IAU 1976 value
 * @const
 * @type{number}
 */
const AU_TO_METERS = 1.4959787e11;

/**
 * Returns Sun position in the geocentric coordinate system by the time.
 * @param {JulianDate} jDate - Julian date time.
 * @returns {Vec3} - Sun geocentric coordinates.
 */
function getSunPosition(jDate) {
    // http://stjarnhimlen.se/comp/tutorial.html
    // a  Mean distance, or semi-major axis
    // e  Eccentricity
    // T  Time at perihelion
    // q  Perihelion distance  = a * (1 - e)
    // Q  Aphelion distance    = a * (1 + e)
    // i  Inclination, i.e. the "tilt" of the orbit relative to the
    //    ecliptic.  The inclination varies from 0 to 180 degrees. If
    //    the inclination is larger than 90 degrees, the planet is in
    //    a retrogade orbit, i.e. it moves "backwards".  The most
    //    well-known celestial body with retrogade motion is Comet Halley.
    // N  (usually written as "Capital Omega") Longitude of Ascending
    //    Node. This is the angle, along the ecliptic, from the Vernal
    //    Point to the Ascending Node, which is the intersection between
    //    the orbit and the ecliptic, where the planet moves from south
    //    of to north of the ecliptic, i.e. from negative to positive
    //    latitudes.
    // w  (usually written as "small Omega") The angle from the Ascending
    //    node to the Perihelion, along the orbit.
    // P  Orbital period       = 365.256898326 * a**1.5/sqrt(1+m) days,
    //    where m = the mass of the planet in solar masses (0 for
    //    comets and asteroids). sqrt() is the square root function.
    // n  Daily motion         = 360_deg / P    degrees/day
    // t  Some epoch as a day count, e.g. Julian Day Number. The Time
    //    at Perihelion, T, should then be expressed as the same day count.
    // t - T   Time since Perihelion, usually in days
    // M  Mean Anomaly         = n * (t - T)  =  (t - T) * 360_deg / P
    //    Mean Anomaly is 0 at perihelion and 180 degrees at aphelion
    // L  Mean Longitude       = M + w + N
    // E  Eccentric anomaly, defined by Kepler's equation:   M = E - e * sin(E)
    //    An auxiliary angle to compute the position in an elliptic orbit
    // v  True anomaly: the angle from perihelion to the planet, as seen
    //    from the Sun
    // r  Heliocentric distance: the planet's distance from the Sun.
    // x,y,z  Rectangular coordinates. Used e.g. when a heliocentric
    //        position (seen from the Sun) should be converted to a
    //        corresponding geocentric position (seen from the Earth).
    var d = jDate - J2000;
    var w = 282.9404 + 4.70935e-5 * d; // longitude of perihelion
    // var a = 1.000000; // mean distance, a.u.
    var e = 0.016709 - 1.151e-9 * d; // eccentricity
    var M = rev(356.047 + 0.9856002585 * d); // mean anomaly
    var oblecl = J2000_OBLIQUITY - 3.563e-7 * d; // obliquity of the ecliptic
    // var L = math.rev(w + M); // Sun's mean longitude
    var E = M + DEGREES * e * Math.sin(M * RADIANS) * (1 + e * Math.cos(M * RADIANS)); // eccentric anomaly
    // Sun rectangular coordinates, where the X axis points towards the perihelion
    var x = Math.cos(E * RADIANS) - e;
    var y = Math.sin(E * RADIANS) * Math.sqrt(1 - e * e);
    var r = Math.sqrt(x * x + y * y); // distance
    var v = Math.atan2(y, x) * DEGREES; // true anomaly
    var lon = rev(v + w); // longitude of the Sun
    // the Sun's ecliptic rectangular coordinates
    x = r * Math.cos(lon * RADIANS);
    y = r * Math.sin(lon * RADIANS);
    // We use oblecl, and rotate these coordinates
    var xequat = x;
    var yequat = y * Math.cos(oblecl * RADIANS);
    var zequat = y * Math.sin(oblecl * RADIANS);
    var theta = TWO_PI * ((d * 24.0) / 23.9344694 - 259.853 / 360.0); // Siderial spin time
    return Quat.zRotation(-theta).mulVec3(new Vec3(-xequat * AU_TO_METERS, -yequat * AU_TO_METERS, zequat * AU_TO_METERS));
    // Convert to RA and Decl
    // var RA = Math.atan2(yequat, xequat) * math.DEGREES;
    // var Decl = Math.atan2(zequat, Math.sqrt(xequat * xequat + yequat * yequat)) * math.DEGREES;
}

/**
 * Represents basic light source.
 * @class
 * @param {string} [name] - Light source name.
 * @param {ILightSourceParams} [params] - Light parameters:
 * @param {Vec3} [params.position] - Light source position if it is a point light, otherwise it is a light direction vector.
 * @param {Vec3} [params.ambient]  - Ambient RGB color.
 * @param {Vec3} [params.diffuse]  - Diffuse RGB color.
 * @param {Vec3} [params.specular]  - Specular RGB color.
 * @param {number} [params.shininess]  - Specular shininess.
 */
class LightSource {
    constructor(name, params) {
        /**
         * Light name.
         * @protected
         * @type {string}
         */
        this._name = name || "light_" + LightSource.__counter__++;
        /**
         * Render node where light is shines.
         * @protected
         * @type {RenderNode}
         */
        this._renderNode = null;
        /**
         * Light position.
         * @public
         * @type {Vec3}
         */
        this._position = params.position || new Vec3();
        /**
         * True if the light is directional.
         * @public
         * @type {boolean}
         */
        this.directional = params.directional != undefined ? params.directional : true;
        /**
         * Ambient color.
         * @protected
         * @type {Vec3}
         */
        this._ambient = params.ambient || new Vec3();
        /**
         * Diffuse color.
         * @protected
         * @type {Vec3}
         */
        this._diffuse = params.diffuse || new Vec3(0.8, 0.8, 0.8);
        /**
         * Specular color.
         * @protected
         * @type {Vec3}
         */
        this._specular = params.specular || new Vec3(0.18, 0.18, 0.18);
        /**
         * Shininess.
         * @protected
         * @type {number}
         */
        this._shininess = params.shininess != undefined ? params.shininess : 3.3;
        /**
         * Light activity.
         * @protected
         * @type {boolean}
         */
        this._active = true;
        this._tempAmbient = this._ambient.clone();
        this._tempDiffuse = this._diffuse.clone();
        this._tempSpecular = this._specular.clone();
        this._tempShininess = this._shininess;
    }
    /**
     * Creates clone of the current light object.
     * @todo: TODO
     * @public
     * @returns {LightSource}
     */
    clone() {
        // TODO
    }
    /**
     * Set light activity. If activity is false the light doesn't shine.
     * @public
     * @param {boolean} active - Light activity.
     */
    setActive(active) {
        if (active && !this._active) {
            const rn = this._renderNode;
            if (rn) {
                let index = rn._lightsNames.indexOf(this._name);
                this._shininess = rn._lightsParamsf[index] = this._tempShininess;
                if (index != -1) {
                    index *= 9;
                    this._ambient.x = rn._lightsParamsv[index] = this._tempAmbient.x;
                    this._ambient.y = rn._lightsParamsv[index + 1] = this._tempAmbient.y;
                    this._ambient.z = rn._lightsParamsv[index + 2] = this._tempAmbient.z;
                    this._diffuse.x = rn._lightsParamsv[index + 3] = this._tempDiffuse.x;
                    this._diffuse.y = rn._lightsParamsv[index + 4] = this._tempDiffuse.y;
                    this._diffuse.z = rn._lightsParamsv[index + 5] = this._tempDiffuse.z;
                    this._specular.x = rn._lightsParamsv[index + 6] = this._tempSpecular.x;
                    this._specular.y = rn._lightsParamsv[index + 7] = this._tempSpecular.y;
                    this._specular.z = rn._lightsParamsv[index + 8] = this._tempSpecular.z;
                }
            }
            this._active = true;
        }
        else if (!active && this._active) {
            this._tempAmbient = this._ambient.clone();
            this._tempDiffuse = this._diffuse.clone();
            this._tempSpecular = this._specular.clone();
            this._tempShininess = this._shininess;
            this.setBlack();
            this._active = false;
        }
    }
    /**
     * Gets light activity.
     * @public
     * @returns {boolean}
     */
    isActive() {
        return this._active;
    }
    /**
     * Set light source position, or if it is a directional type sets light direction vector.
     * @public
     * @param {Vec3} position - Light position or direction vector.
     */
    setPosition3v(position) {
        this._position.x = position.x;
        this._position.y = position.y;
        this._position.z = position.z;
    }
    /**
     * Set light source position, or if it is a directional type sets light direction vector.
     * @public
     */
    setPosition(x, y, z) {
        this._position.x = x;
        this._position.y = y;
        this._position.z = z;
    }
    /**
     * Returns light source position, or if it is a directional type sets light direction vector.
     * @public
     * @returns {Vec3} - Light source position/direction.
     */
    getPosition() {
        return this._position.clone();
    }
    /**
     * Set ambient color.
     * @public
     * @param {Vec3} rgb - Ambient color.
     */
    setAmbient3v(rgb) {
        this.setAmbient(rgb.x, rgb.y, rgb.z);
    }
    /**
     * Set diffuse color.
     * @public
     * @param {Vec3} rgb - Diffuse color.
     */
    setDiffuse3v(rgb) {
        this.setDiffuse(rgb.x, rgb.y, rgb.z);
    }
    /**
     * Set specular color.
     * @public
     * @param {Vec3} rgb - Specular color.
     */
    setSpecular3v(rgb) {
        this.setSpecular(rgb.x, rgb.y, rgb.z);
    }
    /**
     * Set ambient color.
     * @public
     */
    setAmbient(r, g, b) {
        this._ambient.set(r, g, b);
        const rn = this._renderNode;
        if (rn) {
            let index = 9 * rn._lightsNames.indexOf(this._name);
            if (index != -1) {
                rn._lightsParamsv[index] = r;
                rn._lightsParamsv[index + 1] = g;
                rn._lightsParamsv[index + 2] = b;
            }
        }
    }
    /**
     * Set diffuse color.
     * @public
     */
    setDiffuse(r, g, b) {
        this._diffuse.set(r, g, b);
        const rn = this._renderNode;
        if (rn) {
            let index = 9 * rn._lightsNames.indexOf(this._name);
            if (index != -1) {
                rn._lightsParamsv[index + 3] = r;
                rn._lightsParamsv[index + 4] = g;
                rn._lightsParamsv[index + 5] = b;
            }
        }
    }
    /**
     * Set specular color.
     * @public
     */
    setSpecular(r, g, b) {
        this._specular.set(r, g, b);
        const rn = this._renderNode;
        if (rn) {
            let index = 9 * rn._lightsNames.indexOf(this._name);
            if (index != -1) {
                rn._lightsParamsv[index + 6] = r;
                rn._lightsParamsv[index + 7] = g;
                rn._lightsParamsv[index + 8] = b;
            }
        }
    }
    /**
     * Set material shininess.
     * @public
     */
    setShininess(shininess) {
        this._shininess = shininess;
        const rn = this._renderNode;
        if (rn) {
            let index = rn._lightsNames.indexOf(this._name);
            if (index != -1) {
                rn._lightsParamsf[index] = shininess;
            }
        }
    }
    /**
     * Sets light to black.
     * @public
     */
    setBlack() {
        this._ambient.clear();
        this._diffuse.clear();
        this._specular.clear();
        this._shininess = 0;
        const rn = this._renderNode;
        if (rn) {
            let index = 9 * rn._lightsNames.indexOf(this._name);
            if (index !== -1) {
                rn._lightsParamsv[index] = rn._lightsParamsv[index + 1] = rn._lightsParamsv[index + 2] =
                    rn._lightsParamsv[index + 3] = rn._lightsParamsv[index + 4] = rn._lightsParamsv[index + 5] =
                        rn._lightsParamsv[index + 6] = rn._lightsParamsv[index + 7] = rn._lightsParamsv[index + 8] = 0;
            }
        }
    }
    /**
     * Adds current light to the render node scene.
     * @public
     * @param {RenderNode} renderNode - Render node scene.
     */
    addTo(renderNode) {
        this._renderNode = renderNode;
        renderNode._lights.push(this);
        renderNode._lightsNames.push(this._name);
        renderNode._lightsParamsf.push(this._shininess);
        renderNode._lightsParamsv.push.apply(renderNode._lightsParamsv, this._ambient.toArray());
        renderNode._lightsParamsv.push.apply(renderNode._lightsParamsv, this._diffuse.toArray());
        renderNode._lightsParamsv.push.apply(renderNode._lightsParamsv, this._specular.toArray());
        renderNode.transformLights();
    }
    /**
     * Removes from render node scene.
     * @public
     */
    remove() {
        this._renderNode;
        this._renderNode = null;
    }
}
LightSource.__counter__ = 0;

/**
 * Real Sun geocentric position control that place the Sun on the right place by the Earth.
 */
class Sun extends Control {
    constructor(options = {}) {
        super({ autoActivate: true, ...options });
        this._name = "sun";
        this.activationHeight = options.activationHeight || 12079000.0;
        this.offsetVertical = options.offsetVertical || -5000000;
        this.offsetHorizontal = options.offsetHorizontal || 5000000;
        this.sunlight = new LightSource("Sun", {
            ambient: new Vec3(0.15, 0.15, 0.25),
            diffuse: new Vec3(0.9, 0.9, 0.8),
            specular: new Vec3(0.1, 0.1, 0.06),
            shininess: 110
        });
        /**
         * Current frame handler clock date and time.
         * @private
         * @type {Number}
         */
        this._currDate = 0;
        /**
         * Previous frame handler clock date and time.
         * @private
         * @type {Number}
         */
        this._prevDate = 0;
        this._clockPtr = null;
        this._lightOn = false;
        this._f = 0;
        this._k = 0;
        this._stopped = options.stopped || false;
    }
    oninit() {
        this.planet.lightEnabled = true;
        // sunlight initialization
        this.sunlight.addTo(this.planet);
        this.renderer.events.on("draw", this._draw, this);
        if (!this._clockPtr) {
            this._clockPtr = this.renderer.handler.defaultClock;
        }
    }
    stop() {
        this._stopped = true;
        this.deactivate();
    }
    start() {
        this._stopped = false;
        this.activate();
    }
    onactivate() {
        super.onactivate();
        this._stopped = false;
    }
    bindClock(clock) {
        this._clockPtr = clock;
    }
    _draw() {
        if (!this._clockPtr)
            return;
        this._currDate = this._clockPtr.currentDate;
        if (!this._stopped) {
            let cam = this.planet.camera;
            if (cam.getHeight() < this.activationHeight || !this._active) {
                this._lightOn = true;
                this._f = 1;
                let n = cam.eye.normal(), u = cam.getForward();
                u.scale(Math.sign(cam._u.dot(n))); // up
                if (cam.slope > 0.99) {
                    u = cam._u;
                }
                let tu = Vec3.proj_b_to_plane(u, n, u).normalize().scale(this.offsetVertical);
                let tr = Vec3.proj_b_to_plane(cam._r, n, cam._r)
                    .normalize()
                    .scale(this.offsetHorizontal); // right
                let d = tu.add(tr);
                let pos = cam.eye.add(d);
                if (this._k > 0) {
                    this._k -= 0.01;
                    let rot = Quat.getRotationBetweenVectors(this.sunlight._position.normal(), pos.normal());
                    let r = rot.slerp(Quat.IDENTITY, this._k).normalize();
                    this.sunlight.setPosition3v(r.mulVec3(this.sunlight._position));
                }
                else {
                    this.sunlight.setPosition3v(pos);
                }
            }
            else {
                this._k = 1;
                if (this._f > 0) {
                    this._f -= 0.01;
                    let rot = Quat.getRotationBetweenVectors(this.sunlight._position.normal(), getSunPosition(this._currDate).normal());
                    let r = rot.slerp(Quat.IDENTITY, this._f).normalize();
                    this.sunlight.setPosition3v(r.mulVec3(this.sunlight._position));
                }
                else {
                    if ((Math.abs(this._currDate - this._prevDate) > 0.00034 && this._active) ||
                        this._lightOn) {
                        this._lightOn = false;
                        this._prevDate = this._currDate;
                        this.sunlight.setPosition3v(getSunPosition(this._currDate));
                        this._f = 0;
                    }
                }
            }
        }
        else {
            this.sunlight.setPosition3v(getSunPosition(this._currDate));
        }
    }
}

/**
 * Planet GL draw mode(TRIANGLE_STRIP/LINE_STRING) changer.
 */
class ToggleWireframe extends Control {
    constructor(options = {}) {
        super(options);
        this._isActive = false;
        this.toogleWireframe = () => {
            if (this.renderer && this.renderer.handler.gl) {
                if (this.planet.drawMode === this.renderer.handler.gl.LINE_STRIP) {
                    this.planet.setDrawMode(this.renderer.handler.gl.TRIANGLE_STRIP);
                }
                else {
                    this.planet.setDrawMode(this.renderer.handler.gl.LINE_STRIP);
                }
            }
        };
        this._isActive = options.isActive || false;
    }
    oninit() {
        this.renderer.events.on("charkeypress", input.KEY_X, this.toogleWireframe, this);
        if (this._isActive) {
            this.planet.setDrawMode(this.renderer.handler.gl.LINE_STRIP);
        }
    }
}

class TouchExt {
    constructor() {
        this.x = 0;
        this.y = 0;
        this.prev_x = 0;
        this.prev_y = 0;
        this.grabbedPoint = null;
        this.grabbedSpheroid = new Sphere();
        this._vec = new Vec2();
        this._vecPrev = new Vec2();
    }
    get dY() {
        return this.y - this.prev_y;
    }
    get dX() {
        return this.x - this.prev_x;
    }
    get vec() {
        return this._vec.set(this.x, this.y);
    }
    get vecPrev() {
        return this._vecPrev.set(this.prev_x, this.prev_y);
    }
}
/**
 * Touch pad planet camera dragging control.
 */
class TouchNavigation extends Control {
    constructor(options = {}) {
        super(options);
        this._name = "touchNavigation";
        this.grabbedPoint = new Vec3();
        this.inertia = 0.007;
        this.grabbedSpheroid = new Sphere();
        this.planet = null;
        this.qRot = new Quat();
        this.scaleRot = 0;
        this.rot = 1;
        this._eye0 = new Vec3();
        this.pointOnEarth = null;
        this.earthUp = null;
        this.touches = [new TouchExt(), new TouchExt()];
        this._keyLock = new Key();
        this._touching = false;
    }
    oninit() {
        if (this.renderer) {
            this.renderer.events.on("touchstart", this.onTouchStart, this);
            this.renderer.events.on("touchend", this.onTouchEnd, this);
            this.renderer.events.on("doubletouch", this.onDoubleTouch, this);
            this.renderer.events.on("touchcancel", this.onTouchCancel, this);
            this.renderer.events.on("touchmove", this.onTouchMove, this);
            this.renderer.events.on("draw", this.onDraw, this);
        }
    }
    onTouchStart(e) {
        const handler = this.renderer.handler;
        this._touching = true;
        if (e.sys.touches.length === 2) {
            const t0 = this.touches[0];
            const t1 = this.touches[1];
            t0.x = (e.sys.touches.item(0).clientX - e.sys.offsetLeft) * handler.pixelRatio;
            t0.y = (e.sys.touches.item(0).clientY - e.sys.offsetTop) * handler.pixelRatio;
            t0.prev_x = t0.x;
            t0.prev_y = t0.y;
            t0.grabbedPoint = this.planet.getCartesianFromPixelTerrain(new Vec2(t0.x, t0.y)) || null;
            t1.x = (e.sys.touches.item(1).clientX - e.sys.offsetLeft) * handler.pixelRatio;
            t1.y = (e.sys.touches.item(1).clientY - e.sys.offsetTop) * handler.pixelRatio;
            t1.prev_x = t1.x;
            t1.prev_y = t1.y;
            t1.grabbedPoint = this.planet.getCartesianFromPixelTerrain(new Vec2(t1.x, t1.y)) || null;
            this.pointOnEarth = this.planet.getCartesianFromPixelTerrain(this.renderer.handler.getCenter()) || null;
            if (this.pointOnEarth) {
                this.earthUp = this.pointOnEarth.normal();
            }
            if (t0.grabbedPoint && t1.grabbedPoint) {
                t0.grabbedSpheroid.radius = t0.grabbedPoint.length();
                t1.grabbedSpheroid.radius = t1.grabbedPoint.length();
                this.stopRotation();
            }
        }
        else if (e.sys.touches.length === 1) {
            this._startTouchOne(e);
        }
    }
    _startTouchOne(e) {
        const t = this.touches[0];
        const handler = this.renderer.handler;
        t.x = (e.sys.touches.item(0).clientX - e.sys.offsetLeft) * handler.pixelRatio;
        t.y = (e.sys.touches.item(0).clientY - e.sys.offsetTop) * handler.pixelRatio;
        t.prev_x = t.x;
        t.prev_y = t.y;
        // t.grabbedPoint = this.planet!.getCartesianFromPixelTerrain(e, true);
        t.grabbedPoint = this.planet.getCartesianFromPixelTerrain(e) || null;
        this._eye0.copy(this.planet.camera.eye);
        if (t.grabbedPoint) {
            t.grabbedSpheroid.radius = t.grabbedPoint.length();
            this.stopRotation();
        }
    }
    stopRotation() {
        this.qRot.clear();
        this.planet.layerLock.free(this._keyLock);
        this.planet.terrainLock.free(this._keyLock);
        this.planet._normalMapCreator.free(this._keyLock);
    }
    onDoubleTouch(e) {
        this.planet.stopFlying();
        this.stopRotation();
        const p = this.planet.getCartesianFromPixelTerrain(e);
        if (p) {
            const g = this.planet.ellipsoid.cartesianToLonLat(p);
            this.planet.flyLonLat(new LonLat(g.lon, g.lat, this.planet.camera.eye.distance(p) * 0.57));
        }
    }
    onTouchEnd(e) {
        if (e.sys.touches.length === 0) {
            this._touching = false;
        }
        if (e.sys.touches.length === 1) {
            this._startTouchOne(e);
        }
        if (Math.abs(this.touches[0].x - this.touches[0].prev_x) < 3 &&
            Math.abs(this.touches[0].y - this.touches[0].prev_y) < 3) {
            this.scaleRot = 0;
        }
    }
    onTouchCancel(e) {
    }
    onTouchMove(e) {
        let cam = this.planet.camera;
        const handler = this.renderer.handler;
        if (e.sys.touches.length === 2) {
            this.renderer.controlsBag.scaleRot = 1;
            let t0 = this.touches[0], t1 = this.touches[1];
            if (!t0.grabbedPoint || !t1.grabbedPoint) {
                return;
            }
            this.planet.stopFlying();
            t0.prev_x = t0.x;
            t0.prev_y = t0.y;
            t0.x = (e.sys.touches.item(0).clientX - e.sys.offsetLeft) * handler.pixelRatio;
            t0.y = (e.sys.touches.item(0).clientY - e.sys.offsetTop) * handler.pixelRatio;
            t1.prev_x = t1.x;
            t1.prev_y = t1.y;
            t1.x = (e.sys.touches.item(1).clientX - e.sys.offsetLeft) * handler.pixelRatio;
            t1.y = (e.sys.touches.item(1).clientY - e.sys.offsetTop) * handler.pixelRatio;
            const middle = t0.vec.add(t1.vec).scale(0.5);
            const earthMiddlePoint = this.planet.getCartesianFromPixelTerrain(middle);
            if (earthMiddlePoint) {
                this.pointOnEarth = earthMiddlePoint;
                const prevAngle = Math.atan2(t0.prev_y - t1.prev_y, t0.prev_x - t1.prev_x);
                const curAngle = Math.atan2(t0.y - t1.y, t0.x - t1.x);
                const deltaAngle = curAngle - prevAngle;
                const distanceToPointOnEarth = cam.eye.distance(this.pointOnEarth);
                const zoomCur = t0.vec.sub(t1.vec);
                const zoomPrev = t0.vecPrev.sub(t1.vecPrev);
                const scale = zoomCur.length() / zoomPrev.length();
                let d = distanceToPointOnEarth * -(1 - scale);
                cam.eye.addA(cam.getForward().scale(d));
                cam.rotateAround(-deltaAngle, false, this.pointOnEarth, this.earthUp);
                const panCur = t0.vec.add(t1.vec).scale(0.5);
                const panPrev = t0.vecPrev.add(t1.vecPrev).scale(0.5);
                const panOffset = panCur.sub(panPrev).scale(-1);
                var l = 0.5 / distanceToPointOnEarth * cam._lonLat.height * RADIANS;
                if (l > 0.003)
                    l = 0.003;
                cam.rotateHorizontal(l * -panOffset.x, false, this.pointOnEarth, this.earthUp);
                cam.rotateVertical(l * -panOffset.y, this.pointOnEarth);
                cam.checkTerrainCollision();
                cam.update();
            }
            this.scaleRot = 0;
        }
        else if (e.sys.touches.length === 1) {
            let t = this.touches[0];
            t.prev_x = t.x;
            t.prev_y = t.y;
            t.x = (e.sys.touches.item(0).clientX - e.sys.offsetLeft) * handler.pixelRatio;
            t.y = (e.sys.touches.item(0).clientY - e.sys.offsetTop) * handler.pixelRatio;
            if (!t.grabbedPoint) {
                return;
            }
            this.planet.stopFlying();
            let direction = e.direction;
            let targetPoint = new Ray$1(cam.eye, direction).hitSphere(t.grabbedSpheroid);
            if (targetPoint) {
                if (cam.slope > 0.2) {
                    this.qRot = Quat.getRotationBetweenVectors(targetPoint.normal(), t.grabbedPoint.normal());
                    let rot = this.qRot;
                    cam.eye = rot.mulVec3(cam.eye);
                    cam._r = rot.mulVec3(cam._r);
                    cam._u = rot.mulVec3(cam._u);
                    cam._b = rot.mulVec3(cam._b);
                    cam.checkTerrainCollision();
                    cam.update();
                    this.scaleRot = 1;
                }
                else {
                    let p0 = t.grabbedPoint, p1 = Vec3.add(p0, cam._u), p2 = Vec3.add(p0, p0.normal());
                    let dir = cam.unproject(t.x, t.y);
                    let px = new Vec3();
                    if (new Ray$1(cam.eye, dir).hitPlane(p0, p1, p2, px) === Ray$1.INSIDE) {
                        cam.eye = this._eye0.addA(px.subA(p0).negate());
                        cam.checkTerrainCollision();
                        cam.update();
                        this.scaleRot = 0;
                    }
                }
            }
        }
    }
    onDraw() {
        const r = this.renderer;
        r.controlsBag.scaleRot = this.scaleRot;
        if (this._touching) {
            return;
        }
        let cam = this.planet.camera;
        let prevEye = cam.eye.clone();
        if (r.events.mouseState.leftButtonDown || !this.scaleRot) {
            return;
        }
        this.scaleRot -= this.inertia;
        if (this.scaleRot <= 0) {
            this.scaleRot = 0;
        }
        else {
            r.controlsBag.scaleRot = this.scaleRot;
            let rot = this.qRot
                .slerp(Quat.IDENTITY, 1 - this.scaleRot * this.scaleRot * this.scaleRot)
                .normalize();
            if (!(rot.x || rot.y || rot.z)) {
                this.scaleRot = 0;
            }
            cam.eye = rot.mulVec3(cam.eye);
            cam._r = rot.mulVec3(cam._r);
            cam._u = rot.mulVec3(cam._u);
            cam._b = rot.mulVec3(cam._b);
            cam.checkTerrainCollision();
            cam.update();
        }
        if (cam.eye.distance(prevEye) / cam.getAltitude() > 0.01) {
            this.planet.layerLock.lock(this._keyLock);
            this.planet.terrainLock.lock(this._keyLock);
            this.planet._normalMapCreator.lock(this._keyLock);
        }
        else {
            this.planet.layerLock.free(this._keyLock);
            this.planet.terrainLock.free(this._keyLock);
            this.planet._normalMapCreator.free(this._keyLock);
        }
    }
}

const ICON_PLUS_SVG = '<?xml version="1.0"?>' +
    '<svg width=24 height=24 xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">' +
    '    <path d="M 11 5 L 11 11 L 5 11 L 5 13 L 11 13 L 11 19 L 13 19 L 13 13 L 19 13 L 19 11 L 13 11 L 13 5 L 11 5 z"/>' +
    '</svg>';
const ICON_MINUS_SVG = '<?xml version="1.0"?>' +
    '<svg width=24 height=24 xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">' +
    '    <path d="M 5 11 L 5 13 L 19 13 L 19 11 L 5 11 z"/>' +
    '</svg>';
/**
 * Planet zoom buttons control.
 */
class ZoomControl extends Control {
    constructor(options = {}) {
        super(options);
        this._keyLock = new Key();
        this._move = 0;
        this._targetPoint = null;
    }
    oninit() {
        let zoomInBtn = new Button({
            classList: ["og-map-button", "og-zoomin-button"],
            icon: ICON_PLUS_SVG
        });
        zoomInBtn.appendTo(this.renderer.div);
        let zoomOutBtn = new Button({
            classList: ["og-map-button", "og-zoomout-button"],
            icon: ICON_MINUS_SVG
        });
        zoomOutBtn.appendTo(this.renderer.div);
        zoomInBtn.events.on("mousedown", () => this.zoomIn());
        zoomInBtn.events.on("mouseup", () => this.stopZoom());
        zoomOutBtn.events.on("mousedown", () => this.zoomOut());
        zoomOutBtn.events.on("mouseup", () => this.stopZoom());
        zoomInBtn.events.on("touchstart", () => this.zoomIn());
        zoomInBtn.events.on("touchend", () => this.stopZoom());
        zoomInBtn.events.on("touchcancel", () => this.stopZoom());
        zoomOutBtn.events.on("touchstart", () => this.zoomOut());
        zoomOutBtn.events.on("touchend", () => this.stopZoom());
        zoomOutBtn.events.on("touchcancel", () => this.stopZoom());
        this.renderer.events.on("draw", this._draw, this);
    }
    /**
     * Planet zoom in.
     * @public
     */
    zoomIn() {
        this.planet.layerLock.lock(this._keyLock);
        this.planet.terrainLock.lock(this._keyLock);
        this.planet._normalMapCreator.lock(this._keyLock);
        this._targetPoint = this.renderer.getCenter();
        this._move = 1;
    }
    /**
     * Planet zoom out.
     * @public
     */
    zoomOut() {
        this.planet.layerLock.lock(this._keyLock);
        this.planet.terrainLock.lock(this._keyLock);
        this.planet._normalMapCreator.lock(this._keyLock);
        this._targetPoint = this.renderer.getCenter();
        this._move = -1;
    }
    stopZoom() {
        this._move = 0;
        this.planet.layerLock.free(this._keyLock);
        this.planet.terrainLock.free(this._keyLock);
        this.planet._normalMapCreator.free(this._keyLock);
    }
    _draw(e) {
        const cam = this.planet.camera;
        if (this._move !== 0) {
            const pos = this.planet.getCartesianFromPixelTerrain(e.getCenter());
            if (pos) {
                let d = cam.eye.distance(pos) * 0.035;
                cam.eye.addA(cam.getForward().scale(this._move * d));
                cam.checkTerrainCollision();
                cam.update();
            }
        }
    }
}

const OUTLINE_COUNT = 120;
function distanceFormat(v) {
    if (v > 1000) {
        return `${(v / 1000).toFixed(1)} km`;
    }
    else if (v > 9) {
        return `${Math.round(v)} m`;
    }
    else {
        return `${v.toFixed(1)} m`;
    }
}
class SelectionScene extends RenderNode {
    constructor(options = {}) {
        super(options.name);
        this._ignoreTerrain = false;
        this.events = new Events(EVENT_NAMES$1);
        this._ignoreTerrain = options.ignoreTerrain != undefined ? options.ignoreTerrain : true;
        this._onSelect = options.onSelect || null;
        this._autoSelectionHide = options.autoSelectionHide || false;
        this._planet = options.planet || null;
        this._startLonLat = null;
        this._heading = 0;
        this._propsLabel = new Entity({
            'name': 'propsLabel',
            'label': {
                text: "",
                size: 11,
                color: "rgba(455,455,455,1.0)",
                outlineColor: "rgba(0,0,0,0.34)",
                outline: 0.23,
                align: "center",
                offset: [0, 18]
            }
        });
        this._propsLabel?.label?.setVisibility(false);
        this._trackEntity = new Entity({
            polyline: {
                path3v: [],
                thickness: 3.8,
                color: "rgb(455,455,455)",
                isClosed: false
            }
        });
        this._trackEntity.polyline.altitude = 0.01;
        let obj3d = Object3d.createCylinder(1.1, 0, 2.7, 20, 1, true, false, 0, 0, 0);
        this._cornerEntity = [
            new Entity({
                geoObject: {
                    scale: 1,
                    instanced: true,
                    tag: "selection",
                    color: "rgb(0,305,0)",
                    object3d: obj3d
                },
                properties: {
                    name: "start"
                }
            }),
            new Entity({
                geoObject: {
                    scale: 1,
                    instanced: true,
                    tag: "selection",
                    color: "rgb(455,0,0)",
                    object3d: obj3d
                },
                properties: {
                    name: "end"
                }
            })
        ];
        this._trackLayer = new Vector("track", {
            entities: [this._trackEntity, this._propsLabel],
            pickingEnabled: false,
            polygonOffsetUnits: -1.0,
            relativeToGround: true,
            hideInLayerSwitcher: false
        });
        this._cornersLayer = new Vector("corners", {
            entities: [this._cornerEntity[0], this._cornerEntity[1]],
            pickingEnabled: true,
            hideInLayerSwitcher: true,
            scaleByDistance: [1.0, 4000000, 0.01],
            pickingScale: 2
        });
    }
    set ignoreTerrain(v) {
        this._ignoreTerrain = v;
    }
    bindPlanet(planet) {
        this._planet = planet;
    }
    init() {
        this._activate();
    }
    onremove() {
        this._deactivate();
    }
    _activate() {
        this._propsLabel?.label?.setVisibility(false);
        this._onMouseMove_ = this._onMouseMove.bind(this);
        this.renderer?.events.on("mousemove", this._onMouseMove_, this);
        this._onMouseLdown_ = this._onMouseLdown.bind(this);
        this.renderer?.events.on("ldown", this._onMouseLdown_, this);
        this._onMouseLup_ = this._onMouseLup.bind(this);
        this.renderer?.events.on("lup", this._onMouseLup_, this);
        this._planet.addLayer(this._trackLayer);
        this._planet.addLayer(this._cornersLayer);
    }
    _deactivate() {
        this._startLonLat = null;
        this._trackLayer.remove();
        this._cornersLayer.remove();
        this.renderer?.events.off("mousemove", this._onMouseMove_);
        this.renderer?.events.off("ldown", this._onMouseLdown_);
        this.renderer?.events.off("lup", this._onMouseLup_);
        this.clear();
        this._onMouseMove_ = null;
        this._onMouseLdown_ = null;
        this._onMouseLup_ = null;
    }
    _onMouseLdown(e) {
        //workaround to show pointer, because ogGrabbingPoiner keep !importanti which override pointer style
        e.renderer.handler.canvas.classList.remove('ogGrabbingPoiner');
        e.renderer.handler.canvas.style.cursor = 'pointer';
        if (!this._startLonLat) {
            this._propsLabel.label?.setVisibility(false);
            this._trackEntity.polyline?.setPath3v([]);
            this._cornerEntity[0].geoObject?.setVisibility(true);
            this._cornerEntity[1].geoObject?.setVisibility(true);
            this.renderer?.controls.mouseNavigation?.deactivate();
            this._startLonLat = this._planet.getLonLatFromPixelTerrain(e);
            let startPos = this._planet.ellipsoid.lonLatToCartesian(this._startLonLat);
            this._cornerEntity[0].setCartesian3v(startPos);
            this._cornerEntity[1].setCartesian3v(startPos);
        }
    }
    _onMouseLup(e) {
        if (this._startLonLat) {
            this._pickedCorner = null;
            this._anchorLonLat = null;
            this._propsLabel.label?.setVisibility(true);
            if (this._onSelect && typeof this._onSelect === 'function') {
                let startLonLat = this._cornerEntity[0].getLonLat();
                let endLonLat = this._cornerEntity[1].getLonLat();
                let extent = [
                    Math.min(startLonLat.lon, endLonLat.lon),
                    Math.min(startLonLat.lat, endLonLat.lat),
                    Math.max(startLonLat.lon, endLonLat.lon),
                    Math.max(startLonLat.lat, endLonLat.lat)
                ];
                this._onSelect(extent);
            }
            if (this._autoSelectionHide) {
                this.clear();
            }
            this._startLonLat = null;
        }
        e.renderer.handler.canvas.style.cursor = 'default';
        this.renderer?.controls.mouseNavigation?.activate();
    }
    _drawLine(startLonLat, endLonLat, startPos) {
        if (!startPos) {
            startPos = this._planet.ellipsoid.lonLatToCartesian(startLonLat);
        }
        let endPos = this._planet.ellipsoid.lonLatToCartesian(endLonLat);
        let res = this._planet.ellipsoid.direct(startLonLat, endLonLat);
        this._heading = res.initialAzimuth;
        let path = [];
        this._cornerEntity[0].setCartesian3v(startPos);
        this._cornerEntity[1].setCartesian3v(endPos);
        let corners = [
            startPos,
            this._planet.ellipsoid.lonLatToCartesian(new LonLat(endLonLat.lon, startLonLat.lat, startLonLat.height)),
            endPos,
            this._planet.ellipsoid.lonLatToCartesian(new LonLat(startLonLat.lon, endLonLat.lat, startLonLat.height)),
            startPos
        ];
        path.push(startPos);
        let createPath = (sideA, sideB) => {
            let dir = sideB.sub(sideA);
            let dist = dir.length();
            dir.normalize();
            for (let i = 0; i < OUTLINE_COUNT; i++) {
                let f = dir.scaleTo(i * dist / OUTLINE_COUNT).addA(sideA);
                path.push(f);
            }
        };
        for (let i = 0; i < corners.length - 1; i++) {
            createPath(corners[i], corners[i + 1]);
        }
        this._trackEntity.polyline?.setPath3v([path]);
        if (this._ignoreTerrain) ;
    }
    _onMouseMove(e) {
        if (this._startLonLat) {
            this._propsLabel.label?.setVisibility(true);
            let endLonLat = this._planet.getLonLatFromPixelTerrain(e);
            if (!endLonLat)
                return;
            this._drawLine(this._startLonLat, endLonLat);
        }
    }
    clear() {
        this._trackEntity.polyline?.clear();
        this._cornerEntity[0].geoObject?.setVisibility(false);
        this._cornerEntity[1].geoObject?.setVisibility(false);
    }
    frame() {
        let t = this._trackEntity.polyline?.getPath3v()[0];
        if (t) {
            if (!this._ignoreTerrain) {
                let res = 0;
                for (let i = 0, len = t.length - 1; i < len; i++) {
                    res += t[i + 1].distance(t[i]);
                }
                this._propsLabel.setCartesian3v(t[Math.floor(t.length / 2)]);
                this._propsLabel.label?.setText(`${distanceFormat(res)}, ${Math.round(this._heading)} deg`);
            }
        }
    }
    get ellipsoid() {
        return this._planet ? this._planet.ellipsoid : null;
    }
}
const EVENT_NAMES$1 = [
    "add",
    "remove",
    "mousemove",
    "mouseenter",
    "mouseleave",
    "lclick",
    "rclick",
    "mclick",
    "ldblclick",
    "rdblclick",
    "mdblclick",
    "lup",
    "rup",
    "mup",
    "ldown",
    "rdown",
    "mdown",
    "lhold",
    "rhold",
    "mhold",
    "mousewheel",
    "touchmove",
    "touchstart",
    "touchend",
    "doubletouch",
    "touchleave",
    "touchenter"
];

const ICON_BUTTON_SVG$3 = `<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--gis" preserveAspectRatio="xMidYMid meet"><path d="M2.1 0v1.914H0v6h3V3h5.1V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h1.8v1.2h3V0h-4.8zm1.8 7.2v6h3v-6h-3zM0 10.913v6h3v-6H0zM66.9 16.2v6h3v-6h-3zM0 19.914v6h3v-6H0zM66.9 25.2v6h3v-6h-3zM0 28.914v6h3v-6H0zM66.9 34.2v6h3v-6h-3zM0 37.914v6h3v-6H0zM66.9 43.2v6h3v-6h-3zM0 46.914v6h3v-6H0zM66.9 52.2v6h3v-6h-3zM0 55.914v5.191h3.809v-3H3v-2.19H0zm6.809 2.191v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9.648 1.899a2.076 2.076 0 0 0-2.19 2.324l3.137 33.676c.2 1.635 2.135 2.399 3.397 1.34l6.623-5.371l2.969 5.142c1.707 2.958 4.417 3.684 7.375 1.977c2.957-1.708 3.684-4.417 1.976-7.375l-2.959-5.125l7.848-3.008c1.548-.564 1.855-2.62.539-3.611L71.576 60.416a2.073 2.073 0 0 0-1.119-.412z" fill="#000000"></path></svg>`;
/**
 * Activate Selection
 * @param {boolean} [options.ignoreTerrain=false].
 * @param {function} options.onSelect - callback (extent) => {} where extent is selected extent array [minLon,minLat,maxLon,maxLat]
 * @param {boolean} [options.autoSelectionHide=false] - clear selection rectangle  after passing extent to callback
 * @example:
 * to use bootstrap icons, include
 *  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.2/font/bootstrap-icons.css">
 *
 * new Selection({
 *       ignoreTerrain: false,
 *       autoSelectionHide:true,
 *       onSelect: (extent) => {
 *
 *           var vectorSource = new ol.source.Vector({
 *               format: new GeoJSON(),
 *               url: function (extent) {
 *                   return 'https://snap.ogs.trieste.it/geoserver/snap/ows?service=WFS&' +
 *                           'version=1.1.0&request=GetFeature&typename=snap:all_dataset_segy_view&' +
 *                           'outputFormat=application/json&srsname=EPSG:4326&' +
 *                           'bbox=' + extent.join(',') + ',EPSG:4326';
 *               },
 *               strategy: function (extent, resolution) {
 *                   if (this.resolution && this.resolution != resolution) {
 *                       this.loadedExtentsRtree_.clear();
 *                   }
 *                   return [extent];
 *               }
 *           });
 *
 *           vectorSource.loadFeatures(extent);
 *
 *           console.log(extent);
 *
 *       }
 *   });
 */
class Selection extends Control {
    constructor(options = {}) {
        super(options);
        this._selectorScene = new SelectionScene({
            name: `selectionScene:${this.__id}`,
            ignoreTerrain: options.ignoreTerrain,
            onSelect: options.onSelect,
            autoSelectionHide: options.autoSelectionHide
        });
        this._toggleBtn = new ToggleButton({
            classList: ["og-map-button", "og-selection_button"],
            icon: ICON_BUTTON_SVG$3
        });
    }
    set ignoreTerrain(v) {
        this._selectorScene.ignoreTerrain = v;
    }
    oninit() {
        this._toggleBtn.appendTo(this.renderer.div);
        this._toggleBtn.events.on("change", (isActive) => {
            if (isActive) {
                this.activate();
            }
            else {
                this.deactivate();
            }
        });
        this._selectorScene.bindPlanet(this.planet);
    }
    onactivate() {
        this.renderer.addNode(this._selectorScene);
    }
    ondeactivate() {
        this.renderer.removeNode(this._selectorScene);
    }
}

function addSeconds(date, seconds) {
    return new Date(+date + seconds * 1000);
}
function dateToStr(date, showTime = true, showMilliseconds = false) {
    let month = MONTHS[date.getMonth()], day = date.getUTCDate(), year = date.getUTCFullYear();
    if (showTime) {
        let h = date.getUTCHours().toString().padStart(2, '0'), m = date.getUTCMinutes().toString().padStart(2, '0'), s = date.getUTCSeconds().toString().padStart(2, '0');
        if (showMilliseconds) {
            let ms = date.getUTCMilliseconds().toString().padStart(3, '0');
            return `${month} ${day} ${year} ${h}:${m}:${s}.${ms}`;
        }
        return `${month} ${day} ${year} ${h}:${m}:${s}`;
    }
    return `${month} ${day} ${year}`;
}
function createCanvasHTML() {
    return document.createElement("canvas");
}
function getNearestTimeLeft(t, div) {
    return t - (t % div);
}
function drawNotch(ctx, xOffset = 0, size = 10, thickness = 2, color = "white") {
    ctx.lineWidth = thickness;
    ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.moveTo(xOffset, 0);
    ctx.lineTo(xOffset, size);
    ctx.stroke();
}
function drawText(ctx, text, x, y, font = "12px Arial", fillStyle = "black", align = "left", baseLine = "bottom", rotDeg = 0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotDeg * RADIANS);
    ctx.fillStyle = fillStyle;
    ctx.textBaseline = baseLine;
    ctx.font = font;
    ctx.textAlign = align;
    ctx.fillText(text, 0, 0);
    ctx.restore();
}
const SCALES = [
    [0.001, 10],
    [0.002, 10],
    [0.005, 10],
    [0.01, 10],
    [0.02, 10],
    [0.05, 10],
    [0.1, 10],
    [0.25, 10],
    [0.5, 5],
    [1.0, 10],
    [2.0, 10],
    [5.0, 5],
    [10.0, 10],
    [15.0, 15],
    [30.0, 6],
    [60.0, 12], // 1min
    [120.0, 12], // 2min
    [300.0, 5], // 5min
    [600.0, 10], // 10min
    [900.0, 15], // 15min
    [1800.0, 6], // 30min
    [3600.0, 12], // 1hr
    [7200.0, 10], // 2hr
    [14400.0, 4], // 4hr
    [21600.0, 6], // 6hr
    [43200.0, 12], // 12hr
    [86400.0, 24], // 24hr
    [172800.0, 2], // 2days
    [345600.0, 4], // 4days
    [604800.0, 7], // 7days
    [1296000.0, 15], // 15days
    [2592000.0, 5], // 30days
    [5184000.0, 6], // 60days
    [7776000.0, 9], // 90days
    [15552000.0, 18], // 180days
    [31536000.0, 12], // 365days
    [63072000.0, 2], // 2years
    [126144000.0, 4], // 4years
    [157680000.0, 5], // 5years
    [315360000.0, 10], // 10years
    [630720000.0, 2], // 20years
    [1261440000.0, 4], // 40years
    [1576800000.0, 5], // 50years
    [3153600000.0, 10], // 100years
    [6307200000.0, 2], // 200years
    [12614400000.0, 4], // 400years
    [15768000000.0, 5], // 500years
    [31536000000.0, 10], // 1000years
];
function getScale(seconds) {
    for (let i = 0, len = SCALES.length; i < len; i++) {
        if (SCALES[i][0] > seconds) {
            return SCALES[i - 1];
        }
    }
}
const MONTHS = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
];

const TIMELINE_EVENTS = ["change", "current" /*, "tick"*/];
class TimelineModel {
    constructor(options = {}) {
        this.events = createEvents(TIMELINE_EVENTS);
        this._current = options.current || new Date();
        this._rangeStart = options.rangeStart || new Date();
        this._rangeEnd = options.rangeEnd || addSeconds(this._rangeStart, 3600);
        this._range = this._rangeEnd.getTime() - this._rangeStart.getTime();
        this._minDate = options.minDate || null;
        this._maxDate = options.maxDate || null;
        this.multiplier = options.multiplier != undefined ? options.multiplier : 1.0;
        this._requestAnimationFrameId = 0;
        this._prevNow = 0;
        this.dt = 0;
    }
    play() {
        if (!this._requestAnimationFrameId) {
            this._prevNow = window.performance.now();
            this._animationFrameCallback();
        }
    }
    stop() {
        if (this._requestAnimationFrameId) {
            window.cancelAnimationFrame(this._requestAnimationFrameId);
            this._requestAnimationFrameId = 0;
        }
    }
    stopped() {
        return this._requestAnimationFrameId == 0;
    }
    _animationFrameCallback() {
        this._requestAnimationFrameId = window.requestAnimationFrame(() => {
            this._frame();
            this._animationFrameCallback();
        });
    }
    _frame() {
        let now = window.performance.now();
        this.dt = now - this._prevNow;
        this._prevNow = now;
        this.current = new Date(this.currentTime + this.dt * this.multiplier);
        // this._events.dispatch(this._events.tick, this._current);
    }
    get range() {
        return this._range;
    }
    set(rangeStart, rangeEnd) {
        if (rangeStart !== this._rangeStart || rangeEnd !== this._rangeEnd) {
            this._rangeStart = rangeStart;
            this._rangeEnd = rangeEnd;
            this._range = this._rangeEnd.getTime() - this._rangeStart.getTime();
            this.events.dispatch(this.events.change, rangeStart, rangeEnd);
        }
    }
    get current() {
        return this._current;
    }
    get rangeStart() {
        return this._rangeStart;
    }
    get rangeEnd() {
        return this._rangeEnd;
    }
    get rangeStartTime() {
        return this._rangeStart.getTime();
    }
    get rangeEndTime() {
        return this._rangeEnd.getTime();
    }
    get currentTime() {
        return this._current.getTime();
    }
    set current(current) {
        if (current !== this._current) {
            if (this._maxDate && current > this._maxDate) {
                this._current = this._maxDate;
            }
            else if (this._minDate && current < this._minDate) {
                this._current = this._minDate;
            }
            else {
                this._current = current;
            }
            this.events.dispatch(this.events.current, this._current);
        }
    }
    set rangeStart(date) {
        if (date !== this._rangeStart) {
            this._rangeStart = date;
            this._range = this._rangeEnd.getTime() - this._rangeStart.getTime();
            this.events.dispatch(this.events.change, date);
        }
    }
    set rangeEnd(date) {
        if (date !== this._rangeEnd) {
            this._rangeEnd = date;
            this._range = this._rangeEnd.getTime() - this._rangeStart.getTime();
            this.events.dispatch(this.events.change, date);
        }
    }
}

const SECONDS_TO_MILLISECONDS = 1000.0;
const MILLISECONDS_TO_SECONDS = 1.0 / SECONDS_TO_MILLISECONDS;
const TIMELINEVIEW_EVENTS = [
    'startdrag',
    'stopdrag',
    'startdragcurrent',
    'stopdragcurrent',
    'setcurrent',
    'reset',
    'play',
    'playback',
    'pause',
    'visibility'
];
const ICON_PLAY_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8 5v14l11-7z" style="fill: black;"/></svg>';
const ICON_PAUSE_SVG = '<?xml version="1.0" ?><!DOCTYPE svg  PUBLIC \'-//W3C//DTD SVG 1.1//EN\'  \'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\'><svg enable-background="new 0 0 512 512" height="512px" version="1.1" viewBox="0 0 512 512" width="512px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="Layer_6"><rect fill="#252525" height="320" width="60" x="153" y="96"/><rect fill="#252525" height="320" width="60" x="299" y="96"/></g></svg>';
const SCALE_FILL_COLOR = "rgba(64, 59, 59, 1.0)";
const SCALE_NOTCH_COLOR = "#bfbfbf";
const SCALE_TIME_COLOR = "#bfbfbf";
const TEMPLATE$6 = `<div class="og-timeline">

  <div class="og-timeline-top">
  </div>

  <div class="og-timeline-frame">
    <div class="og-timeline-current">
      <div class="og-timeline-current-spin">
        <div class="og-timeline-current-arrow"></div>
      </div>
    </div>
    <div class="og-timeline-scale"></div>
  </div>

  <div class="og-timeline-bottom">
    <div class="og-timeline-controls">
    </div>
  </div>

</div>`;
class TimelineView extends View {
    constructor(options = {}) {
        super({
            template: TEMPLATE$6,
            model: new TimelineModel({
                rangeStart: options.rangeStart,
                rangeEnd: options.rangeEnd,
                current: options.currentDate,
                minDate: options.minDate,
                maxDate: options.maxDate
            })
        });
        this._onMouseWheel = (e) => {
            if (this._isMouseOver) {
                let rect = this._canvasEl.getBoundingClientRect();
                let pointerPosX = e.clientX - rect.left, pointerCenterOffsetX = -(pointerPosX - this.clientWidth * 0.5);
                let pointerTime = this.model.rangeStartTime + this._millisecondsInPixel * pointerPosX;
                this._zoom(pointerTime, pointerCenterOffsetX, Math.sign(e.wheelDelta));
            }
            else if (this._isCurrentMouseOver) {
                let pointerCenterOffsetX = -((this.model.currentTime - this.model.rangeStartTime) / this._millisecondsInPixel - this.clientWidth * 0.5);
                this._zoom(this.model.currentTime, pointerCenterOffsetX, Math.sign(e.wheelDelta));
            }
        };
        this._onMouseWheelFF = (e) => {
            this._onMouseWheel(e);
        };
        this._onMouseDown = (e) => {
            if (this._isMouseOver) {
                this._isDragging = true;
                document.body.classList.add("og-timeline-unselectable");
                this._clickPosX = e.clientX;
                this._clickTime = Date.now();
                this._clickRangeStart = this.model.rangeStart;
                this._clickRangeEnd = this.model.rangeEnd;
                this.events.dispatch(this.events.startdrag, e);
            }
            else if (this._isCurrentMouseOver) {
                this._isCurrentDragging = true;
                document.body.classList.add("og-timeline-unselectable");
                this._clickPosX = e.clientX;
                this._clickCurrentDate = this.model.current;
                this.events.dispatch(this.events.startdragcurrent, e);
            }
        };
        this._onMouseUp = (e) => {
            if (this._isDragging) {
                this._isDragging = false;
                document.body.classList.remove("og-timeline-unselectable");
                if (this._clickPosX === e.clientX && (Date.now() - this._clickTime) < this._clickDelay) {
                    let rect = this._canvasEl.getBoundingClientRect();
                    let current = new Date(this.model.rangeStartTime + (e.clientX - rect.left) * this._millisecondsInPixel);
                    this.model.current = current;
                    this.events.dispatch(this.events.stopdrag, current);
                    this.events.dispatch(this.events.setcurrent, current);
                }
                else {
                    this.events.dispatch(this.events.stopdrag, this.model.current);
                }
            }
            else if (this._isCurrentDragging) {
                this._isCurrentDragging = false;
                document.body.classList.remove("og-timeline-unselectable");
                this.events.dispatch(this.events.stopdragcurrent, this.model.current);
            }
        };
        this._onMouseEnter = () => {
            this._isMouseOver = true;
        };
        this._onMouseOut = () => {
            this._isMouseOver = false;
        };
        this._onCurrentMouseEnter = () => {
            this._isCurrentMouseOver = true;
        };
        this._onCurrentMouseOut = () => {
            this._isCurrentMouseOver = false;
        };
        this._onMouseMove = (e) => {
            if (this._isDragging) {
                let offsetSec = (this._clickPosX - e.clientX) * this._millisecondsInPixel * MILLISECONDS_TO_SECONDS;
                this.model.set(addSeconds(this._clickRangeStart, offsetSec), addSeconds(this._clickRangeEnd, offsetSec));
            }
            else if (this._isCurrentDragging) {
                let offsetSec = (this._clickPosX - e.clientX) * this._millisecondsInPixel * MILLISECONDS_TO_SECONDS;
                let newCurrent = addSeconds(this._clickCurrentDate, -offsetSec);
                if (newCurrent >= this.model.rangeStart && newCurrent <= this.model.rangeEnd) {
                    this.model.current = addSeconds(this._clickCurrentDate, -offsetSec);
                }
            }
        };
        //@ts-ignore
        this.events = this.events.registerNames(TIMELINEVIEW_EVENTS);
        this.fillStyle = options.fillStyle || SCALE_FILL_COLOR;
        this.$controls = null;
        this._frameEl = null;
        this._currentEl = null;
        this._canvasEl = createCanvasHTML();
        this._ctx = this._canvasEl.getContext('2d');
        this._isMouseOver = false;
        this._isDragging = false;
        this._isCurrentDragging = false;
        this._isCurrentMouseOver = false;
        this._minWidth = 330;
        this._canvasScale = 2;
        this._millisecondsInPixel = 0;
        this._clickPosX = 0;
        this._clickRangeStart = new Date();
        this._clickRangeEnd = new Date();
        this._clickCurrentDate = new Date();
        this._clickTime = 0;
        this._clickDelay = 450;
        this._onResizeObserver_ = this._onResizeObserver.bind(this);
        this._resizeObserver = new ResizeObserver(this._onResizeObserver_);
        this._pauseBtn = new ToggleButton({
            classList: ["og-timeline-control_button"],
            icon: ICON_PAUSE_SVG,
            name: "pause"
        });
        this._playBtn = new ToggleButton({
            classList: ["og-timeline-control_button"],
            icon: ICON_PLAY_SVG,
            name: "play"
        });
        this._buttons = new ButtonGroup({
            buttons: [this._pauseBtn, this._playBtn]
        });
        this._visibility = false;
    }
    _onResizeObserver() {
        this.resize();
    }
    get canvasScale() {
        return this._canvasScale;
    }
    set canvasScale(scale) {
        if (scale !== this._canvasScale) {
            this._canvasScale = scale;
            this.resize();
        }
    }
    resize() {
        this._resize();
        this.draw();
    }
    afterRender(parentNode) {
        this.resize();
    }
    render() {
        super.render();
        this.$controls = this.select(".og-timeline-controls");
        this._frameEl = this.select(".og-timeline-frame");
        this._currentEl = this.select(".og-timeline-current");
        this.select(".og-timeline-frame .og-timeline-scale").appendChild(this._canvasEl);
        this._resizeObserver.observe(this.el);
        this.model.events.on("change", () => {
            this.draw();
        });
        this.model.events.on("current", (d) => {
            this._drawCurrent();
            this.events.dispatch(this.events.setcurrent, d);
        });
        this._canvasEl.addEventListener("mouseenter", this._onMouseEnter);
        this._canvasEl.addEventListener("mouseout", this._onMouseOut);
        this._currentEl.addEventListener("mouseenter", this._onCurrentMouseEnter);
        this._currentEl.addEventListener("mouseout", this._onCurrentMouseOut);
        document.body.addEventListener("mousemove", this._onMouseMove);
        document.body.addEventListener("mousedown", this._onMouseDown);
        document.body.addEventListener("mouseup", this._onMouseUp);
        document.body.addEventListener("wheel", this._onMouseWheelFF);
        this._playBtn.appendTo(this.$controls);
        this._pauseBtn.appendTo(this.$controls);
        if (this.model.stopped()) {
            this._pauseBtn.setActive(true, true);
            this._pauseBtn.preventClick = true;
        }
        else {
            this._playBtn.setActive(true, true);
            this._playBtn.preventClick = true;
        }
        this._buttons.events.on("change", (btn) => {
            switch (btn.name) {
                case "play":
                    this.play();
                    break;
                case "pause":
                    this.pause();
                    break;
            }
        });
        // let mltView = new View({
        //     template: `<div class="og-timeline-multiplier">
        //                 <select>
        //                     <option value="0.25">0.25</option>
        //                     <option value="0.5">0.5</option>
        //                     <option value="1" selected>1.0</option>
        //                     <option value="2">2.0</option>
        //                     <option value="3">3.0</option>
        //                     <option value="5">5.0</option>
        //                 </select>
        //                 </div>`
        // });
        //mltView.appendTo($ctl)
        // let multiplierEl = this.select(".og-timeline-multiplier select");
        //
        // multiplierEl.value = this.model.multiplier.toString();
        // multiplierEl.addEventListener("change", (e) => {
        //     this.model.multiplier = Math.sign(this.model.multiplier) * Number(e.target.value);
        // });
        this.setVisibility(true);
        return this;
    }
    setVisibility(visibility) {
        if (visibility !== this._visibility) {
            this._visibility = visibility;
            if (this.el) {
                if (visibility) {
                    this.el.style.display = "block";
                }
                else {
                    this.el.style.display = "none";
                }
            }
            this.events.dispatch(this.events.visibility, visibility);
        }
    }
    reset() {
        this.model.stop();
        this.events.dispatch(this.events.reset, this.model);
    }
    play() {
        this.model.multiplier = Math.abs(this.model.multiplier);
        this.model.play();
        this.events.dispatch(this.events.play, this.model);
    }
    pause() {
        this.model.stop();
        this.events.dispatch(this.events.pause, this.model);
    }
    playBack() {
        this.model.multiplier = -1 * Math.abs(this.model.multiplier);
        this.model.play();
        this.events.dispatch(this.events.playback, this.model);
    }
    _zoom(pointerTime, pointerCenterOffsetX, dir) {
        let centerTime = this.model.rangeStartTime + 0.5 * this.model.range;
        let centerTimeOffset = (pointerTime - centerTime) * MILLISECONDS_TO_SECONDS;
        let rangeStart = addSeconds(this.model.rangeStart, centerTimeOffset), rangeEnd = addSeconds(this.model.rangeEnd, centerTimeOffset);
        let delta = ((rangeEnd.getTime() - rangeStart.getTime()) / 20) * MILLISECONDS_TO_SECONDS;
        let newRangeStart = addSeconds(rangeStart, delta * dir);
        let newRangeEnd = addSeconds(rangeEnd, -delta * dir);
        let msPx = (newRangeEnd.getTime() - newRangeStart.getTime()) / this.clientWidth;
        if (msPx < 31536000000 && msPx > 0.1) {
            let timeOffset = msPx * pointerCenterOffsetX * MILLISECONDS_TO_SECONDS;
            this.model.set(addSeconds(newRangeStart, timeOffset), addSeconds(newRangeEnd, timeOffset));
        }
    }
    get clientWidth() {
        return this._canvasEl ? this._canvasEl.width / this._canvasScale : 0;
    }
    get clientHeight() {
        return this._canvasEl ? this._canvasEl.height / this._canvasScale : 0;
    }
    _resize() {
        if (this._frameEl) {
            this._canvasEl.width = this._frameEl.clientWidth * this._canvasScale;
            this._canvasEl.height = this._frameEl.clientHeight * this._canvasScale;
            this._canvasEl.style.width = `${this._frameEl.clientWidth}px`;
            this._canvasEl.style.height = `${this._frameEl.clientHeight}px`;
        }
    }
    getOffsetByTime(milliseconds) {
        return (milliseconds - this.model.rangeStartTime) / this._millisecondsInPixel;
    }
    remove() {
        super.remove();
        this.model.stop();
    }
    _clearCanvas() {
        this._ctx.fillStyle = this.fillStyle;
        this._ctx.fillRect(0, 0, this.clientWidth * this._canvasScale, this.clientHeight * this._canvasScale);
    }
    _drawCurrent() {
        let curPosX = (this.model.currentTime - this.model.rangeStartTime) / this._millisecondsInPixel;
        if (this.model.current < this.model.rangeStart || this.model.current > this.model.rangeEnd) {
            this._currentEl.style.display = "none";
        }
        else {
            this._currentEl.style.display = "block";
            this._currentEl.style.transform = `translateX(${curPosX}px)`;
        }
    }
    draw() {
        this._millisecondsInPixel = (this.model.range / this.clientWidth);
        let minWidthMs = this._minWidth * this._millisecondsInPixel;
        let scaleData = getScale(minWidthMs * MILLISECONDS_TO_SECONDS);
        if (scaleData) {
            this._clearCanvas();
            let scaleMs = scaleData[0] * SECONDS_TO_MILLISECONDS, scalePx = scaleMs / this._millisecondsInPixel, segCount = scaleData[1];
            let originTime = getNearestTimeLeft(this.model.rangeStartTime, scaleMs);
            let showMilliseconds = scaleData[0] < 1.0, showTime = scaleData[0] < 86400.0;
            for (let i = originTime, rangeEnd = this.model.rangeEndTime + scaleMs; i < rangeEnd; i += scaleMs) {
                let x = this.getOffsetByTime(i);
                if (x >= 0 && x <= this.clientWidth * this._canvasScale) {
                    drawNotch(this._ctx, x * this._canvasScale, 10 * this._canvasScale, 2 * this._canvasScale, SCALE_NOTCH_COLOR);
                }
                for (let j = 1; j < segCount; j++) {
                    let xx = x + j * (scalePx / segCount);
                    if (xx >= 0 && xx <= this.clientWidth * this._canvasScale) {
                        drawNotch(this._ctx, xx * this._canvasScale, 5 * this._canvasScale, 1 * this._canvasScale, SCALE_NOTCH_COLOR);
                    }
                }
                drawText(this._ctx, dateToStr(new Date(i), showTime, showMilliseconds), x * this._canvasScale, 26 * this._canvasScale, "24px monospace", SCALE_TIME_COLOR, "center");
            }
            this._drawCurrent();
        }
    }
}

function addHours(date, hours) {
    const temp = new Date(date);
    temp.setHours(temp.getHours() + hours);
    return temp;
}
const ICON_BUTTON_SVG$2 = `<?xml version="1.0" encoding="utf-8"?>
<!-- Svg Vector Icons : http://www.onlinewebfonts.com/icon -->
    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 1000 1000" enable-background="new 0 0 1000 1000" xml:space="preserve">
    <metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>
    <g><path d="M500,10C229.4,10,10,229.4,10,500s219.4,490,490,490s490-219.4,490-490S770.6,10,500,10z M800.3,800.3c-39,39-84.5,69.7-135,91C613,913.5,557.4,924.7,500,924.7s-112.9-11.2-165.3-33.3c-50.5-21.3-95.9-52-135-91c-39-39-69.7-84.5-91-135C86.5,612.9,75.3,557.4,75.3,500s11.2-112.9,33.3-165.3c21.3-50.5,52-95.9,91-135c39-39,84.5-69.7,135-91C387.1,86.5,442.6,75.3,500,75.3s112.9,11.2,165.3,33.3c50.5,21.3,95.9,52,135,91c39,39,69.7,84.5,91,135c22.1,52.3,33.3,107.9,33.3,165.3s-11.2,112.9-33.3,165.3C869.9,715.8,839.3,761.2,800.3,800.3z"/><path d="M761.3,532.7H532.7V304c0-18.1-14.6-32.7-32.7-32.7s-32.7,14.6-32.7,32.7v261.3l0,0c0,18.1,14.6,32.7,32.7,32.7h261.3c18.1,0,32.7-14.6,32.7-32.7l0,0C794,547.3,779.4,532.7,761.3,532.7z"/></g>
</svg>`;
class TimelineControl extends Control {
    constructor(options = {}) {
        super({
            name: "timeline",
            ...options
        });
        let currentDate = options.current || new Date();
        let startDate = options.rangeStart || addHours(currentDate, -12);
        let endDate = options.rangeEnd || addHours(currentDate, 12);
        this._timelineView = new TimelineView({
            rangeStart: startDate,
            rangeEnd: endDate,
            currentDate: currentDate
        });
        this._toggleBtn = new ToggleButton({
            classList: ["og-map-button", "og-timeline_button"],
            icon: ICON_BUTTON_SVG$2
        });
        this._dialog = new Dialog({
            title: "Timeline",
            visible: false,
            resizable: true,
            useHide: true,
            top: 10,
            left: 60,
            width: 600,
            height: 115,
            minHeight: 115,
            maxHeight: 110
        });
        this._dialog.events.on("visibility", (v) => {
            this._toggleBtn.setActive(v);
        });
    }
    oninit() {
        let $container = this.renderer.div;
        this._toggleBtn.appendTo($container);
        this._dialog.appendTo($container);
        this._toggleBtn.events.on("change", (isActive) => {
            this._dialog.setVisibility(isActive);
            if (isActive) {
                this._timelineView.resize();
            }
        });
        this._timelineView.appendTo(this._dialog.container);
        this._timelineView.events.on("setcurrent", (d) => {
            this.renderer && this.renderer.handler.defaultClock.setDate(d);
        });
        this._timelineView.events.on("startdrag", () => {
            this.renderer && this.renderer.controls.mouseNavigation.deactivate();
        });
        this._timelineView.events.on("stopdrag", () => {
            this.renderer && this.renderer.controls.mouseNavigation.activate();
        });
        this._timelineView.events.on("startdragcurrent", () => {
            this.renderer && this.renderer.controls.mouseNavigation.deactivate();
        });
        this._timelineView.events.on("stopdragcurrent", () => {
            this.renderer && this.renderer.controls.mouseNavigation.activate();
        });
    }
}

class Deferred {
    constructor() {
        this.resolve = () => {
        };
        this.reject = () => {
        };
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
        Object.freeze(this);
    }
}

const DEFAULT_WARNING_HEIGHT_LEVEL = 5;
const ELEVATIONPROFILE_EVENTS = ["startcollecting", "profilecollected", "clear"];
/**
 * Point types
 */
const SAFE = 0;
const WARNING = 1;
const COLLISION = 2;
/**
 * drawData index names
 */
const TRACK = 0;
const GROUND = 1;
const SEGMMENT_LENGTH = 1.0; // Distance between query points on the ground
const GROUND_OFFSET = 1.0; // Ground level offset
const BOTTOM_PADDING = 0.1; // Range minY padding in percentage from the bottom
const TOP_PADDING = 0.2; // Range maxY padding in percentage from the top
const HEIGHT_EPS = 0.1; // Warning height level error
class ElevationProfile {
    constructor(options = {}) {
        this.events = createEvents(ELEVATIONPROFILE_EVENTS);
        this.planet = options.planet || null;
        this._warningHeightLevel = DEFAULT_WARNING_HEIGHT_LEVEL;
        this._pointsReady = false;
        this._isWarning = false;
        this._minX = 0;
        this._planeDistance = this._maxX = 1000;
        this._minY = 0;
        this._maxY = 200;
        this._drawData = [[], []];
        this._promiseArr = [];
        this._promiseCounter = 0;
        this._pMaxY = 0;
        this._pMinY = 0;
        this._pDist = 0;
        this._pTrackCoords = [];
        this._pGroundCoords = [];
        this._pIndex = 0;
    }
    bindPlanet(planet) {
        this.planet = planet;
    }
    setWarningHeightLevel(warningHeight = 0) {
        this._warningHeightLevel = warningHeight;
    }
    setRange(minX, maxX, minY, maxY) {
        this._minX = minX;
        this._maxX = maxX;
        if (minY) {
            this._minY = minY;
        }
        if (maxY) {
            this._maxY = maxY;
        }
    }
    _getHeightAsync(ll, pIndex, promiseCounter) {
        let def = new Deferred();
        if (this.planet) {
            let msl = this.planet.terrain.geoid.getHeightLonLat(ll);
            this.planet.terrain.getHeightAsync(ll, (elv) => {
                if (this.planet && promiseCounter === this._promiseCounter) {
                    elv += msl;
                    this._pGroundCoords[pIndex][1] = elv;
                    this._pGroundCoords[pIndex][2] = SAFE;
                    this._pGroundCoords[pIndex][3] = ll.height;
                    if (elv > this._pMaxY)
                        this._pMaxY = elv;
                    if (elv < this._pMinY)
                        this._pMinY = elv;
                    this._updatePointType(pIndex);
                    def.resolve(elv);
                }
                else {
                    def.reject();
                }
            });
        }
        else {
            def.reject();
        }
        return def.promise;
    }
    _collectCoordsBetweenTwoTrackPoints(index, internalPoints, scaleFactor, p0, trackDir, promiseCounter) {
        if (!this.planet)
            return;
        for (let j = 1; j <= internalPoints; j++) {
            this._pDist += SEGMMENT_LENGTH;
            this._pIndex++;
            // Point on the track segment
            let dirSegLen = j * scaleFactor;
            let pjd = p0.add(trackDir.scaleTo(dirSegLen));
            let llx = this.planet.ellipsoid.cartesianToLonLat(pjd);
            this._pGroundCoords[this._pIndex] = [this._pDist, 0, SAFE, 0, index];
            ((lonlat, index) => {
                this._promiseArr.push(this._getHeightAsync(lonlat, index, promiseCounter));
            })(llx, this._pIndex);
        }
    }
    _collectAllPoints(pointsLonLat, promiseCounter) {
        if (!this.planet)
            return;
        if (promiseCounter !== this._promiseCounter)
            return;
        let p0 = new Vec3(), p1 = new Vec3();
        for (let i = 1, len = pointsLonLat.length; i < len; i++) {
            let lonlat0 = pointsLonLat[i - 1], lonlat1 = pointsLonLat[i];
            this.planet.ellipsoid.lonLatToCartesianRes(lonlat0, p0);
            this.planet.ellipsoid.lonLatToCartesianRes(lonlat1, p1);
            let trackDir = p1.sub(p0);
            let dirLength = trackDir.length();
            let n0 = this.planet.ellipsoid.getSurfaceNormal3v(p0);
            let proj = Vec3.proj_b_to_plane(trackDir, n0);
            let projLen = proj.length();
            let internalPoints = Math.floor(projLen / SEGMMENT_LENGTH);
            let scaleFactor = SEGMMENT_LENGTH * dirLength / projLen;
            this._getGroundElevation(lonlat0, i - 1, promiseCounter);
            proj.normalize();
            trackDir.normalize();
            // Getting internal point elevations and looking for the collisions
            this._collectCoordsBetweenTwoTrackPoints(i - 1, internalPoints, scaleFactor, p0, trackDir, promiseCounter);
            this._pDist += projLen - internalPoints * SEGMMENT_LENGTH;
            this._pIndex++;
            let elv = lonlat1.height;
            if (elv > this._pMaxY)
                this._pMaxY = elv;
            if (elv < this._pMinY)
                this._pMinY = elv;
            this._pTrackCoords[i] = [this._pDist, elv, this._pIndex];
        }
    }
    _getGroundElevation(lonLat, index, promiseCounter) {
        this._pGroundCoords[this._pIndex] = [this._pDist, 0, SAFE, 0, index];
        this._promiseArr.push(this._getHeightAsync(lonLat, this._pIndex, promiseCounter));
    }
    _calcPointsAsync(pointsLonLat, promiseCounter) {
        return new Promise((resolve, reject) => {
            this._pTrackCoords = [[0, pointsLonLat[0].height, 0]];
            this._pMaxY = pointsLonLat[0].height;
            this._pMinY = this._pMaxY;
            this._pDist = 0;
            this._pGroundCoords = [];
            this._pIndex = 0;
            this._promiseArr = [];
            this._collectAllPoints(pointsLonLat, promiseCounter);
            this._getGroundElevation(pointsLonLat[pointsLonLat.length - 1], pointsLonLat.length - 1, promiseCounter);
            Promise.all(this._promiseArr).then(() => {
                resolve({
                    dist: this._pDist,
                    minY: this._pMinY,
                    maxY: this._pMaxY,
                    trackCoords: this._pTrackCoords,
                    groundCoords: this._pGroundCoords
                });
            });
        });
    }
    get minX() {
        return this._minX;
    }
    get planeDistance() {
        return this._planeDistance;
    }
    get maxX() {
        return this._maxX;
    }
    get minY() {
        return this._minY;
    }
    get maxY() {
        return this._maxY;
    }
    get pointsReady() {
        return this._pointsReady;
    }
    get isWarningOrCollision() {
        return this._isWarning;
    }
    get drawData() {
        return this._drawData;
    }
    collectProfile(pointsLonLat) {
        let def = new Deferred();
        if (!this.planet)
            def.reject();
        this._pointsReady = false;
        this._isWarning = false;
        if (!pointsLonLat || !pointsLonLat.length) {
            def.reject();
            return def.promise;
        }
        this.events.dispatch(this.events.startcollecting, this);
        this._promiseCounter++;
        ((counter) => {
            this._calcPointsAsync(pointsLonLat, counter).then((p) => {
                if (counter === this._promiseCounter) {
                    this._planeDistance = p.dist;
                    this.setRange(0, p.dist, p.minY - BOTTOM_PADDING * Math.abs(p.minY), p.maxY + Math.abs(p.maxY) * TOP_PADDING);
                    this._pointsReady = true;
                    this._drawData = [p.trackCoords, p.groundCoords];
                    this.events.dispatch(this.events.profilecollected, this._drawData, this);
                    def.resolve(this._drawData);
                }
            });
        })(this._promiseCounter);
        return def.promise;
    }
    _updatePointType(pIndex) {
        if ((this._pGroundCoords[pIndex][3] >= this._pGroundCoords[pIndex][1]) &&
            (this._pGroundCoords[pIndex][3] < this._pGroundCoords[pIndex][1] + this._warningHeightLevel - HEIGHT_EPS)) {
            this._pGroundCoords[pIndex][2] = WARNING;
        }
        if (this._pGroundCoords[pIndex][3] <= this._pGroundCoords[pIndex][1] + GROUND_OFFSET) {
            this._pGroundCoords[pIndex][2] = COLLISION;
        }
        if (this._pGroundCoords[pIndex][2] === WARNING || this._pGroundCoords[pIndex][2] === COLLISION) {
            this._isWarning = true;
        }
    }
    /**
     * @deprecated
     */
    _setPointsType() {
        this._isWarning = false;
        this._pTrackCoords = this._drawData[TRACK];
        this._pGroundCoords = this._drawData[GROUND];
        for (let i = 0; i < this._pGroundCoords.length; i++) {
            this._updatePointType(i);
        }
        this._drawData[GROUND] = this._pGroundCoords;
        this.events.dispatch(this.events.profilecollected, this._drawData, this);
    }
    clear() {
        this._promiseCounter = 0;
        this._pointsReady = false;
        this._isWarning = false;
        this._drawData = [[], []];
        this._pMaxY = 0;
        this._pMinY = 0;
        this._pDist = 0;
        this._pTrackCoords = [];
        this._pGroundCoords = [];
        this._pIndex = 0;
        this.events.dispatch(this.events.clear, this._drawData, this);
    }
}

const FILL_COLOR = "rgb(63, 63, 63)";
const TRACK_COLOR = "rgb(0, 255, 50)";
const TERRAIN_COLOR = "rgb(198, 198, 198)";
const TERRAIN_FILL_COLOR = "rgb(64, 68, 82)";
const WARNING_COLOR = "rgb(255, 255, 0)";
const COLLISION_COLOR = "rgb(255, 0, 0)";
const LINE_COLORS = [TERRAIN_COLOR, WARNING_COLOR, COLLISION_COLOR];
const TERRAIN_ALPHA = 0.5;
const LINE_WIDTH = 5;
const ELEVATIONPROFILEVIEW_EVENTS = ["startdrag", "stopdrag", "pointer", "mouseenter", "mouseleave", "dblclick", "tracklength", "groundlength", "warninglength", "collisionlength"];
const TEMPLATE$5 = `<div class="og-elevationprofile">
      <div class="og-elevationprofile-loading" style="display: none;">
        <div class="loadingio-spinner-bars-r354qqyl5v">
          <div class="ldio-p0v5a1f6oz">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
          </div>
        </div> 
      </div>     
    </div>`;
class ElevationProfileView extends View {
    constructor(options = {}) {
        super({
            template: TEMPLATE$5,
            model: new ElevationProfile()
        });
        this._onMouseDblClick = (e) => {
            //
            // @todo: The same code as in the pointer mouse move
            //
            let rect = this.$canvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let pointerDistance = this._leftDistance + (this._rightDistance - this._leftDistance) * x / this.clientWidth;
            let groundData = this.model.drawData[1];
            let trackData = this.model.drawData[0];
            let groundPoiIndex;
            if (pointerDistance < 0) {
                groundPoiIndex = 1;
                pointerDistance = 0;
                x = (0 - this._leftDistance) * this.clientWidth / (this._rightDistance - this._leftDistance);
            }
            else if (pointerDistance > this.model.planeDistance) {
                groundPoiIndex = groundData.length - 1;
                pointerDistance = this.model.planeDistance;
                x = (pointerDistance - this._leftDistance) * this.clientWidth / (this._rightDistance - this._leftDistance);
            }
            else {
                groundPoiIndex = -1 - binarySearch(groundData, pointerDistance, (a, b) => {
                    return a - b[0];
                });
            }
            // Ground point
            let gp0 = groundData[groundPoiIndex - 1], gp1 = groundData[groundPoiIndex];
            let d = (pointerDistance - gp0[0]) / (gp1[0] - gp0[0]);
            let groundElv = gp0[1] + d * (gp1[1] - gp0[1]);
            // track point
            let trackPoiIndex = gp0[4];
            let tp0 = trackData[trackPoiIndex], tp1 = trackData[trackPoiIndex + 1];
            d = (pointerDistance - tp0[0]) / (tp1[0] - tp0[0]);
            let trackElv = tp0[1] + d * (tp1[1] - tp0[1]);
            this.events.dispatch(this.events.dblclick, pointerDistance, tp0, tp1, gp0, gp1, trackPoiIndex, groundPoiIndex - 1, trackElv - groundElv);
        };
        this._onMouseEnter = (e) => {
            this._isMouseOver = true;
            this.events.dispatch(this.events.mouseenter, e);
        };
        this._onMouseOut = (e) => {
            this._isMouseOver = false;
            this.events.dispatch(this.events.mouseleave, e);
        };
        this._onMouseDown = (e) => {
            if (this._isMouseOver) {
                this._isDragging = true;
                document.body.classList.add("og-timeline-unselectable");
                this._clickPosX = e.clientX;
                if (!this._customFrame) {
                    this._leftDistance = this.model.minX;
                    this._rightDistance = this.model.maxX;
                }
                this._clickLeftDistance = this._leftDistance;
                this._clickRightDistance = this._rightDistance;
                this.events.dispatch(this.events.startdrag, e);
            }
        };
        this._onMouseUp = (e) => {
            if (this._isDragging) {
                this._isDragging = false;
                document.body.classList.remove("og-timeline-unselectable");
                this.events.dispatch(this.events.stopdrag, e);
            }
        };
        this._onCanvasMouseMove = (e) => {
            if (this.model.pointsReady) {
                if (!this._isDragging) {
                    if (!this._customFrame) {
                        this._leftDistance = this.model.minX;
                        this._rightDistance = this.model.maxX;
                    }
                    let rect = this.$pointerCanvas.getBoundingClientRect();
                    let x = e.clientX - rect.left;
                    this.redrawPointerCanvas(x);
                }
                else {
                    this.clearPointerCanvas();
                }
            }
        };
        this._onMouseMove = (e) => {
            if (this._isDragging && this.model.pointsReady) {
                let offset = (this._clickPosX - e.clientX);
                let distanceOffset = offset * this._canvasScale / this._pixelsInMeter_x;
                this.setFrame(this._clickLeftDistance + distanceOffset, this._clickRightDistance + distanceOffset);
            }
        };
        this._onMouseWheelFF = (e) => {
            this._onMouseWheel(e);
        };
        this._onMouseWheel = (e) => {
            if (this._isMouseOver && this.model.pointsReady) {
                if (!this._customFrame) {
                    this._leftDistance = this.model.minX;
                    this._rightDistance = this.model.maxX;
                }
                this._customFrame = true;
                let padDist = Math.sign(e.wheelDelta) * (this._rightDistance - this._leftDistance) / 20;
                let rect = this.$canvas.getBoundingClientRect();
                let pointerPosX = e.clientX - rect.left, pointerCenterOffsetX = pointerPosX - this.$canvas.clientWidth * 0.5;
                let distanceCenterOffsetX = pointerCenterOffsetX * this._canvasScale / this._pixelsInMeter_x;
                // Move distance under pointer to a screen center
                let leftDistance = distanceCenterOffsetX + this._leftDistance + padDist;
                let rightDistance = distanceCenterOffsetX + this._rightDistance - padDist;
                // move center back to the mouse pointer
                distanceCenterOffsetX = -pointerCenterOffsetX * (rightDistance - leftDistance) / this.clientWidth;
                this.setFrame(leftDistance + distanceCenterOffsetX, rightDistance + distanceCenterOffsetX);
                this.redrawPointerCanvas(pointerPosX);
            }
        };
        //@ts-ignore
        this.events = this.events.registerNames(ELEVATIONPROFILEVIEW_EVENTS);
        this.fillStyle = options.fillStyle || FILL_COLOR;
        this._customFrame = false;
        this._leftDistance = 0;
        this._rightDistance = 0;
        this._pixelsInMeter_x = 0;
        this._pixelsInMeter_y = 0;
        this._canvasScale = 2;
        this.$canvas = document.createElement("canvas");
        this.$canvas.style.position = "absolute";
        this._ctx = this.$canvas.getContext('2d');
        this.$pointerCanvas = document.createElement("canvas");
        this.$pointerCanvas.style.pointerEvents = "none";
        this.$pointerCanvas.style.position = "absolute";
        this._pointerCtx = this.$pointerCanvas.getContext('2d');
        this.$loading = null;
        this._isMouseOver = false;
        this._isDragging = false;
        this._clickPosX = 0;
        this._clickLeftDistance = 0;
        this._clickRightDistance = 0;
        this._timeStartHandler = 0;
        this._onResizeObserver_ = this._onResizeObserver.bind(this);
        this._resizeObserver = new ResizeObserver(this._onResizeObserver_);
    }
    _onResizeObserver() {
        this.resize();
    }
    get canvasScale() {
        return this._canvasScale;
    }
    set canvasScale(scale) {
        if (scale !== this._canvasScale) {
            this._canvasScale = scale;
            this.resize();
        }
    }
    resize() {
        this._resize();
        this.draw();
    }
    render() {
        super.render();
        this._resizeObserver.observe(this.el);
        this.el.appendChild(this.$canvas);
        this.el.appendChild(this.$pointerCanvas);
        this.model.events.on("profilecollected", (data) => {
            this._hideLoading();
            this.clearPointerCanvas();
            this.draw();
        });
        this.model.events.on("startcollecting", () => {
            clearTimeout(this._timeStartHandler);
            //@ts-ignore
            this._timeStartHandler = setTimeout(() => {
                this._showLoading();
            }, 450);
        });
        this.model.events.on("clear", () => {
            this._customFrame = false;
            this._leftDistance = 0;
            this.clearCanvas();
            this.clearPointerCanvas();
        });
        this.$loading = this.select(".og-elevationprofile-loading");
        this.$canvas.addEventListener("mouseenter", this._onMouseEnter);
        this.$canvas.addEventListener("mouseout", this._onMouseOut);
        this.$canvas.addEventListener("dblclick", this._onMouseDblClick);
        this.$canvas.addEventListener("mousemove", this._onCanvasMouseMove);
        document.body.addEventListener("mousemove", this._onMouseMove);
        document.body.addEventListener("mousedown", this._onMouseDown);
        document.body.addEventListener("mouseup", this._onMouseUp);
        document.body.addEventListener("wheel", this._onMouseWheelFF);
        return this;
    }
    _hideLoading() {
        clearTimeout(this._timeStartHandler);
        this.$loading.style.display = "none";
    }
    _showLoading() {
        this.$loading.style.display = "flex";
    }
    redrawPointerCanvas(x) {
        this.clearPointerCanvas();
        let pointerDistance = this._leftDistance + (this._rightDistance - this._leftDistance) * x / this.clientWidth;
        let groundData = this.model.drawData[1];
        let trackData = this.model.drawData[0];
        let groundPoiIndex;
        if (pointerDistance < 0) {
            groundPoiIndex = 1;
            pointerDistance = 0;
            x = (0 - this._leftDistance) * this.clientWidth / (this._rightDistance - this._leftDistance);
        }
        else if (pointerDistance > this.model.planeDistance) {
            groundPoiIndex = groundData.length - 1;
            pointerDistance = this.model.planeDistance;
            x = (pointerDistance - this._leftDistance) * this.clientWidth / (this._rightDistance - this._leftDistance);
        }
        else {
            groundPoiIndex = -1 - binarySearch(groundData, pointerDistance, (a, b) => {
                return a - b[0];
            });
        }
        // Ground point
        let gp0 = groundData[groundPoiIndex - 1], gp1 = groundData[groundPoiIndex];
        let d = (pointerDistance - gp0[0]) / (gp1[0] - gp0[0]);
        let groundElv = gp0[1] + d * (gp1[1] - gp0[1]);
        // track point
        let trackPoiIndex = gp0[4];
        let tp0 = trackData[trackPoiIndex], tp1 = trackData[trackPoiIndex + 1];
        d = (pointerDistance - tp0[0]) / (tp1[0] - tp0[0]);
        let trackElv = tp0[1] + d * (tp1[1] - tp0[1]);
        let trackY = (this.model.maxY - trackElv) * this._pixelsInMeter_y;
        let groundY = (this.model.maxY - groundElv) * this._pixelsInMeter_y;
        this.events.dispatch(this.events.pointer, pointerDistance, tp0, tp1, gp0, gp1, trackPoiIndex, groundPoiIndex - 1, trackElv - groundElv);
        let ctx = this._pointerCtx;
        // Vertical grey line
        ctx.lineWidth = 3;
        ctx.strokeStyle = "rgba(64,64,64,0.6)";
        ctx.beginPath();
        ctx.moveTo(x * this._canvasScale, 0);
        ctx.lineTo(x * this._canvasScale, this.clientHeight * this._canvasScale);
        ctx.stroke();
        // Ground point
        ctx.beginPath();
        ctx.arc(x * this._canvasScale, groundY, 4, 0, 2 * Math.PI, false);
        ctx.fillStyle = '#FFB277';
        ctx.fill();
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#FFB277';
        ctx.stroke();
        // Track point
        ctx.beginPath();
        ctx.arc(x * this._canvasScale, trackY, 4, 0, 2 * Math.PI, false);
        ctx.fillStyle = '#FFB277';
        ctx.fill();
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#FFB277';
        ctx.stroke();
        // Vertical white line
        ctx.lineWidth = 3;
        ctx.strokeStyle = "#FFB277";
        ctx.beginPath();
        ctx.moveTo(x * this._canvasScale, groundY);
        ctx.lineTo(x * this._canvasScale, trackY);
        ctx.stroke();
        // Altitude label
        ctx.fillStyle = "white";
        ctx.font = `${28 / devicePixelRatio}px Arial`;
        ctx.textBaseline = "middle";
        ctx.textAlign = "left";
        ctx.fillText(`${Math.round(trackElv - groundElv).toString()} m`, (x + 5) * this._canvasScale, groundY + (trackY - groundY) * 0.5);
        // distance from the begining label
        ctx.fillStyle = "white";
        ctx.font = `${28 / devicePixelRatio}px Arial`;
        ctx.textAlign = "right";
        let distStr = distanceFormatExt(pointerDistance);
        ctx.fillText(`${distStr[0]} ${distStr[1]}`, (x - 5) * this._canvasScale, (this.clientHeight - 7) * this._canvasScale);
    }
    get clientWidth() {
        return this.$canvas ? this.$canvas.width / this._canvasScale : 0;
    }
    get clientHeight() {
        return this.$canvas ? this.$canvas.height / this._canvasScale : 0;
    }
    _resize() {
        if (this.el) {
            this.$canvas.width = this.el.clientWidth * this._canvasScale;
            this.$canvas.height = this.el.clientHeight * this._canvasScale;
            this.$canvas.style.width = `${this.el.clientWidth}px`;
            this.$canvas.style.height = `${this.el.clientHeight}px`;
            this.$pointerCanvas.width = this.el.clientWidth * this._canvasScale;
            this.$pointerCanvas.height = this.el.clientHeight * this._canvasScale;
            this.$pointerCanvas.style.width = `${this.el.clientWidth}px`;
            this.$pointerCanvas.style.height = `${this.el.clientHeight}px`;
            if (this._customFrame) {
                this._pixelsInMeter_x = this._canvasScale * this.clientWidth / (this._rightDistance - this._leftDistance);
            }
        }
    }
    clearPointerCanvas() {
        this._pointerCtx.fillStyle = "rgba(0,0,0,0)";
        this._pointerCtx.clearRect(0, 0, this.clientWidth * this._canvasScale, this.clientHeight * this._canvasScale);
    }
    clearCanvas() {
        const grd = this._ctx.createLinearGradient(0, 0, 0, this.clientHeight * this._canvasScale);
        grd.addColorStop(0, "black");
        grd.addColorStop(1, this.fillStyle);
        this._ctx.fillStyle = grd;
        this._ctx.fillRect(0, 0, this.clientWidth * this._canvasScale, this.clientHeight * this._canvasScale);
    }
    setFrame(leftDistance, rightDistance) {
        this._leftDistance = leftDistance;
        this._rightDistance = rightDistance;
        this._customFrame = true;
        this._pixelsInMeter_x = this._canvasScale * this.clientWidth / (this._rightDistance - this._leftDistance);
        this.model.setRange(leftDistance, rightDistance);
        this.draw();
    }
    _updateUnits() {
        if (!this._customFrame) {
            this._pixelsInMeter_x = this._canvasScale * this.clientWidth / (this.model.maxX - this.model.minX);
        }
        this._pixelsInMeter_y = this._canvasScale * this.clientHeight / (this.model.maxY - this.model.minY);
    }
    clear() {
        this.model.clear();
        this.clearCanvas();
    }
    draw() {
        let trackCoords = this.model.drawData[0];
        if (trackCoords.length > 1) {
            this._updateUnits();
            this.clearCanvas();
            let groundCoords = this.model.drawData[1];
            this._drawTrack(trackCoords, groundCoords);
            this._drawTerrain(groundCoords);
            this._drawWarningAndCollision(groundCoords);
            this._drawLabels(trackCoords, groundCoords);
        }
        else {
            this.clearCanvas();
        }
    }
    _drawLabels(coords, groundCoords) {
        let ctx = this._ctx;
        if (ctx) {
            let p0 = coords[0];
            const maxY = this.model.maxY;
            let x = (-this._leftDistance + p0[0]) * this._pixelsInMeter_x, yt = (maxY - p0[1]) * this._pixelsInMeter_y; (maxY - groundCoords[p0[2]][1]) * this._pixelsInMeter_y;
            // Track points
            ctx.beginPath();
            ctx.fillStyle = '#F7F718';
            ctx.fillRect(x - 4, yt - 4, 8, 8);
            ctx.stroke();
            // Alt label
            ctx.fillStyle = "white";
            ctx.font = `${26 / devicePixelRatio}px Arial`;
            ctx.textBaseline = "bottom";
            ctx.textAlign = "left";
            ctx.fillText(`${Math.round(p0[1] - groundCoords[p0[2]][1]).toString()} m`, x + 1, yt - 10);
            ctx.stroke();
            for (let i = 1, len = coords.length; i < len; i++) {
                let pi = coords[i];
                x = (-this._leftDistance + pi[0]) * this._pixelsInMeter_x;
                yt = (maxY - pi[1]) * this._pixelsInMeter_y;
                (maxY - groundCoords[pi[2]][1]) * this._pixelsInMeter_y;
                // Track points
                ctx.beginPath();
                ctx.fillStyle = '#F7F718';
                ctx.fillRect(x - 4, yt - 4, 8, 8);
                ctx.stroke();
                // Alt label
                ctx.fillStyle = "white";
                ctx.fillText(`${Math.round(pi[1] - groundCoords[pi[2]][1]).toString()} m`, x + 1, yt - 10);
                ctx.stroke();
            }
        }
    }
    _drawTrack(coords, groundCoords) {
        let p0 = coords[0];
        let ctx = this._ctx;
        if (ctx) {
            const maxY = this.model.maxY;
            ctx.lineWidth = LINE_WIDTH;
            ctx.strokeStyle = TRACK_COLOR;
            ctx.beginPath();
            ctx.moveTo((-this._leftDistance + p0[0]) * this._pixelsInMeter_x, (maxY - p0[1]) * this._pixelsInMeter_y);
            let trackLength = 0;
            for (let i = 1, len = coords.length; i < len; i++) {
                let pi = coords[i];
                ctx.lineTo((-this._leftDistance + pi[0]) * this._pixelsInMeter_x, (maxY - pi[1]) * this._pixelsInMeter_y);
                let prevP = coords[i - 1];
                let a = pi[0] - prevP[0], b = pi[1] - prevP[1], aa = a * a, bb = b * b;
                trackLength += Math.sqrt(aa + bb);
            }
            ctx.stroke();
            // Track points lines
            ctx.lineWidth = 2;
            ctx.strokeStyle = "rgba(255,255,255,0.7)";
            ctx.beginPath();
            let x = (-this._leftDistance + p0[0]) * this._pixelsInMeter_x, yt = (maxY - p0[1]) * this._pixelsInMeter_y, yg = (maxY - groundCoords[p0[2]][1]) * this._pixelsInMeter_y;
            ctx.moveTo(x, yt);
            ctx.lineTo(x, yg);
            for (let i = 1, len = coords.length; i < len; i++) {
                let pi = coords[i];
                x = (-this._leftDistance + pi[0]) * this._pixelsInMeter_x;
                yt = (maxY - pi[1]) * this._pixelsInMeter_y;
                yg = (maxY - groundCoords[pi[2]][1]) * this._pixelsInMeter_y;
                ctx.strokeStyle = "rgba(255,255,255,0.7)";
                ctx.moveTo(x, yt);
                ctx.lineTo(x, yg);
            }
            ctx.stroke();
            this.events.dispatch(this.events.tracklength, trackLength);
        }
    }
    _drawTerrain(coords) {
        let p0 = coords[0];
        let ctx = this._ctx;
        if (ctx) {
            const maxY = this.model.maxY;
            ctx.lineWidth = LINE_WIDTH;
            ctx.strokeStyle = TERRAIN_COLOR;
            ctx.beginPath();
            ctx.moveTo((-this._leftDistance + p0[0]) * this._pixelsInMeter_x, this.$canvas.height);
            ctx.lineTo((-this._leftDistance + p0[0]) * this._pixelsInMeter_x, (maxY - p0[1]) * this._pixelsInMeter_y);
            let groundLength = 0;
            for (let i = 1, len = coords.length; i < len; i++) {
                let pi = coords[i];
                ctx.lineTo((-this._leftDistance + pi[0]) * this._pixelsInMeter_x, (maxY - pi[1]) * this._pixelsInMeter_y);
                let prevP = coords[i - 1];
                let a = pi[0] - prevP[0], b = pi[1] - prevP[1], aa = a * a, bb = b * b;
                groundLength += Math.sqrt(aa + bb);
            }
            ctx.lineTo((-this._leftDistance + coords[coords.length - 1][0]) * this._pixelsInMeter_x, this.$canvas.height);
            ctx.closePath();
            ctx.stroke();
            ctx.save();
            ctx.fillStyle = TERRAIN_FILL_COLOR;
            ctx.globalAlpha = TERRAIN_ALPHA;
            ctx.fill();
            ctx.restore();
            ctx.globalAlpha = 1;
            this.events.dispatch(this.events.groundlength, groundLength);
        }
    }
    _drawWarningAndCollision(coords) {
        let ctx = this._ctx;
        if (ctx && coords.length > 1) {
            let maxY = this.model.maxY;
            ctx.lineWidth = LINE_WIDTH;
            ctx.beginPath();
            let warningLength = 0, collisionLength = 0;
            for (let i = 0, len = coords.length - 1; i < len; i++) {
                let pi0 = coords[i], pi1 = coords[i + 1];
                if (pi0[2] !== SAFE && pi1[2] !== SAFE) {
                    let a = pi1[0] - pi0[0], b = pi1[1] - pi0[1], aa = a * a, bb = b * b;
                    if (pi0[2] === COLLISION) {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.strokeStyle = LINE_COLORS[COLLISION];
                        collisionLength += Math.sqrt(aa + bb);
                    }
                    else if (pi0[2] === WARNING) {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.strokeStyle = LINE_COLORS[WARNING];
                        warningLength += Math.sqrt(aa + bb);
                    }
                    ctx.moveTo((-this._leftDistance + pi0[0]) * this._pixelsInMeter_x, (maxY - pi0[1]) * this._pixelsInMeter_y);
                    ctx.lineTo((-this._leftDistance + pi1[0]) * this._pixelsInMeter_x, (maxY - pi1[1]) * this._pixelsInMeter_y);
                }
            }
            ctx.stroke();
            this.events.dispatch(this.events.warninglength, warningLength);
            this.events.dispatch(this.events.collisionlength, collisionLength);
        }
    }
}

let groundObj3d = Object3d.createCylinder(0.33, 0, 1.0, 20, 1, true, false, 0, 0, 0);
let headObj3d = Object3d.createCylinder(0.33, 0.33, 1.1, 20, 1, true, true, 0, -0.55, 0);
const POINTER_RAY_OPTIONS = {
    startPosition: new Vec3(),
    endPosition: new Vec3(),
    startColor: "rgba(255,131,0,0.2)",
    endColor: "rgba(255,131,0,1.0)",
    thickness: 2.7
};
const POINTER_BILLBOARD_OPTIONS = {
    src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjEuNBNAaMQAAAiLSURBVHhe7Z0r0BxFEMcjIhAIRERERAQCgUAgEBEIBAIRiUAgIiIQiAgEIlUREQgEIgIREYFAIBCIiAgEIiIiAoGIoHimqPAKz5CP/t23/8vcbe89d/dmZ/pf9avLdZK72e6+ee3M7Imjo6Opc8o4b7xn3DIeGEOJz+Y7+C6+k+/2yjQZXOMEOGdcNe4anv4wvjV+m73bT3wGn8VneqIMlIUyeWXNGteYKTj4feNrI9W/xi/HfxxVfCffnYqyUcbJJINrzIjTxjvGV0aqn43fj/+YhSgLZUpFmd81uAbv2rLANWbAC8ZHxp+GxC8ufZ+rKGNaI1FLcC1ck3etB8U1HhCqzk8N6T/jENV7X6LsXIN008iqeXCNB+B54zND+tt4ePzHIsS1cE0SicA1e74YFdc4IgyjrhvqTP3TvJas9Bq59oP2EVzjCJw03jI0TCMBcurUDS1qBCU9PnjbwCeerwbFNQ4MVd9tQ5pyG7+v0mvHJ6N3FF3jgFwy1JPvmlipUfIFvmHY6/luEFzjANDO0fGRfm1eQ0+UzlriqzOG58tecY0985LxnYH+al5D3ZKP8Bm+83zaG66xRy4a6uzU3NZvK/nqkUEH0fNtL7jGHqBH+4EhTWEGL2ddMwYZJbjGPaGgHxuIDA7tJ/mQGdLek8A17sHTxucGiva+P6kGxbf42PP9TrjGHUmDH1V+/xokCVzjDkTwx1HvSeAat4R2SWP8CP7wko9ZmrZ3n8A1bok6fBH88SRf4/u9ksA1bgFr4ZDG+qHxpLuKLFD1YrMRrnFDLhjocfMaGl8aIjLh5sVoLa5xA140+lhxG+pHNAk7TRu7xjXQ+9TK3Jru4ecqxYB7B88YXsw6cY1rUKcv7ujlI907YLbQi1knrnEFavej05ef1ClkpZUXOxfX2AH3p6Pdz1/E6FnDi2EL19iBVu3Gbd18pdgwU+jFsIVrdHjDQHGDJ39pkojm2ovlAq5xCXqWWtETmo7uG2t3L7vGJTTbF73+6UhNARtVvZjOcY0JZ42Y45+uGK2t7BC6xoQbBoqO3/SkGpt5Gy+2M1xjw3MGGZRubgxNS5qv6dxw4hob9OuPsf90pWnizlrANRpM+sSvvwypFqBGb8W6ZWjgHjOKtn/6Ug3OMv1WrFsG4ykjqv3yxGiudbdw4U2DbvjEuL8cqSZv7TJaeNOg1b2h8nTHWIj3whuDSQOUHmcSKkPagr5wNE0afLhioOj8lSc16QvTw2nwYfk8vlB5YjnfPOZp8FX9x8kd5Uqju3kzkCYAPUQU1X+5UjPACaatBEiPcAmVrfmKIQU/Jn/qEpNCs82lSgCOL0U/Na+hcvVD8/qKMU8AjiZDsdGjfCnGl415AnyCJVSVZptIlAD3sISqEgt9ZwnAHSIU07/1SMv7T5EA7CpFPzavofKljuA5EkCbPmICqB4p1m+SAPQGQ3XqMgnAQwtCdeo6CRBTwPXqJgnAKpFQnbpDAsQcQL26RwLEzt96dZ8ECFWsSIDKFQlQuSIBKlckQOUiAThLJlSnZqOAmAeoV7N5gJgJrFd3SQCePBGqU7dIgLgbWK9mdwO1ITRUn66QADoQIlYE1SPF+gIJEGsC69PCmkDOk0WxKrgeaQf4aRIA9AiYUD2a7wuA2BlUn1gKOE8A9ouj2BtYvh42r4z+5gnATlEUHcHy9X3z+poxT4A4H6Aecfxv63wAiOXh9ah1QgioHxAnhJYr1fKz9h/SBOA0aRSnhJUrJQCP/m0lAMQ5geWr85xA0I2haAbKk4b4K08KVTMQ08LlSU37vPqHNPgiVgiVK5r4hXgvvGm4aKC4PVyOFMuNnhfABEFMCpWnjZ8YAjxfBkUiTF/q/LH0rxXrlqFBJ4friVOh6Uod+oUHRYiWIYFnzaG4QzhdqefPo/+9GK9MAJ42SQ0QtcB0pV//wtAvxTUmqBaIiaHpSff9Z0fCduEaE+gLxBNEpyliRuzctl+4xiU0Ioh5gelIsfrQ8GI6xzUuwdjxgRGalojZacOL6RzX6KDNI0wmhPKWev6tWT8P19jBFwaKDmG+0pD9tnHS8OK4gGvsgDuFUQPkr7UdvxTXuAI9Wk7nzYfykX6clwwvdi6ucQ3MKqEYFeQjxYKFvRtV/cI1roG9hDpdNNYPHl6KAWc9re31L+MaN4DHzMUUcT4iFi8bXqxW4ho3RP2Bx81raHw9al557J8Xo7W4xi24ZqAYHYwv+XztbN8qXOMW0OFQpzBuG48n+XrrTt8yrnFLWELGViMUSTC85GN8Ptvftw+ucQcYGTD7hCIJhpN8y8rtrXv8Hq5xR7hpdNdAkQT9Sz7Fx70EH1zjHlAl6Z5BdAz7k3xJLdta2bsPrnFP0j5BzBXsL/mwlzZ/GdfYA/RMbxgo5gl2l3yHL/fq7XfhGnskfSpp3DvYXKmvZs/5HwrX2DOcP6QVRVqoGOqWfMSmnFcNz6e94RoH4IyhziGLFeMmUlv4RItv8RU+83zZK65xIGjDOH9AnZoYKj6RfIFvrhqDtPcernFg2KTwpSHVvMQsvXa2bnNus+ezwXCNI6DaQOPbGoeLumZ8gC9G+9WnuMYRYeOJdh+hGiaP0mvkiF584PlmFFzjAWAxgzqJqMRESK+Ja91pAUffuMYDwvGlaSJQTU65j0DZ0+aNaztveNd+EFxjBjB3QPWYOm9Kh1WkZeUa2KDJNXnXelBcY0bQPnKs2fIj7nOsFZbLRJkp+0Hb+HW4xgzhMGuqTubEl2sC9igcYpqZ71zeH0HZKCNlpczetWSFa8wcJQO7lrtONiUQ3xh9TDbxGXxWVxNEGSjLZIKe4honxlnjdYMFqnSyhhxB8Nl8B9/Fd/LdXpkmg2ssANpdfpEsXacdZq6BJ6Tya+VZyWnnUsLG3/Fv+Lf8H/4vn8FnZd2W78bRif8BxMOwtJg5Ph4AAAAASUVORK5CYII=",
    color: "rgb(255,131,0)",
    size: [8, 8]
};
const POINTER_LABEL_OPTIONS = {
    text: "",
    face: "arial",
    size: 10.5,
    color: "rgba(455,455,455,1.0)",
    outlineColor: "rgba(0,0,0,0.34)",
    outline: 0.23,
    align: "left",
    offset: [5, 15, -5]
};
const LABEL_OPTIONS = {
    face: "arial",
    text: "",
    size: 10.5,
    color: "rgba(455,455,455,1.0)",
    outlineColor: "rgba(0,0,0,0.34)",
    outline: 0.23,
    align: "right",
    offset: [-47, 25, 0]
};
const GROUND_POINTER_OPTIONS = {
    instanced: true,
    tag: "ground-pointer",
    color: "rgb(0,305,0)",
    object3d: groundObj3d
};
const HEAD_POINTER_OPTIONS = {
    instanced: true,
    tag: "head-pointer",
    color: "rgb(305,305,0)",
    object3d: headObj3d
};
class ElevationProfileScene extends RenderNode {
    constructor(options = {}) {
        super("ElevationProfileScene");
        this._onLClick = (e) => {
            let groundPos = this._planet.getCartesianFromPixelTerrain(e.pos);
            if (groundPos) {
                this.addGroundPoint3vAsync(groundPos);
            }
        };
        this._onMouseMove = (e) => {
            this._planet.getCartesianFromMouseTerrain();
            if (this._pickedGroundEntity) {
                let d = new Vec2(e.x, e.y).sub(this._startClickPos), p = this._startEntityPos.add(d);
                let groundCart = this._planet.getCartesianFromPixelTerrain(p);
                if (groundCart) {
                    this.setGroundPointCartesian3v(this._pickedGroundEntity.properties.index, groundCart);
                }
            }
            else if (this._pickedHeadEntity) {
                let cam = this._planet.camera;
                let p0 = this._pickedHeadEntity.properties.groundEntity.getCartesian();
                let groundNormal = this._planet.ellipsoid.getSurfaceNormal3v(p0);
                let p1 = p0.add(groundNormal);
                let p2 = p0.add(cam.getRight());
                let px = new Vec3();
                if (new Ray$1(cam.eye, e.direction).hitPlane(p0, p1, p2, px) === Ray$1.INSIDE) {
                    let h = Vec3.proj_b_to_a(px, p0);
                    let s = h.sub(p0).dot(p0);
                    let headPos = p0.add(groundNormal.scale(Math.sign(s) * h.distance(p0)));
                    this.setHeadPointCartesian3v(this._pickedHeadEntity.properties.index, headPos);
                }
            }
        };
        this._onLUp = (e) => {
        };
        this._onGroundPointerEnter = (e) => {
            e.renderer.handler.canvas.style.cursor = "pointer";
        };
        this._onGroundPointerLeave = (e) => {
            e.renderer.handler.canvas.style.cursor = "default";
        };
        this._onGroundPointerLDown = (e) => {
            this._clampToGround = false;
            this.renderer.controls.mouseNavigation.deactivate();
            this._pickedGroundEntity = e.pickingObject;
            const coords = this._pickedGroundEntity.getCartesian();
            this._startClickPos.set(e.x, e.y);
            this._startEntityPos = this._planet.getPixelFromCartesian(coords);
        };
        this._onGroundPointerLUp = (e) => {
            this._clampToGround = true;
            this.renderer.controls.mouseNavigation.activate();
            this._pickedGroundEntity = null;
        };
        this._onHeadPointerEnter = (e) => {
            e.renderer.handler.canvas.style.cursor = "pointer";
        };
        this._onHeadPointerLeave = (e) => {
            e.renderer.handler.canvas.style.cursor = "default";
        };
        this._onHeadPointerLDown = (e) => {
            this.renderer.controls.mouseNavigation.deactivate();
            this._pickedHeadEntity = e.pickingObject;
        };
        this._onHeadPointerLUp = (e) => {
            this.renderer.controls.mouseNavigation.activate();
            this._pickedHeadEntity = null;
        };
        this.events = createEvents(ELEVATIONPROFILESCENE_EVENTS);
        this._planet = options.planet || null;
        this._pickedGroundEntity = null;
        this._pickedHeadEntity = null;
        this._startClickPos = new Vec2();
        this._startEntityPos = new Vec2();
        this._clampToGround = true;
        this._trackLayer = new Vector("track", {
            entities: [],
            pickingEnabled: false,
            polygonOffsetUnits: -1.0,
            relativeToGround: true,
            hideInLayerSwitcher: true
        });
        this._groundPointersLayer = new Vector("ground-pointers", {
            entities: [],
            pickingEnabled: true,
            hideInLayerSwitcher: true,
            scaleByDistance: [1, 5000, 0.02],
            pickingScale: 1.5
        });
        this._headPointersLayer = new Vector("head-pointers", {
            entities: [],
            pickingEnabled: true,
            hideInLayerSwitcher: true,
            scaleByDistance: [1, 10000, 0.02],
            pickingScale: 1
        });
        this._columnPointersLayer = new Vector("column-pointers", {
            entities: [],
            pickingEnabled: false,
            hideInLayerSwitcher: true
        });
        this._trackEntity = new Entity({
            polyline: {
                path3v: [],
                thickness: 3.8,
                color: "rgba(0,305,0,0.8)",
                isClosed: false
            }
        });
        this._trackLayer = new Vector("column-pointers", {
            entities: [this._trackEntity],
            pickingEnabled: false,
            hideInLayerSwitcher: true
        });
        this._heightsLayer = new Vector("heights-labels", {
            entities: [],
            pickingEnabled: false,
            hideInLayerSwitcher: true
        });
        this._pointerHeadEntity = new Entity({
            cartesian: new Vec3(),
            billboard: POINTER_BILLBOARD_OPTIONS
        });
        this._pointerLabelEntity = new Entity({
            cartesian: new Vec3(),
            label: POINTER_LABEL_OPTIONS
        });
        this._pointerRayEntity = new Entity({
            cartesian: new Vec3(),
            ray: POINTER_RAY_OPTIONS
        });
        this._pointerLayer = new Vector("pointer", {
            entities: [this._pointerHeadEntity, this._pointerLabelEntity, this._pointerRayEntity],
            pickingEnabled: false,
            hideInLayerSwitcher: true
        });
    }
    flyExtent() {
        let entities = this._headPointersLayer.getEntities();
        let minLon = 180, minLat = 180, maxLon = -180, maxLat = -180, maxHeight = -1000000;
        if (entities.length > 1) {
            for (let i = 0; i < entities.length; i++) {
                let ll = entities[i].getLonLat();
                if (ll.lon < minLon)
                    minLon = ll.lon;
                if (ll.lat < minLat)
                    minLat = ll.lat;
                if (ll.lon > maxLon)
                    maxLon = ll.lon;
                if (ll.lat > maxLat)
                    maxLat = ll.lat;
                if (ll.height > maxHeight)
                    maxHeight = ll.height;
            }
            this._planet.camera.flyExtent(new Extent(new LonLat(minLon, minLat), new LonLat(maxLon, maxLat)), maxHeight, null, 0);
        }
    }
    get planet() {
        return this._planet;
    }
    _createGroundPointer(groundCart, altitude = 10) {
        let surfaceNormal = this.ellipsoid.getSurfaceNormal3v(groundCart);
        let headCart = groundCart.add(surfaceNormal.scale(altitude));
        let columnEntity = new Entity({
            ray: {
                startPosition: groundCart,
                endPosition: headCart,
                startColor: "rgba(255,255,255,0.2)",
                endColor: "rgba(355,355,355,1.0)",
                thickness: 3.2
            }
        });
        let groundEntity = new Entity({
            cartesian: groundCart,
            geoObject: GROUND_POINTER_OPTIONS,
        });
        let headEntity = new Entity({
            cartesian: headCart,
            geoObject: HEAD_POINTER_OPTIONS,
            properties: {}
        });
        let heightLabelEntity = new Entity({
            cartesian: headCart,
            label: LABEL_OPTIONS
        });
        heightLabelEntity.appendChild(new Entity({
            cartesian: headCart,
            label: { ...LABEL_OPTIONS, offset: [-47, 45, 0] }
        }));
        const index = this._groundPointersLayer.getEntities().length;
        columnEntity.properties =
            groundEntity.properties =
                headEntity.properties = {
                    index,
                    altitude: altitude,
                    lonLatEll: new LonLat(),
                    headEntity,
                    groundEntity,
                    columnEntity,
                    heightLabelEntity
                };
        return { headEntity, groundEntity, columnEntity, heightLabelEntity };
    }
    setPointerCartesian3v(p, height) {
        this._pointerLabelEntity.setCartesian3v(p);
        this._pointerLabelEntity.label.setText(`${Math.round(height).toString()} m`);
        this._pointerRayEntity.ray.setEndPosition3v(p);
        let n = this._planet.ellipsoid.getSurfaceNormal3v(p);
        this._pointerRayEntity.ray.setStartPosition3v(p.add(n.scale(-height)));
        this._pointerHeadEntity.setCartesian3v(p);
    }
    bindPlanet(planet) {
        this._planet = planet;
    }
    init() {
        this._activate();
    }
    onremove() {
        this._deactivate();
    }
    _activate() {
        this._planet.addLayer(this._trackLayer);
        this._planet.addLayer(this._groundPointersLayer);
        this._planet.addLayer(this._columnPointersLayer);
        this._planet.addLayer(this._headPointersLayer);
        this._planet.addLayer(this._heightsLayer);
        this._planet.addLayer(this._pointerLayer);
        this.renderer.events.on("ldblclick", this._onLClick);
        this.renderer.events.on("mousemove", this._onMouseMove);
        this.renderer.events.on("lup", this._onLUp);
        this._groundPointersLayer.events.on("mouseenter", this._onGroundPointerEnter);
        this._groundPointersLayer.events.on("mouseleave", this._onGroundPointerLeave);
        this._groundPointersLayer.events.on("ldown", this._onGroundPointerLDown);
        this._groundPointersLayer.events.on("lup", this._onGroundPointerLUp);
        this._headPointersLayer.events.on("mouseenter", this._onHeadPointerEnter);
        this._headPointersLayer.events.on("mouseleave", this._onHeadPointerLeave);
        this._headPointersLayer.events.on("ldown", this._onHeadPointerLDown);
        this._headPointersLayer.events.on("lup", this._onHeadPointerLUp);
        this.setPointerVisibility(false);
    }
    getPointLonLat(index) {
        let entity = this._headPointersLayer.getEntities()[index];
        if (entity) {
            return entity.getLonLat();
        }
    }
    getPointsLonLat() {
        let entities = this._headPointersLayer.getEntities();
        let points = new Array(entities.length);
        for (let i = 0, len = points.length; i < len; i++) {
            let ei = entities[i];
            points[i] = ei.getLonLat();
        }
        return points;
    }
    getHeightMSL(lonLat) {
        if (this._planet && this._planet.terrain.geoid) {
            return this._planet.terrain.geoid.getHeightLonLat(lonLat);
        }
        return 0;
    }
    getHeightELLAsync(lonLat) {
        return new Promise((resolve, reject) => {
            this._planet.terrain.getHeightAsync(lonLat, (hGnd) => {
                if (this._planet) {
                    let hMsl = this.getHeightMSL(lonLat);
                    resolve(hGnd + hMsl);
                }
                else {
                    reject();
                }
            });
        });
    }
    addPointLonLatArrayAsync(lonLatArr, stopPropagation = false) {
        if (!this._planet) {
            throw new Error("Planet is not defined");
        }
        let ell = this._planet.ellipsoid;
        for (let i = 0, len = lonLatArr.length - 1; i < len; i++) {
            let p0 = ell.lonLatToCartesian(lonLatArr[i]), p1 = ell.lonLatToCartesian(lonLatArr[i + 1]);
            if (p0.distance(p1) > 100000) {
                throw new Error("Track is too long! 100 km is maximum.");
            }
        }
        let res = new Array(lonLatArr.length);
        for (let i = 0, len = lonLatArr.length; i < len; i++) {
            res[i] = this.addPointLonLatAsync(lonLatArr[i], true);
        }
        Promise.all(res).then(() => {
            if (!stopPropagation) {
                this.events.dispatch(this.events.change, this);
            }
        });
        return res;
    }
    addPointLonLatAsync(lonLat, stopPropagation = false) {
        let headPos = this._planet.ellipsoid.lonLatToCartesian(lonLat);
        let n = this._planet.ellipsoid.getSurfaceNormal3v(headPos);
        let ellLonLat = new LonLat(lonLat.lon, lonLat.lat);
        let ellPos = this._planet.ellipsoid.lonLatToCartesian(ellLonLat);
        let { headEntity, groundEntity, columnEntity, heightLabelEntity } = this._createGroundPointer(ellPos);
        this._groundPointersLayer.add(groundEntity);
        this._columnPointersLayer.add(columnEntity);
        this._headPointersLayer.add(headEntity);
        this._heightsLayer.add(heightLabelEntity);
        this._trackEntity.polyline.appendPoint3v(headEntity.getCartesian());
        groundEntity.properties.lonLatEll.lon = ellLonLat.lon;
        groundEntity.properties.lonLatEll.lat = ellLonLat.lat;
        groundEntity.properties.lonLatEll.height = ellLonLat.height;
        return new Promise((resolve) => {
            this.getHeightELLAsync(lonLat).then((hEll) => {
                groundEntity.properties.lonLatEll.height = hEll;
                let altitude = 10, groundPos;
                if (lonLat.height === 0) {
                    groundPos = headPos.add(n.scaleTo(hEll));
                    headPos = groundPos.add(n.scaleTo(altitude));
                }
                else {
                    altitude = lonLat.height - hEll;
                    groundPos = headPos.sub(n.scaleTo(altitude));
                }
                groundEntity.setCartesian3v(groundPos);
                heightLabelEntity.setCartesian3v(headPos);
                heightLabelEntity.label.setText(`${hEll.toFixed(1)} m`);
                heightLabelEntity.childrenNodes[0].label.setText(`${altitude.toFixed(1)} m`);
                headEntity.properties.altitude = altitude;
                headEntity.setCartesian3v(headPos);
                headEntity.properties.columnEntity.ray.setStartPosition3v(groundPos);
                headEntity.properties.columnEntity.ray.setEndPosition3v(headPos);
                this._trackEntity.polyline?.setPoint3v(headPos, headEntity.properties.index);
                if (!stopPropagation) {
                    this.events.dispatch(this.events.addpoint, headEntity, this);
                    this.events.dispatch(this.events.change, this);
                }
                resolve(headEntity);
            });
        });
    }
    addGroundPointLonLatAsync(lonLat, altitude = 10, stopPropagation = false) {
        let groundPos = this._planet.ellipsoid.lonLatToCartesian(lonLat);
        return this._addPoint(groundPos, lonLat, altitude, stopPropagation);
    }
    addGroundPoint3vAsync(groundPos, altitude = 10, stopPropagation = false) {
        let lonLat = this._planet.ellipsoid.cartesianToLonLat(groundPos);
        return this._addPoint(groundPos, lonLat, altitude, stopPropagation);
    }
    _addPoint(groundPos, lonLat, altitude, stopPropagation = false) {
        return new Promise((resolve, reject) => {
            let { headEntity, groundEntity, columnEntity, heightLabelEntity } = this._createGroundPointer(groundPos, altitude);
            this._groundPointersLayer.add(groundEntity);
            this._columnPointersLayer.add(columnEntity);
            this._headPointersLayer.add(headEntity);
            this._heightsLayer.add(heightLabelEntity);
            this._trackEntity.polyline.appendPoint3v(headEntity.getCartesian());
            groundEntity.properties.lonLatEll.lon = lonLat.lon;
            groundEntity.properties.lonLatEll.lat = lonLat.lat;
            groundEntity.properties.lonLatEll.height = lonLat.height;
            this.getHeightELLAsync(lonLat).then((hEll) => {
                groundEntity.properties.lonLatEll.height = lonLat.height = hEll;
                let groundPos = this._planet.ellipsoid.lonLatToCartesian(lonLat);
                let groundNormal = this._planet.ellipsoid.getSurfaceNormal3v(groundPos);
                let headPos = groundPos.add(groundNormal.scale(altitude));
                heightLabelEntity.setCartesian3v(headPos);
                heightLabelEntity.label.setText(`${hEll.toFixed(1)} m`);
                heightLabelEntity.childrenNodes[0].label.setText(`${altitude.toFixed(1)} m`);
                headEntity.setCartesian3v(headPos);
                headEntity.properties.columnEntity.ray.setEndPosition3v(headPos);
                this._trackEntity.polyline?.setPoint3v(headPos, headEntity.properties.index);
                if (!stopPropagation) {
                    this.events.dispatch(this.events.addpoint, headEntity, this);
                    this.events.dispatch(this.events.change, this);
                }
                resolve(headEntity);
            });
        });
    }
    setHeadPointCartesian3v(entityIndex, headPos) {
        const headEntity = this._headPointersLayer.getEntities()[entityIndex];
        if (headEntity) {
            let groundPos = this._planet.ellipsoid.lonLatToCartesian(headEntity.properties.lonLatEll);
            let altitude = headPos.length() - groundPos.length();
            if (altitude <= 0) {
                headPos = groundPos;
                altitude = 0;
            }
            headEntity.properties.altitude = altitude;
            headEntity.setCartesian3v(headPos);
            headEntity.properties.columnEntity.ray.setEndPosition3v(headPos);
            headEntity.properties.heightLabelEntity.setCartesian3v(headPos);
            headEntity.properties.heightLabelEntity.childrenNodes[0].label.setText(`${altitude.toFixed(1)} m`);
            this._trackEntity.polyline.setPoint3v(headPos, entityIndex);
            this.events.dispatch(this.events.change, this._pickedHeadEntity);
        }
    }
    setGroundPointCartesian3v(entityIndex, groundPos) {
        let groundEntity = this._groundPointersLayer.getEntities()[entityIndex];
        if (groundEntity) {
            let lonLat = this._planet.ellipsoid.cartesianToLonLat(groundPos);
            groundEntity.properties.lonLatEll.lon = lonLat.lon;
            groundEntity.properties.lonLatEll.lat = lonLat.lat;
            groundEntity.properties.lonLatEll.height = lonLat.height;
            let groundNormal = this._planet.ellipsoid.getSurfaceNormal3v(groundPos);
            let headEntity = groundEntity.properties.headEntity;
            let heightLabelEntity = groundEntity.properties.heightLabelEntity;
            let altitude = groundEntity.properties.altitude;
            groundEntity.setCartesian3v(groundPos);
            let headPos = groundPos.add(groundNormal.scale(altitude));
            headEntity.setCartesian3v(headPos);
            headEntity.properties.columnEntity.ray.setStartPosition3v(groundPos);
            headEntity.properties.columnEntity.ray.setEndPosition3v(headPos);
            this._trackEntity.polyline?.setPoint3v(headPos, headEntity.properties.index);
            heightLabelEntity.setCartesian3v(headPos);
            heightLabelEntity.label.setText(`${lonLat.height.toFixed(1)} m`);
            heightLabelEntity.childrenNodes[0].label.setText(`${altitude.toFixed(1)} m`);
            this.events.dispatch(this.events.change, groundEntity.properties.headEntity);
        }
    }
    _deactivate() {
        this.renderer.events.off("ldblclick", this._onLClick);
        this.renderer.events.off("mousemove", this._onMouseMove);
        this.renderer.events.off("lup", this._onLUp);
        this._groundPointersLayer.events.off("mouseenter", this._onGroundPointerEnter);
        this._groundPointersLayer.events.off("mouseleave", this._onGroundPointerLeave);
        this._groundPointersLayer.events.off("ldown", this._onGroundPointerLDown);
        this._groundPointersLayer.events.off("lup", this._onGroundPointerLUp);
        this._headPointersLayer.events.off("mouseenter", this._onHeadPointerEnter);
        this._headPointersLayer.events.off("mouseleave", this._onHeadPointerLeave);
        this._headPointersLayer.events.off("ldown", this._onHeadPointerLDown);
        this._headPointersLayer.events.off("lup", this._onHeadPointerLUp);
        this._trackLayer.remove();
        this._groundPointersLayer.remove();
        this._headPointersLayer.remove();
        this._columnPointersLayer.remove();
        this._trackLayer.remove();
        this._heightsLayer.remove();
        this._pointerLayer.remove();
        this.clear();
    }
    setPointerVisibility(visibility) {
        this._pointerLayer.setVisibility(visibility);
    }
    setVisibility(visibility) {
        this._groundPointersLayer.setVisibility(visibility);
        this._trackLayer.setVisibility(visibility);
        this._columnPointersLayer.setVisibility(visibility);
        this._headPointersLayer.setVisibility(visibility);
        this._trackLayer.setVisibility(visibility);
        this._heightsLayer.setVisibility(visibility);
        this._pointerLayer.setVisibility(visibility);
    }
    clear() {
        this._headPointersLayer.setEntities([]);
        this._groundPointersLayer.setEntities([]);
        this._columnPointersLayer.setEntities([]);
        this._heightsLayer.setEntities([]);
        this._trackEntity.polyline.setPath3v([]);
    }
    frame() {
        if (this._clampToGround) {
            let __tempVec__ = new Vec3();
            const nodes = this._planet._renderedNodes;
            const entities = this._groundPointersLayer.getEntities();
            for (let i = 0; i < entities.length; i++) {
                let ei = entities[i];
                for (let j = 0; j < nodes.length; j++) {
                    let nj = nodes[j];
                    if (nj.segment.isEntityInside(ei)) {
                        nj.segment.getEntityTerrainPoint(ei, __tempVec__);
                        ei.setCartesian3v(__tempVec__);
                        ei.properties.columnEntity.ray.setStartPosition3v(__tempVec__);
                        break;
                    }
                }
            }
        }
    }
    get ellipsoid() {
        return this._planet ? this._planet.ellipsoid : null;
    }
}
const ELEVATIONPROFILESCENE_EVENTS = [
    "change", "addpoint"
];

const TEMPLATE$4 = '<div class="og-elevationprofile-buttons"></div>';
const RESET_SVG_ICON = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="30" height="30" viewBox="0 0 30 30" version="1.1">
  <g transform="translate(0,-289.0625)">
    <path d="M 15 6 C 10.041282 6 6 10.04128 6 15 C 6 19.95872 10.041282 24 15 24 C 16.586491 24 18.07668 23.58246 19.373047 22.857422 L 17.888672 21.375 C 17.00816 21.772814 16.032235 22 15 22 C 11.122162 22 8 18.87784 8 15 C 8 11.12216 11.122162 8 15 8 C 18.877838 8 22 11.12216 22 15 L 19 15 L 23 20 L 27 15 L 24 15 C 24 10.04128 19.958718 6 15 6 z " transform="translate(0,289.0625)" />
  </g>
</svg>`;
const LIST_SVG_ICON = `<?xml version="1.0" encoding="utf-8"?><svg width="800px" height="800px" viewBox="0 0 32 32" id="icon" xmlns="http://www.w3.org/2000/svg"><defs><style>.cls-1{fill:none;}</style></defs><title>list</title><rect x="10" y="6" width="18" height="2"/><rect x="10" y="24" width="18" height="2"/><rect x="10" y="15" width="18" height="2"/><rect x="4" y="15" width="2" height="2"/><rect x="4" y="6" width="2" height="2"/><rect x="4" y="24" width="2" height="2"/></svg>`;
const LOCATION_SVG_ICON = `<?xml version="1.0" encoding="utf-8"?>
<!-- Svg Vector Icons : http://www.onlinewebfonts.com/icon -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 256 256" enable-background="new 0 0 256 256" xml:space="preserve">
<metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>
<g><g><path fill="#000000" d="M127,169.4c23.7,0,42.8-18.3,42.8-41s-19.2-41-42.8-41c-23.7,0-42.8,18.4-42.8,41S103.4,169.4,127,169.4z"/><path fill="#000000" d="M221.7,120.2c-3.8-44-40.9-78.9-87-82V15h-16.3v23.6c-44.8,4-80.3,38.5-84.1,81.7H10v15.6h24.3c3.8,43.1,39.3,77.4,84.1,81.7V241h16.3v-23.2c46-3.1,83.2-37.9,87-82H246v-15.6H221.7L221.7,120.2L221.7,120.2z M128,201.6c-42.5,0-76.7-33-76.7-73.4c0-40.4,34.5-73.4,76.7-73.4c42.5,0,76.7,33,76.7,73.4C204.7,168.5,170.5,201.6,128,201.6L128,201.6z"/></g></g>
</svg>`;
const ELEVATIONPROFILEBUTTONSVIEW_EVENTS = ["reset", "list", "location"];
class ElevationProfileButtonsView extends View {
    constructor(params = {}) {
        super({
            ...params,
            template: TEMPLATE$4
        });
        //@ts-ignore
        this.events = this.events.registerNames(ELEVATIONPROFILEBUTTONSVIEW_EVENTS);
        this.pointListBtn = new ToggleButton({
            classList: ["og-elevationprofile-button"],
            icon: LIST_SVG_ICON,
            title: "Point List"
        });
        this.pointListBtn.events.on("change", (isActive) => {
            this.events.dispatch(this.events.list, isActive);
        });
    }
    render(params) {
        super.render(params);
        let resetBtn = new Button({
            classList: ["og-elevationprofile-button"],
            icon: RESET_SVG_ICON,
            title: "Reset"
        });
        resetBtn.appendTo(this.el);
        resetBtn.events.on("click", () => {
            this.model.clear();
            this.events.dispatch(this.events.reset, this);
        });
        this.pointListBtn.appendTo(this.el);
        let locationBtn = new Button({
            classList: ["og-elevationprofile-button", "og-elevationprofile-button__location"],
            icon: LOCATION_SVG_ICON,
            title: "View bounds"
        });
        locationBtn.appendTo(this.el);
        locationBtn.events.on("click", () => {
            this.events.dispatch(this.events.location, this);
        });
        return this;
    }
}

const LIST_TEMPLATE = `<div class="og-elevationprofile-list">
        <textarea placeholder="[[lon, lat, height], [lon, lat, height], ..., [lon, lat, height]]"></textarea>
        <div class="og-elevationprofile-list-buttons"></div>
    </div>`;
class PointListDialog extends Dialog {
    constructor(params) {
        super({
            title: "Points List",
            visible: false,
            resizable: true,
            useHide: true,
            top: 150,
            left: 200,
            width: 400,
            height: 300,
            minHeight: 100,
            minWidth: 100,
            ...params
        });
        this._onApplyClick = () => {
            try {
                this.model.clear();
                let coordsArr = JSON.parse(this.$textarea.value);
                let lonLatArr = new Array(coordsArr.length);
                for (let i = 0; i < coordsArr.length; i++) {
                    let ci = coordsArr[i];
                    lonLatArr[i] = new LonLat(ci[0], ci[1], ci[2]);
                }
                this.model.addPointLonLatArrayAsync(lonLatArr);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.$textarea = null;
    }
    render(params) {
        super.render(params);
        let view = new View({
            template: LIST_TEMPLATE
        });
        view.appendTo(this.container);
        let applyBtn = new Button({
            classList: ["og-elevationprofile-list-apply"],
            icon: "Apply"
        });
        applyBtn.appendTo(view.select(".og-elevationprofile-list-buttons"));
        applyBtn.events.on("click", this._onApplyClick);
        this.$textarea = view.select("textarea");
        return this;
    }
}

const TEMPLATE$3 = `<div class="og-elevationprofile-legend">
        <div class="og-elevationprofile-legend__row og-elevationprofile-legend__track">
          <div class="og-elevationprofile-square"></div>
          <div class="og-elevationprofile-value">0</div>
          <div class="og-elevationprofile-units">m</div>
        </div>
        <div class="og-elevationprofile-legend__row og-elevationprofile-legend__ground">
          <div class="og-elevationprofile-square"></div>
          <div class="og-elevationprofile-value">0</div>
          <div class="og-elevationprofile-units">m</div>
        </div>
        <div class="og-elevationprofile-legend__row og-elevationprofile-legend__warning">        
          <div class="og-elevationprofile-square"></div>
          <div class="og-elevationprofile-value">0</div>
          <div class="og-elevationprofile-units">m</div>
        </div>
        <div class="og-elevationprofile-legend__row og-elevationprofile-legend__collision">
          <div class="og-elevationprofile-square"></div>
          <div class="og-elevationprofile-value">0</div>
          <div class="og-elevationprofile-units">m</div>
        </div>
      </div>`;
class ElevationProfileLegend extends View {
    constructor(params = {}) {
        super({
            ...params,
            template: TEMPLATE$3
        });
        this.$groundValue = null;
        this.$trackValue = null;
        this.$warningValue = null;
        this.$collisionValue = null;
        this.$trackUnits = null;
        this.$groundUnits = null;
        this.$warningUnits = null;
        this.$collisionUnits = null;
    }
    render(params) {
        super.render(params);
        this.$trackValue = this.select(".og-elevationprofile-legend__track .og-elevationprofile-value");
        this.$groundValue = this.select(".og-elevationprofile-legend__ground .og-elevationprofile-value");
        this.$warningValue = this.select(".og-elevationprofile-legend__warning .og-elevationprofile-value");
        this.$collisionValue = this.select(".og-elevationprofile-legend__collision .og-elevationprofile-value");
        this.$trackUnits = this.select(".og-elevationprofile-legend__track .og-elevationprofile-units");
        this.$groundUnits = this.select(".og-elevationprofile-legend__ground .og-elevationprofile-units");
        this.$warningUnits = this.select(".og-elevationprofile-legend__warning .og-elevationprofile-units");
        this.$collisionUnits = this.select(".og-elevationprofile-legend__collision .og-elevationprofile-units");
        return this;
    }
    clear() {
        this.$trackValue && (this.$trackValue.innerText = "0");
        this.$trackUnits && (this.$trackUnits.innerText = "m");
        this.$groundValue && (this.$groundValue.innerText = "0");
        this.$groundUnits && (this.$groundUnits.innerText = "m");
        this.$warningValue && (this.$warningValue.innerText = "0");
        this.$warningUnits && (this.$warningUnits.innerText = "m");
        this.$collisionValue && (this.$collisionValue.innerText = "0");
        this.$collisionUnits && (this.$collisionUnits.innerText = "m");
    }
    setTrackLength(trackLength) {
        let dist = distanceFormatExt(trackLength);
        this.$trackValue.innerText = dist[0];
        this.$trackUnits.innerText = dist[1];
    }
    setGroundLength(groundLength) {
        let dist = distanceFormatExt(groundLength);
        this.$groundValue.innerText = dist[0];
        this.$groundUnits.innerText = dist[1];
    }
    setWarningLength(warningLength) {
        let warningDist = distanceFormatExt(warningLength);
        this.$warningValue.innerText = warningDist[0];
        this.$warningUnits.innerText = warningDist[1];
    }
    setCollisionLength(collisionLength) {
        let collisionDist = distanceFormatExt(collisionLength);
        this.$collisionValue.innerText = collisionDist[0];
        this.$collisionUnits.innerText = collisionDist[1];
    }
}

const TEMPLATE$2 = `<div class="og-elevationprofile__container">
      <div class="og-elevationprofile__menu"></div>
      <div class="og-elevationprofile__graph"></div>
    </div>`;
const ICON_BUTTON_SVG$1 = `<svg style="width: 2em; height: 2em;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M128 896v-158.293333l331.946667-191.573334 160.853333 93.866667L896 480V896H128M896 381.44l-275.2 159.146667-160.853333-92.586667L128 640v-94.293333l331.946667-191.573334 160.853333 93.866667L896 288v93.44z" fill="" /></svg>`;
class ElevationProfileControl extends Control {
    constructor(options = {}) {
        super({
            name: "ElevationProfileControl",
            ...options
        });
        this._onSceneChange = () => {
            this._collectProfileThrottled();
        };
        this._onElevationProfilePointer = (pointerDistance, tp0, tp1, gp0, gp1, trackPoiIndex, groundPoiIndex, elevation) => {
            let lonLat0 = this._elevationProfileScene.getPointLonLat(trackPoiIndex);
            let lonLat1 = this._elevationProfileScene.getPointLonLat(trackPoiIndex + 1);
            let cart0 = this.planet.ellipsoid.lonLatToCartesian(lonLat0), cart1 = this.planet.ellipsoid.lonLatToCartesian(lonLat1);
            let d = (pointerDistance - tp0[0]) / (tp1[0] - tp0[0]);
            let dir = cart1.sub(cart0);
            this._elevationProfileScene.setPointerCartesian3v(cart0.add(dir.scale(d)), elevation);
        };
        this._onElevationProfileDblClick = (pointerDistance, tp0, tp1, gp0, gp1, trackPoiIndex, groundPoiIndex, elevation) => {
            let lonLat0 = this._elevationProfileScene.getPointLonLat(trackPoiIndex);
            let lonLat1 = this._elevationProfileScene.getPointLonLat(trackPoiIndex + 1);
            let cart0 = this.planet.ellipsoid.lonLatToCartesian(lonLat0), cart1 = this.planet.ellipsoid.lonLatToCartesian(lonLat1);
            let d = (pointerDistance - tp0[0]) / (tp1[0] - tp0[0]);
            let dir = cart1.sub(cart0);
            let poi = cart0.add(dir.scale(d));
            this.planet.camera.flyDistance(poi, this.planet.camera.eye.distance(poi));
        };
        this._onElevationProfileMouseEnter = () => {
            if (this._elevationProfileView.model.pointsReady) {
                this._elevationProfileScene.setPointerVisibility(true);
            }
        };
        this._onElevationProfileMouseLeave = () => {
        };
        this._elevationProfileScene = new ElevationProfileScene();
        this._elevationProfileView = new ElevationProfileView();
        this._elevationProfileLegend = new ElevationProfileLegend();
        this._elevationProfileButtonsView = new ElevationProfileButtonsView({
            model: this._elevationProfileView.model
        });
        this._elevationProfileView.events.on("pointer", this._onElevationProfilePointer);
        this._elevationProfileView.events.on("dblclick", this._onElevationProfileDblClick);
        this._elevationProfileView.events.on("mouseenter", this._onElevationProfileMouseEnter);
        this._elevationProfileView.events.on("mouseleave", this._onElevationProfileMouseLeave);
        this._dialog = new Dialog({
            title: "Elevation Profile",
            visible: false,
            resizable: true,
            useHide: true,
            top: 175,
            left: 65,
            width: 400,
            height: 200,
            minHeight: 100,
            minWidth: 100
        });
        this._graphView = new View({
            template: TEMPLATE$2
        });
        this._poiListDialog = new PointListDialog({
            model: this._elevationProfileScene
        });
        this._toggleBtn = new ToggleButton({
            classList: ["og-map-button", "og-elevationprofile_button"],
            icon: ICON_BUTTON_SVG$1
        });
        this._collectProfileThrottled = throttle(() => {
            let points = this._elevationProfileScene.getPointsLonLat();
            this._elevationProfileView.model.collectProfile(points);
        }, 250);
    }
    oninit() {
        this._dialog.appendTo(this.planet.renderer.div);
        this._graphView.appendTo(this._dialog.container);
        this._toggleBtn.appendTo(this.renderer.div);
        this._dialog.events.on("visibility", (v) => {
            this._toggleBtn.setActive(v);
            if (v) {
                this.activate();
                this._elevationProfileView.resize();
            }
            else {
                this.deactivate();
            }
        });
        this._toggleBtn.events.on("change", (isActive) => {
            this._dialog.setVisibility(isActive);
        });
        this._elevationProfileView.appendTo(this._graphView.select(".og-elevationprofile__graph"));
        this._elevationProfileView.model.bindPlanet(this.planet);
        this._elevationProfileView.model.events.on("clear", () => {
            this._elevationProfileScene.clear();
            this._elevationProfileLegend.clear();
        });
        this._elevationProfileView.model.events.on("startcollecting", () => {
            this._elevationProfileScene.setPointerVisibility(false);
        });
        this._elevationProfileView.events.on("tracklength", (length) => {
            this._elevationProfileLegend.setTrackLength(length);
        });
        this._elevationProfileView.events.on("groundlength", (length) => {
            this._elevationProfileLegend.setGroundLength(length);
        });
        this._elevationProfileView.events.on("warninglength", (length) => {
            this._elevationProfileLegend.setWarningLength(length);
        });
        this._elevationProfileView.events.on("collisionlength", (length) => {
            this._elevationProfileLegend.setCollisionLength(length);
        });
        this._poiListDialog.appendTo(this.planet.renderer.div);
        this._poiListDialog.events.on("visibility", (isVisible) => {
            this._elevationProfileButtonsView.pointListBtn.setActive(isVisible, true);
        });
        this._elevationProfileLegend.appendTo(this._graphView.select(".og-elevationprofile__menu"));
        this._elevationProfileButtonsView.appendTo(this._graphView.select(".og-elevationprofile__menu"));
        this._elevationProfileButtonsView.events.on("list", (isActive) => {
            this._poiListDialog.setVisibility(isActive);
        });
        this._elevationProfileButtonsView.events.on("location", (isActive) => {
            this._elevationProfileScene.flyExtent();
        });
        this._elevationProfileButtonsView.events.on("reset", (isActive) => {
            this._elevationProfileScene.setPointerVisibility(false);
        });
        this._elevationProfileScene.events.on("change", this._onSceneChange);
    }
    onactivate() {
        this.renderer.controls.mouseNavigation.deactivateDoubleClickZoom();
        this.planet && this._elevationProfileScene.bindPlanet(this.planet);
        this.renderer && this.renderer.addNode(this._elevationProfileScene);
    }
    ondeactivate() {
        this._poiListDialog.setVisibility(false);
        this._elevationProfileView.model.clear();
        this.renderer.controls.mouseNavigation.activateDoubleClickZoom();
        this.renderer && this.renderer.removeNode(this._elevationProfileScene);
        this._dialog.hide();
    }
}

const TEMPLATE$1 = `<div class="og-atmosphere og-options-container">
         
         <div class="og-option og-atmosphere-maxOpacity"></div> 
         <div class="og-option og-atmosphere-minOpacity"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-rayleight"></div>
         <div class="og-option og-atmosphere-mie"></div>
         
       <div class="og-emptyline-2"></div>
                  
         <div class="og-option og-atmosphere-height"></div> 
         <div class="og-option og-atmosphere-bottomRadius"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-mieScatteringCoefficient"></div>  
         <div class="og-option og-atmosphere-mieExtinctionCoefficient"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-rayleighScatteringCoefficientA"></div>    
         <div class="og-option og-atmosphere-rayleighScatteringCoefficientB"></div>    
         <div class="og-option og-atmosphere-rayleighScatteringCoefficientC"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-ozoneAbsorptionCoefficientA"></div>    
         <div class="og-option og-atmosphere-ozoneAbsorptionCoefficientB"></div>    
         <div class="og-option og-atmosphere-ozoneAbsorptionCoefficientC"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-ozoneDensityHeight"></div>    
         <div class="og-option og-atmosphere-ozoneDensityWide"></div>    
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-sunAngularRadius"></div> 
         <div class="og-option og-atmosphere-sunIntensity"></div> 
         <div class="og-option og-atmosphere-earthAlbedo"></div>
       
    </div>`;
const ICON_BUTTON_SVG = `<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path fill="#000000" d="M135.688 18.5c-6.798 74.842-23.842 85.39-107.907 59.656 84.85 52.022 73.57 64.954-6.843 96.938 87.743-10.27 103.29 4.89 70.75 87.594 17.805-27.56 32.5-44.498 46.282-54.47-11.813 28.26-18.345 59.274-18.345 91.813 0 84.184 43.71 157.96 109.656 200.376-41.624-43.834-67.686-102.7-67.686-167.875 0-134.923 109.45-244.405 244.375-244.405 30.92 0 60.76 5.762 88 16.25-38.584-26.87-85.517-42.625-136.064-42.625-55.257 0-106.14 18.802-146.562 50.375 4.627-18.783 17.39-38.073 41.03-60.906C190.18 90.942 153.53 95.634 135.69 18.5zm10.03 77.188c5.67.002 11.428 1.247 16.876 3.874 14.506 6.998 22.72 21.81 22 36.938-10.26 10.87-19.507 22.696-27.594 35.344-9.035 2.753-19.075 2.27-28.25-2.156-19.37-9.343-27.5-32.6-18.156-51.97 6.715-13.92 20.638-22.036 35.125-22.03z"/></svg>`;
/**
 * Helps to set up atmosphere parameters.
 */
class AtmosphereConfig extends Control {
    constructor(options = {}) {
        super(options);
        this.$maxOpacity = null;
        this.$minOpacity = null;
        this.$rayleight = null;
        this.$mie = null;
        this.$height = null;
        this.$bottomRadius = null;
        this.$mieScatteringCoefficient = null;
        this.$mieExtinctionCoefficient = null;
        this.$rayleighScatteringCoefficientA = null;
        this.$rayleighScatteringCoefficientB = null;
        this.$rayleighScatteringCoefficientC = null;
        this.$ozoneAbsorptionCoefficientA = null;
        this.$ozoneAbsorptionCoefficientB = null;
        this.$ozoneAbsorptionCoefficientC = null;
        this.$sunAngularRadius = null;
        this.$sunIntensity = null;
        this.$groundAlbedo = null;
        this.$ozoneDensityHeight = null;
        this.$ozoneDensityWide = null;
        this._toggleBtn = new ToggleButton({
            classList: ["og-map-button", "og-atmosphere_button"],
            icon: ICON_BUTTON_SVG
        });
        this._dialog = new Dialog({
            title: "Atmosphere Parameters",
            visible: false,
            useHide: true,
            top: 60,
            left: 60,
            width: 720
        });
        this._dialog.events.on("visibility", (v) => {
            this._toggleBtn.setActive(v);
        });
        this._panel = new View({
            template: TEMPLATE$1
        });
        this._maxOpacity = new Slider({
            label: "Max.opacity",
            max: 5
        });
        this._minOpacity = new Slider({
            label: "Min.opacity",
            max: 5
        });
        this._rayleight = new Slider({
            label: "Rayleight Scale",
            min: -10.0,
            max: 10.0
        });
        this._mie = new Slider({
            label: "Mie Scale",
            min: -10.0,
            max: 10.0
        });
        this._height = new Slider({
            label: "Height",
            max: 1000000.0
        });
        this._bottomRadius = new Slider({
            label: "Planet Radius",
            max: 5 * 6356752.3142451793
        });
        this._mieScatteringCoefficient = new Slider({
            label: "Mie Scattering Coefficient e-6",
            min: -10 * 3.996,
            max: 10 * 3.996
        });
        this._mieExtinctionCoefficient = new Slider({
            label: "Mie Extinction Coef.e-6",
            min: -10 * 4.440,
            max: 10 * 4.440
        });
        this._rayleighScatteringCoefficientA = new Slider({
            label: "Rayleight Scattering Coef A.e-6",
            min: -10 * 5.802,
            max: 10 * 5.802
        });
        this._rayleighScatteringCoefficientB = new Slider({
            label: "Rayleight Scattering Coef B.e-6",
            min: -10 * 13.558,
            max: 10 * 13.558
        });
        this._rayleighScatteringCoefficientC = new Slider({
            label: "Rayleight Scattering Coef C.e-6",
            min: -10 * 33.100,
            max: 10 * 33.100
        });
        this._ozoneAbsorptionCoefficientA = new Slider({
            label: "Ozone absorbtion Coef A.e-6",
            min: -10 * 0.650,
            max: 10 * 0.650
        });
        this._ozoneAbsorptionCoefficientB = new Slider({
            label: "Ozone absorbtion Coef B.e-6",
            min: -10 * 0.650,
            max: 10 * 1.881
        });
        this._ozoneAbsorptionCoefficientC = new Slider({
            label: "Ozone absorbtion Coef C.e-6",
            min: -10 * 0.085,
            max: 10 * 0.085
        });
        this._ozoneDensityHeight = new Slider({
            label: "Ozone Density Height",
            max: 100 * 25000
        });
        this._ozoneDensityWide = new Slider({
            label: "Ozone Density Wide",
            max: 100 * 25000
        });
        this._sunAngularRadius = new Slider({
            label: "Sun Angular Radius",
            max: 1000 * 0.004685
        });
        this._sunIntensity = new Slider({
            label: "Sun Intensity",
            max: 10 * 1.0
        });
        this._groundAlbedo = new Slider({
            label: "Earth Albedo",
            max: 10 * 0.05
        });
        this._parameters = {
            ATMOS_HEIGHT: 0,
            RAYLEIGH_SCALE: 0,
            MIE_SCALE: 0,
            GROUND_ALBEDO: 0,
            BOTTOM_RADIUS: 0,
            rayleighScatteringCoefficient: [0, 0, 0],
            mieScatteringCoefficient: 0,
            mieExtinctionCoefficient: 0,
            ozoneAbsorptionCoefficient: [0, 0, 0],
            SUN_ANGULAR_RADIUS: 0,
            SUN_INTENSITY: 0,
            ozoneDensityHeight: 0,
            ozoneDensityWide: 0,
        };
    }
    oninit() {
        this._toggleBtn.appendTo(this.renderer.div);
        this._dialog.appendTo(this.renderer.div);
        this._panel.appendTo(this._dialog.container);
        if (this._panel.el) {
            this.$height = this._panel.el.querySelector(".og-option.og-atmosphere-height");
            this.$maxOpacity = this._panel.el.querySelector(".og-option.og-atmosphere-maxOpacity");
            this.$minOpacity = this._panel.el.querySelector(".og-option.og-atmosphere-minOpacity");
            this.$rayleight = this._panel.el.querySelector(".og-option.og-atmosphere-rayleight");
            this.$mie = this._panel.el.querySelector(".og-option.og-atmosphere-mie");
            this.$bottomRadius = this._panel.el.querySelector(".og-option.og-atmosphere-bottomRadius");
            this.$mieScatteringCoefficient = this._panel.el.querySelector(".og-option.og-atmosphere-mieScatteringCoefficient");
            this.$mieExtinctionCoefficient = this._panel.el.querySelector(".og-option.og-atmosphere-mieExtinctionCoefficient");
            this.$rayleighScatteringCoefficientA = this._panel.el.querySelector(".og-option.og-atmosphere-rayleighScatteringCoefficientA");
            this.$rayleighScatteringCoefficientB = this._panel.el.querySelector(".og-option.og-atmosphere-rayleighScatteringCoefficientB");
            this.$rayleighScatteringCoefficientC = this._panel.el.querySelector(".og-option.og-atmosphere-rayleighScatteringCoefficientC");
            this.$ozoneAbsorptionCoefficientA = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneAbsorptionCoefficientA");
            this.$ozoneAbsorptionCoefficientB = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneAbsorptionCoefficientB");
            this.$ozoneAbsorptionCoefficientC = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneAbsorptionCoefficientC");
            this.$sunAngularRadius = this._panel.el.querySelector(".og-option.og-atmosphere-sunAngularRadius");
            this.$sunIntensity = this._panel.el.querySelector(".og-option.og-atmosphere-sunIntensity");
            this.$groundAlbedo = this._panel.el.querySelector(".og-option.og-atmosphere-earthAlbedo");
            this.$ozoneDensityHeight = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneDensityHeight");
            this.$ozoneDensityWide = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneDensityWide");
        }
        this._toggleBtn.events.on("change", (isActive) => {
            this._dialog.setVisibility(isActive);
        });
        this._maxOpacity.appendTo(this.$maxOpacity);
        this._minOpacity.appendTo(this.$minOpacity);
        this._height.appendTo(this.$height);
        this._rayleight.appendTo(this.$rayleight);
        this._mie.appendTo(this.$mie);
        this._bottomRadius.appendTo(this.$bottomRadius);
        this._mieScatteringCoefficient.appendTo(this.$mieScatteringCoefficient);
        this._mieExtinctionCoefficient.appendTo(this.$mieExtinctionCoefficient);
        this._rayleighScatteringCoefficientA.appendTo(this.$rayleighScatteringCoefficientA);
        this._rayleighScatteringCoefficientB.appendTo(this.$rayleighScatteringCoefficientB);
        this._rayleighScatteringCoefficientC.appendTo(this.$rayleighScatteringCoefficientC);
        this._ozoneAbsorptionCoefficientA.appendTo(this.$ozoneAbsorptionCoefficientA);
        this._ozoneAbsorptionCoefficientB.appendTo(this.$ozoneAbsorptionCoefficientB);
        this._ozoneAbsorptionCoefficientC.appendTo(this.$ozoneAbsorptionCoefficientC);
        this._sunAngularRadius.appendTo(this.$sunAngularRadius);
        this._sunIntensity.appendTo(this.$sunIntensity);
        this._groundAlbedo.appendTo(this.$groundAlbedo);
        this._ozoneDensityHeight.appendTo(this.$ozoneDensityHeight);
        this._ozoneDensityWide.appendTo(this.$ozoneDensityWide);
        if (this.planet) {
            this._parameters = this.planet.atmosphereControl.parameters;
            this._height.value = this._parameters.ATMOS_HEIGHT;
            this._rayleight.value = this._parameters.RAYLEIGH_SCALE;
            this._mie.value = this._parameters.MIE_SCALE;
            this._bottomRadius.value = this._parameters.BOTTOM_RADIUS;
            this._mieScatteringCoefficient.value = this._parameters.mieScatteringCoefficient;
            this._mieExtinctionCoefficient.value = this._parameters.mieExtinctionCoefficient;
            this._rayleighScatteringCoefficientA.value = this._parameters.rayleighScatteringCoefficient[0];
            this._rayleighScatteringCoefficientB.value = this._parameters.rayleighScatteringCoefficient[1];
            this._rayleighScatteringCoefficientC.value = this._parameters.rayleighScatteringCoefficient[2];
            this._ozoneAbsorptionCoefficientA.value = this._parameters.ozoneAbsorptionCoefficient[0];
            this._ozoneAbsorptionCoefficientB.value = this._parameters.ozoneAbsorptionCoefficient[1];
            this._ozoneAbsorptionCoefficientC.value = this._parameters.ozoneAbsorptionCoefficient[2];
            this._sunAngularRadius.value = this._parameters.SUN_ANGULAR_RADIUS;
            this._sunIntensity.value = this._parameters.SUN_INTENSITY;
            this._groundAlbedo.value = this._parameters.GROUND_ALBEDO;
            this._ozoneDensityHeight.value = this._parameters.ozoneDensityHeight;
            this._ozoneDensityWide.value = this._parameters.ozoneDensityWide;
        }
        this._minOpacity.value = this.planet.atmosphereMinOpacity;
        this._minOpacity.events.on("change", (val) => {
            this.planet.atmosphereMinOpacity = val;
        });
        this._maxOpacity.value = this.planet.atmosphereMaxOpacity;
        this._maxOpacity.events.on("change", (val) => {
            this.planet.atmosphereMaxOpacity = val;
            //let atmos = this.planet!.renderer!.controls.Atmosphere as Atmosphere;
            //atmos.opacity = val;
        });
        this._rayleight.events.on("change", (val) => {
            this._parameters.RAYLEIGH_SCALE = val;
            this._update();
        });
        this._mie.events.on("change", (val) => {
            this._parameters.MIE_SCALE = val;
            this._update();
        });
        this._height.events.on("change", (val) => {
            this._parameters.ATMOS_HEIGHT = val;
            this._update();
        });
        this._bottomRadius.events.on("change", (val) => {
            this._parameters.BOTTOM_RADIUS = val;
            this._update();
        });
        this._mieScatteringCoefficient.events.on("change", (val) => {
            this._parameters.mieScatteringCoefficient = val;
            this._update();
        });
        this._mieExtinctionCoefficient.events.on("change", (val) => {
            this._parameters.mieExtinctionCoefficient = val;
            this._update();
        });
        this._rayleighScatteringCoefficientA.events.on("change", (val) => {
            this._parameters.rayleighScatteringCoefficient[0] = val;
            this._update();
        });
        this._rayleighScatteringCoefficientB.events.on("change", (val) => {
            this._parameters.rayleighScatteringCoefficient[1] = val;
            this._update();
        });
        this._rayleighScatteringCoefficientC.events.on("change", (val) => {
            this._parameters.rayleighScatteringCoefficient[2] = val;
            this._update();
        });
        this._ozoneAbsorptionCoefficientA.events.on("change", (val) => {
            this._parameters.ozoneAbsorptionCoefficient[0] = val;
            this._update();
        });
        this._ozoneAbsorptionCoefficientB.events.on("change", (val) => {
            this._parameters.ozoneAbsorptionCoefficient[1] = val;
            this._update();
        });
        this._ozoneAbsorptionCoefficientC.events.on("change", (val) => {
            this._parameters.ozoneAbsorptionCoefficient[2] = val;
            this._update();
        });
        this._sunAngularRadius.events.on("change", (val) => {
            this._parameters.SUN_ANGULAR_RADIUS = val;
            this._update();
        });
        this._sunIntensity.events.on("change", (val) => {
            this._parameters.SUN_INTENSITY = val;
            this._update();
        });
        this._groundAlbedo.events.on("change", (val) => {
            this._parameters.GROUND_ALBEDO = val;
            this._update();
        });
        this._ozoneDensityHeight.events.on("change", (val) => {
            this._parameters.ozoneDensityHeight = val;
            this._update();
        });
        this._ozoneDensityWide.events.on("change", (val) => {
            this._parameters.ozoneDensityWide = val;
            this._update();
        });
    }
    _update() {
        if (this.planet) {
            this.planet.atmosphereControl.setParameters(this._parameters);
        }
    }
}

var index$4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AtmosphereConfig: AtmosphereConfig,
    CompassButton: CompassButton,
    Control: Control,
    DebugInfo: DebugInfo,
    DrawingControl: DrawingControl,
    DrawingSwitcher: DrawingSwitcher,
    EarthCoordinates: EarthCoordinates,
    EarthNavigation: EarthNavigation,
    ElevationProfileControl: ElevationProfileControl,
    GeoImageDragControl: GeoImageDragControl,
    HeightRuler: HeightRuler,
    KeyboardNavigation: KeyboardNavigation,
    LayerAnimation: LayerAnimation,
    LayerSwitcher: LayerSwitcher,
    Lighting: Lighting,
    MouseNavigation: MouseNavigation,
    MouseWheelZoomControl: MouseWheelZoomControl,
    Ruler: Ruler,
    RulerSwitcher: RulerSwitcher,
    ScaleControl: ScaleControl,
    Selection: Selection,
    ShowFps: ShowFps,
    SimpleNavigation: SimpleNavigation,
    SimpleSkyBackground: SimpleSkyBackground,
    Sun: Sun,
    TimelineControl: TimelineControl,
    ToggleWireframe: ToggleWireframe,
    TouchNavigation: TouchNavigation,
    ZoomControl: ZoomControl
});

class Axes extends RenderNode {
    constructor(size = 100) {
        super("Axes");
        this.size = size;
        this.axesBuffer = null;
        this.axesColorBuffer = null;
    }
    init() {
        this.createAxesBuffer(this.size);
        this.drawMode = this.renderer.handler.gl.LINES;
        this.renderer.handler.addProgram(new Program("axesShader", {
            uniforms: {
                projectionViewMatrix: 'mat4'
            },
            attributes: {
                aVertexPosition: 'vec3',
                aVertexColor: 'vec4'
            },
            vertexShader: `attribute vec3 aVertexPosition;
            attribute vec4 aVertexColor;
            uniform mat4 projectionViewMatrix;
            varying vec4 vColor;
            void main(void) {
                gl_Position = projectionViewMatrix * vec4(aVertexPosition, 1.0);
                vColor = aVertexColor;
            }`,
            fragmentShader: `precision highp float;
            varying vec4 vColor;
            void main(void) {
                gl_FragColor = vColor;
            }`
        }));
    }
    frame() {
        this.renderer.handler.programs.axesShader.activate().set({
            projectionViewMatrix: this.renderer.activeCamera.getProjectionViewMatrix(),
            aVertexPosition: this.axesBuffer,
            aVertexColor: this.axesColorBuffer
        });
        this.renderer.handler.programs.axesShader.drawArrays(this.drawMode, this.axesBuffer.numItems);
    }
    createAxesBuffer(gridSize) {
        const vertices = [
            0.0, 0.0, 0.0, gridSize - 1, 0.0, 0.0, // x - R
            0.0, 0.0, 0.0, 0.0, gridSize - 1, 0.0, // y - B  
            0.0, 0.0, 0.0, 0.0, 0.0, gridSize - 1 // z - G
        ];
        const colors = [
            1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, // x - R
            0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, // y - B
            0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0 // z - G
        ];
        this.axesBuffer = this.renderer.handler.createArrayBuffer(new Float32Array(vertices), 3, 6);
        this.axesColorBuffer = this.renderer.handler.createArrayBuffer(new Float32Array(colors), 4, 6);
    }
}

/**
 * @module og/segment/SegmentHelper
 */
function NewIndexesTypedArray(arr) {
    return new Uint32Array(arr);
}
function NewIndexesTypedArrayEmpty(size) {
    return new Uint32Array(size);
}
function createCenterBodyIndexes(size) {
    let indexes = [];
    let i0 = 1, j0 = 1;
    let i1 = 1, j1 = 1;
    let ind1 = 0, ind2 = 0, nr = 0;
    for (let i = i0; i < size - 1 - i1; i++) {
        for (let j = j0; j < size - j1; j++) {
            ind1 = i * size + j;
            nr = (i + 1) * size;
            ind2 = nr + j;
            indexes.push(ind1, ind2);
        }
        indexes.push(ind2, nr + j0);
    }
    indexes.push(indexes[indexes.length - 1], size * size - size);
    return NewIndexesTypedArray(indexes);
}
function createWestNeighborSkirt(size, deltaGr) {
    let indexes = [];
    const grCount = (size - 1) / deltaGr;
    const b = size * size - size;
    let k = 0;
    for (let i = 0; i < size - 2; i++) {
        if (i % grCount === 0) {
            k = i;
        }
        let rind = b - size * i - size + 1, lind = b - size * k;
        indexes.push(lind, rind);
    }
    if (deltaGr === (size - 1)) {
        indexes.push(size);
        indexes.push(0);
    }
    return NewIndexesTypedArray(indexes);
}
function createNorthNeighborSkirt(size, deltaGr) {
    let indexes = [];
    const grCount = (size - 1) / deltaGr;
    let k = 0;
    for (let i = 0; i < size - 2; i++) {
        if (i % grCount === 0) {
            k = i;
        }
        let rind = size + i + 1, lind = k;
        indexes.push(lind, rind);
    }
    if (deltaGr === (size - 1)) {
        indexes.push(size - 2);
        indexes.push(size - 1);
    }
    return NewIndexesTypedArray(indexes);
}
function createEastNeighborSkirt(size, deltaGr) {
    let indexes = [];
    const grCount = (size - 1) / deltaGr;
    let k = 0;
    for (let i = 0; i < size - 2; i++) {
        if (i % grCount === 0) {
            k = i;
        }
        let rind = size * (i + 1) + size - 2, lind = size + size * k - 1;
        indexes.push(lind, rind);
    }
    if (deltaGr === (size - 1)) {
        indexes.push(size * (size - 1) - 1);
        indexes.push(size * size - 1);
    }
    return NewIndexesTypedArray(indexes);
}
function createSouthNeighborSkirt(size, deltaGr) {
    let indexes = [];
    const grCount = (size - 1) / deltaGr;
    let k = 0;
    const rb = size * (size - 1) - 2;
    const lb = size * size - 1;
    for (let i = 0; i < size - 2; i++) {
        if (i % grCount === 0) {
            k = i;
        }
        let rind = rb - i, lind = lb - k;
        indexes.push(lind, rind);
    }
    if (deltaGr === (size - 1)) {
        indexes.push(size * size - size + 1);
    }
    indexes.push(size * size - size);
    return NewIndexesTypedArray(indexes);
}
function initIndexesBodySkirts(pow) {
    let table = [[], [], [], []];
    for (let i = 0; i <= pow; i++) {
        let d = Math.pow(2, i), d1 = d + 1;
        table[N][i] = [];
        table[W][i] = [];
        table[S][i] = [];
        table[E][i] = [];
        for (let j = 0; j <= pow; j++) {
            let dd = Math.pow(2, j);
            table[W][i][j] = createWestNeighborSkirt(d1, dd);
            table[N][i][j] = createNorthNeighborSkirt(d1, dd);
            table[E][i][j] = createEastNeighborSkirt(d1, dd);
            table[S][i][j] = createSouthNeighborSkirt(d1, dd);
        }
    }
    return table;
}
function initIndexBodiesTable(pow) {
    let table = [];
    for (let i = 0; i <= pow; i++) {
        const d = Math.pow(2, i);
        table[i] = createCenterBodyIndexes(d + 1);
    }
    return table;
}
function createTextureCoords(size) {
    let texCoords = new Uint16Array((size + 1) * (size + 1) * 2);
    let k = 0;
    for (let i = 0; i <= size; i++) {
        for (let j = 0; j <= size; j++) {
            texCoords[k++] = j / size * 0xFFFF;
            texCoords[k++] = i / size * 0xFFFF;
        }
    }
    return texCoords;
}
class SegmentHelper {
    constructor(maxGridSize = 0) {
        this._maxGridSize = maxGridSize;
        this.centerIndexesTable = initIndexBodiesTable(this._maxGridSize);
        this.skirtsIndexesTable = initIndexesBodySkirts(this._maxGridSize);
    }
    get maxGridSize() {
        return this._maxGridSize;
    }
    init() {
        this.centerIndexesTable = initIndexBodiesTable(this._maxGridSize);
        this.skirtsIndexesTable = initIndexesBodySkirts(this._maxGridSize);
    }
    setMaxGridSize(gridSize) {
        this._maxGridSize = gridSize;
        this.init();
    }
    createSegmentIndexes(size, sidesSizes) {
        if (size) {
            let c = this.centerIndexesTable[size], w = this.skirtsIndexesTable[W][size][sidesSizes[W]], n = this.skirtsIndexesTable[N][size][sidesSizes[N]], e = this.skirtsIndexesTable[E][size][sidesSizes[E]], s = this.skirtsIndexesTable[S][size][sidesSizes[S]];
            let indexes = NewIndexesTypedArrayEmpty(c.length + w.length + n.length + e.length + s.length);
            indexes.set(c, 0);
            indexes.set(w, c.length);
            indexes.set(n, c.length + w.length);
            indexes.set(e, c.length + w.length + n.length);
            indexes.set(s, c.length + w.length + n.length + e.length);
            return indexes;
        }
        else {
            return NewIndexesTypedArray([0, 2, 1, 3]);
        }
    }
    initTextureCoordsTable(pow) {
        let table = [];
        for (let i = 0; i <= pow; i++) {
            const d = Math.pow(2, i);
            table[i] = createTextureCoords(d);
        }
        return table;
    }
}
let instance = new SegmentHelper();
function getInstance() {
    return instance;
}

const UTILS = `
    float getLerpValue(in float min, in float max, in float between)
    {
        return (clamp(between, min, max) - min) / (max - min);
    }
    
    vec3 aces(vec3 color) 
    {
        float a = 2.51;
        float b = 0.03;
        float c = 2.43;
        float d = 0.59;
        float e = 0.14;
        return clamp((color * (a * color + b)) / (color * (c * color + d ) + e), 0.0, 1.0);
    }
     
    bool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t1, inout float t2) 
    {
        float b = dot(rayDirection, rayOrigin);
        float c = dot(rayOrigin, rayOrigin) - radius * radius;
        float d = b * b - c;
        if (d < 0.0) {
            return false;
        }
        t1 = -b - sqrt(d);
        t2 = -b + sqrt(d);
        return true;
    }
    
    bool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t) 
    {
        float b = dot(rayDirection, rayOrigin);
        float c = dot(rayOrigin, rayOrigin) - radius * radius;
        float d = b * b - c;
        if (d < 0.0) {
            return false;
        }
        t = -b - sqrt(d);
        return true;
    }
    
    bool intersectEllipsoid( in vec3 ro, in vec3 rd, in vec3 ra, inout float t )
    {
        vec3 ocn = ro/ra;
        vec3 rdn = rd/ra;
        float a = dot( rdn, rdn );
        float b = dot( ocn, rdn );
        float c = dot( ocn, ocn );
        float h = b*b - a*(c-1.0);
                       
        if (h < 0.0) 
        { 
            return false; 
        }
        
        t = (-b-sqrt(h))/a;
        
        return true;
    }
    
    bool intersectEllipsoid( in vec3 ro, in vec3 rd, in vec3 ra, inout float t1, inout float t2)
    {
        vec3 ocn = ro/ra;
        vec3 rdn = rd/ra;
        float a = dot( rdn, rdn );
        float b = dot( ocn, rdn );
        float c = dot( ocn, ocn );
        float h = b*b - a*(c-1.0);
                
        if (h < 0.0) 
        { 
            return false; 
        }
        
        h = sqrt(h);
        t1 = (-b-h)/a;
        t2 = (-b+h)/a;
        
        return true;
    }
    
    vec3 normalEllipsoid( in vec3 pos, in vec3 ra )
    {
        return normalize( pos/(ra*ra) );
    }
`;

const DEFAULT_PARAMS = {
    ATMOS_HEIGHT: 100000.0,
    RAYLEIGH_SCALE: 0.08,
    MIE_SCALE: 0.012,
    GROUND_ALBEDO: 0.05,
    BOTTOM_RADIUS: 6356752.3142451793,
    rayleighScatteringCoefficient: [5.802, 13.558, 33.100],
    mieScatteringCoefficient: 3.996,
    mieExtinctionCoefficient: 4.440,
    ozoneAbsorptionCoefficient: [0.650, 1.881, 0.085],
    SUN_ANGULAR_RADIUS: 0.004685,
    SUN_INTENSITY: 1.0,
    ozoneDensityHeight: 25e3,
    ozoneDensityWide: 15e3,
};
const COMMON = (atmosParams = DEFAULT_PARAMS) => `    
    ${UTILS}
    
    #define PI 3.1415926538
    #define ATMOS_HEIGHT ${atmosParams.ATMOS_HEIGHT.toFixed(2)}
    #define RAYLEIGH_SCALE ${atmosParams.RAYLEIGH_SCALE.toFixed(5)}
    #define MIE_SCALE ${atmosParams.MIE_SCALE.toFixed(5)}
    
    #define SAMPLE_COUNT 16
    #define SQRT_SAMPLE_COUNT 4
            
    const float GROUND_ALBEDO = ${atmosParams.GROUND_ALBEDO.toFixed(2)} / PI;

    // Sphere
    const float BOTTOM_RADIUS = ${atmosParams.BOTTOM_RADIUS.toFixed(10)};
    const float TOP_RADIUS = BOTTOM_RADIUS + ATMOS_HEIGHT;   
    const float EQUATORIAL_RADIUS = 6378137.0;
    
    // Ellipsoid
    const vec3 bottomRadii = vec3(EQUATORIAL_RADIUS, EQUATORIAL_RADIUS, BOTTOM_RADIUS);           
    const vec3 topRadii = bottomRadii + ATMOS_HEIGHT;
    
    const vec3 SPHERE_TO_ELLIPSOID_SCALE = vec3(BOTTOM_RADIUS) / bottomRadii;           
    
    const vec2 rayleighMieHeights = vec2(RAYLEIGH_SCALE, MIE_SCALE) * ATMOS_HEIGHT;
     
    const vec3 rayleighScatteringCoefficient = vec3(${atmosParams.rayleighScatteringCoefficient[0].toFixed(5)}, ${atmosParams.rayleighScatteringCoefficient[1].toFixed(5)}, ${atmosParams.rayleighScatteringCoefficient[2].toFixed(5)}) * 1e-6;
    
    const float mieScatteringCoefficient = ${atmosParams.mieScatteringCoefficient.toFixed(3)} * 1e-6;
    const float mieExtinctionCoefficient = ${atmosParams.mieExtinctionCoefficient.toFixed(3)} * 1e-6;
    const vec3 ozoneAbsorptionCoefficient = vec3(${atmosParams.ozoneAbsorptionCoefficient[0].toFixed(5)}, ${atmosParams.ozoneAbsorptionCoefficient[1].toFixed(5)}, ${atmosParams.ozoneAbsorptionCoefficient[2].toFixed(5)}) * 1e-6;
    
    const float SUN_ANGULAR_RADIUS = ${atmosParams.SUN_ANGULAR_RADIUS.toFixed(10)};
    const float SUN_INTENSITY = ${atmosParams.SUN_INTENSITY.toFixed(2)};        
    
    const float ozoneDensityHeight = ${atmosParams.ozoneDensityHeight.toFixed(1)};//25e3;
    const float ozoneDensityWide = ${atmosParams.ozoneDensityWide.toFixed(1)};//15e3;
    
    vec3 sunWithBloom(vec3 rayDir, vec3 sunDir) 
    {
        float minSunCosTheta = cos(SUN_ANGULAR_RADIUS);            
        float cosTheta = dot(rayDir, sunDir);
        if (cosTheta >= minSunCosTheta) return vec3(1.0);                
        float offset = minSunCosTheta - cosTheta;
        float gaussianBloom = exp(-offset*15000.0)*0.7;
        float invBloom = 1.0/(0.09 + offset*200.0)*0.01;
        return vec3(gaussianBloom + invBloom);
    }
    
    float rayleighPhase(float angle) 
    {
        return 3.0 / (16.0 * PI) * (1.0 + (angle * angle));
    }
    
    float miePhase(float angle) 
    {
        float g = 0.8;
        return 3.0 / (8.0 * PI) * ((1.0 - g * g) * (1.0 + angle * angle)) / ((2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * angle, 1.5));
    }
        
    vec3 opticalDepth(float height, float angle) 
    {
        vec3 rayOrigin = vec3(0.0, BOTTOM_RADIUS + height, 0.0);
        vec3 rayDirection = vec3(sqrt(1.0 - angle * angle), angle, 0.0);
        float t1, t2;
        intersectSphere(rayOrigin, rayDirection, TOP_RADIUS, t1, t2);
        float segmentLength = t2 / float(SAMPLE_COUNT);
        
        float t = segmentLength * 0.5;
        vec3 opticalDepth = vec3(0.0);
        
        for (int i = 0; i < SAMPLE_COUNT; i++) 
        {
            vec3 position = rayOrigin + t * rayDirection;
            float height = length(position) - BOTTOM_RADIUS;
            opticalDepth.xy += exp(-height / rayleighMieHeights) * segmentLength;
            opticalDepth.z += (1.0 - min(abs(height - ozoneDensityHeight) / ozoneDensityWide, 1.0)) * segmentLength;  
            t += segmentLength;
        }
        
        return opticalDepth;
    }
    
    vec3 transmittance(float height, float angle) 
    {
        vec3 opticalDepth = opticalDepth(height, angle);
        return exp(-(rayleighScatteringCoefficient * opticalDepth.x + mieExtinctionCoefficient * opticalDepth.y + ozoneAbsorptionCoefficient * opticalDepth.z));
    }`;
function transmittance(atmosParams) {
    return new Program("transmittance", {
        uniforms: {
            iResolution: "vec2"
        },
        attributes: {
            a_position: "vec2"
        },
        vertexShader: `
            attribute vec2 a_position;
            
            void main(void) 
            {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }`,
        fragmentShader: `
            precision highp float;
            
            ${COMMON(atmosParams)}
                       
            uniform vec2 iResolution;
                        
            void main(void) 
            {
                vec2 uv = gl_FragCoord.xy / iResolution.xy;
                float height = uv.y * ATMOS_HEIGHT;
                float angle = uv.x * 2.0 - 1.0;
                gl_FragColor = vec4(transmittance(height, angle), 1.0);
            }`
    });
}
function scattering(atmosParams) {
    return new Program("scattering", {
        uniforms: {
            iResolution: "vec2",
            transmittanceTexture: "sampler2d"
        },
        attributes: {
            a_position: "vec2"
        },
        vertexShader: `            
            attribute vec2 a_position;  
                      
            void main(void) 
            {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }`,
        fragmentShader: `            
            precision highp float;
            
            uniform sampler2D transmittanceTexture;
            uniform vec2 iResolution;
            
            ${COMMON(atmosParams)}
            
            vec3 transmittanceFromTexture(float height, float angle) 
            {
                float u = (angle + 1.0) * 0.5;
                float v = height / ATMOS_HEIGHT;
                return texture2D(transmittanceTexture, vec2(u, v)).xyz;
            }
                                   
            void main(void) 
            {
                vec2 uv = gl_FragCoord.xy / iResolution.xy;
                
                float height = uv.y * ATMOS_HEIGHT;
                float angle = uv.x * 2.0 - 1.0;
                
                vec3 rayOrigin = vec3(0.0, BOTTOM_RADIUS + height, 0.0);
                vec3 up = rayOrigin / length(rayOrigin);
                vec3 lightDirection = vec3(sqrt(1.0 - angle * angle), angle, 0.0);
                                
                const float isotropicPhase = 1.0 / (4.0 * PI);
                
                vec3 light = vec3(0.0);
                vec3 lightTransferFactor = vec3(0.0);
                
                for (int i = 0; i < SQRT_SAMPLE_COUNT; i++)
                {
                    for (int j = 0; j < SQRT_SAMPLE_COUNT; j++)
                    {
                        float u = ((0.5 + float(i)) / float(SQRT_SAMPLE_COUNT)) * 2.0 - 1.0;
                        float v = (0.5 + float(j)) / float(SQRT_SAMPLE_COUNT);
                        float r = sqrt(1.0 - u * u);
                        float theta = 2.0 * PI * v;
                        vec3 rayDirection = vec3(cos(theta) * r, sin(theta) * r, u);
                                                
                        float rayAngle = dot(up, rayDirection);
                        bool cameraBelow = rayAngle < 0.0;
                        
                        vec3 transmittanceFromCameraToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);
                        
                        float offset = 0.0;
                        float distanceToSpace = 0.0;
                        
                        intersectSphere(rayOrigin, rayDirection, TOP_RADIUS, offset, distanceToSpace);
                        
                        float distanceToGround = 0.0;
                        bool hitGround = intersectSphere(rayOrigin, rayDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround > 0.0;                        
                        float segmentLength = (hitGround ? distanceToGround : distanceToSpace) / float(SAMPLE_COUNT);
                        float t = segmentLength * 0.5;
                        
                        vec3 transmittanceCamera;
                        vec3 transmittanceLight;
                         
                        for (int k = 0; k < SAMPLE_COUNT; k++) 
                        {
                            vec3 position = rayOrigin + t * rayDirection;
                            float height = length(position) - BOTTOM_RADIUS;
                            vec3 up = position / length(position);
                            float rayAngle = dot(up, rayDirection);
                            float lightAngle = dot(up, lightDirection);
                            
                            float distanceToGround;
                            float shadow = intersectSphere(position, lightDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround >= 0.0 ? 0.0 : 1.0;
                            vec3 transmittanceToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);
                            
                            transmittanceCamera = cameraBelow ? (transmittanceToSpace / transmittanceFromCameraToSpace) : (transmittanceFromCameraToSpace / transmittanceToSpace);
                            transmittanceLight = transmittanceFromTexture(height, lightAngle);
                            
                            vec2 opticalDensity = exp(-height / rayleighMieHeights);        
                            vec3 scatteredLight = transmittanceLight * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y) * isotropicPhase;
                            
                            light += shadow * transmittanceCamera * scatteredLight * segmentLength;
                            lightTransferFactor += transmittanceCamera * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y) * segmentLength;
                            
                            t += segmentLength;
                        }
                    
                        if (hitGround) 
                        {
                            vec3 hitPoint = rayOrigin + rayDirection * distanceToGround;
                            vec3 normal = normalize(hitPoint);
                            float diffuseAngle = max(dot(normal, lightDirection), 0.0); 
                            light += transmittanceCamera * transmittanceLight * GROUND_ALBEDO * diffuseAngle;
                        }
                    }
                }
                
                light /= float(SAMPLE_COUNT);
                lightTransferFactor /= float(SAMPLE_COUNT);
                vec3 color = light / (1.0 - lightTransferFactor);                 
                gl_FragColor = vec4(color, 1.0);
            }`
    });
}
// const vec3 solar_irradiance = vec3(1.474000,1.850400,1.911980);
// float GetTextureCoordFromUnitRange(float x, int texture_size) {
//     return 0.5 / float(texture_size) + x * (1.0 - 1.0 / float(texture_size));
// }
//
// float ClampDistance(float d) {
//     return max(d, 0.0 * m);
// }
//
// float SafeSqrt(float a) {
//     return sqrt(max(a, 0.0 * m2));
// }
// float DistanceToTopAtmosphereBoundary(float r, float mu) {
//
//     //assert(r <= atmosphere.top_radius);
//     //assert(mu >= -1.0 && mu <= 1.0);
//
//     float discriminant = r * r * (mu * mu - 1.0) + TOP_RADIUS * TOP_RADIUS;
//     return ClampDistance(-r * mu + SafeSqrt(discriminant));
// }
// vec2 GetTransmittanceTextureUvFromRMu(
//     float r,
//     float mu)
// {
//     //assert(r >= atmosphere.BOTTOM_RADIUS && r <= TOP_RADIUS);
//     //assert(mu >= -1.0 && mu <= 1.0);
//
//     float H = sqrt(TOP_RADIUS * TOP_RADIUS - BOTTOM_RADIUS * BOTTOM_RADIUS);
//     float rho = SafeSqrt(r * r - BOTTOM_RADIUS * BOTTOM_RADIUS);
//     float d = DistanceToTopAtmosphereBoundary(r, mu);
//     float d_min = TOP_RADIUS - r;
//     float d_max = rho + H;
//     float x_mu = (d - d_min) / (d_max - d_min);
//     float x_r = rho / H;
//
//     return vec2(
//         GetTextureCoordFromUnitRange(x_mu, TRANSMITTANCE_TEXTURE_WIDTH),
//         GetTextureCoordFromUnitRange(x_r, TRANSMITTANCE_TEXTURE_HEIGHT)
//     );
// }
// vec3 GetTransmittanceToTopAtmosphereBoundary(in sampler2D transmittance_texture, float r, float mu)
// {
//     //assert(r >= BOTTOM_RADIUS && r <= TOP_RADIUS);
//
//     vec2 uv = GetTransmittanceTextureUvFromRMu(r, mu);
//     return texture(transmittance_texture, uv).xyz;
// }
// vec3 GetTransmittanceToSun(
//     in sampler2D transmittance_texture,
//     float r,
//     float mu_s)
// {
//     float sin_theta_h = BOTTOM_RADIUS / r;
//     float cos_theta_h = -sqrt(max(1.0 - sin_theta_h * sin_theta_h, 0.0));
//
//     return GetTransmittanceToTopAtmosphereBoundary(transmittance_texture, r, mu_s) * smoothstep(
//         -sin_theta_h * SUN_ANGULAR_RADIUS / rad, sin_theta_h * SUN_ANGULAR_RADIUS / rad,
//         mu_s - cos_theta_h
//     );
// }
// vec3 GetSunAndSkyIrradiance(
//     in sampler2D transmittance_texture,
//     in vec3 point,
//     in vec3 normal,
//     in vec3 sun_direction,
//     out vec3 sky_irradiance)
// {
//     float r = length(point);
//     float mu_s = dot(point, sun_direction) / r;
//
//     sky_irradiance = vec3(0.0);  // GetIrradiance(atmosphere, irradiance_texture, r, mu_s) * (1.0 + dot(normal, point) / r) * 0.5;
//
//     return solar_irradiance * GetTransmittanceToSun(transmittance_texture, r, mu_s) * max(dot(normal, sun_direction), 0.0);
// }

// REMEMBER!
// src*(1)+dest*(1-src.alpha)
// glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
// src*(src.alpha)+dest*(1-src.alpha)
// glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
const NIGHT = `const vec3 nightStep = 10.0 * vec3(0.58, 0.48, 0.25);`;
const DEF_BLEND = `#define blend(DEST, SAMPLER, OFFSET, OPACITY) \
                    src = texture( SAMPLER, OFFSET.xy + vTextureCoord.xy * OFFSET.zw );\
                    DEST = DEST * (1.0 - src.a * OPACITY) + src * OPACITY;`;
const DEF_BLEND_WEBGL1 = `#define blend(DEST, SAMPLER, OFFSET, OPACITY) \
                            src = texture2D( SAMPLER, OFFSET.xy + vTextureCoord.xy * OFFSET.zw ); \
                            DEST = DEST * (1.0 - src.a * OPACITY) + src * OPACITY;`;
const DEF_BLEND_PICKING = `#define blendPicking(DEST, OFFSET, SAMPLER, MASK, COLOR, OPACITY) \
    tc = OFFSET.xy + vTextureCoord.xy * OFFSET.zw; \
    t = texture2D(SAMPLER, tc); \
    p = texture2D(MASK, tc); \
    DEST = mix(DEST, vec4(max(COLOR.rgb, p.rgb), OPACITY), (t.a == 0.0 ? 0.0 : 1.0) * COLOR.a);`;
const SLICE_SIZE = 4;
function drawnode_screen_nl() {
    return new Program("drawnode_screen_nl", {
        uniforms: {
            projectionMatrix: "mat4",
            viewMatrix: "mat4",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            samplerCount: "int",
            tileOffsetArr: "vec4",
            layerOpacityArr: "float",
            samplerArr: "sampler2darray",
            defaultTexture: "sampler2d",
            height: "float"
        }, attributes: {
            aVertexPositionHigh: "vec3",
            aVertexPositionLow: "vec3",
            aTextureCoord: "vec2"
        },
        vertexShader: `precision highp float;
            
            attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;
            attribute vec2 aTextureCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            varying vec2 vTextureCoord;

            void main(void) {

                vTextureCoord = aTextureCoord;
                vec3 nh = height * normalize(aVertexPositionHigh + aVertexPositionLow);

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);
                mat4 m = projectionMatrix * viewMatrixRTE;
        
                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;
                
                // This is works for Mac Chrome, prevent some weird optimization I suppose
                gl_Position =  m * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);
            }`,
        fragmentShader: `precision highp float;
            #define SLICE_SIZE ${SLICE_SIZE + 1}
            uniform vec4 tileOffsetArr[SLICE_SIZE];
            uniform float layerOpacityArr[SLICE_SIZE];
            uniform sampler2D defaultTexture;
            uniform sampler2D samplerArr[SLICE_SIZE];
            uniform int samplerCount;
            varying vec2 vTextureCoord;

            ${DEF_BLEND_WEBGL1}

            void main(void) {
                gl_FragColor = texture2D( defaultTexture, vTextureCoord );
                if( samplerCount == 0 ) return;

                vec4 src;

                blend(gl_FragColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);
                if( samplerCount == 1 ) return;

                blend(gl_FragColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);
                if( samplerCount == 2 ) return;

                blend(gl_FragColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);
                if( samplerCount == 3 ) return;

                blend(gl_FragColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);
                if( samplerCount == 4 ) return;

                blend(gl_FragColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);
            }`
    });
}
function drawnode_screen_wl_webgl1NoAtmos() {
    return new Program("drawnode_screen_wl", {
        uniforms: {
            projectionMatrix: "mat4",
            viewMatrix: "mat4",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            height: "float",
            uGlobalTextureCoord: "vec4",
            uNormalMapBias: "vec3",
            samplerCount: "int",
            tileOffsetArr: "vec4",
            layerOpacityArr: "float",
            samplerArr: "sampler2darray",
            defaultTexture: "sampler2d",
            uNormalMap: "sampler2d",
            nightTexture: "sampler2d",
            specularTexture: "sampler2d",
            lightsPositions: "vec3",
            diffuse: "vec3",
            ambient: "vec3",
            specular: "vec4",
            camHeight: "float",
            nightTextureCoefficient: "float"
        }, attributes: {
            aVertexPositionHigh: "vec3",
            aVertexPositionLow: "vec3",
            aTextureCoord: "vec2"
        },
        vertexShader: `
            attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;
            attribute vec2 aTextureCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec4 uGlobalTextureCoord;
            uniform vec3 uNormalMapBias;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            varying vec4 vTextureCoord;
            varying vec3 v_vertex;
            varying vec3 cameraPosition;
            varying vec2 vGlobalTextureCoord;
            varying float v_height;

            void main(void) {

                vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;                
                vec3 nh = height * normalize(aVertexPosition);

                vTextureCoord.xy = aTextureCoord;
                vGlobalTextureCoord = uGlobalTextureCoord.xy + (uGlobalTextureCoord.zw - uGlobalTextureCoord.xy) * aTextureCoord;
                vTextureCoord.zw = uNormalMapBias.z * ( aTextureCoord + uNormalMapBias.xy );

                cameraPosition = eyePositionHigh + eyePositionLow;
                
                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                v_height = height;
                v_vertex = aVertexPosition + nh;
                            
                gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);
            }`,
        fragmentShader: `
            precision highp float;
            
            #define MAX_POINT_LIGHTS 1
            #define SLICE_SIZE ${SLICE_SIZE + 1}

            uniform vec4 specular;
            uniform vec3 diffuse;
            uniform vec3 ambient;

            uniform sampler2D uNormalMap;
            uniform sampler2D nightTexture;
            uniform sampler2D specularTexture;
            uniform sampler2D defaultTexture;
            uniform sampler2D samplerArr[SLICE_SIZE];

            uniform vec4 tileOffsetArr[SLICE_SIZE];
            uniform vec3 lightsPositions[MAX_POINT_LIGHTS];
            uniform float layerOpacityArr[SLICE_SIZE];

            uniform int samplerCount;
            uniform float nightTextureCoefficient;              
            uniform float camHeight;

            varying vec4 vTextureCoord;
            varying vec3 v_vertex;
            varying vec3 cameraPosition;
            varying vec2 vGlobalTextureCoord;
            varying float v_height;

            vec3 sunPos;

            ${NIGHT}

            ${DEF_BLEND_WEBGL1}
            
            ${UTILS}
                                               
            void main(void) {
            
                sunPos = lightsPositions[0];
                                
                vec3 texNormal = texture2D(uNormalMap, vTextureCoord.zw).rgb;
                vec3 normal = normalize((texNormal - 0.5) * 2.0);
                
                float minH = 1200000.0;
                float maxH = minH * 3.0;
                float nightCoef = getLerpValue(minH, maxH, camHeight) * nightTextureCoefficient;
                                
                // if(camHeight > 6000000.0)
                // {
                //     normal = normalize(v_vertex);
                // }
                                            
                vec3 lightDir = normalize(sunPos);
                vec3 viewDir = normalize(cameraPosition - v_vertex);
                                                
                float overGround = 1.0 - step(0.1, v_height);

                float shininess = texture2D( specularTexture, vGlobalTextureCoord.st ).r * 255.0 * overGround;
                vec3 reflectionDirection = reflect(-lightDir, normal);
                float reflection = max( dot(reflectionDirection, viewDir), 0.0);
                vec3 spec = specular.rgb * pow( reflection, specular.w) * shininess;                
                float diffuseLightWeighting = max(dot(normal, lightDir), 0.0);                
                vec4 nightImageColor = texture2D( nightTexture, vGlobalTextureCoord.st );
                vec3 night = nightStep * (.18 - diffuseLightWeighting * 3.0) * nightImageColor.rgb * nightCoef;
                night *= overGround * step(0.0, night);                
                vec4 lightWeighting = vec4(ambient + diffuse * diffuseLightWeighting + night, 1.0);
                
                gl_FragColor = texture2D( defaultTexture, vTextureCoord.xy );
                if( samplerCount == 0 ) {
                    gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);
                    return;
                }

                vec4 src;

                blend(gl_FragColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);
                if( samplerCount == 1 ) {                
                    gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);
                    return;
                }

                blend(gl_FragColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);
                if( samplerCount == 2 ) {
                    gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);
                    return;
                }

                blend(gl_FragColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);
                if( samplerCount == 3 ) {
                    gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);
                    return;
                }

                blend(gl_FragColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);
                if( samplerCount == 4 ) {
                    gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);
                    return;
                }

                blend(gl_FragColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);
                gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);
            }`
    });
}
function drawnode_screen_wl_webgl2NoAtmos() {
    return new Program("drawnode_screen_wl", {
        uniforms: {
            projectionMatrix: "mat4",
            viewMatrix: "mat4",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            height: "float",
            uGlobalTextureCoord: "vec4",
            uNormalMapBias: "vec3",
            samplerCount: "int",
            tileOffsetArr: "vec4",
            layerOpacityArr: "float",
            samplerArr: "sampler2darray",
            defaultTexture: "sampler2d",
            uNormalMap: "sampler2d",
            nightTexture: "sampler2d",
            specularTexture: "sampler2d",
            lightsPositions: "vec3",
            diffuse: "vec3",
            ambient: "vec3",
            specular: "vec4",
            camHeight: "float",
            nightTextureCoefficient: "float",
            transitionOpacity: "float"
        }, attributes: {
            aVertexPositionHigh: "vec3",
            aVertexPositionLow: "vec3",
            aTextureCoord: "vec2"
        },
        vertexShader: `#version 300 es

            precision highp float;

            in vec3 aVertexPositionHigh;
            in vec3 aVertexPositionLow;
            in vec2 aTextureCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec4 uGlobalTextureCoord;
            uniform vec3 uNormalMapBias;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            out vec4 vTextureCoord;
            out vec3 v_vertex;
            out vec3 cameraPosition;
            out vec2 vGlobalTextureCoord;
            out float v_height;

            void main(void) {

                vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;                
                vec3 nh = height * normalize(aVertexPosition);
                
                vTextureCoord.xy = aTextureCoord;
                vGlobalTextureCoord = uGlobalTextureCoord.xy + (uGlobalTextureCoord.zw - uGlobalTextureCoord.xy) * aTextureCoord;
                vTextureCoord.zw = uNormalMapBias.z * ( aTextureCoord + uNormalMapBias.xy );

                cameraPosition = eyePositionHigh + eyePositionLow;
                
                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                v_height = height;
                v_vertex = aVertexPosition + nh;
                            
                gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);
            }`,
        fragmentShader: `#version 300 es

            precision highp float;
            
            #define MAX_POINT_LIGHTS 1
            #define SLICE_SIZE ${SLICE_SIZE + 1}

            uniform vec4 specular;
            uniform vec3 diffuse;
            uniform vec3 ambient;  

            uniform sampler2D uNormalMap;
            uniform sampler2D nightTexture;
            uniform sampler2D specularTexture;
            uniform sampler2D defaultTexture;
            uniform sampler2D samplerArr[SLICE_SIZE];

            uniform vec4 tileOffsetArr[SLICE_SIZE];
            uniform vec3 lightsPositions[MAX_POINT_LIGHTS];
            uniform float layerOpacityArr[SLICE_SIZE];

            uniform int samplerCount;
            uniform float nightTextureCoefficient;
            
            uniform float transitionOpacity;
                
            uniform float camHeight;

            in vec4 vTextureCoord;
            in vec3 v_vertex;
            in vec3 cameraPosition;
            in vec2 vGlobalTextureCoord;
            in float v_height;

            vec3 sunPos;

            layout(location = 0) out vec4 diffuseColor;

            ${NIGHT}

            ${DEF_BLEND}
            
            ${UTILS}
                                               
            void main(void) {
            
                sunPos = lightsPositions[0];
                                
                vec3 texNormal = texture(uNormalMap, vTextureCoord.zw).rgb;
                vec3 normal = normalize((texNormal - 0.5) * 2.0);
                
                float minH = 1200000.0;
                float maxH = minH * 3.0;
                float nightCoef = getLerpValue(minH, maxH, camHeight) * nightTextureCoefficient;
                                
                // if(camHeight > 6000000.0)
                // {
                //     normal = normalize(v_vertex);
                // }
                                            
                vec3 lightDir = normalize(sunPos);
                vec3 viewDir = normalize(cameraPosition - v_vertex);
                                                
                float overGround = 1.0 - step(0.1, v_height);

                float shininess = texture( specularTexture, vGlobalTextureCoord.st ).r * 255.0 * overGround;
                vec3 reflectionDirection = reflect(-lightDir, normal);
                float reflection = max( dot(reflectionDirection, viewDir), 0.0);
                vec3 spec = specular.rgb * pow( reflection, specular.w) * shininess;                
                float diffuseLightWeighting = max(dot(normal, lightDir), 0.0);                
                vec4 nightImageColor = texture( nightTexture, vGlobalTextureCoord.st );
                vec3 night = nightStep * (.18 - diffuseLightWeighting * 3.0) * nightImageColor.rgb * nightCoef;
                night *= overGround * step(0.0, night);                
                vec4 lightWeighting = vec4(ambient + diffuse * diffuseLightWeighting + night, 1.0);
                
                diffuseColor = texture( defaultTexture, vTextureCoord.xy );
                
                if( samplerCount == 0 ) {
                    diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                vec4 src;

                blend(diffuseColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);
                if( samplerCount == 1 ) {                
                    diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);
                if( samplerCount == 2 ) {
                    diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);
                if( samplerCount == 3 ) {
                    diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);
                if( samplerCount == 4 ) {
                    diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);
                diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);
                diffuseColor *= transitionOpacity;
            }`
    });
}
function drawnode_screen_wl_webgl2Atmos(atmosParams) {
    return new Program("drawnode_screen_wl", {
        uniforms: {
            projectionMatrix: "mat4",
            viewMatrix: "mat4",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            height: "float",
            uGlobalTextureCoord: "vec4",
            uNormalMapBias: "vec3",
            samplerCount: "int",
            tileOffsetArr: "vec4",
            layerOpacityArr: "float",
            samplerArr: "sampler2darray",
            defaultTexture: "sampler2d",
            uNormalMap: "sampler2d",
            nightTexture: "sampler2d",
            specularTexture: "sampler2d",
            lightsPositions: "vec3",
            diffuse: "vec3",
            ambient: "vec3",
            specular: "vec4",
            transmittanceTexture: "sampler2D",
            scatteringTexture: "sampler2D",
            camHeight: "float",
            nightTextureCoefficient: "float",
            maxMinOpacity: "vec2",
            transitionOpacity: "float"
        }, attributes: {
            aVertexPositionHigh: "vec3",
            aVertexPositionLow: "vec3",
            aTextureCoord: "vec2"
        },
        vertexShader: `#version 300 es

            precision highp float;

            in vec3 aVertexPositionHigh;
            in vec3 aVertexPositionLow;
            in vec2 aTextureCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec4 uGlobalTextureCoord;
            uniform vec3 uNormalMapBias;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            out vec4 vTextureCoord;
            out vec3 v_vertex;
            out vec3 cameraPosition;
            out vec2 vGlobalTextureCoord;
            out float v_height;

            void main(void) {

                vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;                
                vec3 nh = height * normalize(aVertexPosition);

                vTextureCoord.xy = aTextureCoord;
                vGlobalTextureCoord = uGlobalTextureCoord.xy + (uGlobalTextureCoord.zw - uGlobalTextureCoord.xy) * aTextureCoord;
                vTextureCoord.zw = uNormalMapBias.z * ( aTextureCoord + uNormalMapBias.xy );

                cameraPosition = eyePositionHigh + eyePositionLow;
                
                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                v_height = height;
                v_vertex = aVertexPosition + nh;
                            
                gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);
            }`,
        fragmentShader: `#version 300 es

            precision highp float;
            
            #define MAX_POINT_LIGHTS 1
            #define SLICE_SIZE ${SLICE_SIZE + 1}

            uniform vec4 specular;
            uniform vec3 diffuse;
            uniform vec3 ambient;

            uniform vec3 lightsPositions[MAX_POINT_LIGHTS];

            uniform sampler2D uNormalMap;
            uniform sampler2D nightTexture;
            uniform sampler2D specularTexture;
            uniform sampler2D transmittanceTexture;
            uniform sampler2D scatteringTexture;
            uniform sampler2D defaultTexture;
            uniform sampler2D samplerArr[SLICE_SIZE];

            uniform vec4 tileOffsetArr[SLICE_SIZE];
            uniform float layerOpacityArr[SLICE_SIZE];

            uniform int samplerCount;
            uniform float nightTextureCoefficient;
            
            uniform vec2 maxMinOpacity;                
            uniform float camHeight;
            
            uniform float transitionOpacity;

            in vec4 vTextureCoord;
            in vec3 v_vertex;
            in vec3 cameraPosition;
            in vec2 vGlobalTextureCoord;
            in float v_height;

            vec3 sunPos;

            layout(location = 0) out vec4 diffuseColor;

            ${NIGHT}

            ${DEF_BLEND}
            
            ${COMMON(atmosParams)}            
            
            vec3 transmittanceFromTexture(float height, float angle) 
            {
                float u = (angle + 1.0) * 0.5;
                float v = height / ATMOS_HEIGHT;
                return texture(transmittanceTexture, vec2(u, v)).xyz;
            }

            vec3 multipleScatteringContributionFromTexture(float height, float angle) 
            {
                float u = (angle + 1.0) * 0.5;
                float v = height / ATMOS_HEIGHT;
                return texture(scatteringTexture, vec2(u, v)).xyz;
            }
            
            void getSunIlluminance(in vec3 point, in vec3 lightDir, out vec3 sunIlluminance)
            {
                //     float r = length(point);
                //     float mu_s = dot(point, sun_direction) / r;
                //     float height = r - BOTTOM_RADIUS;
                
                float mu_s = dot(normalize(point), lightDir);
                float height = length(point) - BOTTOM_RADIUS;
                sunIlluminance = SUN_INTENSITY * transmittanceFromTexture(height, mu_s);
            }
           
            void atmosGroundColor(out vec4 fragColor, in vec3 normal)
            {      
                vec3 cameraPosition = cameraPosition;           
                
                if(length(cameraPosition * SPHERE_TO_ELLIPSOID_SCALE) < BOTTOM_RADIUS + 1.0){
                    cameraPosition = normalize(cameraPosition * SPHERE_TO_ELLIPSOID_SCALE) * (BOTTOM_RADIUS + 1.0) / SPHERE_TO_ELLIPSOID_SCALE;
                }             
                                                                                
                vec3 rayDirection = normalize(v_vertex - cameraPosition);
                vec3 lightDir = normalize(sunPos);
                
                rayDirection = normalize(rayDirection * SPHERE_TO_ELLIPSOID_SCALE);
                vec3 camPos = cameraPosition * SPHERE_TO_ELLIPSOID_SCALE;
                lightDir = normalize(lightDir * SPHERE_TO_ELLIPSOID_SCALE);
               

                vec3 light = vec3(0.0);
                vec3 transmittanceFromCameraToSpace = vec3(1.0);
                float offset = 0.0;
                float distanceToSpace = 0.0;
                
                intersectSphere(camPos, rayDirection, TOP_RADIUS, offset, distanceToSpace);
            
                vec3 rayOrigin = camPos;
                
                // above atmosphere
                if (offset > 0.0) 
                {
                    // intersection of camera ray with atmosphere
                    rayOrigin += rayDirection * offset;
                }
                
                float height = length(rayOrigin) - BOTTOM_RADIUS;
                float rayAngle = dot(rayOrigin, rayDirection) / length(rayOrigin);
                bool cameraBelow = rayAngle < 0.0;
                
                transmittanceFromCameraToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);
                
                float phaseAngle = dot(lightDir, rayDirection);
                float rayleighPhase = rayleighPhase(phaseAngle);
                float miePhase = miePhase(phaseAngle);
                
                float distanceToGround = 0.0;
                
                bool hitGround = intersectSphere(camPos, rayDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround > 0.0;                
                //intersectSphere(camPos, rayDirection, BOTTOM_RADIUS, distanceToGround);
               

                if(length(v_vertex * SPHERE_TO_ELLIPSOID_SCALE) > BOTTOM_RADIUS){
                    distanceToGround = distance(camPos, v_vertex * SPHERE_TO_ELLIPSOID_SCALE);
                }
                                                                
                float segmentLength = (distanceToGround - max(offset, 0.0)) / float(SAMPLE_COUNT);
                
                float t = segmentLength * 0.5;
                
                vec3 transmittanceCamera; 
                vec3 transmittanceLight; 
                
                for (int i = 0; i < SAMPLE_COUNT; i++) 
                {
                    vec3 position = rayOrigin + t * rayDirection;
                    float height = length(position) - BOTTOM_RADIUS;
                    vec3 up = position / length(position);
                    float rayAngle = dot(up, rayDirection);
                    float lightAngle = dot(up, lightDir);                                                 
                    vec3 transmittanceToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);
                    transmittanceCamera = cameraBelow ? (transmittanceToSpace / transmittanceFromCameraToSpace) : (transmittanceFromCameraToSpace / transmittanceToSpace);
                    transmittanceLight = transmittanceFromTexture(height, lightAngle);
                    vec2 opticalDensity = exp(-height / rayleighMieHeights);
                    vec3 scatteredLight = transmittanceLight * (rayleighScatteringCoefficient * opticalDensity.x * rayleighPhase + mieScatteringCoefficient * opticalDensity.y * miePhase);
                    scatteredLight += multipleScatteringContributionFromTexture(height, lightAngle) * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y);  
                    light += transmittanceCamera * scatteredLight * segmentLength;
                    t += segmentLength;
                }
                
                light *= SUN_INTENSITY;
        
                vec3 hitPoint = camPos + rayDirection * distanceToGround;
                vec3 up = normalize(hitPoint);
                float diffuseAngle = max(dot(up, lightDir), 0.0);                
                                
                float lightAngle = dot(normal, lightDir);
                vec3 tA = transmittanceCamera * GROUND_ALBEDO * SUN_INTENSITY;                                               
                vec3 scatteringLight = multipleScatteringContributionFromTexture(height, lightAngle);
                vec3 diffuseTransmittanceLight = transmittanceLight * diffuseAngle;                
                light += tA * (scatteringLight + diffuseTransmittanceLight);
                                                                
                fragColor = vec4(pow(light * 8.0, vec3(1.0 / 2.2)), 1.0);
            }

            void getAtmosFadingOpacity(out float opacity)
            {            
                float c = length(cameraPosition);
                float maxDist = sqrt(c * c - BOTTOM_RADIUS * BOTTOM_RADIUS);
                float minDist = c - BOTTOM_RADIUS;
                float vertDist = distance(cameraPosition, v_vertex);                    
                opacity = clamp(maxMinOpacity.y + ( maxMinOpacity.x -  maxMinOpacity.y) * getLerpValue(minDist, maxDist, vertDist), 0.0, 1.0);
            }

            void main(void) {
            
                sunPos = lightsPositions[0];
                                
                vec3 texNormal = texture(uNormalMap, vTextureCoord.zw).rgb;
                vec3 normal = normalize((texNormal - 0.5) * 2.0);
                
                float minH = 1200000.0;
                float maxH = minH * 3.0;
                float nightCoef = getLerpValue(minH, maxH, camHeight) * nightTextureCoefficient;
                                
                // if(camHeight > 6000000.0)
                // {
                //    normal = normalize(v_vertex);
                // }
                                            
                vec3 lightDir = normalize(sunPos);
                vec3 viewDir = normalize(cameraPosition - v_vertex);
                
                vec4 atmosColor;
                atmosGroundColor(atmosColor, normal);
                
                vec3 sunIlluminance;                
                getSunIlluminance(v_vertex * SPHERE_TO_ELLIPSOID_SCALE, lightDir * SPHERE_TO_ELLIPSOID_SCALE, sunIlluminance);
                
                float overGround = 1.0 - step(0.1, v_height);

                float shininess = texture( specularTexture, vGlobalTextureCoord.st ).r * 255.0 * overGround;
                vec3 reflectionDirection = reflect(-lightDir, normal);
                float reflection = max( dot(reflectionDirection, viewDir), 0.0);
                vec3 spec = sunIlluminance * specular.rgb * pow( reflection, specular.w) * shininess;                
                float diffuseLightWeighting = max(dot(normal, lightDir), 0.0);
                              
                vec4 nightImageColor = texture( nightTexture, vGlobalTextureCoord.st );
                vec3 night = nightStep * (.18 - diffuseLightWeighting * 3.0) * nightImageColor.rgb * nightCoef;
                night *= overGround * step(0.0, night);                
                vec4 lightWeighting = vec4(ambient + sunIlluminance * diffuse * diffuseLightWeighting + night, 1.0);
                
                float fadingOpacity;
                getAtmosFadingOpacity(fadingOpacity);
                
                getSunIlluminance(cameraPosition, viewDir * SPHERE_TO_ELLIPSOID_SCALE, sunIlluminance);
                
                spec *= sunIlluminance;

                diffuseColor = texture( defaultTexture, vTextureCoord.xy );
                if( samplerCount == 0 ) {
                    diffuseColor = mix(diffuseColor * lightWeighting, atmosColor, fadingOpacity) + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                vec4 src;

                blend(diffuseColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);
                if( samplerCount == 1 ) {                
                    diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);
                if( samplerCount == 2 ) {
                    diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);
                if( samplerCount == 3 ) {
                    diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);
                if( samplerCount == 4 ) {
                    diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);
                diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);
                diffuseColor *= transitionOpacity;
            }`
    });
}
function drawnode_colorPicking() {
    return new Program("drawnode_colorPicking", {
        uniforms: {
            projectionMatrix: "mat4",
            viewMatrix: "mat4",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            samplerCount: "int",
            tileOffsetArr: "vec4",
            samplerArr: "sampler2darray",
            pickingMaskArr: "sampler2darray",
            pickingColorArr: "vec4",
            height: "float"
        }, attributes: {
            aVertexPositionHigh: "vec3", aVertexPositionLow: "vec3", aTextureCoord: "vec2"
        },
        vertexShader: `precision highp float;
            
            attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;
            attribute vec2 aTextureCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            varying vec2 vTextureCoord;

            void main(void) {

                vTextureCoord = aTextureCoord;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                mat4 m = projectionMatrix * viewMatrixRTE;

                vec3 nh = height * normalize(aVertexPositionHigh + aVertexPositionLow);

                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;

                gl_Position = m * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);
            }`,
        fragmentShader: `precision highp float;
            #define SLICE_SIZE ${SLICE_SIZE + 1}
            uniform vec4 tileOffsetArr[SLICE_SIZE];
            uniform vec4 pickingColorArr[SLICE_SIZE];
            uniform sampler2D samplerArr[SLICE_SIZE];
            uniform sampler2D pickingMaskArr[SLICE_SIZE];
            uniform int samplerCount;
            varying vec2 vTextureCoord;

            ${DEF_BLEND_PICKING}

            void main(void) {
                gl_FragColor = vec4(0.0);
                if( samplerCount == 0 ) return;

                vec2 tc;
                vec4 t;
                vec4 p;

                blendPicking(gl_FragColor, tileOffsetArr[0], samplerArr[0], pickingMaskArr[0], pickingColorArr[0], 1.0);
                if( samplerCount == 1 ) return;

                blendPicking(gl_FragColor, tileOffsetArr[1], samplerArr[1], pickingMaskArr[1], pickingColorArr[1], 1.0);
                if( samplerCount == 2 ) return;

                blendPicking(gl_FragColor, tileOffsetArr[2], samplerArr[2], pickingMaskArr[2], pickingColorArr[2], 1.0);
                if( samplerCount == 3 ) return;

                blendPicking(gl_FragColor, tileOffsetArr[3], samplerArr[3], pickingMaskArr[3], pickingColorArr[3], 1.0);
                if( samplerCount == 4 ) return;

                blendPicking(gl_FragColor, tileOffsetArr[4], samplerArr[4], pickingMaskArr[4], pickingColorArr[4], 1.0);
            }`
    });
}
function drawnode_heightPicking() {
    return new Program("drawnode_heightPicking", {
        uniforms: {
            projectionMatrix: "mat4",
            viewMatrix: "mat4",
            height: "float",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3"
        }, attributes: {
            aVertexPositionHigh: "vec3", aVertexPositionLow: "vec3"
        },
        vertexShader: `precision highp float;

            attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            varying vec3 eyePosition;
            varying vec3 vertexPosition;

            void main(void) {

                // This code is works for Mac Chrome and Safari
                // any other code probably will produce jittering

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                mat4 m = projectionMatrix * viewMatrixRTE;

                vec3 nh = height * normalize(aVertexPositionHigh + aVertexPositionLow);

                eyePosition = eyePositionHigh + eyePositionLow;
                vertexPosition = aVertexPositionHigh + aVertexPositionLow;

                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;
                
                gl_Position =  m * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);         
            }`,
        fragmentShader: `precision highp float;

            varying vec3 eyePosition;
            varying vec3 vertexPosition;

            vec3 encode24(highp float f) {
                float F = abs(f);
                float s = step( 0.0, -f );
                float e = floor( log2(F) );
                float m = exp2(- e) * F;
                e = floor( log2(F) + 127.0 ) + floor( log2(m) );
                return vec3(
                    ( 128.0 * s + floor( e * exp2(-1.0) ) ) / 255.0,
                    ( 128.0 * mod( e, 2.0 ) + mod( floor( m * 128.0 ), 128.0 ) ) / 255.0,
                    floor( mod( floor( m * exp2( 23.0 - 8.0) ), exp2(8.0) ) ) / 255.0);
            }

            void main(void) {
                float range = distance(eyePosition, vertexPosition);
                gl_FragColor = vec4(encode24(range), 1.0);
            }`
    });
}
function drawnode_depth() {
    return new Program("drawnode_depth", {
        uniforms: {
            projectionMatrix: "mat4",
            viewMatrix: "mat4",
            height: "float",
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            frustumPickingColor: "vec3"
        }, attributes: {
            aVertexPositionHigh: "vec3", aVertexPositionLow: "vec3"
        },
        vertexShader: `precision highp float;

            attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            void main(void) {

                // @hack
                // This code is works for Mac Chrome and Safari
                // any other code probably will produce jittering

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                mat4 m = projectionMatrix * viewMatrixRTE;

                vec3 nh = height * normalize(aVertexPositionHigh + aVertexPositionLow);

                vec3 eyePosition = eyePositionHigh + eyePositionLow;
                vec3 vertexPosition = aVertexPositionHigh + aVertexPositionLow;

                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;
                
                gl_Position =  m * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);    
            }`,
        fragmentShader: `precision highp float;
            uniform vec3 frustumPickingColor;

            void main(void) {
                gl_FragColor = vec4(frustumPickingColor, 1.0);
            } `
    });
}

class BaseFramebuffer {
    constructor(handler, options = {}) {
        this.handler = handler;
        this._fbo = null;
        this._width = options.width || handler.canvas.width;
        this._height = options.height || handler.canvas.height;
        this._depthComponent = options.depthComponent != undefined ? options.depthComponent : "DEPTH_COMPONENT16";
        this._useDepth = options.useDepth != undefined ? options.useDepth : true;
        this._active = false;
        this._size = options.size || 1;
        this._depthRenderbuffer = null;
        this._filter = options.filter || "NEAREST";
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    /**
     * Sets framebuffer viewport size.
     * @public
     * @param {number} width - Framebuffer width.
     * @param {number} height - Framebuffer height.
     * @param {boolean} [forceDestroy] -
     */
    setSize(width, height, forceDestroy = false) {
        this._width = width;
        this._height = height;
        if (this._active) {
            this.handler.gl.viewport(0, 0, this._width, this._height);
        }
        if (this._useDepth || forceDestroy) {
            this.destroy();
            this.init();
        }
    }
    init() {
    }
    destroy() {
    }
    /**
     * Returns framebuffer completed.
     * @public
     * @returns {boolean} -
     */
    isComplete() {
        let gl = this.handler.gl;
        return gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
    }
    checkStatus() {
        let gl = this.handler.gl;
        return gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    }
    /**
     * Activate framebuffer frame to draw.
     * @public
     * @returns {Framebuffer} Returns Current framebuffer.
     */
    activate() {
        let gl = this.handler.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
        gl.viewport(0, 0, this._width, this._height);
        this._active = true;
        let c = this.handler.framebufferStack.current().data;
        c && (c._active = false);
        this.handler.framebufferStack.push(this);
        return this;
    }
    /**
     * Deactivate framebuffer frame.
     * @public
     */
    deactivate() {
        let h = this.handler, gl = h.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        this._active = false;
        let f = this.handler.framebufferStack.popPrev();
        if (f) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, f._fbo);
            gl.viewport(0, 0, f._width, f._height);
        }
        else {
            gl.viewport(0, 0, h.canvas.width, h.canvas.height);
        }
    }
}

/**
 * Usefull class for working with JS canvas object.
 * @class
 * @param {number} [width] - Canvas width. Default 256.
 * @param {number} [height] - Canvas height. Default 256.
 */
class ImageCanvas {
    constructor(width = 256, height = 256) {
        this._canvas = document.createElement("canvas");
        this._canvas.width = width;
        this._canvas.height = height;
        this._context = this._canvas.getContext("2d", {
            willReadFrequently: true
        });
    }
    /**
     * Returns canvas object.
     * @public
     * @returns {HTMLCanvasElement}
     */
    getCanvas() {
        return this._canvas;
    }
    /**
     * Returns canvas context pointer.
     * @public
     * @returns {CanvasRenderingContext2D}
     */
    getContext() {
        return this._context;
    }
    /**
     * Fills canvas RGBA with zeroes.
     * @public
     */
    fillEmpty() {
        let imgd = this._context.getImageData(0, 0, this._canvas.width, this._canvas.height);
        let pixels = imgd.data;
        for (let i = 0, n = pixels.length; i < n; i += 4) {
            pixels[i] = pixels[i + 1] = pixels[i + 2] = pixels[i + 3] = 0;
        }
        this._context.putImageData(imgd, 0, 0);
    }
    /**
     * Fills canvas RGBA with color.
     * @public
     * @param {string} color - CSS string color.
     */
    fill(color) {
        this._context.fillStyle = color;
        this._context.fill();
    }
    /**
     * Gets canvas pixels RGBA data.
     * @public
     * @returns {Uint8ClampedArray}
     */
    getData() {
        let imgd = this._context.getImageData(0, 0, this._canvas.width, this._canvas.height);
        return imgd.data;
    }
    /**
     * Fill the canvas by color.
     * @public
     * @param {string} color - CSS string color.
     */
    fillColor(color) {
        this._context.fillStyle = color;
        this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);
    }
    /**
     * Sets RGBA pixel data.
     * @public
     * @param {Array.<number>} data - Array RGBA data.
     */
    setData(data) {
        let imageData = this._context.createImageData(this._canvas.width, this._canvas.height);
        imageData.data.set(data);
        this._context.putImageData(imageData, 0, 0);
    }
    /**
     * Resize canvas.
     * @public
     * @param {number} width - Width.
     * @param {number} height - Height.
     */
    resize(width, height) {
        this._canvas.width = width;
        this._canvas.height = height;
        this._context = this._canvas.getContext("2d");
    }
    /**
     * Draw an image on the canvas.
     * @public
     * @param {Image} img - Draw image.
     * @param {number} [x] - Left top image corner X coordinate on the canvas.
     * @param {number} [y] - Left top image corner Y coordinate on the canvas.
     * @param {number} [width] - Image width slice. Image width is default.
     * @param {number} [height] - Image height slice. Image height is default.
     */
    drawImage(img, x, y, width, height) {
        this._context.drawImage(img, x || 0, y || 0, width || img.width, height || img.height);
    }
    /**
     * Converts canvas to JS image object.
     * @public
     * @returns {Image}
     */
    getImage() {
        let img = new Image();
        img.width = this.getWidth();
        img.height = this.getHeight();
        img.src = this._canvas.toDataURL("image/png");
        return img;
    }
    /**
     * Get measured text width.
     * @public
     * @param {string} text - Measured text.
     * @returns {number}
     */
    getTextWidth(text) {
        let metrics = this._context.measureText(text);
        return Math.round(metrics.width);
    }
    /**
     * Draw a text on the canvas.
     * @public
     * @param {string} text - Text.
     * @param {number} [x] - Canvas X - coordinate. 0 - default.
     * @param {number} [y] - Canvas Y - coordinate. 0 - default.
     * @param {string} [font] - Font style. 'normal 14px Verdana' - is default.
     * @param {string} [color] - Css font color.
     */
    drawText(text, x = 0, y = 14, font = "normal 14px Verdana", color = "black") {
        this._context.fillStyle = color;
        this._context.font = font;
        this._context.fillText(text, x, y);
    }
    /**
     * Gets canvas width.
     * @public
     * @returns {number}
     */
    getWidth() {
        return this._canvas.width;
    }
    /**
     * Gets canvas height.
     * @public
     * @returns {number}
     */
    getHeight() {
        return this._canvas.height;
    }
    /**
     * Load image to canvas.
     * @public
     * @param {string} url - Image url.
     * @param {Function} [callback] - Image onload callback.
     */
    load(url, callback) {
        let img = new Image();
        let that = this;
        img.onload = function () {
            that.resize(img.width, img.height);
            that._context.drawImage(img, 0, 0, img.width, img.height);
            callback && callback(img);
        };
        img.src = url;
    }
    /**
     * Open canvas image in the new window.
     * @public
     */
    openImage() {
        let img = this.getImage();
        let dataUrl = img.src;
        let windowContent = "<!DOCTYPE html>";
        windowContent += "<html>";
        windowContent += "<head><title>Print</title></head>";
        windowContent += "<body>";
        windowContent += '<img src="' + dataUrl + '">';
        windowContent += "</body>";
        windowContent += "</html>";
        let printWin = window.open("", "", "width=" + img.width + "px ,height=" + img.height + "px");
        if (printWin) {
            printWin.document.open();
            printWin.document.write(windowContent);
            printWin.document.close();
            printWin.focus();
        }
    }
    destroy() {
        this._canvas.width = 1;
        this._canvas.height = 1;
        //@ts-ignore
        this._canvas = null;
        //@ts-ignore
        this._context = null;
    }
}

/**
 * Class represents framebuffer.
 * @class
 * @param {Handler} handler - WebGL handler.
 * @param {IFrameBufferParams} [options] - Framebuffer options:
 */
class Framebuffer extends BaseFramebuffer {
    constructor(handler, options = {}) {
        super(handler, options);
        this._isBare = options.isBare || false;
        this._internalFormatArr = options.internalFormat instanceof Array ? options.internalFormat : [options.internalFormat || "RGBA"];
        this._formatArr = options.format instanceof Array ? options.format : [options.format || "RGBA"];
        this._typeArr = options.type instanceof Array ? options.type : [options.type || "UNSIGNED_BYTE"];
        if (options.attachment instanceof Array) {
            this._attachmentArr = options.attachment.map((a, i) => {
                let res = a.toUpperCase();
                if (res === "COLOR_ATTACHMENT") {
                    return `${res}${i.toString()}`;
                }
                return res;
            });
        }
        else {
            this._attachmentArr = [options.attachment || "COLOR_ATTACHMENT0"];
        }
        this._renderbufferTarget = options.renderbufferTarget != undefined ? options.renderbufferTarget : "DEPTH_ATTACHMENT";
        this.textures = options.textures || new Array(this._size);
    }
    // static blit(sourceFramebuffer: Framebuffer, destFramebuffer: Framebuffer, glAttachment: number, glMask: number, glFilter: number) {
    //     let gl = sourceFramebuffer.handler.gl!;
    //
    //     gl.bindFramebuffer(gl.READ_FRAMEBUFFER, sourceFramebuffer._fbo);
    //     gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, destFramebuffer._fbo);
    //     gl.readBuffer(glAttachment);
    //
    //     gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
    //
    //     gl.blitFramebuffer(0, 0, sourceFramebuffer._width, sourceFramebuffer._height, 0, 0, destFramebuffer._width, destFramebuffer._height, glMask, glFilter);
    //
    //     gl.bindFramebuffer(gl.FRAMEBUFFER, null!);
    //     gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null!);
    //     gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null!);
    // }
    destroy() {
        let gl = this.handler.gl;
        if (!gl)
            return;
        for (let i = 0; i < this.textures.length; i++) {
            gl.deleteTexture(this.textures[i]);
        }
        this.textures = new Array(this._size);
        gl.deleteFramebuffer(this._fbo);
        gl.deleteRenderbuffer(this._depthRenderbuffer);
        this._depthRenderbuffer = null;
        this._fbo = null;
        this._active = false;
    }
    /**
     * Framebuffer initialization.
     * @public
     * @override
     */
    init() {
        let gl = this.handler.gl;
        if (!gl)
            return;
        this._fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
        if (!this._isBare) {
            let attachmentArr = [];
            for (let i = 0; i < this.textures.length; i++) {
                let ti = this.textures[i] || this.handler.createEmptyTexture2DExt(this._width, this._height, this._filter, this._internalFormatArr[i], this._formatArr[i], this._typeArr[i]);
                let att_i = gl[this._attachmentArr[i]];
                if (ti) {
                    this.bindOutputTexture(ti, att_i);
                    this.textures[i] = ti;
                }
                if (this._attachmentArr[i] != "DEPTH_ATTACHMENT") {
                    attachmentArr.push(att_i);
                }
            }
            gl.drawBuffers && gl.drawBuffers(attachmentArr);
        }
        if (this._useDepth) {
            this._depthRenderbuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderbuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl[this._depthComponent], this._width, this._height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl[this._renderbufferTarget], gl.RENDERBUFFER, this._depthRenderbuffer);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * Bind buffer texture.
     * @public
     * @param {WebGLTexture} texture - Output texture.
     * @param {number} [glAttachment=0] - color attachment index.
     */
    bindOutputTexture(texture, glAttachment) {
        let gl = this.handler.gl;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment || gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * Gets pixel RGBA color from framebuffer by coordinates.
     * @public
     * @param {Uint8Array} res - Normalized x - coordinate.
     * @param {number} nx - Normalized x - coordinate.
     * @param {number} ny - Normalized y - coordinate.
     * @param {number} [w=1] - Normalized width.
     * @param {number} [h=1] - Normalized height.
     * @param {number} [index=0] - color attachment index.
     */
    readPixels(res, nx, ny, index = 0, w = 1, h = 1) {
        let gl = this.handler.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
        gl.readBuffer && gl.readBuffer(gl.COLOR_ATTACHMENT0 + index || 0);
        gl.readPixels(nx * this._width, ny * this._height, w, h, gl.RGBA, gl[this._typeArr[index]], res);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * Reads all pixels(RGBA colors) from framebuffer.
     * @public
     * @param {Uint8Array} res - Result array.
     * @param {number} [attachmentIndex=0] - color attachment index.
     */
    readAllPixels(res, attachmentIndex = 0) {
        let gl = this.handler.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
        gl.readBuffer && gl.readBuffer(gl.COLOR_ATTACHMENT0 + attachmentIndex);
        gl.readPixels(0, 0, this._width, this._height, gl.RGBA, gl[this._typeArr[attachmentIndex]], res);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * Gets JavaScript image that in the framebuffer.
     * @public
     * @returns {HTMLImageElement} -
     */
    getImage() {
        let data = new Uint8Array(4 * this._width * this._height);
        this.readAllPixels(data);
        let imageCanvas = new ImageCanvas(this._width, this._height);
        imageCanvas.setData(data);
        return imageCanvas.getImage();
    }
}

class Atmosphere extends Control {
    constructor(options = {}) {
        super({
            name: "Atmosphere",
            ...options
        });
        this._transmittanceBuffer = null;
        this._scatteringBuffer = null;
        this.opacity = 1.0;
        this._parameters = {
            ATMOS_HEIGHT: options.height || 100000.0,
            RAYLEIGH_SCALE: options.rayleighScale || 0.08,
            MIE_SCALE: options.mieScale || 0.012,
            GROUND_ALBEDO: options.groundAlbedo || 0.05,
            BOTTOM_RADIUS: options.bottomRadius || 6356752.3142451793,
            rayleighScatteringCoefficient: options.rayleighScatteringCoefficient || [5.802, 13.558, 33.100],
            mieScatteringCoefficient: options.mieScatteringCoefficient || 3.996,
            mieExtinctionCoefficient: options.mieExtinctionCoefficient || 4.440,
            ozoneAbsorptionCoefficient: options.ozoneAbsorptionCoefficient || [0.650, 1.881, 0.085],
            SUN_ANGULAR_RADIUS: options.sunAngularRadius || 0.004685,
            SUN_INTENSITY: options.sunIntensity || 1.0,
            ozoneDensityHeight: options.ozoneDensityHeight || 25e3,
            ozoneDensityWide: options.ozoneDensityWide || 15e3,
        };
    }
    setParameters(parameters) {
        this._parameters = JSON.parse(JSON.stringify(parameters));
        this.initLookupTexturesShaders();
        this.drawLookupTextures();
        this.removeLookupTexturesShaders();
        this.initPlanetAtmosphereShader();
    }
    get parameters() {
        return JSON.parse(JSON.stringify(this._parameters));
    }
    initPlanetAtmosphereShader() {
        this.planet?.initAtmosphereShader(this._parameters);
    }
    oninit() {
        if (this.renderer) {
            //
            // Draw atmosphere lookup textures
            //
            this._initLookupTextures();
            this.initLookupTexturesShaders();
            this.drawLookupTextures();
            this.removeLookupTexturesShaders();
            this.initBackgroundShader();
            this.activate();
        }
    }
    initLookupTexturesShaders() {
        if (this.renderer) {
            this.renderer.handler.addProgram(transmittance(this._parameters), true);
            this.renderer.handler.addProgram(scattering(this._parameters), true);
        }
    }
    initBackgroundShader() {
        if (this.renderer) {
            this.renderer.handler.addProgram(atmosphereBackgroundShader(this._parameters), true);
        }
    }
    removeBackgroundShader() {
        if (this.renderer) {
            this.renderer.handler.removeProgram("atmosphereBackground");
        }
    }
    removeLookupTexturesShaders() {
        if (this.renderer) {
            let h = this.renderer.handler;
            if (this._scatteringBuffer?.isComplete()) {
                h.removeProgram("scattering");
            }
            if (this._transmittanceBuffer?.isComplete()) {
                h.removeProgram("transmittance");
            }
        }
    }
    onactivate() {
        super.onactivate();
        this.planet && this.planet.events.on("draw", this._drawBackground, this);
    }
    ondeactivate() {
        super.ondeactivate();
        this.planet && this.planet.events.off("draw", this._drawBackground);
    }
    _initLookupTextures() {
        let width = 1024, height = 1024;
        this._transmittanceBuffer = new Framebuffer(this.renderer.handler, {
            width: width,
            height: height,
            useDepth: false,
            filter: "LINEAR",
            type: "FLOAT",
            internalFormat: "RGBA16F"
        });
        this._transmittanceBuffer.init();
        this._scatteringBuffer = new Framebuffer(this.renderer.handler, {
            width: width,
            height: height,
            useDepth: false,
            filter: "LINEAR",
            type: "FLOAT",
            internalFormat: "RGBA16F"
        });
        this._scatteringBuffer.init();
    }
    _renderLookupTextures() {
        if (!this.renderer)
            return;
        let positionBuffer = this.renderer.screenFramePositionBuffer;
        let h = this.renderer.handler;
        let gl = h.gl;
        //
        // Draw transmittance texture
        //
        if (this._transmittanceBuffer) {
            this._transmittanceBuffer.activate();
            let p = h.programs.transmittance;
            let sha = p._program.attributes;
            let shu = p._program.uniforms;
            p.activate();
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.uniform2fv(shu.iResolution, [this._transmittanceBuffer.width, this._transmittanceBuffer.height]);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(sha.a_position, positionBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, positionBuffer.numItems);
            this._transmittanceBuffer.deactivate();
        }
        //
        // Draw scattering texture
        //
        if (this._scatteringBuffer && this._transmittanceBuffer) {
            this._scatteringBuffer.activate();
            let p = h.programs.scattering;
            let sha = p._program.attributes;
            let shu = p._program.uniforms;
            p.activate();
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.uniform2fv(shu.iResolution, [this._scatteringBuffer.width, this._scatteringBuffer.height]);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this._transmittanceBuffer.textures[0]);
            gl.uniform1i(shu.transmittanceTexture, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(sha.a_position, positionBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, positionBuffer.numItems);
            this._scatteringBuffer.deactivate();
        }
    }
    drawLookupTextures() {
        this._renderLookupTextures();
    }
    _drawBackground() {
        let h = this.renderer.handler;
        let sh = h.programs.atmosphereBackground, p = sh._program, shu = p.uniforms, gl = h.gl;
        let r = this.renderer;
        let cam = this.planet.camera;
        gl.disable(gl.DEPTH_TEST);
        sh.activate();
        gl.bindBuffer(gl.ARRAY_BUFFER, r.screenFramePositionBuffer);
        gl.vertexAttribPointer(p.attributes.corners, 2, gl.FLOAT, false, 0, 0);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._transmittanceBuffer.textures[0]);
        gl.uniform1i(shu.transmittanceTexture, 0);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, this._scatteringBuffer.textures[0]);
        gl.uniform1i(shu.scatteringTexture, 1);
        gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
        let sunPos = this.planet.sunPos;
        gl.uniform3fv(shu.sunPos, [sunPos.x, sunPos.y, sunPos.z]);
        gl.uniform3fv(shu.camPos, [cam.eye.x, cam.eye.y, cam.eye.z]);
        gl.uniform2fv(shu.iResolution, [r.sceneFramebuffer.width, r.sceneFramebuffer.height]);
        gl.uniform1f(shu.fov, cam.getViewAngle());
        gl.uniform1f(shu.opacity, this.opacity);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.enable(gl.DEPTH_TEST);
    }
}
function atmosphereBackgroundShader(atmosParams) {
    return new Program("atmosphereBackground", {
        uniforms: {
            iResolution: "vec2",
            fov: "float",
            camPos: "vec3",
            viewMatrix: "mat4",
            transmittanceTexture: "sampler2D",
            scatteringTexture: "sampler2D",
            sunPos: "vec3",
            opacity: "float"
        },
        attributes: {
            corners: "vec3"
        },
        vertexShader: `            
            attribute vec2 corners;
            
            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
            }`,
        fragmentShader: `                                   
            precision lowp float;
            
            ${COMMON(atmosParams)}
            
            uniform mat4 viewMatrix;
            uniform vec3 sunPos;
            uniform vec3 camPos;     
            uniform vec2 iResolution;
            uniform float fov;
            uniform float opacity;
                       
            uniform sampler2D transmittanceTexture;
            uniform sampler2D scatteringTexture;
                                                           
            vec3 transmittanceFromTexture(float height, float angle) 
            {
                float u = (angle + 1.0) * 0.5;
                float v = height / ATMOS_HEIGHT;
                return texture2D(transmittanceTexture, vec2(u, v)).xyz;
            }
            
            vec3 multipleScatteringContributionFromTexture(float height, float angle) 
            {
                float u = (angle + 1.0) * 0.5;
                float v = height / ATMOS_HEIGHT;
                return texture2D(scatteringTexture, vec2(u, v)).xyz; 
            }

            bool intersectEllipsoidToSphere(in vec3 ro, in vec3 rd, in vec3 ellRadii, in float sphereRadius, out float t1, out float t2) 
            {
                float offset = 0.0,
                      distanceToSpace = 0.0;
                                                        
                if(intersectEllipsoid(ro, rd, ellRadii, offset, distanceToSpace)){
                    vec3 hitEll = ro + rd * offset;
                    vec3 nEll = normalEllipsoid(hitEll, ellRadii);
                    float t = 0.0;
                    bool intersectsSphere = intersectSphere(hitEll, nEll, sphereRadius, t);
                    vec3 hitSphere = hitEll + nEll * t;
                    t1 = length(hitSphere - ro);
                    
                    hitEll = ro + rd * distanceToSpace;
                    nEll = normalEllipsoid(hitEll, ellRadii);
                    t = 0.0;
                    intersectsSphere = intersectSphere(hitEll, nEll, sphereRadius, t);
                    hitSphere = hitEll + nEll * t;
                    t2 = length(hitSphere - ro);
                    
                    return true; 
                }
                return false; 
            }
            
            mat4 transpose(in mat4 m) 
            {
                vec4 i0 = m[0];
                vec4 i1 = m[1];
                vec4 i2 = m[2];
                vec4 i3 = m[3];
            
                mat4 outMatrix = mat4(
                     vec4(i0.x, i1.x, i2.x, i3.x),
                     vec4(i0.y, i1.y, i2.y, i3.y),
                     vec4(i0.z, i1.z, i2.z, i3.z),
                     vec4(i0.w, i1.w, i2.w, i3.w)
                     );
                                 
                return outMatrix;
            }
                                                                     
            void mainImage(out vec4 fragColor) 
            {            
                vec3 cameraPosition = camPos;
                
                vec3 lightDirection = normalize(sunPos);               
                             
                vec2 uv = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y;
                float fieldOfView = fov;
                float z = 1.0 / tan(fieldOfView * 0.5 * PI / 180.0);
                vec3 rayDirection = normalize(vec3(uv, -z));
                vec4 rd = transpose(viewMatrix) * vec4(rayDirection, 1.0);
                rayDirection = rd.xyz;               
                                          
                vec3 light = vec3(0.0);
                vec3 transmittanceFromCameraToSpace = vec3(1.0);
                float offset = 0.0;
                float distanceToSpace = 0.0;
                                                
                rayDirection = normalize(rayDirection * SPHERE_TO_ELLIPSOID_SCALE);
                cameraPosition *= SPHERE_TO_ELLIPSOID_SCALE;
                lightDirection = normalize(lightDirection * SPHERE_TO_ELLIPSOID_SCALE);
                
                if(length(cameraPosition) < BOTTOM_RADIUS + 100.0){
                    cameraPosition = normalize(cameraPosition) * (BOTTOM_RADIUS + 100.0); 
                }
                                                
                if (intersectSphere(cameraPosition, rayDirection, TOP_RADIUS, offset, distanceToSpace)) 
                {    
                    vec3 rayOrigin = cameraPosition;
                    
                    // above atmosphere                    
                    if (offset > 0.0) {
                        // intersection of camera ray with atmosphere
                        rayOrigin = cameraPosition + rayDirection * offset;
                    }                   
                    
                    float height = length(rayOrigin) - BOTTOM_RADIUS;
                    float rayAngle = dot(rayOrigin, rayDirection) / length(rayOrigin);
                    bool cameraBelow = rayAngle < 0.0;
                    
                    transmittanceFromCameraToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);
                    
                    float phaseAngle = dot(lightDirection, rayDirection);
                    float rayleighPhase = rayleighPhase(phaseAngle);
                    float miePhase = miePhase(phaseAngle);
                    
                    float distanceToGround = 0.0;
                    
                    bool hitGround = intersectSphere(cameraPosition, rayDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround > 0.0;
                    
                    if(intersectSphere(cameraPosition, rayDirection, BOTTOM_RADIUS - 100000.0, distanceToGround) && hitGround)
                    {
                        discard;
                    }
                    
                    float segmentLength = ((hitGround ? distanceToGround : distanceToSpace) - max(offset, 0.0)) / float(SAMPLE_COUNT);
                                                                    
                    float t = segmentLength * 0.5;
                    
                    vec3 transmittanceCamera; 
                    vec3 transmittanceLight; 
            
                    for (int i = 0; i < SAMPLE_COUNT; i++) 
                    {
                        vec3 position = rayOrigin + t * rayDirection;
                        float height = length(position) - BOTTOM_RADIUS; 
                        vec3 up = position / length(position);
                        float rayAngle = dot(up, rayDirection);
                        float lightAngle = dot(up, lightDirection);
                        vec3 transmittanceToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);
                        transmittanceCamera = cameraBelow ? (transmittanceToSpace / transmittanceFromCameraToSpace) : (transmittanceFromCameraToSpace / transmittanceToSpace);
                        transmittanceLight = transmittanceFromTexture(height, lightAngle);
                        vec2 opticalDensity = exp(-height / rayleighMieHeights);
                        vec3 scatteredLight = transmittanceLight * (rayleighScatteringCoefficient * opticalDensity.x * rayleighPhase + mieScatteringCoefficient * opticalDensity.y * miePhase);
                        scatteredLight += multipleScatteringContributionFromTexture(height, lightAngle) * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y);  
                        light += transmittanceCamera * scatteredLight * segmentLength;
                        t += segmentLength;
                    }
                    
                    light *= SUN_INTENSITY;
            
                    if (hitGround) 
                    {
                        vec3 hitPoint = cameraPosition + rayDirection * distanceToGround;
                        vec3 up = hitPoint / length(hitPoint);
                        float diffuseAngle = max(dot(up, lightDirection), 0.0);
                        float lightAngle = dot(up, lightDirection);
                        light += transmittanceCamera * GROUND_ALBEDO * multipleScatteringContributionFromTexture(height, lightAngle) * SUN_INTENSITY;
                        light += transmittanceCamera * transmittanceLight * GROUND_ALBEDO * diffuseAngle * SUN_INTENSITY;
                    }
                }
                                     
                // sun disk
                // float distanceToGround;
                // bool hitGround = intersectSphere(cameraPosition, rayDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround > 0.0;
                // if (!hitGround) {
                //    float angle = dot(rayDirection, lightDirection);
                //    if (angle > cos(SUN_ANGULAR_RADIUS)) {
                //       light = SUN_INTENSITY * transmittanceFromCameraToSpace;
                //    }
                // }
                
                float distanceToGround = 0.0;
                bool hitGround = intersectSphere(cameraPosition, rayDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround > 0.0;
                if(!hitGround)
                {
                    vec3 sunLum = sunWithBloom(rayDirection, lightDirection) * vec3(1.0,1.0,0.8);
                    // limit the bloom effect
                    sunLum = smoothstep(0.002, 1.0, sunLum);
                    light += sunLum * SUN_INTENSITY * transmittanceFromCameraToSpace;
                }
                            
                fragColor = vec4(pow(light * 8.0, vec3(1.0 / 2.2)), clamp(opacity, 0.0, 1.0));           
            }
                                    
            void main(void) 
            {                            
                mainImage(gl_FragColor);            
            }`
    });
}

/**
 * Projection units: 'degrees', 'ft', 'm' or 'km'.
 * @enum {string}
 * @api
 */
const Units = {
    DEGREES: "degrees",
    FEET: "ft",
    METERS: "m",
    KILOMETERS: "km"
};
let _counter = 0;
class Proj {
    constructor(options) {
        this.id = _counter++;
        this.code = options.code;
        this.units = options.units;
    }
    /**
     * Compare projections.
     * @public
     * @param {Proj} proj - Projection object.
     * @returns {boolean}
     */
    equal(proj) {
        return proj.id === this.id;
    }
}

/**
 * @module og/proj/EPSG3857
 */
/**
 * EPSG:3857 projection object.
 * @type {Proj}
 */
const EPSG3857 = new Proj({ code: "epsg:3857", units: Units.METERS });

class Slice {
    constructor(segment) {
        this.segment = segment;
        this.layers = [];
        this.tileOffsetArr = new Float32Array(segment.planet.SLICE_SIZE_4);
        this.layerOpacityArr = new Float32Array(segment.planet.SLICE_SIZE);
    }
    clear() {
        // @ts-ignore
        this.layers = null;
        // @ts-ignore
        this.tileOffsetArr = null;
        // @ts-ignore
        this.layerOpacityArr = null;
    }
    append(layer, material) {
        let n = this.layers.length;
        this.layers.push(layer);
        this.layerOpacityArr[n] = layer.screenOpacity;
        let n4 = n * 4;
        let arr = layer.applyMaterial(material);
        this.tileOffsetArr[n4] = arr[0];
        this.tileOffsetArr[n4 + 1] = arr[1];
        this.tileOffsetArr[n4 + 2] = arr[2];
        this.tileOffsetArr[n4 + 3] = arr[3];
        //arr = this.segment._getLayerExtentOffset(layer);
        //slice.visibleExtentOffsetArr[n4] = arr[0];
        //slice.visibleExtentOffsetArr[n4 + 1] = arr[1];
        //slice.visibleExtentOffsetArr[n4 + 2] = arr[2];
        //slice.visibleExtentOffsetArr[n4 + 3] = arr[3];
    }
}

//Math.round(Math.abs(-pole - extent.southWest.lon) / (extent.northEast.lon - extent.southWest.lon));
function getTileCellIndex(coordinate, tileSize, worldEdge) {
    return Math.floor(Math.abs(worldEdge - coordinate) / tileSize);
}
function getTileCellExtent(x, y, z, worldExtent) {
    let pz = 1.0 / (1 << z);
    let worldWidth = worldExtent.getWidth(), worldHeight = worldExtent.getHeight();
    let w = worldWidth * pz, h = worldHeight * pz;
    let sw_lon = worldExtent.southWest.lon + x * w, ne_lat = worldExtent.northEast.lat - y * h;
    return new Extent(new LonLat(sw_lon, ne_lat - h), new LonLat(sw_lon + w, ne_lat));
}
const TILEGROUP_COMMON = 0;
const TILEGROUP_NORTH = 20;
const TILEGROUP_SOUTH = 300;
function getTileGroupByLat(lat, maxLat = MAX_LAT) {
    if (lat > maxLat) {
        return TILEGROUP_NORTH;
    }
    else if (lat < -maxLat) {
        return TILEGROUP_SOUTH;
    }
    return TILEGROUP_COMMON;
}
let _tempHigh$1 = new Vec3();
let _tempLow$1 = new Vec3();
let _v0 = new Vec3(), _v1 = new Vec3(), _v2 = new Vec3(), _v3 = new Vec3();
let _ray = new Ray$1(), _rayEx = new Ray$1();
const _S = new Array(4);
_S[N] = 0;
_S[E] = 1;
_S[S] = 1;
_S[W] = 0;
const _V = new Array(4);
_V[N] = false;
_V[E] = true;
_V[S] = false;
_V[W] = true;
/**
 * Planet segment Web Mercator tile class that stored and rendered with a quad-tree.
 * @class
 * @param {Node} node - Segment node.
 * @param {Planet} planet - Planet scene.
 * @param {number} tileZoom - Zoom index.
 * @param {Extent} extent - Segment extent.
 */
class Segment {
    constructor(node, planet, tileZoom, extent) {
        this.isPole = false;
        this._tileGroup = TILEGROUP_COMMON;
        this._projection = EPSG3857;
        this.node = node;
        this.planet = planet;
        this.handler = planet.renderer.handler;
        this.bsphere = new Sphere();
        this._plainRadius = 0;
        this.bbox = new Box();
        this._sw = new Vec3();
        this._nw = new Vec3();
        this._se = new Vec3();
        this._ne = new Vec3();
        this.centerNormal = new Vec3();
        this._extent = this._extentMerc = extent;
        this._extentLonLat = new Extent();
        this.gridSize = planet.terrain.gridSizeByZoom[tileZoom];
        this.fileGridSize = 0;
        this.tileZoom = tileZoom;
        this.powTileZoom = 1 << tileZoom; //Math.pow(2, tileZoom);
        this.tileX = 0;
        this.tileXE = 0;
        this.tileXW = 0;
        this.tileYN = 0;
        this.tileYS = 0;
        this.tileY = 0;
        this.tileIndex = "";
        this.elevationData = null;
        this._assignTileIndexes();
        /**
         * @toso: Check it should be Map<number, Material> instead of array
         */
        this.materials = [];
        this.plainReady = false;
        this.initialized = false;
        this.normalMapReady = false;
        this.terrainReady = false;
        this.terrainIsLoading = false;
        this.terrainExists = false;
        this.passReady = false;
        this.plainVertices = null;
        this.plainVerticesHigh = null;
        this.plainVerticesLow = null;
        this.plainNormals = null;
        this.terrainVertices = null;
        this.terrainVerticesHigh = null;
        this.terrainVerticesLow = null;
        this.noDataVertices = null;
        this.tempVertices = null;
        this.tempVerticesHigh = null;
        this.tempVerticesLow = null;
        this.normalMapTexture = null;
        this.normalMapTextureBias = new Float32Array(3);
        this.normalMapVertices = null;
        this.normalMapVerticesHigh = null;
        this.normalMapVerticesLow = null;
        this.normalMapNormals = null;
        this.vertexNormalBuffer = null;
        this.vertexPositionBuffer = null;
        this.vertexPositionBufferHigh = null;
        this.vertexPositionBufferLow = null;
        this.vertexTextureCoordBuffer = null;
        this._globalTextureCoordinates = new Float32Array(4);
        this._inTheQueue = false;
        this._appliedNeighborsZoom = [0, 0, 0, 0];
        this._slices = [];
        this._indexBuffer = null;
        this.readyToEngage = false;
        this.plainProcessing = false;
        this.normalMapTexturePtr = null;
        this._transitionOpacity = 1.0;
        this._transitionTimestamp = 0;
    }
    checkZoom() {
        return this.tileZoom < this.planet.terrain._maxNodeZoom;
    }
    /**
     * Returns entity terrain point.
     * @public
     * @param {Entity} entity - Entity.
     * @param {Vec3} res - Point coordinates.
     * @returns {Vec3} -
     */
    getEntityTerrainPoint(entity, res) {
        return this.getTerrainPoint(entity._cartesian, this.getInsideLonLat(entity), res);
    }
    getInsideLonLat(obj) {
        return obj._lonLatMerc;
    }
    isEntityInside(entity) {
        return this._extentLonLat.isInside(entity._lonLat);
    }
    /**
     * Returns distance from object to terrain coordinates and terrain point that calculates out in the res parameter.
     * @public
     * @param {Vec3} xyz - Cartesian object position.
     * @param {LonLat} insideSegmentPosition - Geodetic object position.
     * @param {Vec3} [res] - Result cartesian coordinates on the terrain.
     * @returns {number} -
     */
    getTerrainPoint(xyz, insideSegmentPosition, res) {
        let verts = this.tempVertices;
        if (verts && verts.length) {
            let norm = this.planet.ellipsoid.getSurfaceNormal3v(xyz);
            _ray.set(xyz, norm.negateTo());
            let ne = this._extent.northEast, sw = this._extent.southWest, size = Math.sqrt(verts.length / 3) - 1;
            let xmax = ne.lon, ymax = ne.lat, xmin = sw.lon, ymin = sw.lat, x = insideSegmentPosition.lon, y = insideSegmentPosition.lat;
            let sxn = xmax - xmin, syn = ymax - ymin;
            let qx = sxn / size, qy = syn / size;
            let xn = x - xmin, yn = y - ymin;
            let indX = Math.floor(xn / qx), indY = Math.floor(size - yn / qy);
            let ind_v0 = ((size + 1) * indY + indX) * 3;
            let ind_v2 = ((size + 1) * (indY + 1) + indX) * 3;
            _v0.set(verts[ind_v0], verts[ind_v0 + 1], verts[ind_v0 + 2]);
            _v1.set(verts[ind_v0 + 3], verts[ind_v0 + 4], verts[ind_v0 + 5]);
            _v2.set(verts[ind_v2], verts[ind_v2 + 1], verts[ind_v2 + 2]);
            let d = _ray.hitTriangle(_v0, _v1, _v2, res);
            if (d === Ray$1.INSIDE) {
                return xyz.distance(res);
            }
            else if (d === Ray$1.AWAY) {
                _rayEx.set(xyz, norm);
                let d = _rayEx.hitTriangle(_v0, _v1, _v2, res);
                if (d === Ray$1.INSIDE) {
                    return -xyz.distance(res);
                }
            }
            _v3.set(verts[ind_v2 + 3], verts[ind_v2 + 4], verts[ind_v2 + 5]);
            d = _ray.hitTriangle(_v1, _v3, _v2, res);
            if (d === Ray$1.INSIDE) {
                return xyz.distance(res);
            }
            else if (d === Ray$1.AWAY) {
                _rayEx.set(xyz, norm);
                let d = _rayEx.hitTriangle(_v1, _v3, _v2, res);
                if (d === Ray$1.INSIDE) {
                    return -xyz.distance(res);
                }
            }
            if (d === Ray$1.AWAY) {
                return -xyz.distance(res);
            }
            return xyz.distance(res);
        }
        else {
            return xyz.distance(this.planet.ellipsoid.hitRay(_ray.origin, _ray.direction));
        }
    }
    /**
     * Project wgs86 to segment native projection.
     * @public
     * @param {LonLat} lonlat - Coordinates to project.
     * @returns {LonLat} -
     */
    projectNative(lonlat) {
        return lonlat.forwardMercator();
    }
    loadTerrain(forceLoading = false) {
        if (this.tileZoom < this.planet.terrain.minZoom || this.planet.terrain.isEmpty) {
            this.terrainIsLoading = true;
            this.elevationsNotExists();
            if (!this._inTheQueue) {
                this.planet._normalMapCreator.queue(this);
            }
        }
        else {
            if (this.tileZoom > this.planet.terrain.maxZoom) {
                this.elevationsNotExists();
            }
            else if (!this.terrainIsLoading && !this.terrainReady) {
                this.planet.terrain.loadTerrain(this, forceLoading);
            }
            // if (!this.terrainIsLoading && !this.terrainReady) {
            //     this.planet.terrain.loadTerrain(this, forceLoading);
            // }
        }
    }
    /**
     * Terrain obtained from server.
     * @param {Float32Array} elevations - Elevation data.
     */
    elevationsExists(elevations) {
        if (this.plainReady && this.terrainIsLoading) {
            let _elevations = new Float32Array(elevations.length);
            _elevations.set(elevations);
            this.elevationData = new Float32Array(elevations.length);
            this.elevationData.set(elevations);
            this.planet._terrainWorker.make({ segment: this, elevations: _elevations });
            this.plainVerticesHigh = null;
            this.plainVerticesLow = null;
            this.normalMapVerticesHigh = null;
            this.normalMapVerticesLow = null;
            if (!this.planet.terrain.equalizeVertices) {
                this.tempVerticesHigh = null;
                this.tempVerticesLow = null;
            }
        }
    }
    /**
     * Keep plain elevation segment for rendering
     *
     * 'this.tileZoom <= this.planet.terrain.maxZoom' it means, that the segment is plain
     *
     */
    elevationsNotExists() {
        if (this.planet && this.tileZoom <= this.planet.terrain.maxNativeZoom) {
            if (this.plainReady && this.terrainIsLoading) {
                this.terrainIsLoading = false;
                let n = this.node;
                n.appliedTerrainNodeId = this.node.nodeId;
                n.equalizedSideWithNodeId[N] = n.equalizedSideWithNodeId[E] = n.equalizedSideWithNodeId[S] =
                    n.equalizedSideWithNodeId[W] = n.appliedTerrainNodeId;
                if (this.planet.lightEnabled && !this._inTheQueue) {
                    this.planet._normalMapCreator.queue(this);
                }
                this.readyToEngage = true;
            }
            // plain terrain only
            this.terrainVertices = this.plainVertices;
            this.terrainVerticesHigh = this.plainVerticesHigh;
            this.terrainVerticesLow = this.plainVerticesLow;
            this.tempVertices = this.terrainVertices;
            this.tempVerticesHigh = this.terrainVerticesHigh;
            this.tempVerticesLow = this.terrainVerticesLow;
            this.noDataVertices = null;
            this.fileGridSize = Math.sqrt(this.terrainVertices.length / 3) - 1;
            this.gridSize = this.fileGridSize;
            this.terrainReady = true;
            this.terrainExists = false;
        }
        else {
            if (this.plainReady && this.terrainIsLoading) {
                this.terrainIsLoading = false;
                let n = this.node;
                n.appliedTerrainNodeId = this.node.nodeId;
                n.equalizedSideWithNodeId[N] = n.equalizedSideWithNodeId[E] = n.equalizedSideWithNodeId[S] =
                    n.equalizedSideWithNodeId[W] = n.appliedTerrainNodeId;
                this.readyToEngage = true;
                this.terrainReady = true;
                this.passReady = true;
                this.terrainExists = false;
            }
        }
    }
    _checkEqualization(neighborSide, neigborNode) {
        return neigborNode && neigborNode.segment && this.tileZoom >= neigborNode.segment.tileZoom &&
            this.node.equalizedSideWithNodeId[neighborSide] !== neigborNode.equalizedSideWithNodeId[OPSIDE[neighborSide]];
    }
    equalize() {
        // Equalization doesnt work correctly for gridSize equals 2
        if (this.tileZoom < 2 || this.gridSize < 2) {
            return;
        }
        this.readyToEngage = true;
        let nn = this.node.neighbors;
        let v = this.tempVertices, vHigh = this.tempVerticesHigh, vLow = this.tempVerticesLow;
        let gs = this.gridSize, gsOne = gs + 1;
        let n = nn[N][0];
        if (this._checkEqualization(N, n)) {
            this.node.equalizedSideWithNodeId[N] = n.equalizedSideWithNodeId[S];
            this.readyToEngage = true;
            let offset = this.node.getOffsetOppositeNeighbourSide(n, N);
            let nv = n.segment.tempVertices, nvHigh = n.segment.tempVerticesHigh, nvLow = n.segment.tempVerticesLow;
            let n_gs = n.segment.gridSize, n_gsOne = n_gs + 1;
            let dz = 1 / (1 << (this.tileZoom - n.segment.tileZoom));
            let inc = Math.max(gs / (n_gs * dz), 1), n_inc = Math.max((n_gs * dz) / gs, 1), n_offset = offset * n_gs;
            for (let k = 0, nk = n_offset; k < gsOne; k += inc, nk += n_inc) {
                const index = k * 3;
                const n_index = (n_gsOne * n_gs + nk) * 3;
                v[index] = nv[n_index];
                v[index + 1] = nv[n_index + 1];
                v[index + 2] = nv[n_index + 2];
                vHigh[index] = nvHigh[n_index];
                vHigh[index + 1] = nvHigh[n_index + 1];
                vHigh[index + 2] = nvHigh[n_index + 2];
                vLow[index] = nvLow[n_index];
                vLow[index + 1] = nvLow[n_index + 1];
                vLow[index + 2] = nvLow[n_index + 2];
            }
        }
        n = nn[E][0];
        if (this._checkEqualization(E, n)) {
            this.node.equalizedSideWithNodeId[E] = n.equalizedSideWithNodeId[W];
            this.readyToEngage = true;
            let offset = this.node.getOffsetOppositeNeighbourSide(n, E);
            let nv = n.segment.tempVertices, nvHigh = n.segment.tempVerticesHigh, nvLow = n.segment.tempVerticesLow;
            let n_gs = n.segment.gridSize, n_gsOne = n_gs + 1;
            let dz = 1 / (1 << (this.tileZoom - n.segment.tileZoom));
            let inc = Math.max(gs / (n_gs * dz), 1), n_inc = Math.max((n_gs * dz) / gs, 1), n_offset = offset * n_gs;
            for (let k = 0, nk = n_offset; k < gsOne; k += inc, nk += n_inc) {
                const index = (gsOne * k + gs) * 3;
                const n_index = n_gsOne * nk * 3;
                v[index] = nv[n_index];
                v[index + 1] = nv[n_index + 1];
                v[index + 2] = nv[n_index + 2];
                vHigh[index] = nvHigh[n_index];
                vHigh[index + 1] = nvHigh[n_index + 1];
                vHigh[index + 2] = nvHigh[n_index + 2];
                vLow[index] = nvLow[n_index];
                vLow[index + 1] = nvLow[n_index + 1];
                vLow[index + 2] = nvLow[n_index + 2];
            }
        }
        n = nn[S][0];
        if (this._checkEqualization(S, n)) {
            this.node.equalizedSideWithNodeId[S] = n.equalizedSideWithNodeId[N];
            this.readyToEngage = true;
            let offset = this.node.getOffsetOppositeNeighbourSide(n, S);
            let nv = n.segment.tempVertices, nvHigh = n.segment.tempVerticesHigh, nvLow = n.segment.tempVerticesLow;
            let n_gs = n.segment.gridSize; // n_gsOne = n_gs + 1;
            let dz = 1 / (1 << (this.tileZoom - n.segment.tileZoom));
            let inc = Math.max(gs / (n_gs * dz), 1), n_inc = Math.max((n_gs * dz) / gs, 1), n_offset = offset * n_gs;
            for (let k = 0, nk = n_offset; k < gsOne; k += inc, nk += n_inc) {
                const index = (gsOne * gs + k) * 3;
                const n_index = nk * 3;
                v[index] = nv[n_index];
                v[index + 1] = nv[n_index + 1];
                v[index + 2] = nv[n_index + 2];
                vHigh[index] = nvHigh[n_index];
                vHigh[index + 1] = nvHigh[n_index + 1];
                vHigh[index + 2] = nvHigh[n_index + 2];
                vLow[index] = nvLow[n_index];
                vLow[index + 1] = nvLow[n_index + 1];
                vLow[index + 2] = nvLow[n_index + 2];
            }
        }
        n = nn[W][0];
        if (this._checkEqualization(W, n)) {
            this.node.equalizedSideWithNodeId[W] = n.equalizedSideWithNodeId[E];
            this.readyToEngage = true;
            let offset = this.node.getOffsetOppositeNeighbourSide(n, W);
            let nv = n.segment.tempVertices, nvHigh = n.segment.tempVerticesHigh, nvLow = n.segment.tempVerticesLow;
            let n_gs = n.segment.gridSize, n_gsOne = n_gs + 1;
            let dz = 1 / (1 << (this.tileZoom - n.segment.tileZoom));
            let inc = Math.max(gs / (n_gs * dz), 1), n_inc = Math.max((n_gs * dz) / gs, 1), n_offset = offset * n_gs;
            for (let k = 0, nk = n_offset; k < gsOne; k += inc, nk += n_inc) {
                const index = gsOne * k * 3;
                const n_index = (n_gsOne * nk + n_gs) * 3;
                v[index] = nv[n_index];
                v[index + 1] = nv[n_index + 1];
                v[index + 2] = nv[n_index + 2];
                vHigh[index] = nvHigh[n_index];
                vHigh[index + 1] = nvHigh[n_index + 1];
                vHigh[index + 2] = nvHigh[n_index + 2];
                vLow[index] = nvLow[n_index];
                vLow[index + 1] = nvLow[n_index + 1];
                vLow[index + 2] = nvLow[n_index + 2];
            }
        }
    }
    engage() {
        this.readyToEngage = false;
        this.createCoordsBuffers(this.tempVerticesHigh, this.tempVerticesLow, this.gridSize);
    }
    _terrainWorkerCallback(data) {
        if (this.plainReady) {
            this.readyToEngage = true;
            this.normalMapNormals = null;
            this.normalMapVertices = null;
            this.normalMapVerticesHigh = null;
            this.normalMapVerticesLow = null;
            this.terrainVertices = null;
            this.terrainVerticesHigh = null;
            this.terrainVerticesLow = null;
            this.noDataVertices = null;
            this.tempVertices = null;
            this.tempVerticesHigh = null;
            this.tempVerticesLow = null;
            this.normalMapNormals = data.normalMapNormals;
            this.normalMapVertices = data.normalMapVertices;
            this.normalMapVerticesHigh = data.normalMapVerticesHigh;
            this.normalMapVerticesLow = data.normalMapVerticesLow;
            this.terrainVertices = data.terrainVertices;
            this.terrainVerticesHigh = data.terrainVerticesHigh;
            this.terrainVerticesLow = data.terrainVerticesLow;
            this.noDataVertices = data.noDataVertices;
            this.tempVertices = this.terrainVertices;
            this.tempVerticesHigh = this.terrainVerticesHigh;
            this.tempVerticesLow = this.terrainVerticesLow;
            this.setBoundingVolumeArr(data.bounds);
            this.gridSize = Math.sqrt(this.terrainVertices.length / 3) - 1;
            let n = this.node;
            n.appliedTerrainNodeId = n.nodeId;
            n.equalizedSideWithNodeId[N] = n.equalizedSideWithNodeId[E] = n.equalizedSideWithNodeId[S] =
                n.equalizedSideWithNodeId[W] = n.appliedTerrainNodeId;
            this.terrainReady = true;
            this.terrainIsLoading = false;
            this.terrainExists = true;
            if (!this.normalMapTexturePtr) {
                const nmc = this.planet._normalMapCreator;
                this.normalMapTexturePtr = this.planet.renderer.handler.createEmptyTexture_l(nmc.width, nmc.height);
            }
            if (this.planet.lightEnabled) {
                this.planet._normalMapCreator.queue(this);
            }
        }
    }
    _normalMapEdgeEqualize(side) {
        let nn = this.node.neighbors;
        let nns = nn[side];
        let n = nns && nns[0];
        let maxZ = this.planet.terrain.maxZoom;
        if (this.tileZoom === maxZ) {
            if (nns && !(nn[0].length || nn[1].length || nn[2].length || nn[3].length)) {
                n = this.node.getEqualNeighbor(side);
            }
        }
        let b = n && n.segment, s = this;
        if (n &&
            b &&
            b.terrainReady &&
            b.terrainExists &&
            b.tileZoom <= maxZ &&
            s._appliedNeighborsZoom[side] !== b.tileZoom) {
            s._appliedNeighborsZoom[side] = b.tileZoom;
            let seg_a = s.normalMapNormals, seg_b = b.normalMapNormals;
            if (!(seg_a && seg_b))
                return;
            let seg_a_raw = s.normalMapNormals, seg_b_raw = b.normalMapNormals;
            // let seg_a_verts = s.terrainVertices,
            //     seg_b_verts = s.terrainVertices;
            let s_gs = Math.sqrt(seg_a.length / 3), 
            // b_gs = Math.sqrt(seg_b.length / 3),
            s_gs1 = s_gs - 1;
            // b_gs1 = b_gs - 1;
            const i_a = s_gs1 * _S[side];
            let nx, ny, nz, q;
            if (s.tileZoom === b.tileZoom) {
                const i_b = s_gs1 - i_a;
                if (_V[side]) {
                    for (let k = 0; k < s_gs; k++) {
                        let vInd_a = (k * s_gs + i_a) * 3, vInd_b = (k * s_gs + i_b) * 3;
                        nx = seg_a_raw[vInd_a] + seg_b_raw[vInd_b];
                        ny = seg_a_raw[vInd_a + 1] + seg_b_raw[vInd_b + 1];
                        nz = seg_a_raw[vInd_a + 2] + seg_b_raw[vInd_b + 2];
                        q = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);
                        seg_b[vInd_b] = seg_a[vInd_a] = nx * q;
                        seg_b[vInd_b + 1] = seg_a[vInd_a + 1] = ny * q;
                        seg_b[vInd_b + 2] = seg_a[vInd_a + 2] = nz * q;
                    }
                }
                else {
                    for (let k = 0; k < s_gs; k++) {
                        let vInd_a = (i_a * s_gs + k) * 3, vInd_b = (i_b * s_gs + k) * 3;
                        nx = seg_a_raw[vInd_a] + seg_b_raw[vInd_b];
                        ny = seg_a_raw[vInd_a + 1] + seg_b_raw[vInd_b + 1];
                        nz = seg_a_raw[vInd_a + 2] + seg_b_raw[vInd_b + 2];
                        q = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);
                        seg_b[vInd_b] = seg_a[vInd_a] = nx * q;
                        seg_b[vInd_b + 1] = seg_a[vInd_a + 1] = ny * q;
                        seg_b[vInd_b + 2] = seg_a[vInd_a + 2] = nz * q;
                    }
                }
                if (!b._inTheQueue && b._appliedNeighborsZoom[OPSIDE[side]] !== s.tileZoom) {
                    b._appliedNeighborsZoom[OPSIDE[side]] = s.tileZoom;
                    s.planet._normalMapCreator.queue(b);
                }
            }
        }
    }
    applyTerrain(elevations) {
        if (elevations) {
            this.elevationsExists(elevations);
        }
        else {
            this.elevationsNotExists();
        }
    }
    deleteBuffers() {
        const gl = this.handler.gl;
        gl.deleteBuffer(this.vertexNormalBuffer);
        gl.deleteBuffer(this.vertexPositionBuffer);
        gl.deleteBuffer(this.vertexPositionBufferHigh);
        gl.deleteBuffer(this.vertexPositionBufferLow);
        this.vertexNormalBuffer = null;
        this.vertexPositionBuffer = null;
        this.vertexPositionBufferHigh = null;
        this.vertexPositionBufferLow = null;
        this.vertexTextureCoordBuffer = null;
    }
    deleteMaterials() {
        let m = this.materials;
        for (let i = 0; i < m.length; i++) {
            let mi = m[i];
            if (mi) {
                mi.clear();
            }
        }
        this.materials.length = 0;
    }
    deleteElevations() {
        this.terrainExists = false;
        this.terrainReady = false;
        this.terrainIsLoading = false;
        this.normalMapVertices = null;
        this.normalMapVerticesHigh = null;
        this.normalMapVerticesLow = null;
        this.normalMapNormals = null;
        this.tempVertices = null;
        this.tempVerticesHigh = null;
        this.tempVerticesLow = null;
        this.terrainVertices = null;
        this.terrainVerticesHigh = null;
        this.terrainVerticesLow = null;
        this.noDataVertices = null;
        this.plainVertices = null;
        this.plainVerticesHigh = null;
        this.plainVerticesLow = null;
        this.plainNormals = null;
        if (this.normalMapReady) {
            this.handler.gl.deleteTexture(this.normalMapTexture);
            this.normalMapReady = false;
        }
        this._appliedNeighborsZoom = [0, 0, 0, 0];
        this.normalMapTextureBias[0] = 0;
        this.normalMapTextureBias[1] = 0;
        this.normalMapTextureBias[2] = 1;
        this._inTheQueue = false;
    }
    clearSegment() {
        this.plainReady = false;
        this.initialized = false;
        this.deleteBuffers();
        this.deleteMaterials();
        this.deleteElevations();
    }
    childrenInitialized() {
        let n = this.node.nodes;
        return n.length === 4 && n[0].segment.initialized && n[1].segment.initialized && n[2].segment.initialized && n[3].segment.initialized;
    }
    destroySegment() {
        this.clearSegment();
        let i = this._slices.length;
        while (i--) {
            this._slices[i].clear();
        }
        //@ts-ignore
        this._slices = null;
        //@ts-ignore
        this.node = null;
        //@ts-ignore
        this.planet = null;
        //@ts-ignore
        this.handler = null;
        //@ts-ignore
        this.bbox = null;
        //@ts-ignore
        this.bsphere = null;
        //@ts-ignore
        this._extent = null;
        //@ts-ignore
        this.materials = null;
        this.plainVertices = null;
        this.plainVerticesHigh = null;
        this.plainVerticesLow = null;
        this.plainNormals = null;
        this.terrainVertices = null;
        this.terrainVerticesHigh = null;
        this.terrainVerticesLow = null;
        this.noDataVertices = null;
        this.tempVertices = null;
        this.tempVerticesHigh = null;
        this.tempVerticesLow = null;
        //@ts-ignore
        this.normalMapTextureBias = null;
        this.normalMapTexture = null;
        this.normalMapVertices = null;
        this.normalMapVerticesHigh = null;
        this.normalMapVerticesLow = null;
        this.normalMapNormals = null;
        this.vertexNormalBuffer = null;
        this.vertexPositionBuffer = null;
        this.vertexPositionBufferHigh = null;
        this.vertexPositionBufferLow = null;
        this.vertexTextureCoordBuffer = null;
        // @ts-ignore
        this._projection = null;
        // @ts-ignore
        this._appliedNeighborsZoom = null;
        // @ts-ignore
        this._globalTextureCoordinates = null;
    }
    /**
     * @todo: looks like it could be simplified in Segment contructor
     */
    _setExtentLonLat() {
        this._extentLonLat = this._extent.inverseMercator();
    }
    _createExtentNormals() {
        const ellipsoid = this.planet.ellipsoid;
        const extent = this._extentLonLat;
        const coord_sw = ellipsoid.geodeticToCartesian(extent.southWest.lon, extent.southWest.lat);
        const coord_ne = ellipsoid.geodeticToCartesian(extent.northEast.lon, extent.northEast.lat);
        const coord_nw = ellipsoid.geodeticToCartesian(extent.southWest.lon, extent.northEast.lat);
        const coord_se = ellipsoid.geodeticToCartesian(extent.northEast.lon, extent.southWest.lat);
        this._sw.copy(coord_sw);
        this._nw.copy(coord_nw);
        this._ne.copy(coord_ne);
        this._se.copy(coord_se);
    }
    createBoundsByExtent() {
        this._createExtentNormals();
        this.setBoundingVolume3v(this._sw, this._ne);
    }
    createBoundsByParent() {
        let pn = this.node;
        while (pn.parentNode && !pn.segment.terrainReady) {
            pn = pn.parentNode;
        }
        let dZ2 = 1 << (this.tileZoom - pn.segment.tileZoom);
        let offsetX = this.tileX - pn.segment.tileX * dZ2, offsetY = this.tileY - pn.segment.tileY * dZ2;
        if (pn.segment.terrainReady && pn.segment.tileZoom >= this.planet.terrain.minZoom) {
            let gridSize = pn.segment.gridSize / dZ2;
            if (gridSize >= 1.0) {
                //
                // (*) Actually, we get parent whole bounding volume
                //
                this.bsphere.center.x = pn.segment.bsphere.center.x;
                this.bsphere.center.y = pn.segment.bsphere.center.y;
                this.bsphere.center.z = pn.segment.bsphere.center.z;
                this.bsphere.radius = pn.segment.bsphere.radius;
                let i0 = gridSize * offsetY;
                let j0 = gridSize * offsetX;
                let pnGsOne = pn.segment.gridSize + 1;
                let ind_sw = 3 * ((i0 + gridSize) * pnGsOne + j0), ind_nw = 3 * (i0 * pnGsOne + j0), ind_ne = 3 * (i0 * pnGsOne + j0 + gridSize), ind_se = 3 * ((i0 + gridSize) * pnGsOne + j0 + gridSize);
                let pVerts = pn.segment.tempVertices;
                let v_sw = new Vec3(pVerts[ind_sw], pVerts[ind_sw + 1], pVerts[ind_sw + 2]), v_ne = new Vec3(pVerts[ind_ne], pVerts[ind_ne + 1], pVerts[ind_ne + 2]);
                // check for segment zoom
                let v_nw = new Vec3(pVerts[ind_nw], pVerts[ind_nw + 1], pVerts[ind_nw + 2]), v_se = new Vec3(pVerts[ind_se], pVerts[ind_se + 1], pVerts[ind_se + 2]);
                this._sw.copy(v_sw);
                this._nw.copy(v_nw);
                this._ne.copy(v_ne);
                this._se.copy(v_se);
            }
            else {
                let pseg = pn.segment;
                let i0 = Math.floor(gridSize * offsetY), j0 = Math.floor(gridSize * offsetX);
                let insideSize = 1.0 / gridSize;
                let t_i0 = offsetY - insideSize * i0, t_j0 = offsetX - insideSize * j0;
                let bigOne;
                if (pseg.gridSize === 1) {
                    bigOne = pseg.tempVertices;
                }
                else {
                    bigOne = getMatrixSubArray64(pseg.tempVertices, pseg.gridSize, i0, j0, 1);
                }
                let v_lt = new Vec3(bigOne[0], bigOne[1], bigOne[2]), v_rb = new Vec3(bigOne[9], bigOne[10], bigOne[11]);
                let vn = new Vec3(bigOne[3] - bigOne[0], bigOne[4] - bigOne[1], bigOne[5] - bigOne[2]), vw = new Vec3(bigOne[6] - bigOne[0], bigOne[7] - bigOne[1], bigOne[8] - bigOne[2]), ve = new Vec3(bigOne[3] - bigOne[9], bigOne[4] - bigOne[10], bigOne[5] - bigOne[11]), vs = new Vec3(bigOne[6] - bigOne[9], bigOne[7] - bigOne[10], bigOne[8] - bigOne[11]);
                let vi_y = t_i0, vi_x = t_j0;
                let coords_lt, coords_rb;
                if (vi_y + vi_x < insideSize) {
                    coords_lt = Vec3.add(vn.scaleTo(vi_x / insideSize), vw.scaleTo(vi_y / insideSize)).addA(v_lt);
                }
                else {
                    coords_lt = Vec3.add(vs.scaleTo(1 - vi_x / insideSize), ve.scaleTo(1 - vi_y / insideSize)).addA(v_rb);
                }
                vi_y = t_i0 + 1;
                vi_x = t_j0 + 1;
                if (vi_y + vi_x < insideSize) {
                    coords_rb = Vec3.add(vn.scaleTo(vi_x / insideSize), vw.scaleTo(vi_y / insideSize)).addA(v_lt);
                }
                else {
                    coords_rb = Vec3.add(vs.scaleTo(1 - vi_x / insideSize), ve.scaleTo(1 - vi_y / insideSize)).addA(v_rb);
                }
                this._createExtentNormals();
                this.setBoundingVolume3v(coords_lt, coords_rb);
            }
        }
        else {
            this.createBoundsByExtent();
        }
    }
    setBoundingSphere(x, y, z, v) {
        this.bsphere.center.x = x;
        this.bsphere.center.y = y;
        this.bsphere.center.z = z;
        this.bsphere.radius = this.bsphere.center.distance(v);
    }
    setBoundingVolume(xmin, ymin, zmin, xmax, ymax, zmax) {
        this.bbox.setFromBoundsArr([xmin, ymin, zmin, xmax, ymax, zmax]);
        let x = xmin + (xmax - xmin) * 0.5, y = ymin + (ymax - ymin) * 0.5, z = zmin + (zmax - zmin) * 0.5;
        this.bsphere.center.set(x, y, z);
        this.bsphere.radius = this.bsphere.center.distance(new Vec3(xmin, ymin, zmin));
    }
    setBoundingVolume3v(vmin, vmax) {
        this.bbox.setFromBoundsArr([vmin.x, vmin.y, vmin.z, vmax.x, vmax.y, vmax.z]);
        let x = vmin.x + (vmax.x - vmin.x) * 0.5, y = vmin.y + (vmax.y - vmin.y) * 0.5, z = vmin.z + (vmax.z - vmin.z) * 0.5;
        this.bsphere.center.set(x, y, z);
        this.bsphere.radius = this.bsphere.center.distance(new Vec3(vmin.x, vmin.y, vmin.z));
    }
    setBoundingVolumeArr(bounds) {
        this.bbox.setFromBoundsArr(bounds);
        let x = bounds[0] + (bounds[3] - bounds[0]) * 0.5, y = bounds[1] + (bounds[4] - bounds[1]) * 0.5, z = bounds[2] + (bounds[5] - bounds[2]) * 0.5;
        this.bsphere.center.set(x, y, z);
        this.bsphere.radius = this.bsphere.center.distance(new Vec3(bounds[0], bounds[1], bounds[2]));
    }
    createCoordsBuffers(verticesHigh, verticesLow, gridSize) {
        const gsgs = (gridSize + 1) * (gridSize + 1);
        const h = this.handler;
        if (this.vertexPositionBufferHigh && this.vertexPositionBufferHigh.numItems === gsgs) {
            h.setStreamArrayBuffer(this.vertexPositionBufferHigh, verticesHigh);
            h.setStreamArrayBuffer(this.vertexPositionBufferLow, verticesLow);
        }
        else {
            h.gl.deleteBuffer(this.vertexPositionBufferHigh);
            h.gl.deleteBuffer(this.vertexPositionBufferLow);
            this.vertexTextureCoordBuffer = this.planet._textureCoordsBufferCache[Math.log2(gridSize)];
            // @todo use it!
            //this.vertexPositionBufferHigh = h.createStreamArrayBuffer(3, gsgs);
            //h.setStreamArrayBuffer(this.vertexPositionBufferHigh, verticesHigh);
            //this.vertexPositionBufferLow = h.createStreamArrayBuffer(3, gsgs);
            //h.setStreamArrayBuffer(this.vertexPositionBufferLow, verticesLow);
            // It works, but I'm not sure that it is correct and better use the comment above
            this.vertexPositionBufferHigh = h.createArrayBuffer(verticesHigh, 3, gsgs);
            this.vertexPositionBufferLow = h.createArrayBuffer(verticesLow, 3, gsgs);
        }
    }
    _addViewExtent() {
        const ext = this._extentLonLat;
        let viewExt = this.planet._viewExtent;
        if (ext.southWest.lon < viewExt.southWest.lon) {
            viewExt.southWest.lon = ext.southWest.lon;
        }
        if (ext.northEast.lon > viewExt.northEast.lon) {
            viewExt.northEast.lon = ext.northEast.lon;
        }
        if (ext.southWest.lat < viewExt.southWest.lat) {
            viewExt.southWest.lat = ext.southWest.lat;
        }
        if (ext.northEast.lat > viewExt.northEast.lat) {
            viewExt.northEast.lat = ext.northEast.lat;
        }
    }
    _assignTileIndexes() {
        this._tileGroup = TILEGROUP_COMMON;
        const tileZoom = this.tileZoom;
        const extent = this._extent;
        const pole = POLE;
        // this.tileX = Math.round(Math.abs(-pole - extent.southWest.lon) / (extent.northEast.lon - extent.southWest.lon));
        // this.tileY = Math.round(Math.abs(pole - extent.northEast.lat) / (extent.northEast.lat - extent.southWest.lat));
        this.tileX = getTileCellIndex(extent.getCenter().lon, extent.getWidth(), -pole);
        this.tileY = getTileCellIndex(extent.getCenter().lat, extent.getHeight(), pole);
        const p2 = this.powTileZoom; //Math.pow(2, tileZoom);
        this.tileXE = (this.tileX + 1) % p2;
        this.tileXW = (p2 + this.tileX - 1) % p2;
        this.tileYN = this.tileY - 1;
        this.tileYS = this.tileY + 1;
        this.tileIndex = Layer.getTileIndex(this.tileX, this.tileY, tileZoom, this._tileGroup);
    }
    initialize() {
        const p = this.planet;
        const n = this.node;
        this.gridSize = p.terrain.gridSizeByZoom[this.tileZoom] || p.terrain.plainGridSize;
        n.sideSizeLog2[0] = n.sideSizeLog2[1] = n.sideSizeLog2[2] = n.sideSizeLog2[3] = Math.log2(this.gridSize);
        if (this.tileZoom <= p.terrain.maxZoom) {
            const nmc = this.planet._normalMapCreator;
            this.normalMapTexturePtr = p.renderer.handler.createEmptyTexture_l(nmc.width, nmc.height);
        }
        this.normalMapTexture = this.planet.transparentTexture;
        this._assignGlobalTextureCoordinates();
        this.initialized = true;
    }
    _assignGlobalTextureCoordinates() {
        const e = this._extent;
        this._globalTextureCoordinates[0] =
            (e.southWest.lon + POLE) * ONE_BY_POLE_DOUBLE;
        this._globalTextureCoordinates[1] =
            (POLE - e.northEast.lat) * ONE_BY_POLE_DOUBLE;
        this._globalTextureCoordinates[2] =
            (e.northEast.lon + POLE) * ONE_BY_POLE_DOUBLE;
        this._globalTextureCoordinates[3] =
            (POLE - e.southWest.lat) * ONE_BY_POLE_DOUBLE;
    }
    createPlainSegmentAsync() {
        let p = this.planet, t = p.terrain;
        if (t.isReady() && !this.plainReady && this.tileZoom <= t.maxZoom) {
            this.plainProcessing = true;
            p._plainSegmentWorker.make(this);
        }
    }
    _plainSegmentWorkerCallback(data) {
        this.plainProcessing = false;
        if (this.initialized && !this.terrainReady) {
            this.plainReady = true;
            this.plainVertices = data.plainVertices;
            this.plainVerticesHigh = data.plainVerticesHigh;
            this.plainVerticesLow = data.plainVerticesLow;
            this.plainNormals = data.plainNormals;
            this._plainRadius = data.plainRadius;
            this.normalMapNormals = data.normalMapNormals;
            this.normalMapVertices = data.normalMapVertices;
            this.normalMapVerticesHigh = data.normalMapVerticesHigh;
            this.normalMapVerticesLow = data.normalMapVerticesLow;
            //this.terrainVertices = this.plainVertices;
            //this.terrainVerticesHigh = this.plainVerticesHigh;
            //this.terrainVerticesLow = this.plainVerticesLow;
            this.fileGridSize = Math.sqrt(data.normalMapVertices.length / 3) - 1;
        }
    }
    createPlainSegment() {
        this.initialize();
        this._createPlainVertices();
        this.readyToEngage = true;
    }
    _projToDeg(lon, lat) {
        return LonLat.inverseMercator(lon, lat);
    }
    _createPlainVertices() {
        const gridSize = this.planet.terrain.gridSizeByZoom[this.tileZoom];
        const fgs = this.planet.terrain.plainGridSize;
        const currGridSize = Math.max(fgs, gridSize);
        const e = this._extent;
        const lonSize = e.getWidth();
        const latSize = e.getHeight();
        const llStep = lonSize / currGridSize;
        const ltStep = latSize / currGridSize;
        const esw_lon = e.southWest.lon;
        const ene_lat = e.northEast.lat;
        const dg = Math.max(fgs / gridSize, 1);
        const gs = currGridSize + 1;
        const r2 = this.planet.ellipsoid._invRadii2;
        const gsgs = gs * gs;
        const gridSize3 = (gridSize + 1) * (gridSize + 1) * 3;
        let ind = 0, nmInd = 0;
        this.plainNormals = new Float32Array(gridSize3);
        this.plainVertices = new Float64Array(gridSize3);
        this.plainVerticesHigh = new Float32Array(gridSize3);
        this.plainVerticesLow = new Float32Array(gridSize3);
        this.normalMapNormals = new Float32Array(gsgs * 3);
        this.normalMapVertices = new Float64Array(gsgs * 3);
        this.normalMapVerticesHigh = new Float32Array(gsgs * 3);
        this.normalMapVerticesLow = new Float32Array(gsgs * 3);
        let verts = this.plainVertices, vertsHigh = this.plainVerticesHigh, vertsLow = this.plainVerticesLow, norms = this.plainNormals, nmVerts = this.normalMapVertices, nmVertsHigh = this.normalMapVerticesHigh, nmVertsLow = this.normalMapVerticesLow, nmNorms = this.normalMapNormals;
        for (let k = 0; k < gsgs; k++) {
            let j = k % gs, i = ~~(k / gs);
            let v = this.planet.ellipsoid.lonLatToCartesian(this._projToDeg(esw_lon + j * llStep, ene_lat - i * ltStep));
            let nx = v.x * r2.x, ny = v.y * r2.y, nz = v.z * r2.z;
            let l = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);
            let nxl = nx * l, nyl = ny * l, nzl = nz * l;
            Vec3.doubleToTwoFloats(v, _tempHigh$1, _tempLow$1);
            nmVerts[nmInd] = v.x;
            nmVertsHigh[nmInd] = _tempHigh$1.x;
            nmVertsLow[nmInd] = _tempLow$1.x;
            nmNorms[nmInd++] = nxl;
            nmVerts[nmInd] = v.y;
            nmVertsHigh[nmInd] = _tempHigh$1.y;
            nmVertsLow[nmInd] = _tempLow$1.y;
            nmNorms[nmInd++] = nyl;
            nmVerts[nmInd] = v.z;
            nmVertsHigh[nmInd] = _tempHigh$1.z;
            nmVertsLow[nmInd] = _tempLow$1.z;
            nmNorms[nmInd++] = nzl;
            if (i % dg === 0 && j % dg === 0) {
                verts[ind] = v.x;
                vertsHigh[ind] = _tempHigh$1.x;
                vertsLow[ind] = _tempLow$1.x;
                norms[ind++] = nxl;
                verts[ind] = v.y;
                vertsHigh[ind] = _tempHigh$1.y;
                vertsLow[ind] = _tempLow$1.y;
                norms[ind++] = nyl;
                verts[ind] = v.z;
                vertsHigh[ind] = _tempHigh$1.z;
                vertsLow[ind] = _tempLow$1.z;
                norms[ind++] = nzl;
            }
        }
        this.terrainVertices = verts;
        this.terrainVerticesHigh = vertsHigh;
        this.terrainVerticesLow = vertsLow;
        this.plainReady = true;
    }
    /**
     * Gets specific layer material.
     * @public
     * @param {Layer} layer - Layer object.
     * @returns {Material | undefined} - Segment material.
     */
    getMaterialByLayer(layer) {
        return this.materials[layer.__id];
    }
    /**
     * @param layer
     * @protected
     *
     * @todo siplify layer._extentMerc in this.getLayerExtent(layer)
     *
     */
    _getLayerExtentOffset(layer) {
        const v0s = layer._extentMerc;
        const v0t = this._extent;
        const sSize_x = v0s.northEast.lon - v0s.southWest.lon;
        const sSize_y = v0s.northEast.lat - v0s.southWest.lat;
        const dV0s_x = (v0t.southWest.lon - v0s.southWest.lon) / sSize_x;
        const dV0s_y = (v0s.northEast.lat - v0t.northEast.lat) / sSize_y;
        const dSize_x = (v0t.northEast.lon - v0t.southWest.lon) / sSize_x;
        const dSize_y = (v0t.northEast.lat - v0t.southWest.lat) / sSize_y;
        return [dV0s_x, dV0s_y, dSize_x, dSize_y];
    }
    initSlice(sliceIndex) {
        let slice = this._slices[sliceIndex];
        if (!slice) {
            slice = this._slices[sliceIndex] = new Slice(this);
        }
        else {
            //TODO: optimization!!!
            slice.layers = [];
        }
        return slice;
    }
    screenRendering(sh, layerSlice, sliceIndex, defaultTexture, isOverlay = false, forcedOpacity) {
        const gl = this.handler.gl;
        const sha = sh.attributes;
        const shu = sh.uniforms;
        const pm = this.materials;
        const p = this.planet;
        let currHeight, li;
        if (layerSlice && layerSlice.length) {
            li = layerSlice[0];
            currHeight = li._height;
        }
        else {
            currHeight = 0;
        }
        // First always draw whole planet base layer segment with solid texture.
        gl.activeTexture(gl.TEXTURE0 + p.SLICE_SIZE + 2);
        gl.bindTexture(gl.TEXTURE_2D, (defaultTexture || this.getDefaultTexture()));
        gl.uniform1i(shu.defaultTexture, p.SLICE_SIZE + 2);
        let n = 0, i = 0;
        let notEmpty = false;
        let slice = this.initSlice(sliceIndex);
        this._indexBuffer = this._getIndexBuffer();
        while (li) {
            if (this.layerOverlap(li) &&
                ((li._fading && li._fadingOpacity > 0.0) ||
                    ((li.minZoom >= p.minCurrZoom || li.maxZoom >= p.minCurrZoom) &&
                        (li.minZoom <= p.maxCurrZoom || li.maxZoom <= p.maxCurrZoom)))) {
                notEmpty = true;
                let m = pm[li.__id];
                if (!m) {
                    m = pm[li.__id] = li.createMaterial(this);
                }
                if (!m.isReady) {
                    this.planet._renderCompleted = false;
                }
                slice.append(li, m);
                p._samplerArr[n] = n;
                gl.activeTexture(gl.TEXTURE0 + n);
                gl.bindTexture(gl.TEXTURE_2D, (m.texture || p.transparentTexture));
                n++;
            }
            i++;
            li = layerSlice[i];
        }
        if (notEmpty || !isOverlay) {
            gl.uniform1f(shu.transitionOpacity, forcedOpacity || this._transitionOpacity > 1.0 ? 1.0 : this._transitionOpacity);
            gl.uniform1i(shu.samplerCount, n);
            gl.uniform1f(shu.height, currHeight);
            gl.uniform1iv(shu.samplerArr, p._samplerArr);
            //slice.uniform(gl, shu);
            gl.uniform4fv(shu.tileOffsetArr, slice.tileOffsetArr);
            gl.uniform1fv(shu.layerOpacityArr, slice.layerOpacityArr);
            //gl.uniform4fv(shu.visibleExtentOffsetArr, slice.visibleExtentOffsetArr);
            // bind normalmap texture
            if (p.lightEnabled) {
                gl.activeTexture(gl.TEXTURE0 + p.SLICE_SIZE + 3);
                gl.bindTexture(gl.TEXTURE_2D, (this.normalMapTexture || p.transparentTexture));
                gl.uniform1i(shu.uNormalMap, p.SLICE_SIZE + 3);
                gl.uniform3fv(shu.uNormalMapBias, this.normalMapTextureBias);
                // bind segment specular and night material texture coordinates
                gl.uniform4fv(shu.uGlobalTextureCoord, this._globalTextureCoordinates);
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferHigh);
            gl.vertexAttribPointer(sha.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferLow);
            gl.vertexAttribPointer(sha.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
            gl.vertexAttribPointer(sha.aTextureCoord, 2, gl.UNSIGNED_SHORT, true, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            gl.drawElements(p.drawMode, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
        }
    }
    heightPickingRendering(sh, layerSlice) {
        const gl = this.handler.gl;
        const sha = sh.attributes;
        const shu = sh.uniforms;
        // var pm = this.materials,
        //     p = this.planet;
        let currHeight;
        if (layerSlice && layerSlice.length) {
            currHeight = layerSlice[0]._height;
        }
        else {
            currHeight = 0;
        }
        gl.uniform1f(shu.height, currHeight);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferHigh);
        gl.vertexAttribPointer(sha.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferLow);
        gl.vertexAttribPointer(sha.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.drawElements(gl.TRIANGLE_STRIP, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
    }
    increaseTransitionOpacity() {
        //this._transitionOpacity += 0.01;
        this._transitionOpacity += (window.performance.now() - this._transitionTimestamp) / this.planet.transitionTime;
        this._transitionTimestamp = window.performance.now();
        if (this._transitionOpacity > 2.0) {
            this._transitionOpacity = 2.0;
        }
        let i = this.node._fadingNodes.length;
        while (i--) {
            let n = this.node._fadingNodes[i];
            if (n.segment) {
                if (n.segment._transitionOpacity > 0 && !this.planet._fadingNodes.has(n.__id)) {
                    this.planet._fadingNodes.set(n.__id, n);
                    n.segment._transitionOpacity = 2.0 - this._transitionOpacity;
                    if (n.segment._transitionOpacity === 0) {
                        this.node._fadingNodes.splice(i, 1);
                    }
                }
            }
            else {
                this._transitionOpacity = 1.0;
                break;
            }
        }
    }
    fadingTransitionOpacity() {
        this._transitionOpacity -= 0.01;
        // this._transitionOpacity -= (window.performance.now() - this._transitionTimestamp) / this.planet.transitionTime;
        this._transitionTimestamp = window.performance.now();
        if (this._transitionOpacity < 0.0) {
            this._transitionOpacity = 0;
        }
    }
    colorPickingRendering(sh, layerSlice, sliceIndex, defaultTexture, isOverlay = false) {
        const gl = this.handler.gl;
        const sha = sh.attributes;
        const shu = sh.uniforms;
        let pm = this.materials, p = this.planet;
        let currHeight;
        if (layerSlice && layerSlice.length) {
            currHeight = layerSlice[0]._height;
        }
        else {
            currHeight = 0;
        }
        let notEmpty = false;
        let slice = this._slices[sliceIndex];
        let len = slice.layers.length;
        for (let n = 0; n < len; n++) {
            notEmpty = true;
            let li = slice.layers[n];
            let n4 = n * 4;
            p._pickingColorArr[n4] = li._pickingColor.x / 255.0;
            p._pickingColorArr[n4 + 1] = li._pickingColor.y / 255.0;
            p._pickingColorArr[n4 + 2] = li._pickingColor.z / 255.0;
            p._pickingColorArr[n4 + 3] = Number(li._pickingEnabled);
            p._samplerArr[n] = n;
            gl.activeTexture(gl.TEXTURE0 + n);
            gl.bindTexture(gl.TEXTURE_2D, (pm[li.__id].texture || this.planet.transparentTexture));
            p._pickingMaskArr[n] = n + p.SLICE_SIZE;
            gl.activeTexture(gl.TEXTURE0 + n + p.SLICE_SIZE);
            gl.bindTexture(gl.TEXTURE_2D, (pm[li.__id].pickingMask || this.planet.transparentTexture));
        }
        if (notEmpty || !isOverlay) {
            gl.uniform1i(shu.samplerCount, len);
            gl.uniform1f(shu.height, currHeight);
            gl.uniform1iv(shu.samplerArr, p._samplerArr);
            gl.uniform1iv(shu.pickingMaskArr, p._pickingMaskArr);
            gl.uniform4fv(shu.pickingColorArr, p._pickingColorArr);
            //slice.uniform(gl, shu);
            gl.uniform4fv(shu.tileOffsetArr, slice.tileOffsetArr);
            gl.uniform1fv(shu.layerOpacityArr, slice.layerOpacityArr);
            //gl.uniform4fv(shu.visibleExtentOffsetArr, slice.visibleExtentOffsetArr);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferHigh);
            gl.vertexAttribPointer(sha.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferLow);
            gl.vertexAttribPointer(sha.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
            gl.vertexAttribPointer(sha.aTextureCoord, 2, gl.UNSIGNED_SHORT, true, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
        }
    }
    depthRendering(sh, layerSlice) {
        const gl = this.handler.gl;
        const sha = sh.attributes;
        const shu = sh.uniforms;
        var currHeight;
        if (layerSlice && layerSlice.length) {
            currHeight = layerSlice[0]._height;
        }
        else {
            currHeight = 0;
        }
        gl.uniform1f(shu.height, currHeight);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferHigh);
        gl.vertexAttribPointer(sha.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferLow);
        gl.vertexAttribPointer(sha.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.drawElements(gl.TRIANGLE_STRIP, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
    }
    _getIndexBuffer() {
        const s = this.node.sideSizeLog2;
        let cache = this.planet._indexesCache[Math.log2(this.gridSize)][s[0]][s[1]][s[2]][s[3]];
        if (!cache.buffer) {
            let indexes = getInstance().createSegmentIndexes(Math.log2(this.gridSize), [s[0], s[1], s[2], s[3]]);
            cache.buffer = this.planet.renderer.handler.createElementArrayBuffer(indexes, 1);
            this.planet._indexesCacheToRemoveCounter++;
        }
        return cache.buffer;
    }
    layerOverlap(layer) {
        return this._extent.overlaps(layer._extentMerc);
    }
    getDefaultTexture() {
        return this.planet.solidTextureOne;
    }
    getExtentLonLat() {
        return this._extentLonLat;
    }
    getExtentMerc() {
        return this._extentMerc;
    }
    getExtent() {
        return this._extent;
    }
    getNeighborSide(b) {
        if (this.tileY === b.tileY) {
            if (this.tileX === b.tileXE) {
                return W;
            }
            else if (this.tileX === b.tileXW) {
                return E;
            }
        }
        else if (this.tileX === b.tileX) {
            if (this.tileY === b.tileYS) {
                return N;
            }
            else if (this.tileY === b.tileYN) {
                return S;
            }
        }
        return -1;
    }
}

let _tempHigh = new Vec3(), _tempLow = new Vec3();
const _vertOrder = [
    new Vec2(0, 0), new Vec2(1, 0),
    new Vec2(0, 1), new Vec2(1, 1)
];
const _neGridSize = Math.sqrt(_vertOrder.length) - 1;
let BOUNDS = {
    xmin: 0.0, ymin: 0.0, zmin: 0.0,
    xmax: 0.0, ymax: 0.0, zmax: 0.0
};
let __staticCounter = 0;
/**
 * Quad tree planet segment node.
 * @constructor
 * @param {Segment} segmentPrototype - Planet segment node constructor.
 * @param {Planet} planet - Planet scene instance.
 * @param {number} partId - NorthEast, SouthWest etc.
 * @param {Node} parent - Parent of this node.
 * @param {number} id - Tree node identifier (id * 4 + 1);
 * @param {number} tileZoom - Deep index of the quad tree.
 * @param {Extent} extent - Planet segment extent.
 */
let Node$1 = class Node {
    constructor(SegmentPrototype, planet, partId, parent, tileZoom, extent) {
        planet._createdNodesCount++;
        this.__id = __staticCounter++;
        this.SegmentPrototype = SegmentPrototype;
        this.planet = planet;
        this.parentNode = parent;
        this.partId = partId;
        this.nodeId = partId + (parent ? parent.nodeId * 4 + 1 : 0);
        this.state = null;
        this.prevState = null;
        this.appliedTerrainNodeId = -1;
        this.sideSizeLog2 = [0, 0, 0, 0];
        this.ready = false;
        this.neighbors = [[], [], [], []];
        this.equalizedSideWithNodeId = [this.nodeId, this.nodeId, this.nodeId, this.nodeId];
        // @todo: this.nodes = null;
        this.nodes = [];
        this.segment = new SegmentPrototype(this, planet, tileZoom, extent);
        this._cameraInside = false;
        this.inFrustum = 0;
        this._fadingNodes = [];
        this.createBounds();
    }
    createChildrenNodes() {
        this.ready = true;
        const p = this.planet;
        const ps = this.segment;
        const ext = ps._extent;
        const z = ps.tileZoom + 1;
        const size_x = ext.getWidth() * 0.5;
        const size_y = ext.getHeight() * 0.5;
        const ne = ext.northEast;
        const sw = ext.southWest;
        const c = new LonLat(sw.lon + size_x, sw.lat + size_y);
        const nd = this.nodes;
        nd[NW] = new Node(this.SegmentPrototype, p, NW, this, z, new Extent(new LonLat(sw.lon, sw.lat + size_y), new LonLat(sw.lon + size_x, ne.lat)));
        nd[NE] = new Node(this.SegmentPrototype, p, NE, this, z, new Extent(c, new LonLat(ne.lon, ne.lat)));
        nd[SW] = new Node(this.SegmentPrototype, p, SW, this, z, new Extent(new LonLat(sw.lon, sw.lat), c));
        nd[SE] = new Node(this.SegmentPrototype, p, SE, this, z, new Extent(new LonLat(sw.lon + size_x, sw.lat), new LonLat(ne.lon, sw.lat + size_y)));
    }
    createBounds() {
        let seg = this.segment;
        seg._setExtentLonLat();
        if (seg.tileZoom === 0) {
            seg.setBoundingSphere(0.0, 0.0, 0.0, new Vec3(0.0, 0.0, seg.planet.ellipsoid.equatorialSize));
        }
        else if (seg.tileZoom < seg.planet.terrain.minZoom) {
            seg.createBoundsByExtent();
        }
        else {
            seg.createBoundsByParent();
        }
        let x = seg.bsphere.center.x, y = seg.bsphere.center.y, z = seg.bsphere.center.z;
        let length = 1.0 / Math.sqrt(x * x + y * y + z * z);
        seg.centerNormal.x = x * length;
        seg.centerNormal.y = y * length;
        seg.centerNormal.z = z * length;
    }
    getState() {
        if (this.state === -1) {
            return this.state;
        }
        let pn = this.parentNode;
        while (pn) {
            if (pn.state !== WALKTHROUGH) {
                return NOTRENDERING;
            }
            pn = pn.parentNode;
        }
        return this.state;
    }
    /**
     * Returns the same deep existent neighbour node.
     * @public
     * @param {number} side - Neighbour side index e.g. og.quadTree.N, og.quadTree.W etc.
     * @returns {Node} -
     */
    getEqualNeighbor(side) {
        let pn = this;
        let part = NEIGHBOUR[side][pn.partId];
        if (part !== -1) {
            // (!) it means that we would never ask to get head node neighbors
            return pn.parentNode.nodes[part];
        }
        else {
            let pathId = [];
            while (pn.parentNode) {
                pathId.push(pn.partId);
                part = NEIGHBOUR[side][pn.partId];
                pn = pn.parentNode;
                if (part !== -1) {
                    let i = pathId.length;
                    side = OPSIDE[side];
                    while (pn && i--) {
                        part = OPPART[side][pathId[i]];
                        pn = pn.nodes[part];
                    }
                    return pn;
                }
            }
        }
    }
    // public isBrother(node: Node): boolean {
    //     return !(this.parentNode || node.parentNode) || (this.parentNode!.nodeId === node.parentNode!.nodeId);
    // }
    traverseNodes(cam, maxZoom, terrainReadySegment, stopLoading, zoomPassNode) {
        if (!this.ready) {
            this.createChildrenNodes();
        }
        let n = this.nodes;
        n[0].renderTree(cam, maxZoom, terrainReadySegment, stopLoading, zoomPassNode);
        n[1].renderTree(cam, maxZoom, terrainReadySegment, stopLoading, zoomPassNode);
        n[2].renderTree(cam, maxZoom, terrainReadySegment, stopLoading, zoomPassNode);
        n[3].renderTree(cam, maxZoom, terrainReadySegment, stopLoading, zoomPassNode);
    }
    renderTree(cam, maxZoom, terrainReadySegment, stopLoading, zoomPassNode) {
        if (this.planet._renderedNodes.length >= MAX_RENDERED_NODES) {
            return;
        }
        if (!maxZoom || zoomPassNode && this.segment.tileZoom > zoomPassNode.segment.tileZoom) {
            this.prevState = this.state;
        }
        this.state = WALKTHROUGH;
        this.clearNeighbors();
        let seg = this.segment, planet = this.planet;
        this._cameraInside = false;
        // Search a node which the camera is flying over.
        if (!this.parentNode || this.parentNode._cameraInside) {
            let inside;
            if ( /*Math.abs(cam._lonLat.lat) <= MAX_LAT && */seg._projection.id === EPSG3857.id) {
                inside = seg._extent.isInside(cam._lonLatMerc);
            }
            else /*if (seg._projection.id === EPSG4326.id)*/ {
                inside = seg._extent.isInside(cam._lonLat);
            }
            if (inside) {
                cam._insideSegment = seg;
                this._cameraInside = true;
            }
        }
        this.inFrustum = 0;
        let frustums = cam.frustums, numFrustums = frustums.length;
        if (seg.tileZoom < 6) {
            for (let i = 0; i < numFrustums; i++) {
                if (frustums[i].containsSphere(seg.bsphere)) {
                    this.inFrustum |= 1 << i;
                }
            }
        }
        else {
            for (let i = 0; i < numFrustums; i++) {
                if (seg.terrainReady) {
                    if (frustums[i].containsBox(seg.bbox)) {
                        this.inFrustum |= 1 << i;
                    }
                }
                else {
                    if (frustums[i].containsSphere(seg.bsphere)) {
                        this.inFrustum |= 1 << i;
                    }
                }
            }
        }
        if (this.inFrustum || this._cameraInside || seg.tileZoom < 3) {
            let h = Math.abs(cam._lonLat.height);
            let horizonDist = cam.eye.length2() - planet.ellipsoid.polarSizeSqr;
            horizonDist = horizonDist < 106876472875.63281 * planet._heightFactor ? 106876472875.63281 * planet._heightFactor : horizonDist;
            let altVis = seg.tileZoom < 2 || seg.tileZoom > 19 ||
                /* Could be replaced with camera frustum always looking down check,
                and not to go through nodes from the opposite of the globe*/
                (seg.tileZoom < 6 && !seg.terrainReady);
            altVis = altVis ||
                cam.eye.distance2(seg._sw) < horizonDist ||
                cam.eye.distance2(seg._nw) < horizonDist ||
                cam.eye.distance2(seg._ne) < horizonDist ||
                cam.eye.distance2(seg._se) < horizonDist;
            if ((this.inFrustum && (altVis || h > 10000.0)) || this._cameraInside) {
                planet.quadTreeStrategy.collectVisibleNode(this);
            }
            if (seg.tileZoom < 2) {
                this.traverseNodes(cam, maxZoom, terrainReadySegment, stopLoading, zoomPassNode);
            }
            else if (seg.terrainReady && (!maxZoom && cam.projectedSize(seg.bsphere.center, seg._plainRadius) < planet.lodSize
                || maxZoom && ((seg.tileZoom === maxZoom) || !altVis))) {
                if (altVis) {
                    seg.passReady = true;
                    this.renderNode(this.inFrustum, !this.inFrustum, terrainReadySegment, stopLoading);
                }
                else {
                    this.state = NOTRENDERING;
                }
            }
            else if (seg.terrainReady && seg.checkZoom() && (!maxZoom || cam.projectedSize(seg.bsphere.center, seg.bsphere.radius) > this.planet._maxLodSize)) {
                this.traverseNodes(cam, maxZoom, seg, stopLoading, zoomPassNode);
            }
            else if (altVis) {
                seg.passReady = maxZoom ? seg.terrainReady : false;
                this.renderNode(this.inFrustum, !this.inFrustum, terrainReadySegment, stopLoading);
            }
            else {
                this.state = NOTRENDERING;
            }
        }
        else {
            this.state = NOTRENDERING;
        }
    }
    renderNode(inFrustum, onlyTerrain, terrainReadySegment, stopLoading) {
        let seg = this.segment;
        // Create and load terrain data
        if (!seg.terrainReady) {
            if (!seg.initialized) {
                seg.initialize();
            }
            this.whileTerrainLoading(terrainReadySegment);
            if (!seg.plainProcessing) {
                seg.createPlainSegmentAsync();
            }
            if (seg.plainReady && !stopLoading) {
                seg.loadTerrain();
            }
        }
        // Create normal map texture
        if (seg.planet.lightEnabled && !seg.normalMapReady) {
            this.whileNormalMapCreating();
        }
        if (onlyTerrain) {
            this.state = -1;
            return;
        }
        // Calculate minimal and maximal zoom index on the screen
        if (!this._cameraInside && seg.tileZoom > this.planet.maxCurrZoom) {
            this.planet.maxCurrZoom = seg.tileZoom;
        }
        if (seg.tileZoom < this.planet.minCurrZoom) {
            this.planet.minCurrZoom = seg.tileZoom;
        }
        seg._addViewExtent();
        // Finally this node proceeds to rendering.
        this.addToRender(inFrustum);
    }
    childrenPrevStateEquals(state) {
        let n = this.nodes;
        return n.length === 4 && n[0].prevState === state && n[1].prevState === state && n[2].prevState === state && n[3].prevState === state;
    }
    isFading() {
        let n = this.nodes;
        return this.state === WALKTHROUGH && this.segment._transitionOpacity > 0.0 && n.length === 4 && (n[0].state === RENDERING && n[1].state === RENDERING && n[2].state === RENDERING && n[3].state === RENDERING);
    }
    _collectFadingNodes() {
        if (this.segment.tileZoom < 3) {
            this.segment._transitionOpacity = 1.0;
            return;
        }
        // Light up the node
        if (this.prevState !== RENDERING) {
            // means that the node is lighting up
            this.segment._transitionOpacity = 0.0;
            // store fading nodes, could be a parent or children nodes
            this._fadingNodes = [];
            let timestamp = window.performance.now();
            this.segment._transitionTimestamp = timestamp;
            if (this.parentNode) {
                // Parent was visible the last frame, make the parent fading
                if (this.parentNode.prevState === RENDERING) {
                    let pn = this.parentNode.parentNode;
                    while (pn) {
                        if (pn.isFading()) {
                            for (let i = 0; i < pn.nodes.length; i++) {
                                pn.nodes[i].segment._transitionOpacity = 1.0;
                                pn.nodes[i]._fadingNodes = [];
                            }
                            pn.segment._transitionOpacity = 0.0;
                            break;
                        }
                        pn = pn.parentNode;
                    }
                    // not sure it's necessary here
                    this.parentNode.whileTerrainLoading();
                    this._fadingNodes.push(this.parentNode);
                    this.parentNode.segment._transitionOpacity = 2.0;
                    this.parentNode.segment._transitionTimestamp = timestamp;
                }
                else {
                    // Check if the children were visible last frame, and make them fading
                    if (this.segment.childrenInitialized() && this.childrenPrevStateEquals(RENDERING)) {
                        for (let i = 0; i < this.nodes.length; i++) {
                            let ni = this.nodes[i];
                            // not sure it's necessary here
                            ni.whileTerrainLoading();
                            this._fadingNodes.push(ni);
                            ni.segment._transitionOpacity = 2.0;
                            ni.segment._transitionTimestamp = timestamp;
                            ni.prevState = ni.state;
                            ni.state = NOTRENDERING;
                        }
                    }
                }
            }
        }
    }
    clearNeighbors() {
        //this.sideSizeLog2[0] = this.sideSizeLog2[1] = this.sideSizeLog2[2] = this.sideSizeLog2[3] = Math.log2(this.segment.gridSize);
        if (this.neighbors) {
            // @ts-ignore
            this.neighbors[0] = this.neighbors[1] = this.neighbors[2] = this.neighbors[3] = null;
            this.neighbors[0] = [];
            this.neighbors[1] = [];
            this.neighbors[2] = [];
            this.neighbors[3] = [];
        }
    }
    _refreshTransitionOpacity() {
        if (this._fadingNodes.length === 0) {
            this.segment._transitionOpacity = 1.0;
        }
        else {
            if (this._fadingNodes.length === 4 && !this.childrenPrevStateEquals(RENDERING)) {
                this.segment._transitionOpacity = 1.0;
                this._fadingNodes = [];
            }
            else {
                // Looks like a bug fix for suddenly empty spaces
                for (let i = 0; i < this._fadingNodes.length; i++) {
                    if (this.segment._transitionOpacity < 1.0 && this._fadingNodes[i].segment._transitionOpacity === 0) {
                        this._fadingNodes[i].segment._transitionOpacity = 0;
                        this.segment._transitionOpacity = 1.0;
                    }
                }
                this.segment.increaseTransitionOpacity();
            }
        }
    }
    /**
     * Picking up current node to render processing.
     * @public
     */
    addToRender(inFrustum) {
        this.state = RENDERING;
        let nodes = this.planet._renderedNodes;
        //@ts-ignore
        if (!this.planet._transitionOpacityEnabled) {
            this.getRenderedNodesNeighbors(nodes);
            nodes.push(this);
        }
        else {
            //@todo: check if it's possible to get rid of the sorting when using breadth traverse tree
            binaryInsert(nodes, this, (a, b) => {
                return a.segment.tileZoom - b.segment.tileZoom;
            });
        }
        if (!this.segment.terrainReady) {
            this.planet._renderCompleted = false;
            this.planet._terrainCompleted = false;
        }
        let k = 0, rf = this.planet._renderedNodesInFrustum;
        while (inFrustum) {
            if (inFrustum & 1) {
                rf[k].push(this);
            }
            k++;
            inFrustum >>= 1;
        }
    }
    applyNeighbor(node, side) {
        const opcs = OPSIDE[side];
        if (this.neighbors[side].length === 0 || node.neighbors[opcs].length === 0) {
            const ap = this.segment;
            const bp = node.segment;
            const ld = ap.gridSize / (bp.gridSize * Math.pow(2, bp.tileZoom - ap.tileZoom));
            let cs_size = ap.gridSize, opcs_size = bp.gridSize;
            if (ld > 1) {
                cs_size = Math.ceil(ap.gridSize / ld);
                opcs_size = bp.gridSize;
            }
            else if (ld < 1) {
                cs_size = ap.gridSize;
                opcs_size = Math.ceil(bp.gridSize * ld);
            }
            this.sideSizeLog2[side] = Math.log2(cs_size);
            node.sideSizeLog2[opcs] = Math.log2(opcs_size);
        }
        //@todo: fix dupe neighbors
        this.neighbors[side].push(node);
        node.neighbors[opcs].push(this);
    }
    /**
     * Searching current node for its neighbours.
     * @public
     */
    getRenderedNodesNeighbors(nodes) {
        for (let i = nodes.length - 1; i >= 0; --i) {
            let ni = nodes[i];
            let cs = this.getCommonSide(ni);
            if (cs !== -1) {
                this.applyNeighbor(ni, cs);
            }
        }
    }
    /**
     * Checking if current node has a common side with input node and return side index N, E, S or W. Otherwise returns -1.
     * @param {Node} node - Input node
     * @returns {number} - Node side index
     */
    getCommonSide(node) {
        const as = this.segment;
        const bs = node.segment;
        if (as.tileZoom === bs.tileZoom && as._tileGroup === bs._tileGroup) {
            return as.getNeighborSide(bs);
        }
        else {
            const a = as._extentLonLat;
            const b = bs._extentLonLat;
            let a_ne = a.northEast, a_sw = a.southWest, b_ne = b.northEast, b_sw = b.southWest;
            let a_ne_lon = a_ne.lon, a_ne_lat = a_ne.lat, a_sw_lon = a_sw.lon, a_sw_lat = a_sw.lat, b_ne_lon = b_ne.lon, b_ne_lat = b_ne.lat, b_sw_lon = b_sw.lon, b_sw_lat = b_sw.lat;
            if (as._tileGroup === bs._tileGroup) {
                if (a_ne_lon === b_sw_lon && ((a_ne_lat <= b_ne_lat && a_sw_lat >= b_sw_lat) || (a_ne_lat >= b_ne_lat && a_sw_lat <= b_sw_lat))) {
                    return E;
                }
                else if (a_sw_lon === b_ne_lon && ((a_ne_lat <= b_ne_lat && a_sw_lat >= b_sw_lat) || (a_ne_lat >= b_ne_lat && a_sw_lat <= b_sw_lat))) {
                    return W;
                }
                else if (a_ne_lat === b_sw_lat && ((a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon) || (a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon))) {
                    return N;
                }
                else if (a_sw_lat === b_ne_lat && ((a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon) || (a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon))) {
                    return S;
                }
                // World edge 180 to -180
                else if (bs.tileX === 0 && b_sw_lon === -a_ne_lon && ((a_ne_lat <= b_ne_lat && a_sw_lat >= b_sw_lat) || (a_ne_lat >= b_ne_lat && a_sw_lat <= b_sw_lat))) {
                    return E;
                }
                else if (as.tileX === 0 && a_sw_lon === -b_ne_lon && ((a_ne_lat <= b_ne_lat && a_sw_lat >= b_sw_lat) || (a_ne_lat >= b_ne_lat && a_sw_lat <= b_sw_lat))) {
                    return W;
                }
            }
            // @todo: replace to the default strategy
            if (as._tileGroup === TILEGROUP_COMMON && bs._tileGroup === TILEGROUP_NORTH && as.tileY === 0 && bs.tileY === bs.powTileZoom /*Math.pow(2, bs.tileZoom)*/ - 1 && ((a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon) || (a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon))) {
                return N;
            }
            else if (as._tileGroup === TILEGROUP_COMMON && bs._tileGroup === TILEGROUP_SOUTH && as.tileY === as.powTileZoom /*Math.pow(2, as.tileZoom)*/ - 1 && bs.tileY === 0 && ((a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon) || (a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon))) {
                return S;
            }
            else if (as._tileGroup === TILEGROUP_SOUTH && bs._tileGroup === TILEGROUP_COMMON && as.tileY === 0 && bs.tileY === bs.powTileZoom /*Math.pow(2, bs.tileZoom)*/ - 1 && ((a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon) || (a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon))) {
                return N;
            }
            else if (as._tileGroup === TILEGROUP_NORTH && bs._tileGroup === TILEGROUP_COMMON && as.tileY === as.powTileZoom /*Math.pow(2, as.tileZoom)*/ - 1 && bs.tileY === 0 && ((a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon) || (a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon))) {
                return S;
            }
        }
        return -1;
    }
    whileNormalMapCreating() {
        const seg = this.segment;
        if (!seg.terrainIsLoading && seg.terrainExists && !seg._inTheQueue) {
            seg.planet._normalMapCreator.queue(seg);
        }
        let pn = this;
        while (pn.parentNode && !pn.segment.normalMapReady) {
            pn = pn.parentNode;
        }
        const dZ2 = 2 << (seg.tileZoom - pn.segment.tileZoom - 1);
        seg.normalMapTexture = pn.segment.normalMapTexture;
        seg.normalMapTextureBias[0] = seg.tileX - pn.segment.tileX * dZ2;
        seg.normalMapTextureBias[1] = seg.tileY - pn.segment.tileY * dZ2;
        seg.normalMapTextureBias[2] = 1.0 / dZ2;
    }
    whileTerrainLoading(terrainReadySegment) {
        const seg = this.segment;
        let pn = this;
        if (terrainReadySegment && terrainReadySegment.terrainReady) {
            pn = terrainReadySegment.node;
        }
        else {
            while (pn.parentNode && !pn.segment.terrainReady) {
                pn = pn.parentNode;
            }
        }
        if (pn.segment.terrainReady && this.appliedTerrainNodeId !== pn.nodeId) {
            let dZ2 = 2 << (seg.tileZoom - pn.segment.tileZoom - 1), // 2 * Math.pow(2, dZ-1)
            offsetX = seg.tileX - pn.segment.tileX * dZ2, offsetY = seg.tileY - pn.segment.tileY * dZ2;
            const pseg = pn.segment;
            let tempVertices, tempVerticesHigh, tempVerticesLow, noDataVertices;
            this.appliedTerrainNodeId = pn.nodeId;
            this.equalizedSideWithNodeId[N] = this.equalizedSideWithNodeId[E] = this.equalizedSideWithNodeId[S] = this.equalizedSideWithNodeId[W] = this.appliedTerrainNodeId;
            let gridSize = pn.segment.gridSize / dZ2, gridSizeExt = pn.segment.fileGridSize / dZ2;
            BOUNDS.xmin = MAX;
            BOUNDS.xmax = MIN;
            BOUNDS.ymin = MAX;
            BOUNDS.ymax = MIN;
            BOUNDS.zmin = MAX;
            BOUNDS.zmax = MIN;
            if (gridSize >= 1) {
                seg.gridSize = gridSize;
                let len = (gridSize + 1) * (gridSize + 1) * 3;
                tempVertices = new Float64Array(len);
                tempVerticesHigh = new Float32Array(len);
                tempVerticesLow = new Float32Array(len);
                if (pseg.noDataVertices) {
                    noDataVertices = new Uint8Array(len / 3);
                }
                getMatrixSubArrayBoundsExt(pseg.terrainVertices, pseg.terrainVerticesHigh, pseg.terrainVerticesLow, pseg.noDataVertices, pseg.gridSize, gridSize * offsetY, gridSize * offsetX, gridSize, tempVertices, tempVerticesHigh, tempVerticesLow, BOUNDS, noDataVertices);
            }
            else if (gridSizeExt >= 1 && pn.segment.terrainExists) {
                seg.gridSize = gridSizeExt;
                let len = (gridSizeExt + 1) * (gridSizeExt + 1) * 3;
                tempVertices = new Float64Array(len);
                tempVerticesHigh = new Float32Array(len);
                tempVerticesLow = new Float32Array(len);
                if (pseg.noDataVertices) {
                    noDataVertices = new Uint8Array(len / 3);
                }
                getMatrixSubArrayBoundsExt(pseg.normalMapVertices, pseg.normalMapVerticesHigh, pseg.normalMapVerticesLow, pseg.noDataVertices, pn.segment.fileGridSize, gridSizeExt * offsetY, gridSizeExt * offsetX, gridSizeExt, tempVertices, tempVerticesHigh, tempVerticesLow, BOUNDS, noDataVertices);
            }
            else {
                seg.gridSize = _neGridSize;
                let i0 = Math.floor(gridSize * offsetY), j0 = Math.floor(gridSize * offsetX);
                let bigOne;
                if (pseg.gridSize === 1) {
                    bigOne = pseg.terrainVertices;
                }
                else {
                    bigOne = getMatrixSubArray64(pseg.terrainVertices, pseg.gridSize, i0, j0, 1);
                }
                let insideSize = 1.0 / gridSize;
                let t_i0 = offsetY - insideSize * i0, t_j0 = offsetX - insideSize * j0;
                let v_lt = new Vec3(bigOne[0], bigOne[1], bigOne[2]), v_rb = new Vec3(bigOne[9], bigOne[10], bigOne[11]);
                let vn = new Vec3(bigOne[3] - bigOne[0], bigOne[4] - bigOne[1], bigOne[5] - bigOne[2]), vw = new Vec3(bigOne[6] - bigOne[0], bigOne[7] - bigOne[1], bigOne[8] - bigOne[2]), ve = new Vec3(bigOne[3] - bigOne[9], bigOne[4] - bigOne[10], bigOne[5] - bigOne[11]), vs = new Vec3(bigOne[6] - bigOne[9], bigOne[7] - bigOne[10], bigOne[8] - bigOne[11]);
                let coords = new Vec3();
                tempVertices = new Float64Array(3 * _vertOrder.length);
                tempVerticesHigh = new Float32Array(3 * _vertOrder.length);
                tempVerticesLow = new Float32Array(3 * _vertOrder.length);
                for (let i = 0; i < _vertOrder.length; i++) {
                    let vi_y = _vertOrder[i].y + t_i0, vi_x = _vertOrder[i].x + t_j0;
                    let vi_x_is = vi_x * gridSize, vi_y_is = vi_y * gridSize;
                    if (vi_y + vi_x < insideSize) {
                        coords = vn.scaleTo(vi_x_is).addA(vw.scaleTo(vi_y_is)).addA(v_lt);
                    }
                    else {
                        coords = vs.scaleTo(1 - vi_x_is).addA(ve.scaleTo(1 - vi_y_is)).addA(v_rb);
                    }
                    Vec3.doubleToTwoFloats(coords, _tempHigh, _tempLow);
                    let i3 = i * 3;
                    tempVertices[i3] = coords.x;
                    tempVertices[i3 + 1] = coords.y;
                    tempVertices[i3 + 2] = coords.z;
                    tempVerticesHigh[i3] = _tempHigh.x;
                    tempVerticesHigh[i3 + 1] = _tempHigh.y;
                    tempVerticesHigh[i3 + 2] = _tempHigh.z;
                    tempVerticesLow[i3] = _tempLow.x;
                    tempVerticesLow[i3 + 1] = _tempLow.y;
                    tempVerticesLow[i3 + 2] = _tempLow.z;
                    if (coords.x < BOUNDS.xmin)
                        BOUNDS.xmin = coords.x;
                    if (coords.x > BOUNDS.xmax)
                        BOUNDS.xmax = coords.x;
                    if (coords.y < BOUNDS.ymin)
                        BOUNDS.ymin = coords.y;
                    if (coords.y > BOUNDS.ymax)
                        BOUNDS.ymax = coords.y;
                    if (coords.z < BOUNDS.zmin)
                        BOUNDS.zmin = coords.z;
                    if (coords.z > BOUNDS.zmax)
                        BOUNDS.zmax = coords.z;
                }
            }
            seg.readyToEngage = true;
            seg.terrainVertices = tempVertices;
            seg.terrainVerticesHigh = tempVerticesHigh;
            seg.terrainVerticesLow = tempVerticesLow;
            seg.tempVertices = tempVertices;
            seg.tempVerticesHigh = tempVerticesHigh;
            seg.tempVerticesLow = tempVerticesLow;
            seg.noDataVertices = noDataVertices;
            seg.setBoundingVolume(BOUNDS.xmin, BOUNDS.ymin, BOUNDS.zmin, BOUNDS.xmax, BOUNDS.ymax, BOUNDS.zmax);
            if (seg.tileZoom > seg.planet.terrain.maxZoom) {
                if (pn.segment.tileZoom >= seg.planet.terrain.maxZoom) {
                    seg._plainRadius = pn.segment._plainRadius / dZ2;
                    seg.terrainReady = true;
                    seg.terrainIsLoading = false;
                    seg.terrainVertices = tempVertices;
                    seg.terrainVerticesHigh = tempVerticesHigh;
                    seg.terrainVerticesLow = tempVerticesLow;
                    seg.passReady = true;
                    this.appliedTerrainNodeId = this.nodeId;
                    this.equalizedSideWithNodeId[N] = this.equalizedSideWithNodeId[E] = this.equalizedSideWithNodeId[S] = this.equalizedSideWithNodeId[W] = this.appliedTerrainNodeId;
                    if (pn.segment.terrainExists) {
                        seg.normalMapVertices = tempVertices;
                        seg.fileGridSize = Math.sqrt(tempVertices.length / 3) - 1;
                        let fgs = Math.sqrt(pseg.normalMapNormals.length / 3) - 1, fgsZ = fgs / dZ2;
                        if (fgs > 1) {
                            seg.normalMapNormals = getMatrixSubArray32(pseg.normalMapNormals, fgs, fgsZ * offsetY, fgsZ * offsetX, fgsZ);
                        }
                        else {
                            // TODO: interpolation
                            seg.normalMapNormals = pseg.normalMapNormals;
                        }
                    }
                }
            }
        }
    }
    destroy() {
        this.prevState = this.state = NOTRENDERING;
        this.segment.destroySegment();
        let n = this.neighbors;
        for (let i = 0, len = n.length; i < len; i++) {
            let ni = n[i];
            if (ni) {
                for (let j = 0; j < ni.length; j++) {
                    let nij = ni[j];
                    if (nij && nij.neighbors) {
                        nij.clearNeighbors();
                    }
                }
            }
        }
        // @ts-ignore
        this.neighbors = null;
        // @ts-ignore
        this.parentNode = null;
        // @ts-ignore
        this.sideSizeLog2 = null;
        // @ts-ignore
        this.segment = null;
    }
    clearTree() {
        const state = this.getState();
        if (state === NOTRENDERING || state === RENDERING) {
            this.destroyBranches();
        }
        else {
            for (let i = 0; i < this.nodes.length; i++) {
                this.nodes[i] && this.nodes[i].clearTree();
            }
        }
    }
    clearBranches() {
        for (let i = 0; i < this.nodes.length; i++) {
            this.nodes[i].clearBranches();
            this.nodes[i].segment.deleteMaterials();
        }
    }
    destroyBranches() {
        if (this.ready) {
            let nodesToRemove = [], i;
            for (i = 0; i < this.nodes.length; i++) {
                nodesToRemove[i] = this.nodes[i];
            }
            this.ready = false;
            this.nodes = [];
            for (i = 0; i < nodesToRemove.length; i++) {
                nodesToRemove[i].destroyBranches();
                nodesToRemove[i].destroy();
                //@ts-ignore
                nodesToRemove[i] = null;
            }
            nodesToRemove.length = 0;
            // @ts-ignore
            nodesToRemove = null;
        }
    }
    traverseTree(callback) {
        callback(this);
        if (this.ready) {
            for (let i = 0; i < this.nodes.length; i++) {
                this.nodes[i].traverseTree(callback);
            }
        }
    }
    getOffsetOppositeNeighbourSide(neighbourNode, side) {
        let pNode = this, neighbourZoom = neighbourNode.segment.tileZoom, offset = 0;
        while (pNode.segment.tileZoom > neighbourZoom) {
            offset += PARTOFFSET[pNode.partId][side] / (1 << (pNode.segment.tileZoom - neighbourZoom));
            pNode = pNode.parentNode;
        }
        return offset;
    }
};

class QueueArray {
    constructor(size = 2048) {
        this._size = size;
        this._array = new Array(this._size);
        this._popIndex = Math.floor(this._size * 0.5);
        this._shiftIndex = this._popIndex;
        this.length = 0;
    }
    reset() {
        this._popIndex = Math.floor(this._size * 0.5);
        this._shiftIndex = this._popIndex;
        this.length = 0;
    }
    clear() {
        this._array.length = 0;
        this._array = new Array(this._size);
        this._popIndex = Math.floor(this._size * 0.5);
        this._shiftIndex = this._popIndex;
        this.length = 0;
    }
    push(data) {
        this.length++;
        this._array[this._popIndex++] = data;
    }
    pop() {
        if (this.length) {
            this.length--;
            let res = this._array[--this._popIndex];
            // @ts-ignore
            this._array[this._popIndex] = null;
            if (!this._array[this._popIndex - 1]) {
                this._popIndex = Math.floor(this._size * 0.5);
                this._shiftIndex = this._popIndex;
            }
            return res;
        }
        return undefined;
    }
    unshift(data) {
        this.length++;
        this._array[--this._shiftIndex] = data;
    }
    shift() {
        if (this.length) {
            this.length--;
            let res = this._array[this._shiftIndex];
            // @ts-ignore
            this._array[this._shiftIndex++] = null;
            if (!this._array[this._shiftIndex]) {
                this._popIndex = Math.floor(this._size * 0.5);
                this._shiftIndex = this._popIndex;
            }
            return res;
        }
        return undefined;
    }
    forEach(callback) {
        for (let i = this._shiftIndex; i < this._popIndex; i++) {
            callback(this._array[i]);
        }
    }
}

class EntityCollectionsTreeStrategy {
    constructor(layer, nodeCapacity) {
        this._layer = layer;
        this._nodeCapacity = nodeCapacity;
        this._secondPASS = [];
        this._counter = 0;
        this._deferredEntitiesPendingQueue = new QueueArray();
        this._renderingNodes = {};
    }
    insertEntity(entity, rightNow = false) {
    }
    setPickingEnabled(pickingEnabled) {
    }
    dispose() {
    }
    insertEntities(entitiesForTree) {
    }
    collectVisibleEntityCollections(outArr) {
    }
    _queueDeferredNode(node) {
        if (this._layer.getVisibility()) {
            node._inTheQueue = true;
            if (this._counter >= 1) {
                this._deferredEntitiesPendingQueue.push(node);
            }
            else {
                this._execDeferredNode(node);
            }
        }
    }
    _execDeferredNode(node) {
        this._counter++;
        requestAnimationFrame(() => {
            node.applyCollection();
            this._counter--;
            if (this._deferredEntitiesPendingQueue.length && this._counter < 1) {
                while (this._deferredEntitiesPendingQueue.length) {
                    let n = this._deferredEntitiesPendingQueue.pop();
                    n._inTheQueue = false;
                    if (n.isVisible()) {
                        this._execDeferredNode(n);
                        return;
                    }
                }
            }
        });
    }
}

class QuadTreeStrategy {
    constructor(planet, name = "", proj = EPSG3857) {
        this.name = name;
        this.projection = proj;
        this._planet = planet;
        this._quadTreeList = [];
        this._visibleNodes = {};
    }
    createEntitiCollectionsTreeStrategy(layer, nodeCapacity) {
        return new EntityCollectionsTreeStrategy(layer, nodeCapacity);
    }
    destroyBranches() {
        for (let i = 0, len = this._quadTreeList.length; i < len; i++) {
            this._quadTreeList[i].destroyBranches();
        }
    }
    clearLayerMaterial(layer) {
        let lid = layer.__id;
        for (let i = 0, len = this._quadTreeList.length; i < len; i++) {
            this._quadTreeList[i].traverseTree(function (node) {
                let mats = node.segment.materials;
                if (mats[lid]) {
                    mats[lid].clear();
                    //@ts-ignore
                    mats[lid] = null;
                    //delete mats[lid];
                }
            });
        }
    }
    get planet() {
        return this._planet;
    }
    init() {
    }
    preRender() {
        for (let i = 0; i < this._quadTreeList.length; i++) {
            let quadTree = this._quadTreeList[i];
            quadTree.createChildrenNodes();
            quadTree.segment.createPlainSegment();
            for (let j = 0; j < quadTree.nodes.length; j++) {
                quadTree.nodes[j].segment.createPlainSegment();
            }
        }
    }
    preLoad() {
        for (let i = 0; i < this._quadTreeList.length; i++) {
            let quadTree = this._quadTreeList[i];
            quadTree.segment.passReady = true;
            quadTree.renderNode(1);
            this._planet.normalMapCreator.drawSingle(quadTree.segment);
            for (let j = 0; j < quadTree.nodes.length; j++) {
                quadTree.nodes[j].segment.passReady = true;
                quadTree.nodes[j].renderNode(1);
                this._planet._normalMapCreator.drawSingle(quadTree.nodes[j].segment);
            }
        }
    }
    _clearVisibleNodes() {
        this._visibleNodes = {};
    }
    collectRenderNodes() {
        this._clearVisibleNodes();
        for (let i = 0; i < this._quadTreeList.length; i++) {
            this._quadTreeList[i].renderTree(this._planet.camera, 0, null);
        }
    }
    clear() {
        for (let i = 0; i < this._quadTreeList.length; i++) {
            this._quadTreeList[i].clearTree();
        }
    }
    get quadTreeList() {
        return this._quadTreeList;
    }
    getTileXY(lonLat, zoom) {
        let z = zoom, x = -1, y = -1, pz = (1 << z);
        x = getTileCellIndex(lonLat.lon, 360 / pz, -180);
        y = getTileCellIndex(lonLat.lat, 180 / pz, 90);
        return [x, y, z, TILEGROUP_COMMON];
    }
    getLonLatTileOffset(lonLat, x, y, z, gridSize) {
        let coords = lonLat;
        let extent = new Extent();
        let worldExtent = Extent.createFromArray([-180, -90, 180, 90]);
        extent = getTileCellExtent(x, y, z, worldExtent);
        let sizeImgW = extent.getWidth() / (gridSize - 1), sizeImgH = extent.getHeight() / (gridSize - 1);
        let i = gridSize - Math.ceil((coords.lat - extent.southWest.lat) / sizeImgH) - 1, j = Math.floor((coords.lon - extent.southWest.lon) / sizeImgW);
        return [i, j];
    }
    collectVisibleNode(node) {
        this._visibleNodes[node.nodeId] = node;
    }
}

/**
 * @module og/proj/EPSG4326
 */
/**
 * EPSG:4326 projection object.
 * @type {Proj}
 */
const EPSG4326 = new Proj({ code: "epsg:4326", units: Units.DEGREES });

const MAX_POLE_ZOOM = 7;
const POLE_PIECE_SIZE = (90.0 - MAX_LAT) / Math.pow(2, MAX_POLE_ZOOM);
/**
 * Planet segment Web Mercator tile class that stored and rendered with quad tree.
 * @class
 * @extends {Segment}
 */
class SegmentLonLat extends Segment {
    constructor(node, planet, tileZoom, extent) {
        super(node, planet, tileZoom, extent);
        this._projection = EPSG4326;
        this._extentLonLat = this._extent;
        this._extentMerc = new Extent(extent.southWest.forwardMercatorEPS01(), extent.northEast.forwardMercatorEPS01());
        this._isNorth = this._extent.northEast.lat > 0;
        this.isPole = true;
    }
    _setExtentLonLat() {
        this._extentLonLat = this._extent;
    }
    projectNative(coords) {
        return coords;
    }
    getInsideLonLat(obj) {
        return obj._lonLat;
    }
    _getMaxZoom() {
        let maxPoleZoom = 0;
        if (this._isNorth) {
            //north pole limits
            let Yz = Math.floor((90.0 - this._extent.northEast.lat) / POLE_PIECE_SIZE);
            maxPoleZoom = Math.floor(Yz / 16) + 7;
        }
        else {
            //south pole limits
            let Yz = Math.floor((MIN_LAT - this._extent.northEast.lat) / POLE_PIECE_SIZE);
            maxPoleZoom = 12 - Math.floor(Yz / 16);
        }
        return maxPoleZoom;
    }
    checkZoom() {
        return super.checkZoom() && this.tileZoom <= this._getMaxZoom();
    }
    _assignTileIndexes() {
        this._assignTileXIndexes(this._extent);
        this._assignTileYIndexes(this._extent);
        this.tileIndex = Layer.getTileIndex(this.tileX, this.tileY, this.tileZoom, this._tileGroup);
    }
    _assignTileXIndexes(extent) {
        this.tileX = getTileCellIndex(extent.getCenter().lon, extent.getWidth(), -180);
        let p2 = 1 << this.tileZoom;
        this.tileXE = (this.tileX + 1) % p2;
        this.tileXW = (p2 + this.tileX - 1) % p2;
    }
    _assignTileYIndexes(extent) {
        const lat = extent.getCenter().lat; //extent.northEast.lat;
        if (lat > 0) {
            this._tileGroup = TILEGROUP_NORTH;
            this.tileY = getTileCellIndex(lat, extent.getHeight(), 90.0);
        }
        else {
            this._tileGroup = TILEGROUP_SOUTH;
            this.tileY = getTileCellIndex(lat, extent.getHeight(), MIN_LAT);
        }
        this.tileYN = this.tileY - 1;
        this.tileYS = this.tileY + 1;
    }
    _projToDeg(lon, lat) {
        return new LonLat(lon, lat);
    }
    _assignGlobalTextureCoordinates() {
        const e = this._extent;
        this._globalTextureCoordinates[0] = (e.southWest.lon + 180.0) / 360.0;
        this._globalTextureCoordinates[1] = (90 - e.northEast.lat) / 180.0;
        this._globalTextureCoordinates[2] = (e.northEast.lon + 180.0) / 360.0;
        this._globalTextureCoordinates[3] = (90 - e.southWest.lat) / 180.0;
    }
    /**
     * @param layer
     * @protected
     *
     * @todo simplify layer._extentMerc in layer.getNativeExtent(this)
     *
     */
    _getLayerExtentOffset(layer) {
        const v0s = layer._extent;
        const v0t = this._extent;
        const sSize_x = v0s.northEast.lon - v0s.southWest.lon;
        const sSize_y = v0s.northEast.lat - v0s.southWest.lat;
        const dV0s_x = (v0t.southWest.lon - v0s.southWest.lon) / sSize_x;
        const dV0s_y = (v0s.northEast.lat - v0t.northEast.lat) / sSize_y;
        const dSize_x = (v0t.northEast.lon - v0t.southWest.lon) / sSize_x;
        const dSize_y = (v0t.northEast.lat - v0t.southWest.lat) / sSize_y;
        return [dV0s_x, dV0s_y, dSize_x, dSize_y];
    }
    layerOverlap(layer) {
        return this._extent.overlaps(layer._extent);
    }
    getDefaultTexture() {
        return this._isNorth ? this.planet.solidTextureOne : this.planet.solidTextureTwo;
    }
    getExtentLonLat() {
        return this._extent;
    }
}

/**
 * @todo: remove planet parameter. It's already available in the layer.
 */
class EntityCollectionNode {
    constructor(strategy, partId, parent, extent, planet, zoom) {
        this.strategy = strategy;
        this.layer = strategy._layer;
        this.parentNode = parent;
        this.childrenNodes = [];
        this.partId = partId;
        //this.nodeId = partId + id;
        this.nodeId = partId + (parent ? parent.nodeId * 4 + 1 : 0);
        this.state = null;
        this.extent = extent;
        this.count = 0;
        this.deferredEntities = [];
        this.entityCollection = null;
        this.zoom = zoom;
        this._inTheQueue = false;
        this.bsphere = new Sphere();
        planet && this._setExtentBounds();
    }
    insertEntity(entity, rightNow = false) {
        this.buildTree([entity], rightNow);
    }
    _addEntitiesToCollection(entities, rightNow = false) {
        if (entities.length) {
            const l = this.layer;
            const p = l._planet;
            let ec = this.entityCollection;
            if (!ec) {
                ec = new EntityCollection({
                    pickingEnabled: l._pickingEnabled,
                    labelMaxLetters: l.labelMaxLetters
                });
                ec._layer = this.layer;
                ec.addTo(p, true);
                ec._quadNode = this;
                l._bindEventsDefault(ec);
                this.entityCollection = ec;
            }
            if (rightNow || !l.async) {
                this.entityCollection.addEntities(entities);
            }
            else {
                this.deferredEntities.push.apply(this.deferredEntities, entities);
            }
        }
    }
    _setExtentBounds() {
        if (!this.nodeId) {
            this.bsphere.radius = this.layer._planet.ellipsoid.equatorialSize;
            this.bsphere.center = new Vec3();
        }
        else {
            this.bsphere.setFromExtent(this.layer._planet.ellipsoid, this.extent.inverseMercator());
        }
    }
    __setLonLat__(entity) {
        if (entity._lonLat.isZero() && !entity._cartesian.isZero()) {
            entity._lonLat = this.layer._planet.ellipsoid.cartesianToLonLat(entity._cartesian);
        }
        if (Math.abs(entity._lonLat.lat) < MAX_LAT) {
            entity._lonLatMerc = entity._lonLat.forwardMercator();
        }
        else {
            entity._lonLatMerc = new LonLat();
        }
        return entity._lonLatMerc;
    }
    buildTree(entities, rightNow = false) {
        this.count += entities.length;
        if (entities.length > this.layer._nodeCapacity) {
            const cn = this.childrenNodes;
            if (!cn.length) {
                this.createChildrenNodes();
            }
            let en_nw = [], en_ne = [], en_sw = [], en_se = [];
            let i = entities.length;
            while (i--) {
                const ei = entities[i];
                if (cn[NW].isInside(ei)) {
                    ei._nodePtr = cn[NW];
                    en_nw.push(ei);
                }
                else if (cn[NE].isInside(ei)) {
                    ei._nodePtr = cn[NE];
                    en_ne.push(ei);
                }
                else if (cn[SW].isInside(ei)) {
                    ei._nodePtr = cn[SW];
                    en_sw.push(ei);
                }
                else if (cn[SE].isInside(ei)) {
                    ei._nodePtr = cn[SE];
                    en_se.push(ei);
                }
            }
            en_nw.length && cn[NW].buildTree(en_nw, rightNow);
            en_ne.length && cn[NE].buildTree(en_ne, rightNow);
            en_sw.length && cn[SW].buildTree(en_sw, rightNow);
            en_se.length && cn[SE].buildTree(en_se, rightNow);
        }
        else {
            this._addEntitiesToCollection(entities, rightNow);
        }
    }
    isInside(entity) {
        if (entity._lonLatMerc) {
            return this.extent.isInside(entity._lonLatMerc);
        }
        else {
            return false;
        }
    }
    createChildrenNodes() {
        const s = this.strategy;
        const ext = this.extent;
        const size_x = ext.getWidth() * 0.5;
        const size_y = ext.getHeight() * 0.5;
        const ne = ext.northEast;
        const sw = ext.southWest;
        const c = new LonLat(sw.lon + size_x, sw.lat + size_y);
        const nd = this.childrenNodes;
        const p = this.layer._planet;
        const z = this.zoom + 1;
        nd[NW] = new EntityCollectionNode(s, NW, this, new Extent(new LonLat(sw.lon, sw.lat + size_y), new LonLat(sw.lon + size_x, ne.lat)), p, z);
        nd[NE] = new EntityCollectionNode(s, NE, this, new Extent(c, new LonLat(ne.lon, ne.lat)), p, z);
        nd[SW] = new EntityCollectionNode(s, SW, this, new Extent(new LonLat(sw.lon, sw.lat), c), p, z);
        nd[SE] = new EntityCollectionNode(s, SE, this, new Extent(new LonLat(sw.lon + size_x, sw.lat), new LonLat(ne.lon, sw.lat + size_y)), p, z);
    }
    collectRenderCollectionsPASS1(visibleNodes, outArr) {
        const n = visibleNodes[this.nodeId];
        if (n) {
            const cn = this.childrenNodes;
            if (this.entityCollection) {
                this.renderCollection(outArr, visibleNodes);
            }
            else if (cn.length) {
                if (n.state === RENDERING) {
                    this.strategy._secondPASS.push(this);
                }
                else {
                    cn[NW].collectRenderCollectionsPASS1(visibleNodes, outArr);
                    cn[NE].collectRenderCollectionsPASS1(visibleNodes, outArr);
                    cn[SW].collectRenderCollectionsPASS1(visibleNodes, outArr);
                    cn[SE].collectRenderCollectionsPASS1(visibleNodes, outArr);
                }
            }
        }
    }
    collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId) {
        const p = this.layer._planet;
        const cam = p.camera;
        const altVis = (cam.eye.distance(this.bsphere.center) - this.bsphere.radius <
            VISIBLE_DISTANCE * Math.sqrt(cam._lonLat.height)) || cam._lonLat.height > 10000;
        if (this.count > 0 && altVis && cam.containsSphere(this.bsphere)) {
            const cn = this.childrenNodes;
            if (this.entityCollection) {
                this.renderCollection(outArr, visibleNodes, renderingNodeId);
            }
            else if (cn.length) {
                cn[NW].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
                cn[NE].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
                cn[SW].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
                cn[SE].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
            }
        }
    }
    applyCollection() {
        this.entityCollection.addEntities(this.deferredEntities);
        this.deferredEntities.length = 0;
        this.deferredEntities = [];
        this._inTheQueue = false;
    }
    traverseTree(callback) {
        const cn = this.childrenNodes;
        if (this.entityCollection) {
            callback(this);
        }
        else if (cn.length) {
            cn[NW].traverseTree(callback);
            cn[NE].traverseTree(callback);
            cn[SW].traverseTree(callback);
            cn[SE].traverseTree(callback);
        }
    }
    renderCollection(outArr, visibleNodes, renderingNodeId) {
        const s = this.strategy;
        s._renderingNodes[this.nodeId] = true;
        if (this.deferredEntities.length && !this._inTheQueue) {
            if (this.layer.async) {
                s._queueDeferredNode(this);
            }
            else {
                this.applyCollection();
            }
        }
        let ec = this.entityCollection;
        let l = this.layer;
        ec._fadingOpacity = l._fadingOpacity;
        ec.scaleByDistance = l.scaleByDistance;
        ec.pickingScale = l.pickingScale;
        ec.polygonOffsetUnits = l.polygonOffsetUnits;
        outArr.push(ec);
        if (l.clampToGround || l.relativeToGround) {
            const e = ec._entities;
            let i = e.length;
            if (visibleNodes[this.nodeId] && visibleNodes[this.nodeId].state === RENDERING) {
                while (i--) {
                    let ei = e[i];
                    this.alignEntityToTheGround(ei, visibleNodes[this.nodeId].segment);
                }
            }
            else if (renderingNodeId) {
                while (i--) {
                    let ei = e[i];
                    this.alignEntityToTheGround(ei, visibleNodes[renderingNodeId].segment);
                }
            }
            else {
                const n = l._planet._renderedNodes;
                while (i--) {
                    let ei = e[i];
                    let j = n.length;
                    while (j--) {
                        if (n[j].segment.isEntityInside(ei)) {
                            this.alignEntityToTheGround(ei, n[j].segment);
                            break;
                        }
                    }
                }
            }
        }
    }
    alignEntityToTheGround(entity, segment) {
        let res = new Vec3();
        segment.getEntityTerrainPoint(entity, res);
        let alt = (Number(this.layer.relativeToGround) && entity._altitude) || 0.0;
        if (alt) {
            let n = this.layer._planet.ellipsoid.getSurfaceNormal3v(res);
            entity._setCartesian3vSilent(res.addA(n.scale(alt)));
        }
        else {
            entity._setCartesian3vSilent(res);
        }
    }
    isVisible() {
        if (this.strategy._renderingNodes[this.nodeId]) {
            return true;
        }
        return false;
    }
}

class EarthEntityCollectionNodeLonLat extends EntityCollectionNode {
    constructor(strategy, partId, parent, extent, planet, zoom) {
        super(strategy, partId, parent, extent, planet, zoom);
        this.strategy = strategy;
        this.isNorth = false;
    }
    createChildrenNodes() {
        const s = this.strategy;
        const ext = this.extent;
        const size_x = ext.getWidth() * 0.5;
        const size_y = ext.getHeight() * 0.5;
        const ne = ext.northEast;
        const sw = ext.southWest;
        const c = new LonLat(sw.lon + size_x, sw.lat + size_y);
        const nd = this.childrenNodes;
        const p = this.layer._planet;
        const z = this.zoom + 1;
        nd[NW] = new EarthEntityCollectionNodeLonLat(s, NW, this, new Extent(new LonLat(sw.lon, sw.lat + size_y), new LonLat(sw.lon + size_x, ne.lat)), p, z);
        nd[NE] = new EarthEntityCollectionNodeLonLat(s, NE, this, new Extent(c, new LonLat(ne.lon, ne.lat)), p, z);
        nd[SW] = new EarthEntityCollectionNodeLonLat(s, SW, this, new Extent(new LonLat(sw.lon, sw.lat), c), p, z);
        nd[SE] = new EarthEntityCollectionNodeLonLat(s, SE, this, new Extent(new LonLat(sw.lon + size_x, sw.lat), new LonLat(ne.lon, sw.lat + size_y)), p, z);
    }
    _setExtentBounds() {
        if (this.extent.northEast.lat > 0) {
            this.isNorth = true;
        }
        this.bsphere.setFromExtent(this.layer._planet.ellipsoid, this.extent);
    }
    __setLonLat__(entity) {
        if (entity._lonLat.isZero()) {
            entity._lonLat = this.layer._planet.ellipsoid.cartesianToLonLat(entity._cartesian);
        }
        return entity._lonLat;
    }
    isVisible() {
        if (this.isNorth && this.strategy._renderingNodesNorth[this.nodeId]) {
            return true;
        }
        else if (this.strategy._renderingNodesSouth[this.nodeId]) {
            return true;
        }
        return false;
    }
    isInside(entity) {
        return this.extent.isInside(entity._lonLat);
    }
    renderCollection(outArr, visibleNodes, renderingNode) {
        if (this.isNorth) {
            this.strategy._renderingNodesNorth[this.nodeId] = true;
        }
        else {
            this.strategy._renderingNodesSouth[this.nodeId] = true;
        }
        if (this.deferredEntities.length && !this._inTheQueue) {
            if (this.layer.async) {
                this.strategy._queueDeferredNode(this);
            }
            else {
                this.applyCollection();
            }
        }
        const ec = this.entityCollection;
        ec._fadingOpacity = this.layer._fadingOpacity;
        ec.scaleByDistance = this.layer.scaleByDistance;
        ec.pickingScale = this.layer.pickingScale;
        if (!ec.isEmpty()) {
            outArr.push(ec);
        }
    }
}

class EarthEntityCollectionsTreeStrategy extends EntityCollectionsTreeStrategy {
    constructor(layer, nodeCapacity) {
        super(layer, nodeCapacity);
        let planet = layer._planet;
        this._entityCollectionsTree = new EntityCollectionNode(this, NW, null, Extent.createFromArray([-20037508.34, -20037508.34, 20037508.34, 20037508.34]), planet, 0);
        this._entityCollectionsTreeNorth = new EarthEntityCollectionNodeLonLat(this, NW, null, Extent.createFromArray([-180, MAX_LAT, 180, 90]), planet, 0);
        this._entityCollectionsTreeSouth = new EarthEntityCollectionNodeLonLat(this, NW, null, Extent.createFromArray([-180, -90, 180, MIN_LAT]), planet, 0);
        this._renderingNodes = {};
        this._renderingNodesNorth = {};
        this._renderingNodesSouth = {};
    }
    insertEntity(entity, rightNow = false) {
        if (entity._lonLat.lat > MAX_LAT) {
            this._entityCollectionsTreeNorth.__setLonLat__(entity);
            this._entityCollectionsTreeNorth.insertEntity(entity, rightNow);
        }
        else if (entity._lonLat.lat < MIN_LAT) {
            this._entityCollectionsTreeSouth.__setLonLat__(entity);
            this._entityCollectionsTreeSouth.insertEntity(entity, rightNow);
        }
        else {
            this._entityCollectionsTree.__setLonLat__(entity);
            this._entityCollectionsTree.insertEntity(entity, rightNow);
        }
    }
    setPickingEnabled(pickingEnabled) {
        this._entityCollectionsTree && this._entityCollectionsTree.traverseTree((node) => {
            node.entityCollection.setPickingEnabled(pickingEnabled);
        });
        this._entityCollectionsTreeNorth && this._entityCollectionsTreeNorth.traverseTree((node) => {
            node.entityCollection.setPickingEnabled(pickingEnabled);
        });
        this._entityCollectionsTreeSouth && this._entityCollectionsTreeSouth.traverseTree((node) => {
            node.entityCollection.setPickingEnabled(pickingEnabled);
        });
    }
    dispose() {
        //@ts-ignore
        this._entityCollectionsTree = null;
        //@ts-ignore
        this._entityCollectionsTreeNorth = null;
        //@ts-ignore
        this._entityCollectionsTreeSouth = null;
        this._renderingNodes = {};
        this._renderingNodesNorth = {};
        this._renderingNodesSouth = {};
    }
    insertEntities(entitiesForTree) {
        let northEntities = [], southEntities = [], mercEntities = [];
        for (let i = 0, len = entitiesForTree.length; i < len; i++) {
            let entity = entitiesForTree[i];
            // north tree
            if (entity._lonLat.lat > MAX_LAT) {
                northEntities.push(entity);
                this._entityCollectionsTreeNorth.__setLonLat__(entity);
            }
            else if (entity._lonLat.lat < MIN_LAT) {
                southEntities.push(entity);
                this._entityCollectionsTreeSouth.__setLonLat__(entity);
            }
            else {
                mercEntities.push(entity);
                this._entityCollectionsTree.__setLonLat__(entity);
            }
        }
        this._entityCollectionsTree.buildTree(mercEntities);
        this._entityCollectionsTreeNorth.buildTree(northEntities);
        this._entityCollectionsTreeSouth.buildTree(southEntities);
    }
    collectVisibleEntityCollections(outArr) {
        this._renderingNodes = {};
        this._renderingNodesNorth = {};
        this._renderingNodesSouth = {};
        let pqs = this._layer._planet.quadTreeStrategy;
        // Merc nodes
        this._secondPASS = [];
        this._entityCollectionsTree.collectRenderCollectionsPASS1(pqs._visibleNodes, outArr);
        let i = this._secondPASS.length;
        while (i--) {
            this._secondPASS[i].collectRenderCollectionsPASS2(pqs._visibleNodes, outArr, this._secondPASS[i].nodeId);
        }
        // North nodes
        this._secondPASS = [];
        this._entityCollectionsTreeNorth.collectRenderCollectionsPASS1(pqs._visibleNodesNorth, outArr);
        i = this._secondPASS.length;
        while (i--) {
            this._secondPASS[i].collectRenderCollectionsPASS2(pqs._visibleNodesNorth, outArr, this._secondPASS[i].nodeId);
        }
        // South nodes
        this._secondPASS = [];
        this._entityCollectionsTreeSouth.collectRenderCollectionsPASS1(pqs._visibleNodesSouth, outArr);
        i = this._secondPASS.length;
        while (i--) {
            this._secondPASS[i].collectRenderCollectionsPASS2(pqs._visibleNodesSouth, outArr, this._secondPASS[i].nodeId);
        }
    }
}

class EarthQuadTreeStrategy extends QuadTreeStrategy {
    constructor(planet) {
        super(planet, "Earth");
        this._visibleNodesNorth = {};
        this._visibleNodesSouth = {};
    }
    collectVisibleNode(node) {
        let tg = node.segment._tileGroup;
        if (tg === TILEGROUP_NORTH) {
            this._visibleNodesNorth[node.nodeId] = node;
        }
        else if (tg === TILEGROUP_SOUTH) {
            this._visibleNodesSouth[node.nodeId] = node;
        }
        else {
            this._visibleNodes[node.nodeId] = node;
        }
    }
    _clearVisibleNodes() {
        super._clearVisibleNodes();
        this._visibleNodesNorth = {};
        this._visibleNodesSouth = {};
    }
    createEntitiCollectionsTreeStrategy(layer, nodeCapacity) {
        return new EarthEntityCollectionsTreeStrategy(layer, nodeCapacity);
    }
    init() {
        this._quadTreeList = [
            new Node$1(Segment, this.planet, 0, null, 0, Extent.createFromArray([-20037508.34, -20037508.34, 20037508.34, 20037508.34])),
            new Node$1(SegmentLonLat, this.planet, 0, null, 0, Extent.createFromArray([-180, MAX_LAT, 180, 90])),
            new Node$1(SegmentLonLat, this.planet, 0, null, 0, Extent.createFromArray([-180, -90, 180, MIN_LAT]))
        ];
    }
    getTileXY(lonLat, zoom) {
        let tileGroup = getTileGroupByLat(lonLat.lat, MAX_LAT), z = zoom, x = -1, y = -1, pz = (1 << z) /*Math.pow(2, z)*/;
        if (tileGroup === TILEGROUP_NORTH) {
            x = getTileCellIndex(lonLat.lon, 360 / pz, -180);
            y = getTileCellIndex(lonLat.lat, (90 - MAX_LAT) / pz, 90);
        }
        else if (tileGroup === TILEGROUP_SOUTH) {
            x = getTileCellIndex(lonLat.lon, 360 / pz, -180);
            y = getTileCellIndex(lonLat.lat, (90 - MAX_LAT) / pz, MIN_LAT);
        }
        else {
            let merc = forward(lonLat);
            x = getTileCellIndex(merc.lon, POLE2 / pz, -POLE);
            y = getTileCellIndex(merc.lat, POLE2 / pz, POLE);
        }
        return [x, y, z, tileGroup];
    }
    getLonLatTileOffset(lonLat, x, y, z, gridSize) {
        let coords = lonLat;
        let extent = new Extent();
        if (lonLat.lat > MAX_LAT) {
            let worldExtent = Extent.createFromArray([-180, MAX_LAT, 180, 90]);
            extent = getTileCellExtent(x, y, z, worldExtent);
        }
        else if (lonLat.lat < MIN_LAT) {
            let worldExtent = Extent.createFromArray([-180, -90, 180, MIN_LAT]);
            extent = getTileCellExtent(x, y, z, worldExtent);
        }
        else {
            coords = forward(lonLat);
            extent = getTileExtent(x, y, z);
        }
        let sizeImgW = extent.getWidth() / (gridSize - 1), sizeImgH = extent.getHeight() / (gridSize - 1);
        let i = gridSize - Math.ceil((coords.lat - extent.southWest.lat) / sizeImgH) - 1, j = Math.floor((coords.lon - extent.southWest.lon) / sizeImgW);
        return [i, j];
    }
}

/* This file is mostly a straight translation of
 * GeographicLib/src/Geoid.cpp from C++ to JavaScript
 * by Kim Vandry <vandry@TZoNE.ORG>
 *
 * @license
 *  **
 * * \file Geoid.cpp
 * * \brief Implementation for GeographicLib::Geoid class
 * *
 * * Copyright (c) Charles Karney (2009) <charles@karney.com>
 * * and licensed under the LGPL.  For more information, see
 * * http://geographiclib.sourceforge.net/
 * **********************************************************************
 *
 * Geoid height grade not supported
 * The files can be downloaded from here:
 * http://geographiclib.sourceforge.net/1.18/geoid.html
 */
class Geoid {
    constructor(options = {}) {
        this.model = options.model || null;
        this.src = options.src || null;
        this._cached_ix = 0;
        this._cached_iy = 0;
        this._v00 = 0;
        this._v01 = 0;
        this._v10 = 0;
        this._v11 = 0;
        this._t = 0;
    }
    static loadModel(url) {
        if (!url) {
            return new Promise((resolve) => {
                resolve(null);
            });
        }
        else
            return fetch(url, {})
                .then((r) => {
                if (!r.ok) {
                    throw Error("Geoid model file: HTTP error " + r.status);
                }
                return r.arrayBuffer();
            })
                .then((r) => {
                if (r) {
                    return new Uint8Array(r);
                }
                else {
                    throw Error("Geoid model file: no data from " + url);
                }
            })
                .then(function (rawfile) {
                if (!((rawfile[0] === 80) && (rawfile[1] === 53) && (((rawfile[2] === 13) && (rawfile[3] === 10)) ||
                    (rawfile[2] === 10)))) {
                    throw new Error("Geoid model file: no PGM header");
                }
                var i = (rawfile[2] === 13) ? 4 : 3;
                var offset = null;
                var scale = null;
                function getline() {
                    let start = i;
                    for (var j = i;; j++) {
                        if (j >= rawfile.length) {
                            throw new Error("Geoid model file: missing newline in header");
                        }
                        if (rawfile[j] === 10) {
                            i = j + 1;
                            break;
                        }
                    }
                    if ((j > start) && (rawfile[j - 1] === 13))
                        j--;
                    return String.fromCharCode.apply(null, rawfile.slice(start, j));
                }
                var m, s;
                for (;;) {
                    s = getline();
                    if (s[0] !== '#')
                        break;
                    m = s.match(/^# Offset (.*)$/);
                    if (m) {
                        offset = parseInt(m[1], 10);
                        if (!isFinite(offset)) {
                            throw new Error("Geoid model file: bad offset " + m[1]);
                        }
                    }
                    else {
                        m = s.match(/^# Scale (.*)$/);
                        if (m) {
                            scale = parseFloat(m[1]);
                            if (!isFinite(scale)) {
                                throw new Error("Geoid model file: bad scale " + m[1]);
                            }
                        }
                    }
                }
                m = s.match(/^\s*(\d+)\s+(\d+)\s*$/);
                let width = 0;
                let height = 0;
                if (m) {
                    width = parseInt(m[1], 10);
                    height = parseInt(m[2], 10);
                }
                if (!(m && (width >= 0) && (height >= 0))) {
                    throw new Error("Geoid model file: bad PGM width&height line");
                }
                let levels = parseInt(getline());
                if (levels != 65535) {
                    throw new Error("Geoid model file: PGM file must have 65535 gray levels");
                }
                if (offset === null) {
                    throw new Error("Geoid model file: PGM file does not contain offset");
                }
                if (scale === null) {
                    throw new Error("Geoid model file: PGM file does not contain scale");
                }
                if ((width < 2) || (height < 2)) {
                    throw new Error("Geoid model file: Raster size too small");
                }
                let payload_len = rawfile.length - i;
                if (payload_len !== (width * height * 2)) {
                    throw new Error("Geoid model file: File has the wrong length");
                }
                return {
                    scale: scale,
                    offset: offset,
                    width: width,
                    height: height,
                    rlonres: width / 360,
                    rlatres: (height - 1) / 180,
                    i: i,
                    rawfile: rawfile
                };
            });
    }
    setModel(model) {
        this.model = model;
    }
    _rawval(ix, iy) {
        let model = this.model;
        if (iy < 0) {
            iy = -iy;
            ix += model.width / 2;
        }
        else if (iy >= model.height) {
            iy = 2 * (model.height - 1) - iy;
            ix += model.width / 2;
        }
        if (ix < 0) {
            ix += model.width;
        }
        else if (ix >= model.width) {
            ix -= model.width;
        }
        let k = (iy * model.width + ix) * 2 + model.i;
        return (model.rawfile[k] << 8) | model.rawfile[k + 1];
    }
    getHeightLonLat(lonlat) {
        return this.getHeight(lonlat.lon, lonlat.lat);
    }
    getHeight(lon, lat) {
        if (!this.model)
            return 0;
        let model = this.model;
        if (lon < 0)
            lon += 360.0;
        let fy = (90 - lat) * model.rlatres;
        let fx = lon * model.rlonres;
        let iy = Math.floor(fy);
        let ix = Math.floor(fx);
        fx -= ix;
        fy -= iy;
        if (iy === (model.height - 1)) {
            iy--;
        }
        if ((this._cached_ix !== ix) || (this._cached_iy !== iy)) {
            this._cached_ix = ix;
            this._cached_iy = iy;
            this._v00 = this._rawval(ix, iy);
            this._v01 = this._rawval(ix + 1, iy);
            this._v10 = this._rawval(ix, iy + 1);
            this._v11 = this._rawval(ix + 1, iy + 1);
        }
        let a = (1 - fx) * this._v00 + fx * this._v01;
        let b = (1 - fx) * this._v10 + fx * this._v11;
        let h = (1 - fy) * a + fy * b;
        return model.offset + model.scale * h;
    }
}

class GeoImageCreator {
    constructor(planet, maxFrames = 5) {
        this.MAX_FRAMES = maxFrames;
        this._gridSize = 64;
        this._planet = planet;
        this._framebuffer = null;
        this._framebufferMercProj = null;
        this._texCoordsBuffer = null;
        this._indexBuffer = null;
        this._currentFrame = 0;
        this._queue = [];
        this._animate = [];
        this._quadTexCoordsBuffer = null;
        this._quadVertexBuffer = null;
    }
    init() {
        this._initShaders();
        this._initBuffers();
    }
    /**
     * Creates geoImage corners coordinates grid buffer.
     * @public
     * @param{Array.<LonLat>} c - GeoImage corners coordinates.
     * @param{boolean} [toMerc=false] - Transform to web mercator.
     * @return{WebGLBuffer} Grid coordinates buffer.
     */
    createGridBuffer(c, toMerc = false) {
        let gs = this._gridSize;
        let v03 = new LonLat((c[3].lon - c[0].lon) / gs, (c[3].lat - c[0].lat) / gs), v12 = new LonLat((c[2].lon - c[1].lon) / gs, (c[2].lat - c[1].lat) / gs), v01 = new LonLat((c[1].lon - c[0].lon) / gs, (c[1].lat - c[0].lat) / gs), v32 = new LonLat((c[2].lon - c[3].lon) / gs, (c[2].lat - c[3].lat) / gs);
        const size = (gs + 1) * (gs + 1) * 2, halfSize = size / 2;
        let gridHigh = new Float32Array(size), gridLow = new Float32Array(size);
        let lonLatArr = new Array(halfSize);
        let kh = 0, kl = 0, k = 0;
        let tempArr = new Float32Array(2);
        for (let i = 0; i <= gs; i++) {
            let P03i = new LonLat(c[0].lon + i * v03.lon, c[0].lat + i * v03.lat), P12i = new LonLat(c[1].lon + i * v12.lon, c[1].lat + i * v12.lat);
            for (let j = 0; j <= gs; j++) {
                let P01j = new LonLat(c[0].lon + j * v01.lon, c[0].lat + j * v01.lat), P32j = new LonLat(c[3].lon + j * v32.lon, c[3].lat + j * v32.lat);
                let xx = getLinesIntersectionLonLat(P03i, P12i, P01j, P32j);
                doubleToTwoFloats2(xx.lon, tempArr);
                gridHigh[kh++] = tempArr[0];
                gridLow[kl++] = tempArr[1];
                doubleToTwoFloats2(xx.lat, tempArr);
                gridHigh[kh++] = tempArr[0];
                gridLow[kl++] = tempArr[1];
                lonLatArr[k++] = xx;
            }
        }
        if (toMerc) {
            for (let i = 0; i < halfSize; i++) {
                let c = lonLatArr[i].forwardMercator();
                doubleToTwoFloats2(c.lon, tempArr);
                gridHigh[i * 2] = tempArr[0];
                gridLow[i * 2] = tempArr[1];
                doubleToTwoFloats2(c.lat, tempArr);
                gridHigh[i * 2 + 1] = tempArr[0];
                gridLow[i * 2 + 1] = tempArr[1];
            }
        }
        return [
            this._planet.renderer.handler.createArrayBuffer(gridHigh, 2, halfSize),
            this._planet.renderer.handler.createArrayBuffer(gridLow, 2, halfSize)
        ];
    }
    frame() {
        let i = this.MAX_FRAMES;
        while (i-- && this._queue.length) {
            const q = this._queue.shift();
            q._isRendering = false;
            q.rendering();
            q.events.dispatch(q.events.loadend);
        }
        i = this._animate.length;
        while (i--) {
            this._animate[i].rendering();
        }
    }
    add(geoImage) {
        if (!geoImage._isRendering) {
            geoImage._isRendering = true;
            if (geoImage._animate) {
                this._animate.push(geoImage);
            }
            else {
                this._queue.push(geoImage);
            }
        }
    }
    remove(geoImage) {
        if (geoImage._isRendering) {
            geoImage._creationProceeding = false;
            geoImage._isRendering = false;
            let arr;
            if (geoImage._animate) {
                arr = this._animate;
            }
            else {
                arr = this._queue;
            }
            for (let i = 0; i < arr.length; i++) {
                if (arr[i].isEqual(geoImage)) {
                    arr.splice(i, 1);
                    return;
                }
            }
        }
    }
    _initBuffers() {
        let h = this._planet.renderer.handler;
        this._framebuffer = new Framebuffer(h, { width: 2, height: 2, useDepth: false });
        this._framebuffer.init();
        this._framebufferMercProj = new Framebuffer(h, { width: 2, height: 2, useDepth: false });
        this._framebufferMercProj.init();
        let gs = Math.log2(this._gridSize);
        this._texCoordsBuffer = this._planet._textureCoordsBufferCache[gs];
        this._indexBuffer = this._planet._indexesCache[gs][gs][gs][gs][gs].buffer;
        this._quadTexCoordsBuffer = h.createArrayBuffer(new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]), 2, 4);
        this._quadVertexBuffer = h.createArrayBuffer(new Float32Array([-1, 1, 1, 1, -1, -1, 1, -1]), 2, 4);
    }
    _initShaders() {
        this._planet.renderer.handler.addProgram(new Program("geoImageTransform", {
            uniforms: {
                sourceTexture: "sampler2d",
                extentParamsHigh: "vec4",
                extentParamsLow: "vec4",
                isFullExtent: "bool"
            },
            attributes: {
                cornersHigh: "vec2",
                cornersLow: "vec2",
                texCoords: "vec2"
            },
            vertexShader: `attribute vec2 cornersHigh; 
                     attribute vec2 cornersLow;
                      attribute vec2 texCoords; 
                      uniform vec4 extentParamsHigh; 
                      uniform vec4 extentParamsLow; 
                      varying vec2 v_texCoords;
                      void main() {                                                             
                          v_texCoords = texCoords; 
                          vec2 highDiff = cornersHigh - extentParamsHigh.xy;
                          vec2 lowDiff = cornersLow - extentParamsLow.xy;                                        
                          gl_Position = vec4((-1.0 + (highDiff * step(1.0, length(highDiff)) + lowDiff) * extentParamsHigh.zw) * vec2(1.0, -1.0), 0.0, 1.0); 
                      }`,
            fragmentShader: `precision highp float;
                        uniform sampler2D sourceTexture;
                        uniform bool isFullExtent;
                        varying vec2 v_texCoords;
                        void main () {
                            if(!isFullExtent && (v_texCoords.x <= 0.001 || v_texCoords.x >= 0.999 ||
                                v_texCoords.y <= 0.001 || v_texCoords.y >= 0.999)) {
                                discard;
                            }
                            gl_FragColor = texture2D(sourceTexture, v_texCoords);
                        }`
        }));
    }
}

const LOADER_EVENTS = ["loadend", "layerloadend"];
class Loader {
    constructor(maxRequests = 24) {
        this.MAX_REQUESTS = maxRequests;
        this.events = createEvents(LOADER_EVENTS);
        this._loading = 0;
        this._queue = []; //new QueueArray();
        this._senderRequestCounter = [];
        this._promises = {
            'json': r => r.json(),
            'blob': r => r.blob(),
            'arrayBuffer': r => r.arrayBuffer(),
            'imageBitmap': r => r.blob().then((r) => createImageBitmap(r, {
                premultiplyAlpha: "premultiply"
            })),
            'text': r => r.text()
        };
    }
    load(params, callback) {
        if (params.sender) {
            if (!this._senderRequestCounter[params.sender.__id]) {
                this._senderRequestCounter[params.sender.__id] = {
                    sender: params.sender, counter: 0, __requestCounterFrame__: 0
                };
            }
            this._senderRequestCounter[params.sender.__id].counter++;
        }
        this._queue.push({ params, callback });
        this._exec();
    }
    fetch(params) {
        return fetch(params.src, params.options || {})
            .then((response) => {
            if (!response.ok) {
                throw Error(`Unable to load '${params.src}'`);
            }
            return this._promises[params.type || "blob"](response);
        })
            .then((data) => {
            return { status: "ready", data: data };
        })
            .catch((err) => {
            return { status: "error", msg: err.toString() };
        });
    }
    getRequestCounter(sender) {
        if (sender) {
            let r = this._senderRequestCounter[sender.__id];
            if (r) {
                return r.counter;
            }
        }
        return 0;
    }
    isIdle(sender) {
        return sender.isIdle;
    }
    _checkLoadend(request, sender) {
        if (request.counter === 0 && (!sender._planet || sender._planet._terrainCompletedActivated)) {
            sender.events.dispatch(sender.events.loadend, sender);
            this.events.dispatch(this.events.layerloadend, sender);
            request.__requestCounterFrame__ = 0;
        }
        else {
            request.__requestCounterFrame__ = requestAnimationFrame(() => {
                this._checkLoadend(request, sender);
            });
        }
    }
    _handleResponse(q, response) {
        q.callback(response);
        let sender = q.params.sender;
        if (sender && (sender.events.loadend.handlers.length || this.events.layerloadend.handlers.length)) {
            let request = this._senderRequestCounter[sender.__id];
            if (request && request.counter > 0) {
                request.counter--;
                cancelAnimationFrame(request.__requestCounterFrame__);
                request.__requestCounterFrame__ = requestAnimationFrame(() => {
                    this._checkLoadend(request, sender);
                });
            }
        }
        this._exec();
    }
    _exec() {
        if (this._queue.length > 0 && this._loading < this.MAX_REQUESTS) {
            let q = this._queue.pop();
            if (!q)
                return;
            let p = q.params;
            if (!p.filter || p.filter(p)) {
                this._loading++;
                return fetch(p.src, p.options || {})
                    .then((response) => {
                    if (!response.ok) {
                        throw Error(`Unable to load '${p.src}'`);
                    }
                    return this._promises[p.type || "blob"](response);
                })
                    .then((data) => {
                    this._loading--;
                    this._handleResponse(q, { status: "ready", data: data });
                })
                    .catch((err) => {
                    this._loading--;
                    this._handleResponse(q, { status: "error", msg: err.toString() });
                });
            }
            else {
                this._handleResponse(q, { status: "abort" });
            }
        }
        else if (this._loading === 0) {
            this.events.dispatch(this.events.loadend);
        }
    }
    abort(sender) {
        if (this._senderRequestCounter[sender.__id]) {
            this._senderRequestCounter[sender.__id].counter = 0;
            cancelAnimationFrame(this._senderRequestCounter[sender.__id].__requestCounterFrame__);
            this._senderRequestCounter[sender.__id].__requestCounterFrame__ = 0;
        }
        for (let i = 0, len = this._queue.length; i < len; i++) {
            let qi = this._queue[i];
            if (qi && qi.params.sender && sender.isEqual(qi.params.sender)) {
                qi.callback({ 'status': "abort" });
                //@ts-ignore
                this._queue[i] = null;
            }
        }
    }
    abortAll() {
        for (let i = 0, len = this._queue.length; i < len; i++) {
            let qi = this._queue[i];
            if (qi) {
                let sender = qi.params.sender;
                if (sender && this._senderRequestCounter[sender.__id]) {
                    this._senderRequestCounter[sender.__id].counter = 0;
                    cancelAnimationFrame(this._senderRequestCounter[sender.__id].__requestCounterFrame__);
                    this._senderRequestCounter[sender.__id].__requestCounterFrame__ = 0;
                }
                qi.callback({ 'status': "abort" });
                //@ts-ignore
                this._queue[i] = null;
            }
        }
        this._queue = [];
    }
    get loading() {
        return this._loading;
    }
    get queue() {
        return this._queue;
    }
}

class NormalMapCreator {
    constructor(planet, options = {}) {
        this._minTabelSize = options.minTableSize || 1;
        this._maxTableSize = options.maxTableSize || 8;
        this._planet = planet;
        this._handler = null;
        this._verticesBufferArray = [];
        this._indexBufferArray = [];
        this._positionBuffer = null;
        this._framebuffer = null;
        this._normalMapVerticesTexture = null;
        this._width = options.width || 128;
        this._height = options.height || 128;
        this._queue = new QueueArray(1024);
        this._lock = new Lock();
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    init() {
        this._maxTableSize = this._planet.maxGridSize || 8;
        this._handler = this._planet.renderer.handler;
        /*==================================================================================
         * http://www.sunsetlakesoftware.com/2013/10/21/optimizing-gaussian-blurs-mobile-gpu
         *=================================================================================*/
        const normalMapBlur = new Program("normalMapBlur", {
            attributes: {
                a_position: "vec2"
            },
            uniforms: {
                s_texture: "sampler2d"
            },
            vertexShader: `attribute vec2 a_position;
                       attribute vec2 a_texCoord;

                      varying vec2 blurCoordinates[5];

                      void main() {
                          vec2 vt = a_position * 0.5 + 0.5; 
                          ${" "}
                          gl_Position = vec4(a_position, 0.0, 1.0);
                          blurCoordinates[0] = vt;
                          blurCoordinates[1] = vt + ${(1.0 / this._width) * 1.407333};
                          blurCoordinates[2] = vt - ${(1.0 / this._height) * 1.407333};
                          blurCoordinates[3] = vt + ${(1.0 / this._width) * 3.294215};
                          blurCoordinates[4] = vt - ${(1.0 / this._height) * 3.294215};
                }`,
            fragmentShader: `precision lowp float;
                        uniform sampler2D s_texture;                        
                        varying vec2 blurCoordinates[5];                        

                        void main() {
                            lowp vec4 sum = vec4(0.0);
                            //if(blurCoordinates[0].x <= 0.01 || blurCoordinates[0].x >= 0.99 ||
                            //    blurCoordinates[0].y <= 0.01 || blurCoordinates[0].y >= 0.99){
                            //    sum = texture2D(s_texture, blurCoordinates[0]);
                            //} else {
                                sum += texture2D(s_texture, blurCoordinates[0]) * 0.204164;
                                sum += texture2D(s_texture, blurCoordinates[1]) * 0.304005;
                                sum += texture2D(s_texture, blurCoordinates[2]) * 0.304005;
                                sum += texture2D(s_texture, blurCoordinates[3]) * 0.093913;
                                sum += texture2D(s_texture, blurCoordinates[4]) * 0.093913;
                            //}
                            gl_FragColor = sum;
                        }`
        });
        const normalMap = new Program("normalMap", {
            attributes: {
                a_position: "vec2",
                a_normal: "vec3"
            },
            uniforms: {},
            vertexShader: `attribute vec2 a_position;
                      attribute vec3 a_normal;
                      
                      varying vec3 v_color;
                      
                      void main() {
                          gl_Position = vec4(a_position, 0, 1);
                          v_color = normalize(a_normal) * 0.5 + 0.5;
                      }`,
            fragmentShader: `precision highp float;
                        
                        varying vec3 v_color;
                        
                        void main () {
                            gl_FragColor = vec4(v_color, 1.0);
                        }`
        });
        this._handler.addProgram(normalMapBlur);
        this._handler.addProgram(normalMap);
        //create hidden handler buffer
        this._framebuffer = new Framebuffer(this._handler, {
            width: this._width,
            height: this._height,
            useDepth: false
        });
        this._framebuffer.init();
        this._normalMapVerticesTexture = this._handler.createEmptyTexture_l(this._width, this._height);
        //create vertices hasharray for different grid size segments from 2^4(16) to 2^7(128)
        for (let p = this._minTabelSize; p <= this._maxTableSize; p++) {
            const gs = (1 << p); //Math.pow(2, p);
            const gs2 = gs / 2;
            let vertices = new Float32Array((gs + 1) * (gs + 1) * 2);
            for (let i = 0; i <= gs; i++) {
                for (let j = 0; j <= gs; j++) {
                    let ind = (i * (gs + 1) + j) * 2;
                    vertices[ind] = -1 + j / gs2;
                    vertices[ind + 1] = -1 + i / gs2;
                }
            }
            this._verticesBufferArray[gs] = this._handler.createArrayBuffer(vertices, 2, vertices.length / 2);
            this._indexBufferArray[gs] =
                this._planet._indexesCache[Math.log2(gs)][Math.log2(gs)][Math.log2(gs)][Math.log2(gs)][Math.log2(gs)].buffer;
        }
        //create 2d screen square buffer
        const positions = new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]);
        this._positionBuffer = this._handler.createArrayBuffer(positions, 2, positions.length / 2);
    }
    _drawNormalMapBlur(segment) {
        let normals = segment.normalMapNormals;
        if (segment.node &&
            segment.node.getState() !== NOTRENDERING &&
            normals &&
            normals.length) {
            const size = normals.length / 3;
            const gridSize = Math.sqrt(size) - 1;
            let indBuf = this._verticesBufferArray[gridSize];
            if (indBuf) {
                if (segment.planet.terrain.equalizeNormals) {
                    segment._normalMapEdgeEqualize(N);
                    segment._normalMapEdgeEqualize(S);
                    segment._normalMapEdgeEqualize(W);
                    segment._normalMapEdgeEqualize(E);
                }
                let outTexture = segment.normalMapTexturePtr;
                const h = this._handler;
                const gl = h.gl;
                let _normalsBuffer = h.createArrayBuffer(normals, 3, size, gl.DYNAMIC_DRAW);
                const f = this._framebuffer;
                let p = h.programs.normalMap;
                let sha = p._program.attributes;
                f.bindOutputTexture(this._normalMapVerticesTexture);
                p.activate();
                gl.bindBuffer(gl.ARRAY_BUFFER, indBuf);
                gl.vertexAttribPointer(sha.a_position, indBuf.itemSize, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, _normalsBuffer);
                gl.vertexAttribPointer(sha.a_normal, _normalsBuffer.itemSize, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBufferArray[gridSize]);
                gl.drawElements(gl.TRIANGLE_STRIP, this._indexBufferArray[gridSize].numItems, gl.UNSIGNED_INT, 0);
                gl.deleteBuffer(_normalsBuffer);
                //
                // blur pass
                //
                f.bindOutputTexture(outTexture);
                p = h.programs.normalMapBlur;
                p.activate();
                gl.bindBuffer(gl.ARRAY_BUFFER, this._positionBuffer);
                gl.vertexAttribPointer(p._program.attributes.a_position, this._positionBuffer.itemSize, gl.FLOAT, false, 0, 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this._normalMapVerticesTexture);
                gl.uniform1i(p._program.uniforms.s_texture, 0);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, this._positionBuffer.numItems);
                return true;
            }
            else {
                return true;
            }
        }
        return false;
    }
    _drawNormalMapNoBlur(segment) {
        let normals = segment.normalMapNormals;
        if (segment.node &&
            segment.node.getState() !== NOTRENDERING &&
            normals &&
            normals.length) {
            const size = normals.length / 3;
            const gridSize = Math.sqrt(size) - 1;
            let indBuf = this._verticesBufferArray[gridSize];
            if (indBuf) {
                if (segment.planet.terrain.equalizeNormals) {
                    segment._normalMapEdgeEqualize(N);
                    segment._normalMapEdgeEqualize(S);
                    segment._normalMapEdgeEqualize(W);
                    segment._normalMapEdgeEqualize(E);
                }
                let outTexture = segment.normalMapTexturePtr;
                const h = this._handler;
                const gl = h.gl;
                let _normalsBuffer = h.createArrayBuffer(normals, 3, size, gl.DYNAMIC_DRAW);
                const f = this._framebuffer;
                const p = h.programs.normalMap;
                const sha = p._program.attributes;
                f.bindOutputTexture(outTexture);
                p.activate();
                gl.bindBuffer(gl.ARRAY_BUFFER, indBuf);
                gl.vertexAttribPointer(sha.a_position, indBuf.itemSize, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, _normalsBuffer);
                gl.vertexAttribPointer(sha.a_normal, _normalsBuffer.itemSize, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBufferArray[gridSize]);
                gl.drawElements(gl.TRIANGLE_STRIP, this._indexBufferArray[gridSize].numItems, gl.UNSIGNED_INT, 0);
                gl.deleteBuffer(_normalsBuffer);
                return true;
            }
            else {
                return true;
            }
        }
        return false;
    }
    _drawNormalMap(segment) {
        if (segment.planet.terrain.isBlur(segment)) {
            return this._drawNormalMapBlur(segment);
        }
        else {
            return this._drawNormalMapNoBlur(segment);
        }
    }
    drawSingle(segment) {
        const h = this._handler;
        const gl = h.gl;
        this._framebuffer.activate();
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
        if (segment.terrainReady && this._drawNormalMap(segment)) {
            segment.normalMapReady = true;
            segment.normalMapTexture = segment.normalMapTexturePtr;
            segment.normalMapTextureBias[0] = 0;
            segment.normalMapTextureBias[1] = 0;
            segment.normalMapTextureBias[2] = 1;
        }
        segment._inTheQueue = false;
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        this._framebuffer.deactivate();
    }
    frame() {
        if (this._queue.length) {
            const h = this._handler;
            const gl = h.gl;
            this._framebuffer.activate();
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.BLEND);
            let deltaTime = 0, startTime = window.performance.now();
            while (this._lock.isFree() && this._queue.length && deltaTime < 0.25) {
                const segment = this._queue.shift();
                if (segment.terrainReady && this._drawNormalMap(segment)) {
                    segment.normalMapReady = true;
                    segment.normalMapTexture = segment.normalMapTexturePtr;
                    segment.normalMapTextureBias[0] = 0;
                    segment.normalMapTextureBias[1] = 0;
                    segment.normalMapTextureBias[2] = 1;
                }
                segment._inTheQueue = false;
                deltaTime = window.performance.now() - startTime;
            }
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);
            this._framebuffer.deactivate();
        }
    }
    get queueSize() {
        return this._queue.length;
    }
    queue(segment) {
        segment._inTheQueue = true;
        this._queue.push(segment);
    }
    unshift(segment) {
        segment._inTheQueue = true;
        this._queue.unshift(segment);
    }
    remove(segment) {
        //...
    }
    clear() {
        while (this._queue.length) {
            let s = this._queue.pop();
            s._inTheQueue = false;
        }
    }
    /**
     * Set activity off
     * @public
     */
    lock(key) {
        this._lock.lock(key);
    }
    /**
     * Set activity on
     * @public
     */
    free(key) {
        this._lock.free(key);
    }
}

/**
 * @module og/proj/equi
 */
/**
 * Any equrectangualr projection object.
 * @type {Proj}
 */
const equi = new Proj({ code: "equi", units: Units.DEGREES });

// import { QueueArray } from '../QueueArray.js';
class PlainSegmentWorker extends BaseWorker {
    constructor(numWorkers = 2) {
        super(numWorkers, PLAIN_SEGMENT_PROGRAM);
    }
    _onMessage(e) {
        this._source.get(e.data.id)._plainSegmentWorkerCallback(e.data);
        e.data.plainVertices = null;
        e.data.plainVerticesHigh = null;
        e.data.plainVerticesLow = null;
        e.data.plainNormals = null;
        e.data.normalMapNormals = null;
        e.data.normalMapVertices = null;
        e.data.normalMapVerticesHigh = null;
        e.data.normalMapVerticesLow = null;
        this._source.delete(e.data.id);
    }
    setGeoid(geoid) {
        if (geoid.model) {
            let m = geoid.model;
            let model = {
                scale: m.scale,
                offset: m.offset,
                width: m.width,
                height: m.height,
                rlonres: m.rlonres,
                rlatres: m.rlatres,
                i: m.i
            };
            this._workerQueue.forEach((w) => {
                let rawfile = new Uint8Array(m.rawfile.length);
                rawfile.set(m.rawfile);
                w.postMessage({
                    model: model,
                    rawfile: rawfile
                }, [
                    rawfile.buffer
                ]);
            });
        }
        else {
            this._workerQueue.forEach((w) => {
                w.postMessage({
                    model: null
                });
            });
        }
    }
    make(segment) {
        if (segment.initialized) {
            if (this._workerQueue.length) {
                let w = this._workerQueue.pop();
                this._source.set(this._sourceId, segment);
                let isLonLat = (segment._projection.id === EPSG4326.id || segment._projection.id === equi.id) ? 1.0 : 0.0;
                let params = new Float64Array([
                    this._sourceId,
                    isLonLat,
                    segment.planet.terrain.gridSizeByZoom[segment.tileZoom],
                    segment.planet.terrain.plainGridSize,
                    segment._extent.southWest.lon,
                    segment._extent.southWest.lat,
                    segment._extent.northEast.lon,
                    segment._extent.northEast.lat,
                    // @ts-ignore
                    segment.planet.ellipsoid._e2,
                    segment.planet.ellipsoid.equatorialSize,
                    segment.planet.ellipsoid._invRadii2.x,
                    segment.planet.ellipsoid._invRadii2.y,
                    segment.planet.ellipsoid._invRadii2.z,
                    segment.planet._heightFactor
                ]);
                this._sourceId++;
                w.postMessage({
                    params: params
                }, [
                    params.buffer
                ]);
            }
            else {
                this._pendingQueue.push(segment);
            }
        }
        else {
            this.check();
        }
    }
}
const PLAIN_SEGMENT_PROGRAM = `
    'use strict';
    
    let model = null;

    let cached_ix = null;
    let cached_iy = null;
    let v00 = null;
    let v01 = null;
    let v10 = null;
    let v11 = null;
    let t = null;

    function rawval(ix, iy) {

        if (iy < 0) {
            iy = -iy;
            ix += model.width / 2;
        } else if (iy >= model.height) {
            iy = 2 * (model.height - 1) - iy;
            ix += model.width / 2;
        }

        if (ix < 0) {
            ix += model.width;
        } else if (ix >= model.width) {
            ix -= model.width;
        }

        var k = (iy * model.width + ix) * 2 + model.i;

        return (model.rawfile[k] << 8) | model.rawfile[k + 1];
    };

    function getHeightMSL(lon, lat) {

        if (!model) return 0;

        if (lon < 0) lon += 360.0;

        var fy = (90 - lat) * model.rlatres;
        var fx = lon * model.rlonres;
        var iy = Math.floor(fy);
        var ix = Math.floor(fx);

        fx -= ix;
        fy -= iy;

        if (iy === (model.height - 1)) {
            iy--;
        }

        if ((cached_ix !== ix) || (cached_iy !== iy)) {

            cached_ix = ix;
            cached_iy = iy;

            v00 = rawval(ix, iy);
            v01 = rawval(ix + 1, iy);
            v10 = rawval(ix, iy + 1);
            v11 = rawval(ix + 1, iy + 1);
        }

        let h = null;

        var a = (1 - fx) * v00 + fx * v01;
        var b = (1 - fx) * v10 + fx * v11;

        h = (1 - fy) * a + fy * b;

        return model.offset + model.scale * h;
    };

    const HALF_PI = Math.PI * 0.5;
    const POLE = 20037508.34;
    const PI_BY_POLE = Math.PI / POLE;
    const INV_POLE_BY_180 = 180.0 / POLE;
    const INV_PI_BY_180 = 180.0 / Math.PI;
    const INV_PI_BY_180_HALF_PI = INV_PI_BY_180 * HALF_PI;
    const RADIANS = Math.PI / 180.0;
    const INV_PI_BY_360 = INV_PI_BY_180 * 2.0;

    let E2 = 0.0,
        A = 0.0;

    let _projFunc = null;

    const Vec3 = function (x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    };

    var geodeticToCartesian = function (lon, lat, heightFactor, res) {

        let h = getHeightMSL(lon, lat) * heightFactor;

        let latrad = RADIANS * lat,
            lonrad = RADIANS * lon;

        let slt = Math.sin(latrad);

        let N = A / Math.sqrt(1.0 - E2 * slt * slt);
        let nc = (N + h) * Math.cos(latrad);       
           
        res.x = nc * Math.cos(lonrad);
        res.y = nc * Math.sin(lonrad);
        res.z = (N * (1 - E2) + h) * slt;
    };

    var geodeticToCartesianInverse = function (lon, lat, heightFactor, res){
        geodeticToCartesian(
            lon * INV_POLE_BY_180,
            INV_PI_BY_360 * Math.atan(Math.exp(lat * PI_BY_POLE)) - INV_PI_BY_180_HALF_PI,
            heightFactor,
            res);
    };

    var v = new Vec3(0.0, 0.0, 0.0);
    var _tempHigh = new Vec3(0.0, 0.0, 0.0);
    var _tempLow = new Vec3(0.0, 0.0, 0.0);

    var doubleToTwoFloats = function(v, high, low) {

        let x = v.x, y = v.y, z = v.z;
    
        if (x >= 0.0) {
            var doubleHigh = Math.floor(x / 65536.0) * 65536.0;
            high.x = Math.fround(doubleHigh);
            low.x = Math.fround(x - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-x / 65536.0) * 65536.0;
            high.x = Math.fround(-doubleHigh);
            low.x = Math.fround(x + doubleHigh);
        }

        if (y >= 0.0) {
            var doubleHigh = Math.floor(y / 65536.0) * 65536.0;
            high.y = Math.fround(doubleHigh);
            low.y = Math.fround(y - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-y / 65536.0) * 65536.0;
            high.y = Math.fround(-doubleHigh);
            low.y = Math.fround(y + doubleHigh);
        }

        if (z >= 0.0) {
            var doubleHigh = Math.floor(z / 65536.0) * 65536.0;
            high.z = Math.fround(doubleHigh);
            low.z = Math.fround(z - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-z / 65536.0) * 65536.0;
            high.z = Math.fround(-doubleHigh);
            low.z = Math.fround(z + doubleHigh);
        }
    };

    self.onmessage = function (msg) {
        if(msg.data.model) {
            model = msg.data.model;
            model.rawfile = msg.data.rawfile;
        } else if(msg.data.params) {

            let xmin = 549755748352.0, xmax = -549755748352.0, 
                ymin = 549755748352.0, ymax = -549755748352.0, 
                zmin = 549755748352.0, zmax = -549755748352.0;

            E2 = msg.data.params[8];
            A = msg.data.params[9];

            let gridSize = msg.data.params[2],
                fgs = msg.data.params[3],
                r2_x = msg.data.params[10],
                r2_y = msg.data.params[11],
                r2_z = msg.data.params[12];

            let heightFactor =  msg.data.params[13];
        
            if(msg.data.params[1] === 0.0){
                _projFunc = geodeticToCartesianInverse;
            }else{
                _projFunc = geodeticToCartesian;
            }

            let maxFgs = Math.max(fgs, gridSize);
            let llStep = (msg.data.params[6] - msg.data.params[4]) / maxFgs;
            let ltStep = (msg.data.params[7] - msg.data.params[5]) / maxFgs;

            let esw_lon = msg.data.params[4],
                ene_lat = msg.data.params[7];

            let dg = Math.max(fgs / gridSize, 1.0),
                gs = maxFgs + 1;
            
            const gsgs = gs * gs;

            const gridSize3 = (gridSize + 1) * (gridSize + 1) * 3;

            let plainNormals = new Float32Array(gridSize3);

            let plainVertices = new Float64Array(gridSize3);
            let plainVerticesHigh = new Float32Array(gridSize3);
            let plainVerticesLow = new Float32Array(gridSize3);

            let normalMapNormals = new Float32Array(gsgs * 3);

            let normalMapVertices = new Float64Array(gsgs * 3);
            let normalMapVerticesHigh = new Float32Array(gsgs * 3);
            let normalMapVerticesLow = new Float32Array(gsgs * 3);

            let ind = 0,
                nmInd = 0;

            for (let k = 0; k < gsgs; k++) {

                let j = k % gs,
                    i = ~~(k / gs);

                _projFunc(esw_lon + j * llStep, ene_lat - i * ltStep, heightFactor, v);

                let nx = v.x * r2_x, ny = v.y * r2_y, nz = v.z * r2_z;
                let l = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);            
                let nxl = nx * l,
                    nyl = ny * l,
                    nzl = nz * l;

                doubleToTwoFloats(v, _tempHigh, _tempLow);

                normalMapVertices[nmInd] = v.x;
                normalMapVerticesHigh[nmInd] = _tempHigh.x;
                normalMapVerticesLow[nmInd] = _tempLow.x;
                normalMapNormals[nmInd++] = nxl;

                normalMapVertices[nmInd] = v.y;
                normalMapVerticesHigh[nmInd] = _tempHigh.y;
                normalMapVerticesLow[nmInd] = _tempLow.y;
                normalMapNormals[nmInd++] = nyl;

                normalMapVertices[nmInd] = v.z;
                normalMapVerticesHigh[nmInd] = _tempHigh.z;
                normalMapVerticesLow[nmInd] = _tempLow.z;
                normalMapNormals[nmInd++] = nzl;

                if (i % dg === 0 && j % dg === 0) {
                    plainVertices[ind] = v.x;
                    plainVerticesHigh[ind] = _tempHigh.x;
                    plainVerticesLow[ind] = _tempLow.x;
                    plainNormals[ind++] = nxl;

                    plainVertices[ind] = v.y;
                    plainVerticesHigh[ind] = _tempHigh.y;
                    plainVerticesLow[ind] = _tempLow.y;
                    plainNormals[ind++] = nyl;

                    plainVertices[ind] = v.z;
                    plainVerticesHigh[ind] = _tempHigh.z;
                    plainVerticesLow[ind] = _tempLow.z;
                    plainNormals[ind++] = nzl;

                    if (v.x < xmin) xmin = v.x; if (v.x > xmax) xmax = v.x;
                    if (v.y < ymin) ymin = v.y; if (v.y > ymax) ymax = v.y;
                    if (v.z < zmin) zmin = v.z; if (v.z > zmax) zmax = v.z;
                }
            }

            let x = (xmax - xmin) * 0.5,
                y = (ymax - ymin) * 0.5,
                z = (zmax - zmin) * 0.5;

            let plainRadius = Math.sqrt(x * x + y * y + z * z);

            self.postMessage({
                id: msg.data.params[0],
                plainVertices: plainVertices,
                plainVerticesHigh: plainVerticesHigh,
                plainVerticesLow: plainVerticesLow,
                plainNormals: plainNormals,
                normalMapNormals: normalMapNormals,
                normalMapVertices: normalMapVertices,
                normalMapVerticesHigh: normalMapVerticesHigh,
                normalMapVerticesLow: normalMapVerticesLow,
                plainRadius: plainRadius
             }, [
                plainVertices.buffer,
                plainVerticesHigh.buffer,
                plainVerticesLow.buffer,
                plainNormals.buffer,
                normalMapNormals.buffer,
                normalMapVertices.buffer,
                normalMapVerticesHigh.buffer,
                normalMapVerticesLow.buffer
            ]);
        }
    }`;

function planeNormalize(plane) {
    let t = 1.0 / Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
    plane[0] *= t;
    plane[1] *= t;
    plane[2] *= t;
    plane[3] *= t;
}
/**
 * Frustum object, part of the camera object.
 * @class
 * @param {*} options
 */
class Frustum {
    constructor(options = {}) {
        this._pickingColorU = new Float32Array([0, 0, 0]);
        this._f = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
        this.projectionMatrix = new Mat4();
        this.inverseProjectionMatrix = new Mat4();
        this.projectionViewMatrix = new Mat4();
        this.inverseProjectionViewMatrix = new Mat4();
        this.left = 0.0;
        this.right = 0.0;
        this.bottom = 0.0;
        this.top = 0.0;
        this.near = 0.0;
        this.far = 0.0;
        this.cameraFrustumIndex = options.cameraFrustumIndex != undefined ? options.cameraFrustumIndex : -1;
        this.setProjectionMatrix(options.fov || 30.0, options.aspect || 1.0, options.near || 1.0, options.far || 1000.0);
    }
    getRightPlane() {
        return this._f[0];
    }
    getLeftPlane() {
        return this._f[1];
    }
    getBottomPlane() {
        return this._f[2];
    }
    getTopPlane() {
        return this._f[3];
    }
    getBackwardPlane() {
        return this._f[4];
    }
    getForwardPlane() {
        return this._f[5];
    }
    getProjectionViewMatrix() {
        return this.projectionViewMatrix._m;
    }
    getProjectionMatrix() {
        return this.projectionMatrix._m;
    }
    getInverseProjectionMatrix() {
        return this.inverseProjectionMatrix._m;
    }
    /**
     * Sets up camera projection matrix.
     * @public
     * @param {number} angle - Camera's view angle.
     * @param {number} aspect - Screen aspect ratio.
     * @param {number} near - Near camera distance.
     * @param {number} far - Far camera distance.
     */
    setProjectionMatrix(angle, aspect, near, far) {
        this.top = near * Math.tan(angle * RADIANS_HALF);
        this.bottom = -this.top;
        this.right = this.top * aspect;
        this.left = -this.right;
        this.near = near;
        this.far = far;
        this.projectionMatrix.setPerspective(this.left, this.right, this.bottom, this.top, near, far);
        this.projectionMatrix.inverseTo(this.inverseProjectionMatrix);
    }
    /**
     * Camera's projection matrix values.
     * @public
     * @param {Mat4} viewMatrix - View matrix.
     */
    setViewMatrix(viewMatrix) {
        this.projectionViewMatrix = this.projectionMatrix.mul(viewMatrix);
        this.projectionViewMatrix.inverseTo(this.inverseProjectionViewMatrix);
        let m = this.projectionViewMatrix._m;
        /* Right */
        this._f[0][0] = m[3] - m[0];
        this._f[0][1] = m[7] - m[4];
        this._f[0][2] = m[11] - m[8];
        this._f[0][3] = m[15] - m[12];
        planeNormalize(this._f[0]);
        /* Left */
        this._f[1][0] = m[3] + m[0];
        this._f[1][1] = m[7] + m[4];
        this._f[1][2] = m[11] + m[8];
        this._f[1][3] = m[15] + m[12];
        planeNormalize(this._f[1]);
        /* Bottom */
        this._f[2][0] = m[3] + m[1];
        this._f[2][1] = m[7] + m[5];
        this._f[2][2] = m[11] + m[9];
        this._f[2][3] = m[15] + m[13];
        planeNormalize(this._f[2]);
        /* Top */
        this._f[3][0] = m[3] - m[1];
        this._f[3][1] = m[7] - m[5];
        this._f[3][2] = m[11] - m[9];
        this._f[3][3] = m[15] - m[13];
        planeNormalize(this._f[3]);
        /* Backward */
        this._f[4][0] = m[3] - m[2];
        this._f[4][1] = m[7] - m[6];
        this._f[4][2] = m[11] - m[10];
        this._f[4][3] = m[15] - m[14];
        planeNormalize(this._f[4]);
        /* Forward */
        this._f[5][0] = m[3] + m[2];
        this._f[5][1] = m[7] + m[6];
        this._f[5][2] = m[11] + m[10];
        this._f[5][3] = m[15] + m[14];
        planeNormalize(this._f[5]);
    }
    /**
     * Returns true if a point in the frustum.
     * @public
     * @param {Vec3} point - Cartesian point.
     * @returns {boolean} -
     */
    containsPoint(point) {
        for (let p = 0; p < 6; p++) {
            let d = point.dotArr(this._f[p]) + this._f[p][3];
            if (d <= 0) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns true if the frustum contains a bonding sphere, but bottom plane exclude.
     * @public
     * @param {Sphere} sphere - Bounding sphere.
     * @returns {boolean} -
     */
    containsSphereBottomExc(sphere) {
        let r = -sphere.radius, f = this._f;
        if (sphere.center.dotArr(f[0]) + f[0][3] <= r)
            return false;
        if (sphere.center.dotArr(f[1]) + f[1][3] <= r)
            return false;
        if (sphere.center.dotArr(f[3]) + f[3][3] <= r)
            return false;
        if (sphere.center.dotArr(f[4]) + f[4][3] <= r)
            return false;
        if (sphere.center.dotArr(f[5]) + f[5][3] <= r)
            return false;
        return true;
    }
    containsSphereButtom(sphere) {
        let r = -sphere.radius, f = this._f;
        if (sphere.center.dotArr(f[2]) + f[2][3] <= r)
            return false;
        return true;
    }
    /**
     * Returns true if the frustum contains a bonding sphere.
     * @public
     * @param {Sphere} sphere - Bounding sphere.
     * @returns {boolean} -
     */
    containsSphere(sphere) {
        let r = -sphere.radius, f = this._f;
        if (sphere.center.dotArr(f[0]) + f[0][3] <= r)
            return false;
        if (sphere.center.dotArr(f[1]) + f[1][3] <= r)
            return false;
        if (sphere.center.dotArr(f[2]) + f[2][3] <= r)
            return false;
        if (sphere.center.dotArr(f[3]) + f[3][3] <= r)
            return false;
        if (sphere.center.dotArr(f[4]) + f[4][3] <= r)
            return false;
        if (sphere.center.dotArr(f[5]) + f[5][3] <= r)
            return false;
        return true;
    }
    /**
     * Returns true if the frustum contains a bonding sphere.
     * @public
     * @param {Vec3} center - Sphere center.
     * @param {number} radius - Sphere radius.
     * @returns {boolean} -
     */
    containsSphere2(center, radius) {
        let r = -radius;
        if (center.dotArr(this._f[0]) + this._f[0][3] <= r)
            return false;
        if (center.dotArr(this._f[1]) + this._f[1][3] <= r)
            return false;
        if (center.dotArr(this._f[2]) + this._f[2][3] <= r)
            return false;
        if (center.dotArr(this._f[3]) + this._f[3][3] <= r)
            return false;
        if (center.dotArr(this._f[4]) + this._f[4][3] <= r)
            return false;
        if (center.dotArr(this._f[5]) + this._f[5][3] <= r)
            return false;
        return true;
    }
    /**
     * Returns true if the frustum contains a bounding box.
     * @public
     * @param {Box} box - Bounding box.
     * @returns {boolean} -
     */
    containsBox(box) {
        let result = true, cout, cin;
        for (let i = 0; i < 6; i++) {
            cout = 0;
            cin = 0;
            for (let k = 0; k < 8 && (cin === 0 || cout === 0); k++) {
                let d = box.vertices[k].dotArr(this._f[i]) + this._f[i][3];
                if (d < 0) {
                    cout++;
                }
                else {
                    cin++;
                }
            }
            if (cin === 0) {
                return false;
            }
            else if (cout > 0) {
                result = true;
            }
        }
        return result;
    }
}

const EVENT_NAMES = [
    /**
     * When camera has been updated.
     * @event og.Camera#viewchange
     */
    "viewchange",
    /**
     * Camera is stopped.
     * @event og.Camera#moveend
     */
    "moveend"
];
/**
 * Camera class.
 * @class
 * @param {Renderer} [renderer] - Renderer uses the camera instance.
 * @param {Object} [options] - Camera options:
 * @param {Object} [options.name] - Camera name.
 * @param {number} [options.viewAngle=47] - Camera angle of view. Default is 47.0
 * @param {number} [options.near=1] - Camera near plane distance. Default is 1.0
 * @param {number} [options.far=og.math.MAX] - Camera far plane distance. Default is og.math.MAX
 * @param {Vec3} [options.eye=[0,0,0]] - Camera eye position. Default (0,0,0)
 * @param {Vec3} [options.look=[0,0,0]] - Camera look position. Default (0,0,0)
 * @param {Vec3} [options.up=[0,1,0]] - Camera eye position. Default (0,1,0)
 *
 * @fires EventsHandler<CameraEvents>#viewchange
 * @fires EventsHandler<CameraEvents>#moveend
 */
class Camera {
    constructor(renderer, options = {}) {
        this.renderer = renderer;
        this.events = createEvents(EVENT_NAMES, this);
        this.eye = options.eye || new Vec3();
        this.eyeHigh = new Float32Array(3);
        this.eyeLow = new Float32Array(3);
        this._aspect = options.aspect || 1.0;
        this._viewAngle = options.viewAngle || 47.0;
        this._viewMatrix = new Mat4();
        this._normalMatrix = new Mat3();
        this._r = new Vec3(1.0, 0.0, 0.0);
        this._u = new Vec3(0.0, 1.0, 0.0);
        this._b = new Vec3(0.0, 0.0, 1.0);
        // Previous frame values
        this._pr = this._r.clone();
        this._pu = this._u.clone();
        this._pb = this._b.clone();
        this._peye = this.eye.clone();
        this.isMoving = false;
        this._tanViewAngle_hrad = 0.0;
        this._tanViewAngle_hradOneByHeight = 0.0;
        this.frustums = [];
        this.frustumColors = [];
        if (options.frustums) {
            for (let i = 0, len = options.frustums.length; i < len; i++) {
                let fi = options.frustums[i];
                let fr = new Frustum({
                    fov: this._viewAngle,
                    aspect: this._aspect,
                    near: fi[0],
                    far: fi[1]
                });
                fr.cameraFrustumIndex = this.frustums.length;
                this.frustums.push(fr);
                //this.frustumColors.push.apply(this.frustumColors, fr._pickingColorU);
                this.frustumColors.push(fr._pickingColorU[0], fr._pickingColorU[1], fr._pickingColorU[2]);
            }
        }
        else {
            let near = 1.0, far = 10000.0;
            let fr = new Frustum({
                fov: this._viewAngle,
                aspect: this._aspect,
                near: near,
                far: far
            });
            fr.cameraFrustumIndex = this.frustums.length;
            this.frustums.push(fr);
            //this.frustumColors.push.apply(this.frustumColors, fr._pickingColorU);
            this.frustumColors.push(fr._pickingColorU[0], fr._pickingColorU[1], fr._pickingColorU[2]);
        }
        this.FARTHEST_FRUSTUM_INDEX = this.frustums.length - 1;
        this.currentFrustumIndex = 0;
        this.isFirstPass = false;
        this._projSizeConst = 0;
        this.set(options.eye || new Vec3(0.0, 0.0, 1.0), options.look || new Vec3(), options.up || new Vec3(0.0, 1.0, 0.0));
    }
    checkMoveEnd() {
        let r = this._r, u = this._u, b = this._b, eye = this.eye;
        if (this._peye.equal(eye) && this._pr.equal(r) && this._pu.equal(u) && this._pb.equal(b)) {
            if (this.isMoving) {
                this.events.dispatch(this.events.moveend, this);
            }
            this.isMoving = false;
        }
        else {
            this.isMoving = true;
        }
        this._pr.copy(r);
        this._pu.copy(u);
        this._pb.copy(b);
        this._peye.copy(eye);
    }
    bindRenderer(renderer) {
        this.renderer = renderer;
        for (let i = 0; i < this.frustums.length; i++) {
            this.renderer.assignPickingColor(this.frustums[i]);
        }
        this._aspect = this.renderer.handler.getClientAspect();
        this._setProj(this._viewAngle, this._aspect);
    }
    /**
     * Camera initialization.
     * @public
     * @param {Object} [options] - Camera options:
     * @param {number} [options.viewAngle] - Camera angle of view.
     * @param {number} [options.near] - Camera near plane distance. Default is 1.0
     * @param {number} [options.far] - Camera far plane distance. Default is math.MAX
     * @param {Vec3} [options.eye] - Camera eye position. Default (0,0,0)
     * @param {Vec3} [options.look] - Camera look position. Default (0,0,0)
     * @param {Vec3} [options.up] - Camera eye position. Default (0,1,0)
     */
    _init(options) {
        this._setProj(this._viewAngle, this._aspect);
        this.set(options.eye || new Vec3(0.0, 0.0, 1.0), options.look || new Vec3(), options.up || new Vec3(0.0, 1.0, 0.0));
    }
    getUp() {
        return this._u.clone();
    }
    getDown() {
        return this._u.negateTo();
    }
    getRight() {
        return this._r.clone();
    }
    getLeft() {
        return this._r.negateTo();
    }
    getForward() {
        return this._b.negateTo();
    }
    getBackward() {
        return this._b.clone();
    }
    /**
     * Updates camera view space
     * @public
     * @virtual
     */
    update() {
        let u = this._r, v = this._u, n = this._b, eye = this.eye;
        Vec3.doubleToTwoFloat32Array(eye, this.eyeHigh, this.eyeLow);
        this._viewMatrix.set([
            u.x, v.x, n.x, 0.0,
            u.y, v.y, n.y, 0.0,
            u.z, v.z, n.z, 0.0,
            -eye.dot(u), -eye.dot(v), -eye.dot(n), 1.0
        ]);
        // do not clean up, someday it will be using
        //this._normalMatrix = this._viewMatrix.toMatrix3(); // this._viewMatrix.toInverseMatrix3().transposeTo();
        for (let i = 0, len = this.frustums.length; i < len; i++) {
            this.frustums[i].setViewMatrix(this._viewMatrix);
        }
        this.events.dispatch(this.events.viewchange, this);
    }
    /**
     * Refresh camera matrices
     * @public
     */
    refresh() {
        this._setProj(this._viewAngle, this._aspect);
        this.update();
    }
    /**
     * Sets aspect ratio
     * @public
     * @param {Number} aspect - Camera aspect ratio
     */
    setAspectRatio(aspect) {
        this._aspect = aspect;
        this.refresh();
    }
    /**
     * Returns aspect ratio
     * @public
     * @returns {number} - Aspect ratio
     */
    getAspectRatio() {
        return this._aspect;
    }
    /**
     * Sets up camera projection
     * @public
     * @param {number} angle - Camera view angle
     * @param {number} aspect - Screen aspect ratio
     */
    _setProj(angle, aspect) {
        this._viewAngle = angle;
        this._aspect = aspect;
        this._tanViewAngle_hrad = Math.tan(angle * RADIANS_HALF);
        this._tanViewAngle_hradOneByHeight =
            this._tanViewAngle_hrad * this.renderer.handler._oneByHeight;
        let c = this.renderer.handler.canvas;
        this._projSizeConst = Math.min(c.clientWidth < 512 ? 512 : c.clientWidth, c.clientHeight < 512 ? 512 : c.clientHeight) / (angle * RADIANS);
        for (let i = 0, len = this.frustums.length; i < len; i++) {
            this.frustums[i].setProjectionMatrix(angle, aspect, this.frustums[i].near, this.frustums[i].far);
        }
    }
    /**
     * Sets camera view angle in degrees
     * @public
     * @param {number} angle - View angle
     */
    setViewAngle(angle) {
        this._viewAngle = angle;
        this.refresh();
    }
    /**
     * Gets camera view angle in degrees
     * @public
     * @returns {number} angle -
     */
    getViewAngle() {
        return this._viewAngle;
    }
    get viewAngle() {
        return this._viewAngle;
    }
    /**
     * Sets camera to eye position
     * @public
     * @param {Vec3} eye - Camera position
     * @param {Vec3} look - Look point
     * @param {Vec3} up - Camera up vector
     * @returns {Camera} - This camera
     */
    set(eye, look, up) {
        this.eye.x = eye.x;
        this.eye.y = eye.y;
        this.eye.z = eye.z;
        look = look || this._b;
        up = up || this._u;
        this._b.x = eye.x - look.x;
        this._b.y = eye.y - look.y;
        this._b.z = eye.z - look.z;
        this._r.copy(up.cross(this._b));
        this._b.normalize();
        this._r.normalize();
        this._u.copy(this._b.cross(this._r));
        return this;
    }
    /**
     * Sets camera look point
     * @public
     * @param {Vec3} look - Look point
     * @param {Vec3} [up] - Camera up vector otherwise camera current up vector(this._u)
     */
    look(look, up) {
        this._b.set(this.eye.x - look.x, this.eye.y - look.y, this.eye.z - look.z);
        this._r.copy((up || this._u).cross(this._b));
        this._b.normalize();
        this._r.normalize();
        this._u.copy(this._b.cross(this._r));
    }
    /**
     * Slides camera to vector d - (du, dv, dn)
     * @public
     * @param {number} du - delta X
     * @param {number} dv - delta Y
     * @param {number} dn - delta Z
     */
    slide(du, dv, dn) {
        this.eye.x += du * this._r.x + dv * this._u.x + dn * this._b.x;
        this.eye.y += du * this._r.y + dv * this._u.y + dn * this._b.y;
        this.eye.z += du * this._r.z + dv * this._u.z + dn * this._b.z;
    }
    /**
     * Roll the camera to the angle in degrees
     * @public
     * @param {number} angle - Delta roll angle in degrees
     */
    roll(angle) {
        let cs = Math.cos(RADIANS * angle);
        let sn = Math.sin(RADIANS * angle);
        let t = this._r.clone();
        this._r.set(cs * t.x - sn * this._u.x, cs * t.y - sn * this._u.y, cs * t.z - sn * this._u.z);
        this._u.set(sn * t.x + cs * this._u.x, sn * t.y + cs * this._u.y, sn * t.z + cs * this._u.z);
    }
    /**
     * Pitch the camera to the angle in degrees
     * @public
     * @param {number} angle - Delta pitch angle in degrees
     */
    pitch(angle) {
        let cs = Math.cos(RADIANS * angle);
        let sn = Math.sin(RADIANS * angle);
        let t = this._b.clone();
        this._b.set(cs * t.x - sn * this._u.x, cs * t.y - sn * this._u.y, cs * t.z - sn * this._u.z);
        this._u.set(sn * t.x + cs * this._u.x, sn * t.y + cs * this._u.y, sn * t.z + cs * this._u.z);
    }
    /**
     * Yaw the camera to the angle in degrees
     * @public
     * @param {number} angle - Delta yaw angle in degrees
     */
    yaw(angle) {
        let cs = Math.cos(RADIANS * angle);
        let sn = Math.sin(RADIANS * angle);
        let t = this._r.clone();
        this._r.set(cs * t.x - sn * this._b.x, cs * t.y - sn * this._b.y, cs * t.z - sn * this._b.z);
        this._b.set(sn * t.x + cs * this._b.x, sn * t.y + cs * this._b.y, sn * t.z + cs * this._b.z);
    }
    /**
     * Returns normal vector direction to the unprojected screen point from camera eye
     * @public
     * @param {number} x - Screen X coordinate
     * @param {number} y - Screen Y coordinate
     * @returns {Vec3} - Direction vector
     */
    unproject(x, y) {
        let c = this.renderer.handler.canvas, w = c.width * 0.5, h = c.height * 0.5;
        let px = (x - w) / w, py = -(y - h) / h;
        let world1 = this.frustums[0].inverseProjectionViewMatrix.mulVec4(new Vec4(px, py, -1.0, 1.0)).affinity(), world2 = this.frustums[0].inverseProjectionViewMatrix.mulVec4(new Vec4(px, py, 0.0, 1.0)).affinity();
        return world2.subA(world1).toVec3().normalize();
    }
    /**
     * Gets projected 3d point to the 2d screen coordinates
     * @public
     * @param {Vec3} v - Cartesian 3d coordinates
     * @returns {Vec2} - Screen point coordinates
     */
    project(v) {
        let r = this.frustums[0].projectionViewMatrix.mulVec4(v.toVec4()), c = this.renderer.handler.canvas;
        return new Vec2((1 + r.x / r.w) * c.width * 0.5, (1 - r.y / r.w) * c.height * 0.5);
    }
    /**
     * Rotates camera around center point
     * @public
     * @param {number} angle - Rotation angle in radians
     * @param {boolean} [isArc] - If true camera up vector gets from current up vector every frame,
     * otherwise up is always input parameter.
     * @param {Vec3} [center] - Point that the camera rotates around
     * @param {Vec3} [up] - Camera up vector
     */
    rotateAround(angle, isArc, center, up) {
        center = center || Vec3.ZERO;
        up = up || Vec3.UP;
        let rot = new Mat4().setRotation(isArc ? this._u : up, angle);
        let tr = new Mat4().setIdentity().translate(center);
        let ntr = new Mat4().setIdentity().translate(center.negateTo());
        let trm = tr.mul(rot).mul(ntr);
        this.eye = trm.mulVec3(this.eye);
        this._u = rot.mulVec3(this._u).normalize();
        this._r = rot.mulVec3(this._r).normalize();
        this._b = rot.mulVec3(this._b).normalize();
    }
    /**
     * Rotates camera around center point by horizontal.
     * @public
     * @param {number} angle - Rotation angle in radians.
     * @param {boolean} [isArc] - If true camera up vector gets from current up vector every frame,
     * otherwise up is always input parameter.
     * @param {Vec3} [center] - Point that the camera rotates around.
     * @param {Vec3} [up] - Camera up vector.
     */
    rotateHorizontal(angle, isArc, center, up) {
        this.rotateAround(angle, isArc, center, up);
    }
    /**
     * Rotates camera around center point by vertical.
     * @param {number} angle - Rotation angle in radians.
     * @param {Vec3} [center] - Point that the camera rotates around.
     */
    rotateVertical(angle, center) {
        this.rotateAround(angle, false, center, this._r);
    }
    /**
     * Gets 3d size factor. Uses in LOD distance calculation.
     * @public
     * @param {Vec3} p - Far point.
     * @param {Vec3} r - Far point.
     * @returns {number} - Size factor.
     */
    projectedSize(p, r) {
        return Math.atan(r / this.eye.distance(p)) * this._projSizeConst;
    }
    /**
     * Returns model matrix.
     * @public
     * @returns {NumberArray16} - View matrix.
     */
    getViewMatrix() {
        return this._viewMatrix._m;
    }
    /**
     * Returns normal matrix.
     * @public
     * @returns {NumberArray9} - Normal matrix.
     */
    getNormalMatrix() {
        return this._normalMatrix._m;
    }
    setCurrentFrustum(k) {
        this.currentFrustumIndex = k;
        this.isFirstPass = k === this.FARTHEST_FRUSTUM_INDEX;
    }
    getCurrentFrustum() {
        return this.currentFrustumIndex;
    }
    containsSphere(sphere) {
        for (let i = 0; i < this.frustums.length; i++) {
            if (this.frustums[i].containsSphere(sphere)) {
                return true;
            }
        }
        return false;
    }
    get frustum() {
        return this.frustums[this.currentFrustumIndex];
    }
    /**
     * Returns projection matrix.
     * @public
     * @returns {Mat4} - Projection matrix.
     */
    getProjectionMatrix() {
        return this.frustum.projectionMatrix._m;
    }
    /**
     * Returns projection and model matrix product.
     * @public
     * @return {Mat4} - Projection-view matrix.
     */
    getProjectionViewMatrix() {
        return this.frustum.projectionViewMatrix._m;
    }
    /**
     * Returns inverse projection and model matrix product.
     * @public
     * @returns {Mat4} - Inverse projection-view matrix.
     */
    getInverseProjectionViewMatrix() {
        return this.frustum.inverseProjectionViewMatrix._m;
    }
    /**
     * Returns inverse projection matrix.
     * @public
     * @returns {Mat4} - Inverse projection-view matrix.
     */
    getInverseProjectionMatrix() {
        return this.frustum.inverseProjectionMatrix._m;
    }
}

/**
 * Planet camera.
 * @class
 * @extends {Camera}
 * @param {Planet} planet - Planet render node.
 * @param {IPlanetCameraParams} [options] - Planet camera options:
 * @param {string} [options.name] - Camera name.
 * @param {number} [options.viewAngle] - Camera angle of view.
 * @param {number} [options.near] - Camera near plane distance. Default is 1.0
 * @param {number} [options.far] - Camera far plane distance. Default is og.math.MAX
 * @param {number} [options.minAltitude] - Minimal altitude for the camera. Default is 5
 * @param {number} [options.maxAltitude] - Maximal altitude for the camera. Default is 20000000
 * @param {Vec3} [options.eye] - Camera eye position. Default (0,0,0)
 * @param {Vec3} [options.look] - Camera look position. Default (0,0,0)
 * @param {Vec3} [options.up] - Camera eye position. Default (0,1,0)
 */
class PlanetCamera extends Camera {
    constructor(planet, options = {}) {
        super(planet.renderer, {
            ...options,
            frustums: options.frustums || [[1, 100 + 0.075], [100, 1000 + 0.075], [1000, 1e6 + 10000], [1e6, 1e9]],
        });
        this.planet = planet;
        this.minAltitude = options.minAltitude || 1;
        this.maxAltitude = options.maxAltitude || 20000000;
        this._lonLat = this.planet.ellipsoid.cartesianToLonLat(this.eye);
        this._lonLatMerc = this._lonLat.forwardMercator();
        this._terrainAltitude = this._lonLat.height;
        this._terrainPoint = new Vec3();
        this._insideSegment = null;
        this.slope = 0;
        this._keyLock = new Key();
        this._framesArr = [];
        this._framesCounter = 0;
        this._numFrames = 50;
        this._completeCallback = null;
        this._frameCallback = null;
        this._flying = false;
        this._checkTerrainCollision = true;
        this.eyeNorm = this.eye.getNormal();
    }
    setTerrainCollisionActivity(isActive) {
        this._checkTerrainCollision = isActive;
    }
    /**
     * Updates camera view space.
     * @public
     * @virtual
     */
    update() {
        this.events.stopPropagation();
        let maxAlt = this.maxAltitude + this.planet.ellipsoid.getEquatorialSize();
        if (this.eye.length() > maxAlt) {
            this.eye.copy(this.eye.getNormal().scale(maxAlt));
        }
        super.update();
        this.updateGeodeticPosition();
        this.eyeNorm = this.eye.getNormal();
        this.slope = this._b.dot(this.eyeNorm);
        this.events.dispatch(this.events.viewchange, this);
    }
    updateGeodeticPosition() {
        this.planet.ellipsoid.cartesianToLonLatRes(this.eye, this._lonLat);
        if (Math.abs(this._lonLat.lat) <= MAX_LAT) {
            LonLat.forwardMercatorRes(this._lonLat, this._lonLatMerc);
        }
    }
    /**
     * Sets altitude over the terrain.
     * @public
     * @param {number} alt - Altitude over the terrain.
     */
    setAltitude(alt) {
        let t = this._terrainPoint;
        let n = this.planet.ellipsoid.getSurfaceNormal3v(this.eye);
        this.eye.x = n.x * alt + t.x;
        this.eye.y = n.y * alt + t.y;
        this.eye.z = n.z * alt + t.z;
        this._terrainAltitude = alt;
    }
    /**
     * Gets altitude over the terrain.
     * @public
     */
    getAltitude() {
        return this._terrainAltitude;
    }
    /**
     * Places camera to view to the geographical point.
     * @public
     * @param {LonLat} lonlat - New camera and camera view position.
     * @param {LonLat} [lookLonLat] - Look up coordinates.
     * @param {Vec3} [up] - Camera UP vector. Default (0,1,0)
     */
    setLonLat(lonlat, lookLonLat, up) {
        this.stopFlying();
        this._lonLat.set(lonlat.lon, lonlat.lat, lonlat.height || this._lonLat.height);
        let el = this.planet.ellipsoid;
        let newEye = el.lonLatToCartesian(this._lonLat);
        let newLook = lookLonLat ? el.lonLatToCartesian(lookLonLat) : Vec3.ZERO;
        this.set(newEye, newLook, up || Vec3.NORTH);
        this.update();
    }
    /**
     * Returns camera geographical position.
     * @public
     * @returns {LonLat}
     */
    getLonLat() {
        return this._lonLat;
    }
    /**
     * Returns camera height.
     * @public
     * @returns {number}
     */
    getHeight() {
        return this._lonLat.height;
    }
    /**
     * Gets position by viewable extent.
     * @public
     * @param {Extent} extent - Viewable extent.
     * @param {Number} height - Camera height
     * @returns {Vec3}
     */
    getExtentPosition(extent, height) {
        height = height || 0;
        let north = extent.getNorth();
        let south = extent.getSouth();
        let east = extent.getEast();
        let west = extent.getWest();
        if (west > east) {
            east += 360;
        }
        let e = this.planet.ellipsoid;
        let cart = new LonLat(east, north);
        let northEast = e.lonLatToCartesian(cart);
        cart.lat = south;
        let southEast = e.lonLatToCartesian(cart);
        cart.lon = west;
        let southWest = e.lonLatToCartesian(cart);
        cart.lat = north;
        let northWest = e.lonLatToCartesian(cart);
        let center = Vec3.sub(northEast, southWest).scale(0.5).addA(southWest);
        let mag = center.length();
        if (mag < 0.000001) {
            cart.lon = (east + west) * 0.5;
            cart.lat = (north + south) * 0.5;
            center = e.lonLatToCartesian(cart);
        }
        northWest.subA(center);
        southEast.subA(center);
        northEast.subA(center);
        southWest.subA(center);
        let direction = center.getNormal(); // ellipsoid.getSurfaceNormal(center).negate().normalize();
        let right = direction.cross(Vec3.NORTH).normalize();
        let up = right.cross(direction).normalize();
        let _h = Math.max(Math.abs(up.dot(northWest)), Math.abs(up.dot(southEast)), Math.abs(up.dot(northEast)), Math.abs(up.dot(southWest)));
        let _w = Math.max(Math.abs(right.dot(northWest)), Math.abs(right.dot(southEast)), Math.abs(right.dot(northEast)), Math.abs(right.dot(southWest)));
        let tanPhi = Math.tan(this._viewAngle * RADIANS * 0.5);
        let tanTheta = this._aspect * tanPhi;
        let d = Math.max(_w / tanTheta, _h / tanPhi);
        center.normalize();
        center.scale(mag + d + height);
        return center;
    }
    /**
     * View current extent.
     * @public
     * @param {Extent} extent - Current extent.
     * @param {number} [height]
     */
    viewExtent(extent, height) {
        this.stopFlying();
        this.set(this.getExtentPosition(extent, height), Vec3.ZERO, Vec3.NORTH);
        this.update();
    }
    /**
     * Flies to the current extent.
     * @public
     * @param {Extent} extent - Current extent.
     * @param {number} [height] - Destination height.
     * @param {Vec3} [up] - Camera UP in the end of flying. Default - (0,1,0)
     * @param {Number} [ampl] - Altitude amplitude factor.
     * @param {Function} [completeCallback] - Callback that calls after flying when flying is finished.
     * @param {Function} [startCallback] - Callback that calls before the flying begins.
     * @param {Function} [frameCallback] - Each frame callback
     */
    flyExtent(extent, height, up, ampl, completeCallback, startCallback, frameCallback) {
        this.flyCartesian(this.getExtentPosition(extent, height), Vec3.ZERO, up, ampl == null ? 1 : ampl, completeCallback, startCallback, frameCallback);
    }
    viewDistance(cartesian, distance = 10000.0) {
        let p0 = this.eye.add(this.getForward().scaleTo(distance));
        let _rot = Quat.getRotationBetweenVectors(p0.getNormal(), cartesian.getNormal());
        if (_rot.isZero()) {
            let newPos = cartesian.add(this.getBackward().scaleTo(distance));
            this.set(newPos, cartesian);
        }
        else {
            let newPos = cartesian.add(_rot.mulVec3(this.getBackward()).scale(distance)), newUp = _rot.mulVec3(this.getUp());
            this.set(newPos, cartesian, newUp);
        }
        this.update();
    }
    flyDistance(cartesian, distance = 10000.0, ampl = 0.0, completeCallback, startCallback, frameCallback) {
        let p0 = this.eye.add(this.getForward().scaleTo(distance));
        let _rot = Quat.getRotationBetweenVectors(p0.getNormal(), cartesian.getNormal());
        if (_rot.isZero()) {
            let newPos = cartesian.add(this.getBackward().scaleTo(distance));
            this.set(newPos, cartesian);
        }
        else {
            let newPos = cartesian.add(_rot.mulVec3(this.getBackward()).scale(distance)), newUp = _rot.mulVec3(this.getUp());
            this.flyCartesian(newPos, cartesian, newUp, ampl, completeCallback, startCallback, frameCallback);
        }
    }
    /**
     * Flies to the cartesian coordinates.
     * @public
     * @param {Vec3} cartesian - Finish cartesian coordinates.
     * @param {Vec3} [look] - Camera LOOK in the end of flying. Default - (0,0,0)
     * @param {Vec3} [up] - Camera UP vector in the end of flying. Default - (0,1,0)
     * @param {Number} [ampl=1.0] - Altitude amplitude factor.
     * @param {Function} [completeCallback] - Callback that calls after flying when flying is finished.
     * @param {Function} [startCallback] - Callback that calls before the flying begins.
     * @param {Function} [frameCallback] - Each frame callback
     */
    flyCartesian(cartesian, look = Vec3.ZERO, up = Vec3.NORTH, ampl = 1.0, completeCallback = () => {
    }, startCallback = () => {
    }, frameCallback = () => {
    }) {
        this.stopFlying();
        look = look || Vec3.ZERO;
        up = up || Vec3.NORTH;
        this._completeCallback = completeCallback;
        this._frameCallback = frameCallback;
        if (startCallback) {
            startCallback.call(this);
        }
        if (look instanceof LonLat) {
            look = this.planet.ellipsoid.lonLatToCartesian(look);
        }
        let ground_a = this.planet.ellipsoid.lonLatToCartesian(new LonLat(this._lonLat.lon, this._lonLat.lat));
        let v_a = this._u, n_a = this._b;
        let lonlat_b = this.planet.ellipsoid.cartesianToLonLat(cartesian);
        let up_b = up;
        let ground_b = this.planet.ellipsoid.lonLatToCartesian(new LonLat(lonlat_b.lon, lonlat_b.lat, 0));
        let n_b = Vec3.sub(cartesian, look);
        let u_b = up_b.cross(n_b);
        n_b.normalize();
        u_b.normalize();
        let v_b = n_b.cross(u_b);
        let an = ground_a.getNormal();
        let bn = ground_b.getNormal();
        let anbn = 1.0 - an.dot(bn);
        let hM_a = ampl * SQRT_HALF * Math.sqrt(anbn > 0.0 ? anbn : 0.0);
        let maxHeight = 6639613;
        let currMaxHeight = Math.max(this._lonLat.height, lonlat_b.height);
        if (currMaxHeight > maxHeight) {
            maxHeight = currMaxHeight;
        }
        let max_h = currMaxHeight + 2.5 * hM_a * (maxHeight - currMaxHeight);
        let zero = Vec3.ZERO;
        // camera path and orientations calculation
        for (let i = 0; i <= this._numFrames; i++) {
            let d = 1 - i / this._numFrames;
            d = d * d * (3 - 2 * d);
            d *= d;
            let g_i = ground_a.smerp(ground_b, d).normalize();
            let ground_i = this.planet.getRayIntersectionEllipsoid(new Ray$1(zero, g_i));
            let t = 1 - d;
            let height_i = this._lonLat.height * d * d * d +
                max_h * 3 * d * d * t +
                max_h * 3 * d * t * t +
                lonlat_b.height * t * t * t;
            let eye_i = ground_i.addA(g_i.scale(height_i));
            let up_i = v_a.smerp(v_b, d);
            let look_i = Vec3.add(eye_i, n_a.smerp(n_b, d).negateTo());
            let n = new Vec3(eye_i.x - look_i.x, eye_i.y - look_i.y, eye_i.z - look_i.z);
            let u = up_i.cross(n);
            n.normalize();
            u.normalize();
            let v = n.cross(u);
            this._framesArr[i] = {
                eye: eye_i,
                n: n,
                u: u,
                v: v
            };
        }
        this._framesCounter = this._numFrames;
        this._flying = true;
    }
    /**
     * Flies to the geo coordinates.
     * @public
     * @param {LonLat} lonlat - Finish coordinates.
     * @param {Vec3 | LonLat} [look] - Camera LOOK in the end of flying. Default - (0,0,0)
     * @param {Vec3} [up] - Camera UP vector in the end of flying. Default - (0,1,0)
     * @param {number} [ampl] - Altitude amplitude factor.
     * @param {Function} [completeCallback] - Callback that calls after flying when flying is finished.
     * @param {Function} [startCallback] - Callback that calls befor the flying begins.
     * @param {Function} [frameCallback] - each frame callback
     */
    flyLonLat(lonlat, look, up, ampl, completeCallback, startCallback, frameCallbak) {
        let _lonLat = new LonLat(lonlat.lon, lonlat.lat, lonlat.height || this._lonLat.height);
        this.flyCartesian(this.planet.ellipsoid.lonLatToCartesian(_lonLat), look, up, ampl, completeCallback, startCallback, frameCallbak);
    }
    /**
     * Breaks the flight.
     * @public
     */
    stopFlying() {
        this.planet.layerLock.free(this._keyLock);
        this.planet.terrainLock.free(this._keyLock);
        this.planet.normalMapCreator.free(this._keyLock);
        this._flying = false;
        this._framesArr.length = 0;
        this._framesArr = [];
        this._framesCounter = -1;
        this._frameCallback = null;
    }
    /**
     * Returns camera is flying.
     * @public
     * @returns {boolean}
     */
    isFlying() {
        return this._flying;
    }
    /**
     * Rotates around planet to the left.
     * @public
     * @param {number} angle - Rotation angle.
     * @param {boolean} [spin] - If its true rotates around globe spin.
     */
    rotateLeft(angle, spin) {
        this.rotateHorizontal(angle * RADIANS, spin !== true, Vec3.ZERO);
        this.update();
    }
    /**
     * Rotates around planet to the right.
     * @public
     * @param {number} angle - Rotation angle.
     * @param {boolean} [spin] - If its true rotates around globe spin.
     */
    rotateRight(angle, spin) {
        this.rotateHorizontal(-angle * RADIANS, spin !== true, Vec3.ZERO);
        this.update();
    }
    /**
     * Rotates around planet to the North Pole.
     * @public
     * @param {number} angle - Rotation angle.
     */
    rotateUp(angle) {
        this.rotateVertical(angle * RADIANS, Vec3.ZERO);
        this.update();
    }
    /**
     * Rotates around planet to the South Pole.
     * @public
     * @param {number} angle - Rotation angle.
     */
    rotateDown(angle) {
        this.rotateVertical(-angle * RADIANS, Vec3.ZERO);
        this.update();
    }
    rotateVertical(angle, center, minSlope = 0) {
        let rot = new Mat4().setRotation(this._r, angle);
        let tr = new Mat4().setIdentity().translate(center);
        let ntr = new Mat4().setIdentity().translate(center.negateTo());
        let trm = tr.mul(rot).mul(ntr);
        let eye = trm.mulVec3(this.eye);
        let u = rot.mulVec3(this._u).normalize();
        let r = rot.mulVec3(this._r).normalize();
        let b = rot.mulVec3(this._b).normalize();
        let eyeNorm = eye.getNormal();
        let slope = b.dot(eyeNorm);
        if (minSlope) {
            let dSlope = slope - this.slope;
            if (slope < minSlope && dSlope < 0)
                return;
            if ((slope > 0.1 && u.dot(eyeNorm) > 0) ||
                this.slope <= 0.1 ||
                this._u.dot(this.eye.getNormal()) <= 0.0) {
                this.eye = eye;
                this._u = u;
                this._r = r;
                this._b = b;
            }
        }
        else {
            this.eye = eye;
            this._u = u;
            this._r = r;
            this._b = b;
        }
    }
    /**
     * Prepare camera to the frame. Used in render node frame function.
     * @public
     */
    checkFly() {
        if (this._flying) {
            let c = this._numFrames - this._framesCounter;
            this.planet.layerLock.lock(this._keyLock);
            this.planet.terrainLock.lock(this._keyLock);
            this.planet.normalMapCreator.lock(this._keyLock);
            this.eye = this._framesArr[c].eye;
            this._r = this._framesArr[c].u;
            this._u = this._framesArr[c].v;
            this._b = this._framesArr[c].n;
            if (this._frameCallback) {
                this._frameCallback();
            }
            this.update();
            this._framesCounter--;
            if (this._framesCounter < 0) {
                this.stopFlying();
                if (this._completeCallback) {
                    this._completeCallback();
                    this._completeCallback = null;
                }
            }
        }
    }
    checkTerrainCollision() {
        this._terrainAltitude = this._lonLat.height;
        if (this._insideSegment && this._insideSegment.planet) {
            this._terrainAltitude = this._insideSegment.getTerrainPoint(this.eye, this._insideSegment.getInsideLonLat(this), this._terrainPoint);
            if (this._terrainAltitude < this.minAltitude && this._checkTerrainCollision) {
                this.setAltitude(this.minAltitude);
            }
            return this._terrainPoint;
        }
    }
    getSurfaceVisibleDistance(d) {
        let R = this.planet.ellipsoid.equatorialSize;
        return R * Math.acos(R / (R + this._lonLat.height + d));
    }
    getHeading() {
        let u = this.eye.getNormal();
        let f = Vec3.proj_b_to_plane(this.slope >= 0.97 ? this.getUp() : this.getForward(), u).normalize(), n = Vec3.proj_b_to_plane(Vec3.NORTH, u).normalize();
        let res = Math.sign(u.dot(f.cross(n))) * Math.acos(f.dot(n)) * DEGREES;
        if (res < 0.0) {
            return 360.0 + res;
        }
        return res;
    }
    isVisible(poi) {
        let e = this.eye.length();
        return this.eye.distance(poi) < Math.sqrt(e * e - this.planet.ellipsoid.equatorialSizeSqr);
    }
}

// import { QueueArray } from '../QueueArray.js';
class TerrainWorker extends BaseWorker {
    constructor(numWorkers = 2) {
        super(numWorkers, TERRAIN_PROGRAM);
    }
    _onMessage(e) {
        this._source.get(e.data.id).segment._terrainWorkerCallback(e.data);
        this._source.delete(e.data.id);
        e.data.normalMapNormals = null;
        e.data.normalMapVertices = null;
        e.data.normalMapVerticesHigh = null;
        e.data.normalMapVerticesLow = null;
        e.data.terrainVertices = null;
        e.data.terrainVerticesHigh = null;
        e.data.terrainVerticesLow = null;
    }
    make(info) {
        if (info.segment.plainReady && info.segment.terrainIsLoading) {
            if (this._workerQueue.length) {
                const w = this._workerQueue.pop();
                this._source.set(this._sourceId, info);
                let segment = info.segment;
                w.postMessage({
                    'elevations': info.elevations,
                    'this_plainVertices': segment.plainVertices,
                    'this_plainNormals': segment.plainNormals,
                    'this_normalMapVertices': segment.normalMapVertices,
                    'this_normalMapNormals': segment.normalMapNormals,
                    'heightFactor': segment.planet._heightFactor,
                    'gridSize': segment.planet.terrain.gridSizeByZoom[segment.tileZoom],
                    'noDataValues': segment.planet.terrain.noDataValues,
                    'id': this._sourceId
                }, [
                    info.elevations.buffer,
                    segment.plainVertices.buffer,
                    segment.plainNormals.buffer,
                    segment.normalMapVertices.buffer,
                    segment.normalMapNormals.buffer
                ]);
                this._sourceId++;
            }
            else {
                this._pendingQueue.push(info);
            }
        }
        else {
            this.check();
        }
    }
}
const TERRAIN_PROGRAM = `'use strict';
    //
    //Terrain worker
    //

    function binarySearchFast(arr, x) {
        let start = 0,
            end = arr.length - 1;
        while (start <= end) {
            let k = Math.floor((start + end) * 0.5); 
            if (Math.abs(arr[k] - x) < 1e-3)
                return k;
            else if (arr[k] < x)
                start = k + 1;
            else
                end = k - 1;
        }
        return -1;
    };

    function checkNoDataValue(noDataValues, value) {
        return binarySearchFast(noDataValues, value) !== -1;
    };


    var Vec3 = function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    };

    var doubleToTwoFloats = function(v, high, low) {

        let x = v.x, y = v.y, z = v.z;
    
        if (x >= 0.0) {
            var doubleHigh = Math.floor(x / 65536.0) * 65536.0;
            high.x = Math.fround(doubleHigh);
            low.x = Math.fround(x - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-x / 65536.0) * 65536.0;
            high.x = Math.fround(-doubleHigh);
            low.x = Math.fround(x + doubleHigh);
        }

        if (y >= 0.0) {
            var doubleHigh = Math.floor(y / 65536.0) * 65536.0;
            high.y = Math.fround(doubleHigh);
            low.y = Math.fround(y - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-y / 65536.0) * 65536.0;
            high.y = Math.fround(-doubleHigh);
            low.y = Math.fround(y + doubleHigh);
        }

        if (z >= 0.0) {
            var doubleHigh = Math.floor(z / 65536.0) * 65536.0;
            high.z = Math.fround(doubleHigh);
            low.z = Math.fround(z - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-z / 65536.0) * 65536.0;
            high.z = Math.fround(-doubleHigh);
            low.z = Math.fround(z + doubleHigh);
        }
    };

    Vec3.prototype.sub = function(v) {
        return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
    };

    Vec3.prototype.add = function(v) {
        return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
    };

    Vec3.prototype.cross = function(v) {
        return new Vec3(
            this.y * v.z - this.z * v.y,
            this.z * v.x - this.x * v.z,
            this.x * v.y - this.y * v.x
        );
    };

    Vec3.prototype.normalize = function(v) {
        var x = this.x, y = this.y, z = this.z;
        var length = 1.0 / Math.sqrt(x * x + y * y + z * z);
        this.x = x * length;
        this.y = y * length;
        this.z = z * length;
        return this;
    };

    Vec3.prototype.distance = function(v) {
        return this.sub(v).length();
    };

    Vec3.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };

    var blerp = function(x, y, fQ11, fQ21, fQ12, fQ22) {
        return (fQ11 * (1.0 - x) * (1.0 - y) + fQ21 * x * (1.0 - y) + fQ12 * (1.0 - x) * y + fQ22 * x * y);
    };
    
    var slice = function (t, h1, h0) {
      return t * (h1 - h0);
    };

    var _tempVec = new Vec3(0.0, 0.0, 0.0);

    var _tempHigh = new Vec3(0.0, 0.0, 0.0),
        _tempLow = new Vec3(0.0, 0.0, 0.0);

    self.onmessage = function (e) {
        var elevations = e.data.elevations,
            this_plainVertices = e.data.this_plainVertices,
            this_plainNormals = e.data.this_plainNormals,
            this_normalMapVertices = e.data.this_normalMapVertices,
            this_normalMapNormals = e.data.this_normalMapNormals,
            heightFactor =  e.data.heightFactor,
            gridSize = e.data.gridSize,
            noDataValues = e.data.noDataValues,
            id = e.data.id;
        
        var xmin = 549755748352.0, xmax = -549755748352.0, 
            ymin = 549755748352.0, ymax = -549755748352.0, 
            zmin = 549755748352.0, zmax = -549755748352.0;

        const fileGridSize = Math.sqrt(elevations.length) - 1;

        const fileGridSize_one = fileGridSize + 1;
        const fileGridSize_one_x2 = fileGridSize_one * fileGridSize_one;
        const tgs = gridSize;
        const dg = fileGridSize / tgs;
        const gs = tgs + 1;
        const hf = heightFactor;

        var nmvInd = 0,
            vInd = 0,
            noDataInd = 0;

        var gsgs3 = gs * gs * 3;

        var terrainVertices = new Float64Array(gsgs3),
            terrainVerticesHigh = new Float32Array(gsgs3),
            terrainVerticesLow = new Float32Array(gsgs3),
            noDataVertices = new Uint8Array(gs * gs);

        var normalMapNormals,
            normalMapVertices,
            normalMapVerticesHigh,
            normalMapVerticesLow;

        var nv = this_normalMapVertices,
            nn = this_normalMapNormals;

        if (fileGridSize >= tgs) {

            normalMapNormals = new Float32Array(fileGridSize_one_x2 * 3);
            normalMapVertices = new Float64Array(fileGridSize_one_x2 * 3);
            normalMapVerticesHigh = new Float32Array(fileGridSize_one_x2 * 3);
            normalMapVerticesLow = new Float32Array(fileGridSize_one_x2 * 3);

            for (let k = 0; k < fileGridSize_one_x2; k++) {

                var j = k % fileGridSize_one,
                    i = ~~(k / fileGridSize_one);

                //
                // V0
                //
                var hInd0 = k;
                var vInd0 = hInd0 * 3;
                var currElv = elevations[hInd0];
                if(checkNoDataValue(noDataValues, currElv)) {
                    currElv = 0.0;
                }
                var h0 = hf * currElv;
                var v0 = new Vec3(nv[vInd0] + h0 * nn[vInd0], nv[vInd0 + 1] + h0 * nn[vInd0 + 1], nv[vInd0 + 2] + h0 * nn[vInd0 + 2]);
                                
                doubleToTwoFloats(v0, _tempHigh, _tempLow);

                normalMapVertices[vInd0] = v0.x;
                normalMapVertices[vInd0 + 1] = v0.y;
                normalMapVertices[vInd0 + 2] = v0.z;

                normalMapVerticesHigh[vInd0] = _tempHigh.x;
                normalMapVerticesHigh[vInd0 + 1] = _tempHigh.y;
                normalMapVerticesHigh[vInd0 + 2] = _tempHigh.z;

                normalMapVerticesLow[vInd0] = _tempLow.x;
                normalMapVerticesLow[vInd0 + 1] = _tempLow.y;
                normalMapVerticesLow[vInd0 + 2] = _tempLow.z;

                //
                // The vertex goes into screen buffer
                if (i % dg === 0 && j % dg === 0) {

                    let currVert = new Vec3(nv[vInd0], nv[vInd0 + 1], nv[vInd0 + 2]);
                    let nextVert = new Vec3(nv[vInd0 + 3], nv[vInd0 + 4], nv[vInd0 + 5]);

                    let nextElv =  elevations[hInd0 + 1];
                    if(checkNoDataValue(noDataValues, nextElv)) {
                        nextElv = 0.0;
                    }
                    
                    let eps = false;
                    if(noDataValues.length === 0){
                        let step = currVert.distance(nextVert);
                        let deltaElv = Math.abs(currElv - nextElv);
                        eps = ((deltaElv / step) > 10.0) || (currElv < -5000);
                    }

                    if(eps){
                        noDataVertices[noDataInd] = 1;
                    } else {
                        noDataVertices[noDataInd] = 0;
                        if (v0.x < xmin) xmin = v0.x; if (v0.x > xmax) xmax = v0.x;
                        if (v0.y < ymin) ymin = v0.y; if (v0.y > ymax) ymax = v0.y;
                        if (v0.z < zmin) zmin = v0.z; if (v0.z > zmax) zmax = v0.z;
                    }

                    terrainVerticesHigh[vInd] = _tempHigh.x;
                    terrainVerticesLow[vInd] = _tempLow.x;
                    terrainVertices[vInd++] = v0.x;

                    terrainVerticesHigh[vInd] = _tempHigh.y;
                    terrainVerticesLow[vInd] = _tempLow.y;
                    terrainVertices[vInd++] = v0.y;

                    terrainVerticesHigh[vInd] = _tempHigh.z;
                    terrainVerticesLow[vInd] = _tempLow.z;
                    terrainVertices[vInd++] = v0.z;

                    noDataInd++;
                }

                if (i !== fileGridSize && j !== fileGridSize) {

                    //
                    //  V1
                    //
                    var hInd1 = k + 1;
                    var vInd1 = hInd1 * 3;
                    var elv = elevations[hInd1];
                    if(checkNoDataValue(noDataValues, elv)) {
                        elv = 0.0;
                    }
                    var h1 = hf * elv;
                    var v1 = new Vec3(nv[vInd1] + h1 * nn[vInd1], nv[vInd1 + 1] + h1 * nn[vInd1 + 1], nv[vInd1 + 2] + h1 * nn[vInd1 + 2]);

                    doubleToTwoFloats(v1, _tempHigh, _tempLow);

                    normalMapVertices[vInd1] = v1.x;
                    normalMapVertices[vInd1 + 1] = v1.y;
                    normalMapVertices[vInd1 + 2] = v1.z;

                    normalMapVerticesHigh[vInd1] = _tempHigh.x;
                    normalMapVerticesHigh[vInd1 + 1] = _tempHigh.y;
                    normalMapVerticesHigh[vInd1 + 2] = _tempHigh.z;

                    normalMapVerticesLow[vInd1] = _tempLow.x;
                    normalMapVerticesLow[vInd1 + 1] = _tempLow.y;
                    normalMapVerticesLow[vInd1 + 2] = _tempLow.z;

                    //
                    //  V2
                    //
                    var hInd2 = k + fileGridSize_one;
                    var vInd2 = hInd2 * 3;
                    var elv = elevations[hInd2];
                    if(checkNoDataValue(noDataValues, elv)) {
                        elv = 0.0;
                    }
                    var h2 = hf * elv;
                    var v2 = new Vec3(nv[vInd2] + h2 * nn[vInd2], nv[vInd2 + 1] + h2 * nn[vInd2 + 1], nv[vInd2 + 2] + h2 * nn[vInd2 + 2]);

                    doubleToTwoFloats(v2, _tempHigh, _tempLow);

                    normalMapVertices[vInd2] = v2.x;
                    normalMapVertices[vInd2 + 1] = v2.y;
                    normalMapVertices[vInd2 + 2] = v2.z;

                    normalMapVerticesHigh[vInd2] = _tempHigh.x;
                    normalMapVerticesHigh[vInd2 + 1] = _tempHigh.y;
                    normalMapVerticesHigh[vInd2 + 2] = _tempHigh.z;

                    normalMapVerticesLow[vInd2] = _tempLow.x;
                    normalMapVerticesLow[vInd2 + 1] = _tempLow.y;
                    normalMapVerticesLow[vInd2 + 2] = _tempLow.z;

                    //
                    //  V3
                    //
                    var hInd3 = k + fileGridSize_one + 1;
                    var vInd3 = hInd3 * 3;
                    var elv = elevations[hInd3];
                    if(checkNoDataValue(noDataValues, elv)) {
                        elv = 0.0;
                    }
                    var h3 = hf * elv;
                    var v3 = new Vec3(nv[vInd3] + h3 * nn[vInd3], nv[vInd3 + 1] + h3 * nn[vInd3 + 1], nv[vInd3 + 2] + h3 * nn[vInd3 + 2]);

                    doubleToTwoFloats(v3, _tempHigh, _tempLow);

                    normalMapVertices[vInd3] = v3.x;
                    normalMapVertices[vInd3 + 1] = v3.y;
                    normalMapVertices[vInd3 + 2] = v3.z;

                    normalMapVerticesHigh[vInd3] = _tempHigh.x;
                    normalMapVerticesHigh[vInd3 + 1] = _tempHigh.y;
                    normalMapVerticesHigh[vInd3 + 2] = _tempHigh.z;

                    normalMapVerticesLow[vInd3] = _tempLow.x;
                    normalMapVerticesLow[vInd3 + 1] = _tempLow.y;
                    normalMapVerticesLow[vInd3 + 2] = _tempLow.z;

                    //
                    // Normal
                    //
                    var e10 = v1.sub(v0),
                        e20 = v2.sub(v0),
                        e30 = v3.sub(v0);
                    var sw = e20.cross(e30).normalize();
                    var ne = e30.cross(e10).normalize();
                    var n0 = ne.add(sw).normalize();

                    normalMapNormals[vInd0] += n0.x;
                    normalMapNormals[vInd0 + 1] += n0.y;
                    normalMapNormals[vInd0 + 2] += n0.z;

                    normalMapNormals[vInd1] += ne.x;
                    normalMapNormals[vInd1 + 1] += ne.y;
                    normalMapNormals[vInd1 + 2] += ne.z;

                    normalMapNormals[vInd2] += sw.x;
                    normalMapNormals[vInd2 + 1] += sw.y;
                    normalMapNormals[vInd2 + 2] += sw.z;

                    normalMapNormals[vInd3] += n0.x;
                    normalMapNormals[vInd3 + 1] += n0.y;
                    normalMapNormals[vInd3 + 2] += n0.z;
                }
            }

        } else {

            normalMapNormals = new Float32Array(gsgs3);
            normalMapVertices = new Float64Array(gsgs3);
            normalMapVerticesHigh = new Float32Array(gsgs3);
            normalMapVerticesLow = new Float32Array(gsgs3);
            normalMapNormals = new Float32Array(gsgs3);

            var oneSize = tgs / fileGridSize;
            var h, inside_i, inside_j, v_i, v_j;
            var gsgs = gsgs3 / 3;
            var fgsOne = fileGridSize + 1;

            for(let i = 0; i < gsgs; i++) {
                let ii = Math.floor(i / gs),
                    ij = i % gs;
              
                let qii = ii % oneSize,
                    qij = ij % oneSize;

                let hlt_ind = Math.floor(ii / oneSize) * fgsOne + Math.floor(ij / oneSize);

                if (ij === tgs) {
                    hlt_ind -= 1;
                    qij = oneSize;
                }

                if (ii === tgs) {
                    hlt_ind -= fgsOne;
                    qii = oneSize;
                }

                let hrt_ind = hlt_ind + 1,
                    hlb_ind = hlt_ind + fgsOne,
                    hrb_ind = hlb_ind + 1;

                let h_lt = elevations[hlt_ind],
                    h_rt = elevations[hrt_ind],
                    h_lb = elevations[hlb_ind],
                    h_rb = elevations[hrb_ind];

                if(checkNoDataValue(noDataValues, h_lt)) {
                    h_lt = 0.0;
                }

                if(checkNoDataValue(noDataValues, h_rt)) {
                    h_rt = 0.0;
                }

                if(checkNoDataValue(noDataValues, h_lb)) {
                    h_lb = 0.0;
                }

                if(checkNoDataValue(noDataValues, h_rb)) {
                    h_rb = 0.0;
                }

                let hi = blerp(qij / oneSize, qii / oneSize, h_lt, h_rt, h_lb, h_rb);

                let i3 = i * 3;

                _tempVec.x = this_plainVertices[i3] + hi * this_plainNormals[i3],
                _tempVec.y = this_plainVertices[i3 + 1] + hi * this_plainNormals[i3 + 1],
                _tempVec.z = this_plainVertices[i3 + 2] + hi * this_plainNormals[i3 + 2];

                doubleToTwoFloats(_tempVec, _tempHigh, _tempLow);

                terrainVertices[i3] = _tempVec.x;
                terrainVertices[i3 + 1] = _tempVec.y;
                terrainVertices[i3 + 2] = _tempVec.z;

                terrainVerticesHigh[i3] = _tempHigh.x;
                terrainVerticesHigh[i3 + 1] = _tempHigh.y;
                terrainVerticesHigh[i3 + 2] = _tempHigh.z;

                terrainVerticesLow[i3] = _tempLow.x;
                terrainVerticesLow[i3 + 1] = _tempLow.y;
                terrainVerticesLow[i3 + 2] = _tempLow.z;

                if (_tempVec.x < xmin) xmin = _tempVec.x; if (_tempVec.x > xmax) xmax = _tempVec.x;
                if (_tempVec.y < ymin) ymin = _tempVec.y; if (_tempVec.y > ymax) ymax = _tempVec.y;
                if (_tempVec.z < zmin) zmin = _tempVec.z; if (_tempVec.z > zmax) zmax = _tempVec.z;
            }

            normalMapVertices.set(terrainVertices);
            normalMapVerticesHigh.set(terrainVerticesHigh);
            normalMapVerticesLow.set(terrainVerticesLow);

            for (let k = 0; k < gsgs; k++) {

                var j = k % gs,
                    i = ~~(k / gs);

                if (i !== tgs && j !== tgs) {
                    var v0ind = k * 3,
                        v1ind = v0ind + 3,
                        v2ind = v0ind + gs * 3,
                        v3ind = v2ind + 3;


                    var v0 = new Vec3(terrainVertices[v0ind], terrainVertices[v0ind + 1], terrainVertices[v0ind + 2]),
                        v1 = new Vec3(terrainVertices[v1ind], terrainVertices[v1ind + 1], terrainVertices[v1ind + 2]),
                        v2 = new Vec3(terrainVertices[v2ind], terrainVertices[v2ind + 1], terrainVertices[v2ind + 2]),
                        v3 = new Vec3(terrainVertices[v3ind], terrainVertices[v3ind + 1], terrainVertices[v3ind + 2]);

                    var e10 = v1.sub(v0).normalize(),
                        e20 = v2.sub(v0).normalize(),
                        e30 = v3.sub(v0).normalize();

                    var sw = e20.cross(e30).normalize();
                    var ne = e30.cross(e10).normalize();
                    var n0 = ne.add(sw).normalize();

                    normalMapNormals[v0ind] += n0.x;
                    normalMapNormals[v0ind + 1] += n0.y;
                    normalMapNormals[v0ind + 2] += n0.z;

                    normalMapNormals[v1ind] += ne.x;
                    normalMapNormals[v1ind + 1] += ne.y;
                    normalMapNormals[v1ind + 2] += ne.z;

                    normalMapNormals[v2ind] += sw.x;
                    normalMapNormals[v2ind + 1] += sw.y;
                    normalMapNormals[v2ind + 2] += sw.z;

                    normalMapNormals[v3ind] += n0.x;
                    normalMapNormals[v3ind + 1] += n0.y;
                    normalMapNormals[v3ind + 2] += n0.z;
                }
            }
        }

        self.postMessage({
                id: id,
                normalMapNormals: normalMapNormals,
                normalMapVertices: normalMapVertices,
                normalMapVerticesHigh: normalMapVerticesHigh,
                normalMapVerticesLow: normalMapVerticesLow,
                terrainVertices: terrainVertices,
                terrainVerticesHigh: terrainVerticesHigh,
                terrainVerticesLow: terrainVerticesLow,
                noDataVertices: noDataVertices,
                //bounds: [xmin, xmax, ymin, ymax, zmin, zmax]
                bounds: [xmin, ymin, zmin, xmax, ymax, zmax]
             }, [
                    normalMapNormals.buffer, 
                    normalMapVertices.buffer, 
                    normalMapVerticesHigh.buffer, 
                    normalMapVerticesLow.buffer, 
                    terrainVertices.buffer,
                    terrainVerticesHigh.buffer,
                    terrainVerticesLow.buffer,
                    noDataVertices.buffer
            ]);
    }`;

let tempArr = new Float32Array(2);
const MAX_FRAME_TIME = 25.0;
class VectorTileCreator {
    constructor(planet, width = 512, height = 512) {
        this._width = width;
        this._height = height;
        this._planet = planet;
        this._framebuffer = null;
        this._queue = [];
        this._handler = null;
    }
    init() {
        this._handler = this._planet.renderer.handler;
        //Line
        if (!this._handler.programs.vectorTileLineRasterization) {
            this._handler.addProgram(new Program("vectorTileLineRasterization", {
                uniforms: {
                    'viewport': "vec2",
                    'thicknessOutline': "float",
                    'alpha': "float",
                    'extentParamsHigh': "vec4",
                    'extentParamsLow': "vec4"
                },
                attributes: {
                    'prevHigh': "vec2",
                    'currentHigh': "vec2",
                    'nextHigh': "vec2",
                    'prevLow': "vec2",
                    'currentLow': "vec2",
                    'nextLow': "vec2",
                    'order': "float",
                    'color': "vec4",
                    'thickness': "float"
                },
                vertexShader: `attribute vec2 prevHigh;
                attribute vec2 currentHigh;
                attribute vec2 nextHigh;

                attribute vec2 prevLow;
                attribute vec2 currentLow;
                attribute vec2 nextLow;

                attribute float order;
                attribute float thickness;
                attribute vec4 color;
                uniform float thicknessOutline;
                uniform vec2 viewport;
                uniform vec4 extentParamsHigh;
                uniform vec4 extentParamsLow;
                varying vec4 vColor;
                
                vec2 proj(vec2 coordHigh, vec2 coordLow) {
                    vec2 highDiff = coordHigh - extentParamsHigh.xy;
                    vec2 lowDiff = coordLow - extentParamsLow.xy;                    
                    return vec2(-1.0 + (highDiff * step(1.0, length(highDiff)) + lowDiff) * extentParamsHigh.zw) * vec2(1.0, -1.0);
                }
                
                void main(){
                    vColor = color;

                    vec2 vNext = proj(nextHigh, nextLow),
                         vCurrent = proj(currentHigh, currentLow),
                         vPrev = proj(prevHigh, prevLow);

                    vec2 _next = vNext;
                    vec2 _prev = vPrev;
                    vec2 _current = vCurrent;

                    if(_prev == _current){
                        if(_next == _current){
                            _next = _current + vec2(1.0, 0.0);
                            _prev = _current - _next;
                        }else{
                            _prev = _current + normalize(_current - _next);
                        }
                    }

                    if(_next == _current){
                        _next = _current + normalize(_current - _prev);
                    }

                    vec2 sNext = _next;
                    vec2 sCurrent = _current;
                    vec2 sPrev = _prev;
                    
                    vec2 dirNext = normalize(sNext - sCurrent);
                    vec2 dirPrev = normalize(sPrev - sCurrent);
                    float dotNP = dot(dirNext, dirPrev);
                    
                    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));
                    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));
                    vec2 d = (thickness + thicknessOutline) * 0.5 * sign(order) / viewport;
                    
                    vec2 m;
                    if(dotNP >= 0.99991){
                        m = sCurrent - normalPrev * d;
                    }else{
                        vec2 dir = normalPrev + normalNext;
                        m = sCurrent + dir * d / (dirNext.x * dir.y - dirNext.y * dir.x);
                        
                        if( dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0 ){
                            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);
                            if(occw == -1.0){
                                m = sCurrent + normalPrev * d;
                            }else if(occw == 1.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == -2.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == 2.0){
                                m = sCurrent + normalPrev * d;
                            }
                        }else if(distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))){
                            m = sCurrent + normalNext * d;
                        }
                    }
                    gl_Position = vec4(m.x, m.y, 0.0, 1.0);
                }`,
                fragmentShader: `precision highp float;
                uniform float alpha;
                varying vec4 vColor;
                void main() {
                    gl_FragColor = vec4(vColor.rgb, alpha * vColor.a);
                }`
            }));
        }
        //Polygon
        if (!this._handler.programs.vectorTilePolygonRasterization) {
            this._handler.addProgram(new Program("vectorTilePolygonRasterization", {
                uniforms: {
                    'extentParamsHigh': "vec4",
                    'extentParamsLow': "vec4"
                },
                attributes: {
                    'coordinatesHigh': "vec2",
                    'coordinatesLow': "vec2",
                    'colors': "vec4"
                },
                vertexShader: `attribute vec2 coordinatesHigh;
                attribute vec2 coordinatesLow; 
                attribute vec4 colors; 
                uniform vec4 extentParamsHigh; 
                uniform vec4 extentParamsLow; 
                varying vec4 color;

                vec2 proj(vec2 coordHigh, vec2 coordLow) {
                    vec2 highDiff = coordHigh - extentParamsHigh.xy;
                    vec2 lowDiff = coordLow - extentParamsLow.xy;
                    return vec2(-1.0 + (highDiff * step(1.0, length(highDiff)) + lowDiff) * extentParamsHigh.zw) * vec2(1.0, -1.0);
                }

                void main() { 
                    color = colors;
                    gl_Position = vec4(proj(coordinatesHigh, coordinatesLow), 0.0, 1.0); 
                }`,
                fragmentShader: `precision highp float;
                varying vec4 color;
                void main () {  
                    gl_FragColor = color; 
                }`
            }));
        }
        this._framebuffer = new Framebuffer(this._handler, {
            width: this._width,
            height: this._height,
            useDepth: false
        });
        this._framebuffer.init();
    }
    frame() {
        if (this._planet.layerLock.isFree() && this._queue.length) {
            let h = this._handler, gl = h.gl;
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.DEPTH_TEST);
            let hLine = h.programs.vectorTileLineRasterization, hPoly = h.programs.vectorTilePolygonRasterization;
            let _w = this._width, _h = this._height, width = _w, height = _h, _w2 = width << 1, _h2 = height << 1;
            // var prevLayerId = -1;
            let extentParamsHigh = new Float32Array(4);
            let extentParamsLow = new Float32Array(4);
            let f = this._framebuffer.activate();
            let deltaTime = 0, startTime = window.performance.now();
            while (this._queue.length && deltaTime < MAX_FRAME_TIME) {
                let material = this._queue.shift();
                if (material.isLoading && material.segment.node.getState() === RENDERING) {
                    let pickingEnabled = material.layer._pickingEnabled;
                    if (material.segment.tileZoom < 4) {
                        width = _w2;
                        height = _h2;
                    }
                    else {
                        width = _w;
                        height = _h;
                    }
                    let texture = material._updateTexture || h.createEmptyTexture_l(width, height);
                    let pickingMask = pickingEnabled ? material._updatePickingMask || h.createEmptyTexture_n(width, height) : null;
                    material.applyTexture(texture, pickingMask);
                    f.setSize(width, height);
                    f.bindOutputTexture(texture);
                    gl.clearColor(0.0, 0.0, 0.0, 0.0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    let extent = material.segment.getExtentMerc();
                    doubleToTwoFloats2(extent.southWest.lon, tempArr);
                    extentParamsHigh[0] = tempArr[0];
                    extentParamsLow[0] = tempArr[1];
                    doubleToTwoFloats2(extent.southWest.lat, tempArr);
                    extentParamsHigh[1] = tempArr[0];
                    extentParamsLow[1] = tempArr[1];
                    extentParamsHigh[2] = 2.0 / extent.getWidth();
                    extentParamsHigh[3] = 2.0 / extent.getHeight();
                    hPoly.activate();
                    let sh = hPoly._program;
                    let sha = sh.attributes, shu = sh.uniforms;
                    let geomHandler = material.layer._geometryHandler;
                    //=========================================
                    //Polygon rendering
                    //=========================================
                    gl.uniform4fv(shu.extentParamsHigh, extentParamsHigh);
                    gl.uniform4fv(shu.extentParamsLow, extentParamsLow);
                    gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyVerticesHighBufferMerc);
                    gl.vertexAttribPointer(sha.coordinatesHigh, geomHandler._polyVerticesHighBufferMerc.itemSize, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyVerticesLowBufferMerc);
                    gl.vertexAttribPointer(sha.coordinatesLow, geomHandler._polyVerticesLowBufferMerc.itemSize, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyColorsBuffer);
                    gl.vertexAttribPointer(sha.colors, geomHandler._polyColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geomHandler._polyIndexesBuffer);
                    gl.drawElements(gl.TRIANGLES, geomHandler._polyIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                    //Polygon picking PASS
                    if (pickingEnabled) {
                        f.bindOutputTexture(pickingMask);
                        gl.clearColor(0.0, 0.0, 0.0, 0.0);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyPickingColorsBuffer);
                        gl.vertexAttribPointer(sha.colors, geomHandler._polyPickingColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);
                        gl.drawElements(gl.TRIANGLES, geomHandler._polyIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                    }
                    //=========================================
                    //Strokes and linestrings rendering
                    //=========================================
                    f.bindOutputTexture(texture);
                    hLine.activate();
                    sh = hLine._program;
                    sha = sh.attributes;
                    shu = sh.uniforms;
                    gl.uniform2fv(shu.viewport, [width, height]);
                    gl.uniform4fv(shu.extentParamsHigh, extentParamsHigh);
                    gl.uniform4fv(shu.extentParamsLow, extentParamsLow);
                    //vertex
                    let mb = geomHandler._lineVerticesHighBufferMerc;
                    gl.bindBuffer(gl.ARRAY_BUFFER, mb);
                    gl.vertexAttribPointer(sha.prevHigh, mb.itemSize, gl.FLOAT, false, 8, 0);
                    gl.vertexAttribPointer(sha.currentHigh, mb.itemSize, gl.FLOAT, false, 8, 32);
                    gl.vertexAttribPointer(sha.nextHigh, mb.itemSize, gl.FLOAT, false, 8, 64);
                    mb = geomHandler._lineVerticesLowBufferMerc;
                    gl.bindBuffer(gl.ARRAY_BUFFER, mb);
                    gl.vertexAttribPointer(sha.prevLow, mb.itemSize, gl.FLOAT, false, 8, 0);
                    gl.vertexAttribPointer(sha.currentLow, mb.itemSize, gl.FLOAT, false, 8, 32);
                    gl.vertexAttribPointer(sha.nextLow, mb.itemSize, gl.FLOAT, false, 8, 64);
                    //order
                    gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineOrdersBuffer);
                    gl.vertexAttribPointer(sha.order, geomHandler._lineOrdersBuffer.itemSize, gl.FLOAT, false, 4, 0);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geomHandler._lineIndexesBuffer);
                    //PASS - stroke
                    gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineStrokesBuffer);
                    gl.vertexAttribPointer(sha.thickness, geomHandler._lineStrokesBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineStrokeColorsBuffer);
                    gl.vertexAttribPointer(sha.color, geomHandler._lineStrokeColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    //Antialias pass
                    gl.uniform1f(shu.thicknessOutline, 2);
                    gl.uniform1f(shu.alpha, 0.54);
                    gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                    //
                    //Aliased pass
                    gl.uniform1f(shu.thicknessOutline, 1);
                    gl.uniform1f(shu.alpha, 1.0);
                    gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                    //PASS - inside line
                    gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineThicknessBuffer);
                    gl.vertexAttribPointer(sha.thickness, geomHandler._lineThicknessBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineColorsBuffer);
                    gl.vertexAttribPointer(sha.color, geomHandler._lineColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    //Antialias pass
                    gl.uniform1f(shu.thicknessOutline, 2);
                    gl.uniform1f(shu.alpha, 0.54);
                    gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                    //
                    //Aliased pass
                    gl.uniform1f(shu.thicknessOutline, 1);
                    gl.uniform1f(shu.alpha, 1.0);
                    gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                    if (pickingEnabled) {
                        f.bindOutputTexture(pickingMask);
                        gl.uniform1f(shu.thicknessOutline, 8);
                        gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._linePickingColorsBuffer);
                        gl.vertexAttribPointer(sha.color, geomHandler._linePickingColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);
                        gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                    }
                }
                else {
                    material.isLoading = false;
                }
                deltaTime = window.performance.now() - startTime;
            }
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);
            f.deactivate();
        }
    }
    add(material) {
        this._queue.push(material);
    }
    remove(material) {
        //...
    }
    get queueSize() {
        return this._queue.length;
    }
}

/**
 * Class represents a plant ellipsoid.
 * @class
 * @param {number} equatorialSize - Equatorial ellipsoid size.
 * @param {number} polarSize - Polar ellipsoid size.
 */
class Ellipsoid {
    constructor(equatorialSize = 1, polarSize = 1) {
        this._a = equatorialSize;
        this._b = polarSize;
        this._flattening = (equatorialSize - polarSize) / equatorialSize;
        this._f = 1 / this._flattening;
        this._a2 = equatorialSize * equatorialSize;
        this._b2 = polarSize * polarSize;
        const qa2b2 = Math.sqrt(this._a2 - this._b2);
        this._e = qa2b2 / equatorialSize;
        this._e2 = this._e * this._e;
        this._e22 = this._e2 * this._e2;
        this._k = qa2b2 / polarSize;
        this._k2 = this._k * this._k;
        this._radii = new Vec3(equatorialSize, equatorialSize, polarSize);
        this._radii2 = new Vec3(this._a2, this._a2, this._b2);
        this._invRadii = new Vec3(1.0 / equatorialSize, 1.0 / equatorialSize, 1.0 / polarSize);
        this._invRadii2 = new Vec3(1.0 / this._a2, 1.0 / this._a2, 1.0 / this._b2);
    }
    /**
     * Returns the distance travelling from ‚Äòthis‚Äô point to destination point along a rhumb line.
     * @param   {LonLat} startLonLat coordinates.
     * @param   {LonLat} endLonLat coordinates
     * @returns {number} Distance in m between this point and destination point (same units as radius).
     */
    rhumbDistanceTo(startLonLat, endLonLat) {
        const f1 = startLonLat.lat * RADIANS;
        const f2 = endLonLat.lat * RADIANS;
        const df = f2 - f1;
        let d = Math.abs(endLonLat.lon - startLonLat.lon) * RADIANS;
        if (Math.abs(d) > Math.PI)
            d = d > 0 ? -(2 * Math.PI - d) : (2 * Math.PI + d);
        const dd = Math.log(Math.tan(f2 / 2 + Math.PI / 4) / Math.tan(f1 / 2 + Math.PI / 4));
        const q = Math.abs(dd) > 10e-12 ? df / dd : Math.cos(f1);
        const t = Math.sqrt(df * df + q * q * d * d); // angular distance in radians
        return t * this._a;
    }
    /**
     * Returns the point at given fraction between two points on the great circle.
     * @param   {LonLat} lonLat1 - Longitude/Latitude of source point.
     * @param   {LonLat} lonLat2 - Longitude/Latitude of destination point.
     * @param   {number} fraction - Fraction between the two points (0 = source point, 1 = destination point).
     * @returns {LonLat} Intermediate point between points.
     */
    getIntermediatePointOnGreatCircle(lonLat1, lonLat2, fraction) {
        if (fraction == 0)
            return lonLat1.clone();
        if (fraction == 1)
            return lonLat2.clone();
        const inverse = this.inverse(lonLat1, lonLat2);
        const dist = inverse.distance;
        const azimuth = inverse.initialAzimuth;
        return isNaN(azimuth) ? lonLat1 : this.getGreatCircleDestination(lonLat1, azimuth, dist * fraction);
    }
    /**
     * REMOVE ASAP after
     * @param lonLat1
     * @param lonLat2
     * @returns {number}
     */
    static getBearing(lonLat1, lonLat2) {
        let f1 = lonLat1.lat * RADIANS, l1 = lonLat1.lon * RADIANS;
        let f2 = lonLat2.lat * RADIANS, l2 = lonLat2.lon * RADIANS;
        let y = Math.sin(l2 - l1) * Math.cos(f2);
        let x = Math.cos(f1) * Math.sin(f2) - Math.sin(f1) * Math.cos(f2) * Math.cos(l2 - l1);
        return Math.atan2(y, x) * DEGREES;
    }
    getFlattening() {
        return this._flattening;
    }
    /**
     * Gets ellipsoid equatorial size.
     * @public
     * @returns {number} -
     */
    getEquatorialSize() {
        return this._a;
    }
    get equatorialSize() {
        return this._a;
    }
    get equatorialSizeSqr() {
        return this._a2;
    }
    /**
     * Gets ellipsoid polar size.
     * @public
     * @returns {number} -
     */
    getPolarSize() {
        return this._b;
    }
    get polarSize() {
        return this._b;
    }
    get polarSizeSqr() {
        return this._b2;
    }
    /**
     * Calculate cartesian coordinates by its ECEF geodetic coordinates.
     * @public
     * @param {LonLat} lonlat - Geodetic coordinates.
     * @returns {Vec3} -
     */
    lonLatToCartesian(lonlat) {
        return this.geodeticToCartesian(lonlat.lon, lonlat.lat, lonlat.height);
    }
    /**
     * Calculate cartesian coordinates by its ECEF geodetic coordinates.
     * @public
     * @param {LonLat} lonlat - Geodetic coordinates.
     * @param {Vec3} res - Output variable reference.
     * @returns {Vec3} -
     */
    lonLatToCartesianRes(lonlat, res) {
        return this.geodeticToCartesian(lonlat.lon, lonlat.lat, lonlat.height, res);
    }
    /**
     * Gets cartesian ECEF 3d coordinates from geodetic coordinates.
     * @public
     * @param {Number} lon - Longitude.
     * @param {Number} lat - Latitude.
     * @param {Number} height - Height.
     * @param {Vec3} res - Output result variable.
     * @returns {Vec3} -
     */
    geodeticToCartesian(lon, lat, height = 0, res = new Vec3()) {
        let latrad = RADIANS * lat, lonrad = RADIANS * lon;
        let slt = Math.sin(latrad);
        let N = this._a / Math.sqrt(1 - this._e2 * slt * slt);
        let nc = (N + height) * Math.cos(latrad);
        res.x = nc * Math.cos(lonrad);
        res.y = nc * Math.sin(lonrad);
        res.z = (N * (1 - this._e2) + height) * slt;
        return res;
    }
    /**
     * Gets Wgs84 geodetic coordinates from cartesian ECEF.
     * @public
     * @param {Vec3} p - Cartesian coordinates.
     * @returns {LonLat} -
     */
    projToSurface(p) {
        let pX = p.x || 0.0, pY = p.y || 0.0, pZ = p.z || 0.0;
        let length = Math.sqrt(pX * pX + pY * pY + pZ * pZ);
        if (length === 0) {
            return this.lonLatToCartesian(new LonLat());
        }
        let invRadii2X = this._invRadii2.x, invRadii2Y = this._invRadii2.y, invRadii2Z = this._invRadii2.z;
        let x2 = pX * pX * invRadii2X, y2 = pY * pY * invRadii2Y, z2 = pZ * pZ * invRadii2Z;
        let norm = x2 + y2 + z2;
        let ratio = Math.sqrt(1.0 / norm);
        let first = p.scaleTo(ratio);
        if (norm < EPS1) {
            return !Number.isFinite(ratio) ? new Vec3() : first;
        }
        let lambda = ((1.0 - ratio) * length) / first.mulA(this._invRadii2).length();
        let m_X = 0.0, m_Y = 0.0, m_Z = 0.0;
        do {
            m_X = 1.0 / (1.0 + lambda * invRadii2X);
            m_Y = 1.0 / (1.0 + lambda * invRadii2Y);
            m_Z = 1.0 / (1.0 + lambda * invRadii2Z);
            let m_X2 = m_X * m_X, m_Y2 = m_Y * m_Y, m_Z2 = m_Z * m_Z;
            let func = x2 * m_X2 + y2 * m_Y2 + z2 * m_Z2 - 1.0;
            if (Math.abs(func) < EPS12) {
                break;
            }
            let m_X3 = m_X2 * m_X, m_Y3 = m_Y2 * m_Y, m_Z3 = m_Z2 * m_Z;
            lambda += 0.5 * func / (x2 * m_X3 * invRadii2X + y2 * m_Y3 * invRadii2Y + z2 * m_Z3 * invRadii2Z);
        } while (true); // eslint-disable-line
        return new Vec3(pX * m_X, pY * m_Y, pZ * m_Z);
    }
    /**
     * Converts 3d cartesian coordinates to geodetic
     * @param {Vec3} cart - Cartesian coordinates
     * @returns {LonLat} - Geodetic coordinates
     */
    cartesianToLonLat(cart) {
        return this.cartesianToLonLatRes(cart);
    }
    /**
     * Converts 3d cartesian coordinates to geodetic
     * @param {Vec3} cart - Cartesian coordinates
     * @param {LonLat} res - Link geodetic coordinates variable
     * @returns {LonLat} - Geodetic coordinates
     */
    cartesianToLonLatRes(cart, res = new LonLat()) {
        let p = this.projToSurface(cart);
        let n = this.getSurfaceNormal3v(p), h = cart.sub(p);
        res.lon = Math.atan2(n.y, n.x) * DEGREES;
        res.lat = Math.asin(n.z) * DEGREES;
        res.height = Math.sign(h.dot(cart)) * h.length();
        return res;
    }
    /**
     * Gets ellipsoid surface normal.
     * @public
     * @param {Vec3} coord - Spatial coordinates.
     * @return {Vec3} -
     */
    getSurfaceNormal3v(coord) {
        let r2 = this._invRadii2;
        let nx = coord.x * r2.x, ny = coord.y * r2.y, nz = coord.z * r2.z;
        let l = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);
        return new Vec3(nx * l, ny * l, nz * l);
    }
    getGreatCircleDistance(lonLat1, lonLat2) {
        return this.inverse(lonLat1, lonLat2).distance;
    }
    /**
     * Calculates the destination point given start point lat / lon, azimuth(deg) and distance (m).
     * Source: http://movable-type.co.uk/scripts/latlong-vincenty-direct.html and optimized / cleaned up by Mathias Bynens <http://mathiasbynens.be/>
     * Based on the Vincenty direct formula by T. Vincenty, ‚ÄúDirect and Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations‚Äù, Survey Review, vol XXII no 176, 1975 <http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf>
     * @param {LonLat} lonLat - Origin coordinates
     * @param {number} azimuth - View azimuth in degrees
     * @param {number} dist - Distance to the destination point coordinates in meters
     * @returns {LonLat} - Destination point coordinates
     */
    getGreatCircleDestination(lonLat, azimuth, dist) {
        return this.direct(lonLat, azimuth, dist).destination;
    }
    /**
     * Returns inverse Geodesic solution for two points
     * @param {LonLat} lonLat1 - start coordinates point
     * @param {LonLat} lonLat2 - end coordinates point
     * @returns {IInverseResult} - Contains distance, initialAzimuth, and finalAzimuth values
     */
    inverse(lonLat1, lonLat2) {
        let a = this._a, b = this._b, f = this._flattening;
        const fi1 = lonLat1.lat * RADIANS, lambda1 = lonLat1.lon * RADIANS;
        const fi2 = lonLat2.lat * RADIANS, lambda2 = lonLat2.lon * RADIANS;
        const L = lambda2 - lambda1; // L = difference in longitude, U = reduced latitude, defined by tan U = (1-f)¬∑tanœÜ.
        const tanU1 = (1 - f) * Math.tan(fi1), cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)), sinU1 = tanU1 * cosU1;
        const tanU2 = (1 - f) * Math.tan(fi2), cosU2 = 1 / Math.sqrt((1 + tanU2 * tanU2)), sinU2 = tanU2 * cosU2;
        const antipodal = Math.abs(L) > Math.PI / 2 || Math.abs(fi2 - fi1) > Math.PI / 2;
        let lmb = L, sinLmb = null, cosLmb = null; // lmb - difference in longitude on an auxiliary sphere
        let s = antipodal ? Math.PI : 0, sin_s = 0, cos_s = antipodal ? -1 : 1, sinSqs = null; // s - angular distance lonLat1 lonLat2 on the sphere
        let cos2sm = 1; // sm - angular distance on the sphere from the equator to the midpoint of the line
        let cosSqa = 1; // a - azimuth of the geodesic at the equator
        let lmb_ = null, iterations = 0;
        do {
            sinLmb = Math.sin(lmb);
            cosLmb = Math.cos(lmb);
            sinSqs = (cosU2 * sinLmb) ** 2 + (cosU1 * sinU2 - sinU1 * cosU2 * cosLmb) ** 2;
            if (Math.abs(sinSqs) < 1e-24)
                break; // co-incident/antipodal points (œÉ < ‚âà0.006mm)
            sin_s = Math.sqrt(sinSqs);
            cos_s = sinU1 * sinU2 + cosU1 * cosU2 * cosLmb;
            s = Math.atan2(sin_s, cos_s);
            const sin_a = cosU1 * cosU2 * sinLmb / sin_s;
            cosSqa = 1 - sin_a * sin_a;
            cos2sm = (cosSqa != 0) ? (cos_s - 2 * sinU1 * sinU2 / cosSqa) : 0; // on equatorial line cos¬≤Œ± = 0 (¬ß6)
            const C = f / 16 * cosSqa * (4 + f * (4 - 3 * cosSqa));
            lmb_ = lmb;
            lmb = L + (1 - C) * f * sin_a * (s + C * sin_s * (cos2sm + C * cos_s * (-1 + 2 * cos2sm * cos2sm)));
        } while (Math.abs(lmb - lmb_) > EPS12 && ++iterations < 1000);
        const uSq = cosSqa * (a * a - b * b) / (b * b);
        const A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
        const B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
        const ds = B * sin_s * (cos2sm + B / 4 * (cos_s * (-1 + 2 * cos2sm * cos2sm) - B / 6 * cos2sm * (-3 + 4 * sin_s * sin_s) * (-3 + 4 * cos2sm * cos2sm)));
        const dist = b * A * (s - ds); // s = length of the geodesic
        // note special handling of exactly antipodal points where sin¬≤œÉ = 0 (due to discontinuity
        // atan2(0, 0) = 0 but atan2(Œµ, 0) = œÄ/2 / 90¬∞) - in which case bearing is always meridional,
        // due north (or due south!)
        // Œ± = azimuths of the geodesic; Œ±2 the direction P‚ÇÅ P‚ÇÇ produced
        const a1 = Math.abs(sinSqs) < Number.EPSILON ? 0 : Math.atan2(cosU2 * sinLmb, cosU1 * sinU2 - sinU1 * cosU2 * cosLmb);
        const a2 = Math.abs(sinSqs) < Number.EPSILON ? Math.PI : Math.atan2(cosU1 * sinLmb, -sinU1 * cosU2 + cosU1 * sinU2 * cosLmb);
        return {
            distance: dist,
            initialAzimuth: Math.abs(dist) < Number.EPSILON ? NaN : zeroTwoPI(a1) * DEGREES,
            finalAzimuth: Math.abs(dist) < Number.EPSILON ? NaN : zeroTwoPI(a2) * DEGREES
        };
    }
    /**
     * Calculates the destination point given start point lat / lon, azimuth(deg) and distance (m).
     * Source: http://movable-type.co.uk/scripts/latlong-vincenty-direct.html and optimized / cleaned up by Mathias Bynens <http://mathiasbynens.be/>
     * Based on the Vincenty direct formula by T. Vincenty, ‚ÄúDirect and Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations‚Äù, Survey Review, vol XXII no 176, 1975 <http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf>
     * @param {LonLat} lonLat - Origin coordinates
     * @param {number} azimuth - View azimuth in degrees
     * @param {number} dist - Distance to the destination point coordinates in meters
     * @returns {{ destination: LonLat; finalAzimuth: number }} - Destination point coordinates
     */
    direct(lonLat, azimuth, dist) {
        let lon1 = lonLat.lon, lat1 = lonLat.lat;
        let a = this._a, b = this._b, f = this._flattening, s = dist, alpha1 = azimuth * RADIANS, sinAlpha1 = Math.sin(alpha1), cosAlpha1 = Math.cos(alpha1), tanU1 = (1 - f) * Math.tan(lat1 * RADIANS), cosU1 = 1 / Math.sqrt(1 + tanU1 * tanU1), sinU1 = tanU1 * cosU1, sigma1 = Math.atan2(tanU1, cosAlpha1), sinAlpha = cosU1 * sinAlpha1, cosSqAlpha = 1 - sinAlpha * sinAlpha, uSq = (cosSqAlpha * (a * a - b * b)) / (b * b), A = 1 + (uSq / 16384) * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq))), B = (uSq / 1024) * (256 + uSq * (-128 + uSq * (74 - 47 * uSq))), sigma = s / (b * A), sigmaP = 2 * Math.PI;
        let cos2SigmaM = 0, sinSigma = 0, cosSigma = 0, deltaSigma = 0;
        while (Math.abs(sigma - sigmaP) > 1e-12) {
            cos2SigmaM = Math.cos(2 * sigma1 + sigma);
            sinSigma = Math.sin(sigma);
            cosSigma = Math.cos(sigma);
            deltaSigma = B * sinSigma *
                (cos2SigmaM + (B / 4) *
                    (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) -
                        (B / 6) * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
            sigmaP = sigma;
            sigma = s / (b * A) + deltaSigma;
        }
        let tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1, lat2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1, (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp)), lambda = Math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1), C = (f / 16.0) * cosSqAlpha * (4.0 + f * (4.0 - 3.0 * cosSqAlpha)), L = lambda - (1.0 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM))), revAz = Math.atan2(sinAlpha, -tmp);
        return {
            destination: new LonLat(lon1 + L * DEGREES, lat2 * DEGREES),
            finalAzimuth: revAz * DEGREES
        };
    }
    /**
     * Returns cartesian coordinates of the intersection of a ray and an ellipsoid.
     * If the ray doesn't hit ellipsoid returns null.
     * @public
     * @param {Vec3} origin - Ray origin point.
     * @param {Vec3} direction - Ray direction.
     * @returns {Vec3} -
     */
    hitRay(origin, direction) {
        let q = this._invRadii.mul(origin);
        let w = this._invRadii.mul(direction);
        let q2 = q.dot(q);
        let qw = q.dot(w);
        let difference, w2, product, discriminant, temp;
        if (q2 > 1.0) {
            // Outside ellipsoid.
            if (qw >= 0.0) {
                // Looking outward or tangent (0 intersections).
                return undefined;
            }
            // qw < 0.0.
            var qw2 = qw * qw;
            difference = q2 - 1.0; // Positively valued.
            w2 = w.dot(w);
            product = w2 * difference;
            let eps = Math.abs(qw2 - product);
            if (eps > EPS15 && qw2 < product) {
                // Imaginary roots (0 intersections).
                return undefined;
            }
            else if (qw2 > product) {
                // Distinct roots (2 intersections).
                discriminant = qw * qw - product;
                temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.
                var root0 = temp / w2;
                var root1 = difference / temp;
                if (root0 < root1) {
                    return origin.add(direction.scaleTo(root0));
                }
                return origin.add(direction.scaleTo(root1));
            }
            else {
                // qw2 == product.  Repeated roots (2 intersections).
                var root = Math.sqrt(difference / w2);
                return origin.add(direction.scaleTo(root));
            }
        }
        else if (q2 < 1.0) {
            // Inside ellipsoid (2 intersections).
            difference = q2 - 1.0; // Negatively valued.
            w2 = w.dot(w);
            product = w2 * difference; // Negatively valued.
            discriminant = qw * qw - product;
            temp = -qw + Math.sqrt(discriminant); // Positively valued.
            return origin.add(direction.scaleTo(temp / w2));
        }
        else {
            // q2 == 1.0. On ellipsoid.
            if (qw < 0.0) {
                // Looking inward.
                w2 = w.dot(w);
                return origin.add(direction.scaleTo(-qw / w2));
            }
            // qw >= 0.0.  Looking outward or tangent.
            // return undefined
        }
    }
    getNorthFrameRotation(cartesian) {
        let n = this.getSurfaceNormal3v(cartesian);
        let t = Vec3.proj_b_to_plane(Vec3.NORTH, n);
        return Quat.getLookRotation(t, n);
    }
    /**
     * @todo this is not precise function, needs to be replaced or removed
     * @param lonLat1
     * @param bearing
     * @param distance
     * @returns {LonLat}
     */
    getBearingDestination(lonLat1, bearing = 0.0, distance = 0) {
        bearing = bearing * RADIANS;
        var nlon = ((lonLat1.lon + 540) % 360) - 180;
        var f1 = lonLat1.lat * RADIANS, l1 = nlon * RADIANS;
        var dR = distance / this._a;
        var f2 = Math.asin(Math.sin(f1) * Math.cos(dR) + Math.cos(f1) * Math.sin(dR) * Math.cos(bearing));
        return new LonLat((l1 +
            Math.atan2(Math.sin(bearing) * Math.sin(dR) * Math.cos(f1), Math.cos(dR) - Math.sin(f1) * Math.sin(f2))) *
            DEGREES, f2 * DEGREES);
    }
    /**
     * Returns the point at given fraction between two points on the great circle.
     * @param   {LonLat} lonLat1 - Longitude/Latitude of source point.
     * @param   {LonLat} lonLat2 - Longitude/Latitude of destination point.
     * @param   {number} fraction - Fraction between the two points (0 = source point, 1 = destination point).
     * @returns {LonLat} Intermediate point between points.
     */
    static getIntermediatePointOnGreatCircle(lonLat1, lonLat2, fraction) {
        var f1 = lonLat1.lat * RADIANS, l1 = lonLat1.lon * RADIANS;
        var f2 = lonLat2.lat * RADIANS, l2 = lonLat2.lon * RADIANS;
        var sinf1 = Math.sin(f1), cosf1 = Math.cos(f1), sinl1 = Math.sin(l1), cosl1 = Math.cos(l1);
        var sinf2 = Math.sin(f2), cosf2 = Math.cos(f2), sinl2 = Math.sin(l2), cosl2 = Math.cos(l2);
        var df = f2 - f1, dl = l2 - l1;
        var a = Math.sin(df / 2) * Math.sin(df / 2) +
            Math.cos(f1) * Math.cos(f2) * Math.sin(dl / 2) * Math.sin(dl / 2);
        var d = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var A = Math.sin((1 - fraction) * d) / Math.sin(d);
        var B = Math.sin(fraction * d) / Math.sin(d);
        var x = A * cosf1 * cosl1 + B * cosf2 * cosl2;
        var y = A * cosf1 * sinl1 + B * cosf2 * sinl2;
        var z = A * sinf1 + B * sinf2;
        var f3 = Math.atan2(z, Math.sqrt(x * x + y * y));
        var l3 = Math.atan2(y, x);
        return new LonLat(((l3 * DEGREES + 540) % 360) - 180, f3 * DEGREES);
    }
    static getRhumbBearing(lonLat1, lonLat2) {
        var dLon = (lonLat2.lon - lonLat1.lon) * RADIANS;
        var dPhi = Math.log(Math.tan((lonLat2.lat * RADIANS) / 2 + Math.PI / 4) /
            Math.tan((lonLat1.lat * RADIANS) / 2 + Math.PI / 4));
        if (Math.abs(dLon) > Math.PI) {
            if (dLon > 0) {
                dLon = (2 * Math.PI - dLon) * -1;
            }
            else {
                dLon = 2 * Math.PI + dLon;
            }
        }
        return (Math.atan2(dLon, dPhi) * DEGREES + 360) % 360;
    }
}

/**
 * WGS84 ellipsoid object.
 * @type {Ellipsoid}
 */
const wgs84 = new Ellipsoid(6378137.0, 6356752.3142451793); // Equitorial Radius (m), Polar Radius (m)

const CUR_LOD_SIZE = 250; //px
const MIN_LOD_SIZE = 312; //px
const MAX_LOD_SIZE = 190; //px
let _tempPickingPix_ = new Uint8Array(4);
let _tempDepthColor_ = new Uint8Array(4);
const DEPTH_DISTANCE = 11; //m
/**
 * Maximum created nodes count. The more nodes count the more memory usage.
 * @const
 * @type {number}
 * @default
 */
const MAX_NODES = 200;
const HORIZON_TANGENT = 0.81;
/**
 * Main class for rendering planet
 * @class
 * @extends {RenderNode}
 * @param {string} [options.name="Earth"] - Planet name(Earth by default)
 * @param {Ellipsoid} [options.ellipsoid] - Planet ellipsoid(WGS84 by default)
 * @param {Number} [options.maxGridSize=128] - Segment maximal grid size
 * @param {Number} [options.maxEqualZoomAltitude=15000000.0] - Maximal altitude since segments on the screen become the same zoom level
 * @param {Number} [options.minEqualZoomAltitude=10000.0] - Minimal altitude since segments on the screen become the same zoom level
 * @param {Number} [options.minEqualZoomCameraSlope=0.8] - Minimal camera slope above te globe where segments on the screen become the same zoom level
 *
 * @fires EventsHandler<PlanetEventList>#draw
 * @fires EventsHandler<PlanetEventList>#layeradd
 * @fires EventsHandler<PlanetEventList>#baselayerchange
 * @fires EventsHandler<PlanetEventList>#layerremove
 * @fires EventsHandler<PlanetEventList>#layervisibilitychange
 * @fires EventsHandler<PlanetEventList>#geoimageadd
 */
class Planet extends RenderNode {
    constructor(options = {}) {
        super(options.name);
        this._renderingFadingNodes = (nodes, sh, currentNode, sl, sliceIndex, outTransparentSegments) => {
            let isFirstPass = sliceIndex === 0;
            let isEq = this.terrain.equalizeVertices;
            for (let j = 0, len = currentNode._fadingNodes.length; j < len; j++) {
                let f = currentNode._fadingNodes[j].segment;
                if (this._fadingNodes.has(currentNode._fadingNodes[0].__id) && !nodes.has(f.node.__id)) {
                    nodes.set(f.node.__id, true);
                    if (f._transitionOpacity < 1.0) {
                        outTransparentSegments.push(f);
                    }
                    else {
                        if (isFirstPass) {
                            isEq && f.equalize();
                            f.readyToEngage && f.engage();
                            f.screenRendering(sh, sl, sliceIndex);
                        }
                        else {
                            f.screenRendering(sh, sl, sliceIndex, this.transparentTexture, true);
                        }
                    }
                }
            }
        };
        this._renderingFadingNodesNoDepth = (nodes, sh, currentNode, sl, sliceIndex) => {
            let isFirstPass = sliceIndex === 0;
            let isEq = this.terrain.equalizeVertices;
            let gl = sh.gl;
            gl.disable(gl.DEPTH_TEST);
            for (let j = 0, len = currentNode._fadingNodes.length; j < len; j++) {
                let f = currentNode._fadingNodes[j].segment;
                if (this._fadingNodes.has(currentNode._fadingNodes[0].__id) && !nodes.has(f.node.__id)) {
                    nodes.set(f.node.__id, true);
                    if (isFirstPass) {
                        isEq && f.equalize();
                        f.readyToEngage && f.engage();
                        f.screenRendering(sh, sl, sliceIndex);
                    }
                    else {
                        f.screenRendering(sh, sl, sliceIndex, this.transparentTexture, true);
                    }
                }
            }
            gl.enable(gl.DEPTH_TEST);
        };
        this._atmosphere = new Atmosphere(options.atmosphereParameters);
        this._prevNodes = new Map();
        this._currNodes = new Map();
        this.transitionTime = 580;
        this.ellipsoid = options.ellipsoid || wgs84;
        this.lightEnabled = true;
        this._planetRadius2 = (this.ellipsoid.getPolarSize() - 10000.0) * (this.ellipsoid.getPolarSize() - 10000.0);
        this._layers = [];
        this._updateLayer = false;
        this.visibleTileLayers = [];
        this.visibleVectorLayers = [];
        this._visibleTileLayerSlices = [];
        this._frustumEntityCollections = [];
        this.baseLayer = null;
        this.terrain = null;
        this.camera = new PlanetCamera(this, {
            frustums: options.frustums,
            eye: new Vec3(25000000, 0, 0),
            look: Vec3.ZERO,
            up: Vec3.NORTH,
            minAltitude: options.minAltitude,
            maxAltitude: options.maxAltitude
        });
        this.maxEqualZoomAltitude = options.maxEqualZoomAltitude || 15000000.0;
        this.minEqualZoomAltitude = options.minEqualZoomAltitude || 10000.0;
        this.minEqualZoomCameraSlope = options.minEqualZoomCameraSlope || 0.8;
        this.mousePositionOnEarth = new Vec3();
        this.emptyTexture = null;
        this.transparentTexture = null;
        this.defaultTexture = null;
        this.minCurrZoom = MAX;
        this.maxCurrZoom = MIN;
        this._viewExtent = new Extent(new LonLat(180, 180), new LonLat(-180, -180));
        this._skipPreRender = false;
        this._initialViewExtent = null;
        this._createdNodesCount = 0;
        this._renderedNodes = [];
        this._renderedNodesInFrustum = [];
        this._fadingNodes = new Map;
        this._fadingNodesInFrustum = [];
        this.layerLock = new Lock();
        this.terrainLock = new Lock();
        this._heightFactor = 1.0;
        this._indexesCache = [];
        this._indexesCacheToRemove = [];
        this._indexesCacheToRemoveCounter = 0;
        this._textureCoordsBufferCache = [];
        this.quadTreeStrategy = options.quadTreeStrategyPrototype ? new options.quadTreeStrategyPrototype(this) : new EarthQuadTreeStrategy(this);
        this._nightTexture = null;
        this._specularTexture = null;
        let a = createColorRGB(options.ambient, new Vec3(0.2, 0.2, 0.3));
        let d = createColorRGB(options.diffuse, new Vec3(1.0, 1.0, 1.0));
        let s = createColorRGB(options.specular, new Vec3(0.00063, 0.00055, 0.00032));
        let shininess = options.shininess || 18.0;
        this._ambient = new Float32Array([a.x, a.y, a.z]);
        this._diffuse = new Float32Array([d.x, d.y, d.z]);
        this._specular = new Float32Array([s.x, s.y, s.z, shininess]);
        this._maxGridSize = Math.log2(options.maxGridSize || 256);
        this.SLICE_SIZE = 4;
        this.SLICE_SIZE_4 = this.SLICE_SIZE * 4;
        this.SLICE_SIZE_3 = this.SLICE_SIZE * 3;
        this._lodSize = CUR_LOD_SIZE;
        this._curLodSize = CUR_LOD_SIZE;
        this._minLodSize = MIN_LOD_SIZE;
        this._maxLodSize = MAX_LOD_SIZE;
        this._pickingColorArr = new Float32Array(this.SLICE_SIZE_4);
        this._samplerArr = new Int32Array(this.SLICE_SIZE);
        this._pickingMaskArr = new Int32Array(this.SLICE_SIZE);
        this._geoImageCreator = new GeoImageCreator(this);
        this._vectorTileCreator = new VectorTileCreator(this);
        this._normalMapCreator = new NormalMapCreator(this);
        this._terrainWorker = new TerrainWorker(3);
        this._plainSegmentWorker = new PlainSegmentWorker(3);
        this._tileLoader = new Loader(options.maxLoadingRequests || 12);
        this._memKey = new Key();
        this.events = createEvents(PLANET_EVENTS);
        this._distBeforeMemClear = 0.0;
        this._prevCamEye = new Vec3();
        this._initialized = false;
        this.always = [];
        this._renderCompleted = false;
        this._renderCompletedActivated = false;
        this._terrainCompleted = false;
        this._terrainCompletedActivated = false;
        this._collectRenderNodesIsActive = true;
        this.nightTextureCoefficient = 2.0;
        this._renderScreenNodesPASS = this._renderScreenNodesPASSNoAtmos;
        this._renderScreenNodesWithHeightPASS = this._renderScreenNodesWithHeightPASSNoAtmos;
        this._atmosphereEnabled = options.atmosphereEnabled || false;
        this._atmosphereMaxMinOpacity = new Float32Array([1.0, 0.41]);
        this.solidTextureOne = null;
        this.solidTextureTwo = null;
        this._nightTextureSrc = options.nightTextureSrc || null;
        this._specularTextureSrc = options.specularTextureSrc || null;
        this._transitionOpacityEnabled = options.transitionOpacityEnabled != undefined ? options.transitionOpacityEnabled : true;
    }
    /**
     * Returns true if current terrain data set is loaded
     */
    get terrainReady() {
        return this._terrainCompleted && this._terrainCompletedActivated;
    }
    get maxGridSize() {
        return this._maxGridSize;
    }
    getNorthFrameRotation(cartesian) {
        return this.ellipsoid.getNorthFrameRotation(cartesian);
    }
    set atmosphereMaxOpacity(opacity) {
        this._atmosphereMaxMinOpacity[0] = opacity;
    }
    get atmosphereMaxOpacity() {
        return this._atmosphereMaxMinOpacity[0];
    }
    set atmosphereMinOpacity(opacity) {
        this._atmosphereMaxMinOpacity[1] = opacity;
    }
    get atmosphereMinOpacity() {
        return this._atmosphereMaxMinOpacity[1];
    }
    set atmosphereEnabled(enabled) {
        if (enabled != this._atmosphereEnabled) {
            this._atmosphereEnabled = enabled;
            this._initializeAtmosphere();
        }
    }
    get atmosphereEnabled() {
        return this._atmosphereEnabled;
    }
    set diffuse(rgb) {
        let vec = createColorRGB(rgb);
        this._diffuse = new Float32Array(vec.toArray());
    }
    set ambient(rgb) {
        let vec = createColorRGB(rgb);
        this._ambient = new Float32Array(vec.toArray());
    }
    set specular(rgb) {
        let vec = createColorRGB(rgb);
        this._specular = new Float32Array([vec.x, vec.y, vec.y, this._specular[3]]);
    }
    set shininess(v) {
        this._specular[3] = v;
    }
    get normalMapCreator() {
        return this._normalMapCreator;
    }
    get layers() {
        return [...this._layers];
    }
    /**
     * @todo: remove after tests
     * Get the collection of layers associated with this planet.
     * @return {Array.<Layer>} Layers array.
     * @public
     */
    getLayers() {
        return this.layers;
    }
    get sunPos() {
        return this.renderer.controls.sun.sunlight.getPosition();
    }
    /**
     * Add the given control to the renderer of the planet scene.
     * @param {Control} control - Control.
     */
    addControl(control) {
        control.planet = this;
        control.addTo(this.renderer);
    }
    get lodSize() {
        return this._lodSize;
    }
    setLodSize(currentLodSize, minLodSize, maxLodSize) {
        this._maxLodSize = maxLodSize || this._maxLodSize;
        this._minLodSize = minLodSize || this._minLodSize;
        this._curLodSize = currentLodSize;
        this._renderCompletedActivated = false;
        this._terrainCompletedActivated = false;
    }
    /**
     * Add the given controls array to the renderer of the planet.
     * @param {Array.<Control>} cArr - Control array.
     */
    addControls(cArr) {
        for (let i = 0; i < cArr.length; i++) {
            this.addControl(cArr[i]);
        }
    }
    /**
     * Return layer by it name
     * @param {string} name - Name of the layer. og.Layer.prototype.name
     * @public
     * @returns {Layer} -
     */
    getLayerByName(name) {
        for (let i = 0, len = this._layers.length; i < len; i++) {
            if (name === this._layers[i].name) {
                return this._layers[i];
            }
        }
    }
    /**
     * Adds layer to the planet.
     * @param {Layer} layer - Layer object.
     * @public
     */
    addLayer(layer) {
        layer.addTo(this);
    }
    /**
     * Dispatch layer visibility changing event.
     * @param {Layer} layer - Changed layer.
     * @public
     */
    _onLayerVisibilityChanged(layer) {
        this.events.dispatch(this.events.layervisibilitychange, layer);
    }
    /**
     * Adds the given layers array to the planet.
     * @param {Array.<Layer>} layers - Layers array.
     * @public
     */
    addLayers(layers) {
        for (let i = 0, len = layers.length; i < len; i++) {
            this.addLayer(layers[i]);
        }
    }
    /**
     * Removes the given layer from the planet.
     * @param {Layer} layer - Layer to remove.
     * @public
     */
    removeLayer(layer) {
        layer.remove();
    }
    /**
     *
     * @public
     * @param {Layer} layer - Material layer.
     */
    _clearLayerMaterial(layer) {
        this.quadTreeStrategy.clearLayerMaterial(layer);
    }
    /**
     * Sets base layer coverage to the planet.
     * @param {Layer} layer - Layer object.
     * @public
     */
    setBaseLayer(layer) {
        if (this.baseLayer) {
            if (!this.baseLayer.isEqual(layer)) {
                this.baseLayer.setVisibility(false);
                this.baseLayer = layer;
                layer.setVisibility(true);
                this.events.dispatch(this.events.baselayerchange, layer);
            }
        }
        else {
            this.baseLayer = layer;
            this.baseLayer.setVisibility(true);
            this.events.dispatch(this.events.baselayerchange, layer);
        }
    }
    /**
     * Sets elevation scale. 1.0 is default.
     * @param {number} factor - Elevation scale.
     */
    setHeightFactor(factor) {
        this._renderCompletedActivated = false;
        this._terrainCompletedActivated = false;
        if (this._heightFactor !== factor) {
            this._heightFactor = factor;
            this.quadTreeStrategy.destroyBranches();
            this._clearRenderedNodeList();
            this._clearRenderNodesInFrustum();
        }
    }
    /**
     * Gets elevation scale.
     * @returns {number} Terrain elevation scale
     */
    getHeightFactor() {
        return this._heightFactor;
    }
    /**
     * Sets terrain provider
     * @public
     * @param {EmptyTerrain} terrain - Terrain provider.
     */
    setTerrain(terrain) {
        this._renderCompletedActivated = false;
        this._terrainCompletedActivated = false;
        if (this._initialized) {
            this.memClear();
        }
        if (this.terrain) {
            this.terrain.abortLoading();
            this.terrain.clearCache();
            this.terrain._planet = null;
        }
        this.terrain = terrain;
        this.terrain._planet = this;
        this.quadTreeStrategy.destroyBranches();
        if (terrain._geoid.model) {
            this._plainSegmentWorker.setGeoid(terrain.getGeoid());
            terrain._isReady = true;
        }
        else {
            Geoid.loadModel(terrain.geoid.src)
                .then((m) => {
                terrain.geoid.setModel(m);
                this._plainSegmentWorker.setGeoid(terrain.getGeoid());
                terrain._isReady = true;
            })
                .catch((err) => {
                console.warn(err);
            });
        }
    }
    initAtmosphereShader(atmosParams) {
        if (this.renderer && this.renderer.handler && this._atmosphereEnabled) {
            let h = this.renderer.handler;
            if (h.isWebGl2()) {
                h.removeProgram("drawnode_screen_wl");
                h.addProgram(drawnode_screen_wl_webgl2Atmos(atmosParams), true);
            }
            else {
                console.warn("Atmosphere WebGL2 only");
            }
        }
    }
    get atmosphereControl() {
        return this._atmosphere;
    }
    _initializeAtmosphere() {
        if (!this.renderer)
            return;
        let h = this.renderer.handler;
        h.removeProgram("drawnode_screen_wl");
        if (this._atmosphereEnabled) {
            this._renderScreenNodesPASS = this._renderScreenNodesPASSAtmos;
            this._renderScreenNodesWithHeightPASS = this._renderScreenNodesWithHeightPASSAtmos;
            if (!this.renderer.controls.Atmosphere) {
                this.addControl(this._atmosphere);
            }
            this._atmosphere.activate();
            if (h.isWebGl2()) {
                h.addProgram(drawnode_screen_wl_webgl2Atmos(this._atmosphere.parameters), true);
            }
            else {
                h.addProgram(drawnode_screen_wl_webgl1NoAtmos(), true);
            }
            if (this.renderer.controls.SimpleSkyBackground) {
                this.renderer.controls.SimpleSkyBackground.deactivate();
            }
        }
        else {
            this._renderScreenNodesPASS = this._renderScreenNodesPASSNoAtmos;
            this._renderScreenNodesWithHeightPASS = this._renderScreenNodesWithHeightPASSNoAtmos;
            this._atmosphere.deactivate();
            if (!this.renderer.controls.SimpleSkyBackground) {
                this.addControl(new SimpleSkyBackground());
            }
            else {
                this.renderer.controls.SimpleSkyBackground.activate();
            }
            if (h.isWebGl2()) {
                h.addProgram(drawnode_screen_wl_webgl2NoAtmos(), true);
            }
            else {
                h.addProgram(drawnode_screen_wl_webgl1NoAtmos(), true);
            }
        }
    }
    _initializeShaders() {
        let h = this.renderer.handler;
        h.addProgram(drawnode_screen_nl(), true);
        h.addProgram(drawnode_colorPicking(), true);
        h.addProgram(drawnode_depth(), true);
        h.addProgram(drawnode_heightPicking(), true);
        this.renderer.addPickingCallback(this, this._renderColorPickingFramebufferPASS);
        this.renderer.addDepthCallback(this, this._renderDepthFramebufferPASS);
        this.renderer.addDistanceCallback(this, this._renderDistanceFramebufferPASS);
    }
    _onLayerLoadend(layer) {
        this.events.dispatch(this.events.layerloadend, layer);
    }
    init() {
        this._tileLoader.events.on("layerloadend", this._onLayerLoadend, this);
        // Initialization indexes table
        getInstance().setMaxGridSize(this._maxGridSize);
        const TABLESIZE = this._maxGridSize;
        let kk = 0;
        // Initialization indexes buffers cache. It takes about 120mb RAM!
        for (let i = 0; i <= TABLESIZE; i++) {
            !this._indexesCache[i] && (this._indexesCache[i] = new Array(TABLESIZE));
            for (let j = 0; j <= TABLESIZE; j++) {
                !this._indexesCache[i][j] && (this._indexesCache[i][j] = new Array(TABLESIZE));
                for (let k = 0; k <= TABLESIZE; k++) {
                    !this._indexesCache[i][j][k] && (this._indexesCache[i][j][k] = new Array(TABLESIZE));
                    for (let m = 0; m <= TABLESIZE; m++) {
                        !this._indexesCache[i][j][k][m] && (this._indexesCache[i][j][k][m] = new Array(TABLESIZE));
                        for (let q = 0; q <= TABLESIZE; q++) {
                            let ptr = {
                                buffer: null
                            };
                            if (i >= 1 && i === j && i === k && i === m && i === q) {
                                let indexes = getInstance().createSegmentIndexes(i, [j, k, m, q]);
                                ptr.buffer = this.renderer.handler.createElementArrayBuffer(indexes, 1);
                            }
                            else {
                                this._indexesCacheToRemove[kk++] = ptr;
                            }
                            this._indexesCache[i][j][k][m][q] = ptr;
                        }
                    }
                }
            }
        }
        this.renderer.events.on("resize", () => {
            this._renderCompletedActivated = false;
            this._terrainCompletedActivated = false;
        });
        this.renderer.events.on("drawtransparent", () => {
            this._renderScreenNodesWithHeightPASS();
        });
        // Initialize texture coordinates buffer pool
        this._textureCoordsBufferCache = [];
        let texCoordCache = getInstance().initTextureCoordsTable(TABLESIZE + 1);
        for (let i = 0; i <= TABLESIZE; i++) {
            this._textureCoordsBufferCache[i] = this.renderer.handler.createArrayBuffer(texCoordCache[i], 2, ((1 << i) + 1) * ((1 << i) + 1));
        }
        // creating empty textures
        this.renderer.handler.createDefaultTexture(null, (t) => {
            this.solidTextureOne = t;
            this.solidTextureTwo = t;
        });
        this.transparentTexture = this.renderer.handler.transparentTexture;
        this._renderedNodesInFrustum = new Array(this.camera.frustums.length);
        for (let i = 0, len = this._renderedNodesInFrustum.length; i < len; i++) {
            this._renderedNodesInFrustum[i] = [];
        }
        // Creating quad trees nodes
        this.quadTreeStrategy.init();
        this.drawMode = this.renderer.handler.gl.TRIANGLE_STRIP;
        // Applying shaders
        this._initializeShaders();
        this._initializeAtmosphere();
        this._updateVisibleLayers();
        this.renderer.addPickingCallback(this, this._frustumEntityCollectionPickingCallback);
        // loading Earth night glowing texture
        if (this._nightTextureSrc) {
            let img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => {
                this._nightTexture = this.renderer.handler.createTextureDefault(img);
                this._nightTexture.default = true;
            };
            img.src = this._nightTextureSrc;
            // createImageBitmap(NIGHT).then((e: ImageBitmap) => {
            //     this._nightTexture = this.renderer!.handler!.createTextureDefault(e);
            // });
        }
        // load water specular mask
        if (this._specularTextureSrc) {
            let img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => {
                this._specularTexture = this.renderer.handler.createTextureDefault(img);
                this._specularTexture.default = true;
            };
            img.src = this._specularTextureSrc;
            // createImageBitmap(SPECULAR).then((e: ImageBitmap) => {
            //     this._specularTexture = this.renderer!.handler!.createTexture_l(e);
            // });
        }
        this._geoImageCreator.init();
        this._vectorTileCreator.init();
        this._normalMapCreator.init();
        this.renderer.events.on("draw", this._globalPreDraw, this, -100);
        // Loading first nodes for better viewing if you have started on a lower altitude.
        this._preRender();
        this.renderer.events.on("postdraw", () => {
            this._checkRendercompleted();
        });
        this.initLayers();
        this._initialized = true;
        //
        // after init
        //
        if (this._initialViewExtent) {
            this.viewExtent(this._initialViewExtent);
        }
        this.renderer.activeCamera = this.camera;
        this.camera.bindRenderer(this.renderer);
        this.camera.update();
    }
    initLayers() {
        let temp = [...this._layers];
        for (let i = 0; i < temp.length; i++) {
            this.removeLayer(temp[i]);
            this.addLayer(temp[i]);
        }
    }
    _clearIndexesCache() {
        this._indexesCacheToRemoveCounter = 0;
        let c = this._indexesCacheToRemove, gl = this.renderer.handler.gl;
        for (let i = 0, len = c.length; i < len; i++) {
            let ci = c[i];
            gl.deleteBuffer(ci.buffer);
            ci.buffer = null;
        }
    }
    _preRender() {
        this.quadTreeStrategy.preRender();
        this._preLoad();
    }
    _preLoad() {
        this._clearRenderedNodeList();
        this._skipPreRender = false;
        this.quadTreeStrategy.preLoad();
    }
    /**
     * Creates default textures first for the North Pole and whole globe and second for the South Pole.
     * @public
     * @param{IDefaultTextureParams} param0 -
     * @param{IDefaultTextureParams} param1 -
     */
    createDefaultTextures(param0, param1) {
        this.renderer.handler.gl.deleteTexture(this.solidTextureOne);
        this.renderer.handler.gl.deleteTexture(this.solidTextureTwo);
        this.renderer.handler.createDefaultTexture(param0, (texture) => {
            this.solidTextureOne = texture;
        });
        this.renderer.handler.createDefaultTexture(param1, (texture) => {
            this.solidTextureTwo = texture;
        });
    }
    _getLayerAttributionHTML(layer) {
        return `<div class="og-attribution__layer">${layer.getAttribution()}</div>`;
    }
    /**
     * Updates attribution lists
     * @public
     */
    updateAttributionsList() {
        let html = "";
        for (let i = 0, len = this._layers.length; i < len; i++) {
            let li = this._layers[i];
            if (li.getVisibility()) {
                if (li.getAttribution().length) {
                    html += this._getLayerAttributionHTML(li);
                }
            }
        }
        this._applyAttribution(html);
    }
    updateVisibleLayers() {
        this._updateLayer = true;
    }
    _updateVisibleLayers() {
        this.visibleTileLayers = [];
        this.visibleTileLayers.length = 0;
        this.visibleVectorLayers = [];
        this.visibleVectorLayers.length = 0;
        let html = "";
        for (let i = 0, len = this._layers.length; i < len; i++) {
            let li = this._layers[i];
            if (li.getVisibility()) {
                if (li.isBaseLayer()) {
                    this.createDefaultTextures(li._defaultTextures[0], li._defaultTextures[1]);
                    this.baseLayer = li;
                }
                if (li.hasImageryTiles()) {
                    this.visibleTileLayers.push(li);
                }
                if (li.isVector) {
                    this.visibleVectorLayers.push(li);
                }
                if (li.getAttribution().length) {
                    html += this._getLayerAttributionHTML(li);
                }
            }
            else if (li._fading && li._fadingOpacity > 0) {
                if (li.hasImageryTiles()) {
                    this.visibleTileLayers.push(li);
                }
                if (li.isVector) {
                    this.visibleVectorLayers.push(li);
                }
            }
        }
        this._applyAttribution(html);
        this._sortLayers();
    }
    /**
     * Apply to render list of layer attributions
     * @protected
     */
    _applyAttribution(html) {
        if (this.renderer && this.renderer.div) {
            if (html.length) {
                if (this.renderer.div.attributions.innerHTML !== html) {
                    this.renderer.div.attributions.innerHTML = html;
                }
            }
            else {
                this.renderer.div.attributions.innerHTML = "";
            }
        }
    }
    /**
     * Sort visible layer - preparing for rendering.
     * @protected
     */
    _sortLayers() {
        this.visibleVectorLayers.sort((a, b) => (a.getZIndex() - b.getZIndex()) || (a.getHeight() - b.getHeight()));
        this._visibleTileLayerSlices = [];
        this._visibleTileLayerSlices.length = 0;
        if (this.visibleTileLayers.length) {
            this.visibleTileLayers.sort((a, b) => (a.getHeight() - b.getHeight()) || (a.getZIndex() - b.getZIndex()));
            let k = -1;
            let currHeight = this.visibleTileLayers[0].getHeight();
            for (let i = 0, len = this.visibleTileLayers.length; i < len; i++) {
                if (i % this.SLICE_SIZE === 0 || this.visibleTileLayers[i].getHeight() !== currHeight) {
                    k++;
                    this._visibleTileLayerSlices[k] = [];
                    currHeight = this.visibleTileLayers[i].getHeight();
                }
                this._visibleTileLayerSlices[k].push(this.visibleTileLayers[i]);
            }
        }
    }
    _clearRenderedNodeList() {
        this._renderedNodes.length = 0;
        this._renderedNodes = [];
    }
    _clearRenderNodesInFrustum() {
        for (let i = 0, len = this._renderedNodesInFrustum.length; i < len; i++) {
            this._renderedNodesInFrustum[i].length = 0;
            this._renderedNodesInFrustum[i] = [];
        }
    }
    _collectRenderedNodesMaxZoom(cam) {
        if (cam.slope > this.minEqualZoomCameraSlope && cam._lonLat.height < this.maxEqualZoomAltitude && cam._lonLat.height > this.minEqualZoomAltitude) {
            this.minCurrZoom = this.maxCurrZoom;
            let temp = this._renderedNodes, rf = this._renderedNodesInFrustum, temp2 = [];
            this._clearRenderNodesInFrustum();
            this._renderedNodes = [];
            for (let i = 0, len = temp.length; i < len; i++) {
                let ri = temp[i];
                let ht = ri.segment.centerNormal.dot(cam._b);
                if (ri.segment.tileZoom === this.maxCurrZoom || ht < HORIZON_TANGENT) {
                    this._renderedNodes.push(ri);
                    let k = 0, inFrustum = ri.inFrustum;
                    while (inFrustum) {
                        if (inFrustum & 1) {
                            rf[k].push(ri);
                        }
                        k++;
                        inFrustum >>= 1;
                    }
                }
                else {
                    temp2.push(ri);
                }
            }
            for (let i = 0, len = temp2.length; i < len; i++) {
                temp2[i].renderTree(cam, this.maxCurrZoom, null, false, temp2[i]);
            }
        }
    }
    set transitionOpacityEnabled(isEnabled) {
        this._transitionOpacityEnabled = isEnabled;
        //@todo: set render nodes transition opacity to one
    }
    get transitionOpacityEnabled() {
        return this._transitionOpacityEnabled;
    }
    /**
     * Collects visible quad nodes.
     * @protected
     */
    _collectRenderNodes(cam) {
        this._lodSize = lerp(cam.slope < 0.0 ? 0.0 : cam.slope, this._curLodSize, this._minLodSize);
        cam._insideSegment = null;
        // clear first
        this._clearRenderedNodeList();
        this._clearRenderNodesInFrustum();
        this._viewExtent.southWest.set(180, 180);
        this._viewExtent.northEast.set(-180, -180);
        // todo: replace to camera
        this.minCurrZoom = MAX;
        this.maxCurrZoom = MIN;
        this.quadTreeStrategy.collectRenderNodes();
        this._collectRenderedNodesMaxZoom(cam);
        // main camera effect
        this._fadingNodes.clear();
        if (this._transitionOpacityEnabled) {
            let opaqueNodes = [];
            for (let i = 0; i < this._renderedNodes.length; i++) {
                let ri = this._renderedNodes[i];
                // it's not impossible to move the code into Node.addToRender, because
                // we can't know actual state before _collectRenderedNodesMaxZoom pass
                ri._collectFadingNodes();
                ri._refreshTransitionOpacity();
                if (ri.segment._transitionOpacity >= 1.0) {
                    ri.clearNeighbors();
                    ri.getRenderedNodesNeighbors(opaqueNodes);
                    opaqueNodes.push(ri);
                }
                else {
                    for (let j = 0; j < ri._fadingNodes.length; j++) {
                        let rij = ri._fadingNodes[j];
                        if (rij.segment && rij.segment._transitionOpacity >= 1.0) {
                            rij.clearNeighbors();
                            rij.getRenderedNodesNeighbors(opaqueNodes);
                            opaqueNodes.push(rij);
                        }
                    }
                }
            }
        }
    }
    _renderScreenNodesPASSNoAtmos() {
        let cam = this.renderer.activeCamera;
        let sh = this._setUniformsNoAtmos(cam);
        //
        // PASS 0: rendering base slice of layers, which is often zero height
        this._renderingScreenNodes(sh, cam, this._renderedNodesInFrustum[cam.currentFrustumIndex]);
    }
    _renderScreenNodesPASSAtmos() {
        let cam = this.renderer.activeCamera;
        let sh = this._setUniformsAtmos(cam);
        //
        // PASS 0: rendering base slice of layers, which is often zero height
        this._renderingScreenNodes(sh, cam, this._renderedNodesInFrustum[cam.currentFrustumIndex]);
    }
    _renderScreenNodesWithHeightPASSNoAtmos() {
        let cam = this.renderer.activeCamera;
        let sh = this._setUniformsNoAtmos(cam);
        //
        // PASS 1: rendering slices, and layers with heights, without transition opacity effect
        this._renderingScreenNodesWithHeight(sh, cam, this._renderedNodesInFrustum[cam.currentFrustumIndex]);
    }
    _renderScreenNodesWithHeightPASSAtmos() {
        let cam = this.renderer.activeCamera;
        let sh = this._setUniformsAtmos(cam);
        //
        // PASS 1: rendering slices, and layers with heights, without transition opacity effect
        this._renderingScreenNodesWithHeight(sh, cam, this._renderedNodesInFrustum[cam.currentFrustumIndex]);
    }
    _globalPreDraw() {
        let cam = this.camera;
        // Might be it's better to replace it in setTerrain,
        // but we have to be sure that setTerrain exists with renderer insttance
        this.renderer.__useDistanceFramebuffer__ = !this.terrain.isEmpty;
        this._distBeforeMemClear += this._prevCamEye.distance(cam.eye);
        this._prevCamEye.copy(cam.eye);
        cam.checkFly();
        // free memory
        if (this._createdNodesCount > MAX_NODES && this._distBeforeMemClear > 1000.0) {
            this.terrain.clearCache();
            this.memClear();
        }
        if (this._indexesCacheToRemoveCounter > 600) {
            this._clearIndexesCache();
        }
    }
    /**
     * Render node callback.
     * @public
     */
    preFrame() {
        if (this._updateLayer) {
            this._updateLayer = false;
            this._updateVisibleLayers();
        }
        if (this.camera.isFirstPass) {
            this.camera.update();
            if (this._skipPreRender && this._collectRenderNodesIsActive) {
                this._collectRenderNodes(this.camera);
            }
            this._skipPreRender = true;
            this.transformLights();
            // creates terrain normal maps
            this._normalMapCreator.frame();
            // Creating geoImages textures.
            this._geoImageCreator.frame();
            // Vector tiles rasterization
            this._vectorTileCreator.frame();
            this.camera.checkTerrainCollision();
            this.camera.update();
            // Here is the planet node dispatches a draw event before
            // rendering begins, and we have got render nodes.
            this.events.dispatch(this.events.draw, this);
            // Collect entity collections from vector layers
            this._collectVectorLayerCollections();
        }
        this.drawEntityCollections(this._frustumEntityCollections);
    }
    /**
     * Render node callback.
     * Frame function is called for each renderer activrCamera frustum.
     * @public
     * @override
     */
    frame() {
        this._renderScreenNodesPASS();
    }
    _checkRendercompleted() {
        if (this._renderCompleted) {
            if (!this._renderCompletedActivated) {
                this._renderCompletedActivated = true;
                this.events.dispatch(this.events.rendercompleted, true);
            }
        }
        else {
            this._renderCompletedActivated = false;
        }
        this._renderCompleted = true;
        if (this._terrainCompleted) {
            if (!this._terrainCompletedActivated) {
                this._terrainCompletedActivated = true;
                this.events.dispatch(this.events.terraincompleted, true);
            }
        }
        else {
            this._terrainCompletedActivated = false;
        }
        this._terrainCompleted = true;
    }
    lockQuadTree() {
        this._collectRenderNodesIsActive = false;
        this.camera.setTerrainCollisionActivity(false);
    }
    unlockQuadTree() {
        this._collectRenderNodesIsActive = true;
        this.camera.setTerrainCollisionActivity(true);
    }
    _setUniformsNoAtmos(cam) {
        let sh, shu;
        let renderer = this.renderer;
        let h = renderer.handler;
        let gl = h.gl;
        gl.enable(gl.CULL_FACE);
        renderer.enableBlendOneSrcAlpha();
        if (this.lightEnabled) {
            h.programs.drawnode_screen_wl.activate();
            sh = h.programs.drawnode_screen_wl._program;
            shu = sh.uniforms;
            gl.uniform3fv(shu.lightsPositions, this._lightsPositions);
            gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
            gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
            if (this.baseLayer) {
                gl.uniform3fv(shu.diffuse, this.baseLayer._diffuse || this._diffuse);
                gl.uniform3fv(shu.ambient, this.baseLayer._ambient || this._ambient);
                gl.uniform4fv(shu.specular, this.baseLayer._specular || this._specular);
                gl.uniform1f(shu.nightTextureCoefficient, this.baseLayer.nightTextureCoefficient || this.nightTextureCoefficient);
            }
            else {
                gl.uniform3fv(shu.diffuse, this._diffuse);
                gl.uniform3fv(shu.ambient, this._ambient);
                gl.uniform4fv(shu.specular, this._specular);
                gl.uniform1f(shu.nightTextureCoefficient, this.nightTextureCoefficient);
            }
            //
            // Night and specular
            //
            gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE);
            gl.bindTexture(gl.TEXTURE_2D, this._nightTexture || this.transparentTexture);
            gl.uniform1i(shu.nightTexture, this.SLICE_SIZE);
            gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE + 1);
            gl.bindTexture(gl.TEXTURE_2D, this._specularTexture || this.transparentTexture);
            gl.uniform1i(shu.specularTexture, this.SLICE_SIZE + 1);
            gl.uniform1f(shu.camHeight, cam.getHeight());
        }
        else {
            h.programs.drawnode_screen_nl.activate();
            sh = h.programs.drawnode_screen_nl._program;
            shu = sh.uniforms;
            gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
            gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
        }
        gl.uniform3fv(shu.eyePositionHigh, cam.eyeHigh);
        gl.uniform3fv(shu.eyePositionLow, cam.eyeLow);
        return sh;
    }
    _setUniformsAtmos(cam) {
        let sh, shu;
        let renderer = this.renderer;
        let h = renderer.handler;
        let gl = h.gl;
        gl.enable(gl.CULL_FACE);
        renderer.enableBlendOneSrcAlpha();
        if (this.lightEnabled) {
            h.programs.drawnode_screen_wl.activate();
            sh = h.programs.drawnode_screen_wl._program;
            shu = sh.uniforms;
            gl.uniform3fv(shu.lightsPositions, this._lightsPositions);
            gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
            gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
            if (this.baseLayer) {
                gl.uniform3fv(shu.diffuse, this.baseLayer._diffuse || this._diffuse);
                gl.uniform3fv(shu.ambient, this.baseLayer._ambient || this._ambient);
                gl.uniform4fv(shu.specular, this.baseLayer._specular || this._specular);
                gl.uniform1f(shu.nightTextureCoefficient, this.baseLayer.nightTextureCoefficient || this.nightTextureCoefficient);
            }
            else {
                gl.uniform3fv(shu.diffuse, this._diffuse);
                gl.uniform3fv(shu.ambient, this._ambient);
                gl.uniform4fv(shu.specular, this._specular);
                gl.uniform1f(shu.nightTextureCoefficient, this.nightTextureCoefficient);
            }
            gl.uniform2fv(shu.maxMinOpacity, this._atmosphereMaxMinOpacity);
            //
            // Night and specular
            //
            gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE);
            gl.bindTexture(gl.TEXTURE_2D, this._nightTexture || this.transparentTexture);
            gl.uniform1i(shu.nightTexture, this.SLICE_SIZE);
            gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE + 1);
            gl.bindTexture(gl.TEXTURE_2D, this._specularTexture || this.transparentTexture);
            gl.uniform1i(shu.specularTexture, this.SLICE_SIZE + 1);
            //
            // atmos precomputed textures
            //
            gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE + 4);
            gl.bindTexture(gl.TEXTURE_2D, renderer.controls.Atmosphere._transmittanceBuffer.textures[0]);
            gl.uniform1i(shu.transmittanceTexture, this.SLICE_SIZE + 4);
            gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE + 5);
            gl.bindTexture(gl.TEXTURE_2D, renderer.controls.Atmosphere._scatteringBuffer.textures[0]);
            gl.uniform1i(shu.scatteringTexture, this.SLICE_SIZE + 5);
            gl.uniform1f(shu.camHeight, cam.getHeight());
        }
        else {
            h.programs.drawnode_screen_nl.activate();
            sh = h.programs.drawnode_screen_nl._program;
            shu = sh.uniforms;
            gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
            gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
        }
        gl.uniform3fv(shu.eyePositionHigh, cam.eyeHigh);
        gl.uniform3fv(shu.eyePositionLow, cam.eyeLow);
        return sh;
    }
    /**
     * Drawing nodes
     */
    _renderingScreenNodes(sh, cam, renderedNodes) {
        let firstPass = cam.isFirstPass;
        let sl = this._visibleTileLayerSlices;
        if (sl.length) {
            let sli = sl[0];
            for (let i = sli.length - 1; i >= 0; --i) {
                let li = sli[i];
                if (li._fading && firstPass && li._refreshFadingOpacity()) {
                    sli.splice(i, 1);
                }
            }
        }
        let nodes = new Map;
        let transparentSegments = [];
        let isEq = this.terrain.equalizeVertices;
        let i = renderedNodes.length;
        if (cam.slope > 0.8 || !this.terrain || this.terrain.isEmpty /*|| cam.getAltitude() > 10000*/) {
            while (i--) {
                let ri = renderedNodes[i];
                let s = ri.segment;
                this._renderingFadingNodesNoDepth(nodes, sh, ri, sl[0], 0);
                isEq && s.equalize();
                s.readyToEngage && s.engage();
                s.screenRendering(sh, sl[0], 0);
            }
        }
        else {
            while (i--) {
                let ri = renderedNodes[i];
                let s = ri.segment;
                this._renderingFadingNodes(nodes, sh, ri, sl[0], 0, transparentSegments);
                if (s._transitionOpacity < 1) {
                    transparentSegments.push(s);
                }
                else {
                    isEq && s.equalize();
                    s.readyToEngage && s.engage();
                    s.screenRendering(sh, sl[0], 0);
                }
            }
            for (let j = 0; j < transparentSegments.length; j++) {
                let tj = transparentSegments[j];
                isEq && tj.equalize();
                tj.readyToEngage && tj.engage();
                tj.screenRendering(sh, sl[0], 0);
            }
        }
    }
    _renderingScreenNodesWithHeight(sh, cam, renderedNodes) {
        let gl = this.renderer.handler.gl;
        let firstPass = cam.isFirstPass;
        let sl = this._visibleTileLayerSlices;
        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.disable(gl.CULL_FACE);
        let nodes = new Map;
        let transparentSegments = [];
        for (let j = 1, len = sl.length; j < len; j++) {
            let slj = sl[j];
            for (let i = slj.length - 1; i >= 0; --i) {
                let li = slj[i];
                if (li._fading && firstPass && li._refreshFadingOpacity()) {
                    slj.splice(i, 1);
                }
            }
            gl.polygonOffset(0, -j);
            let i = renderedNodes.length;
            while (i--) {
                let ri = renderedNodes[i];
                this._renderingFadingNodes(nodes, sh, ri, sl[j], j, transparentSegments);
                if (ri.segment._transitionOpacity < 1) {
                    ri.segment.initSlice(j);
                }
                else {
                    ri.segment.screenRendering(sh, sl[j], j, this.transparentTexture, true);
                }
            }
        }
        gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.enable(gl.CULL_FACE);
    }
    _renderDistanceFramebufferPASS() {
        if (!this.terrain.isEmpty) {
            let sh;
            let renderer = this.renderer;
            let h = renderer.handler;
            let gl = h.gl;
            let cam = renderer.activeCamera;
            h.programs.drawnode_heightPicking.activate();
            sh = h.programs.drawnode_heightPicking._program;
            let shu = sh.uniforms;
            gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
            gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
            gl.uniform3fv(shu.eyePositionHigh, cam.eyeHigh);
            gl.uniform3fv(shu.eyePositionLow, cam.eyeLow);
            // drawing planet nodes
            let rn = this._renderedNodesInFrustum[cam.currentFrustumIndex];
            let sl = this._visibleTileLayerSlices;
            let i = rn.length;
            while (i--) {
                rn[i].segment.heightPickingRendering(sh, sl[0]);
            }
        }
    }
    _renderColorPickingFramebufferPASS() {
        let sh;
        let renderer = this.renderer;
        let h = renderer.handler;
        let gl = h.gl;
        h.programs.drawnode_colorPicking.activate();
        sh = h.programs.drawnode_colorPicking._program;
        let shu = sh.uniforms;
        let cam = renderer.activeCamera;
        gl.enable(gl.CULL_FACE);
        gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
        gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
        gl.uniform3fv(shu.eyePositionHigh, cam.eyeHigh);
        gl.uniform3fv(shu.eyePositionLow, cam.eyeLow);
        // drawing planet nodes
        let rn = this._renderedNodesInFrustum[cam.getCurrentFrustum()];
        let sl = this._visibleTileLayerSlices;
        let i = rn.length;
        while (i--) {
            rn[i].segment.colorPickingRendering(sh, sl[0], 0);
        }
        // Here is set blending for transparent overlays
        renderer.enableBlendDefault();
        gl.enable(gl.POLYGON_OFFSET_FILL);
        for (let j = 1, len = sl.length; j < len; j++) {
            i = rn.length;
            gl.polygonOffset(0, -j);
            while (i--) {
                rn[i].segment.colorPickingRendering(sh, sl[j], j, this.transparentTexture, true);
            }
        }
        gl.disable(gl.POLYGON_OFFSET_FILL);
    }
    _renderDepthFramebufferPASS() {
        let sh;
        let renderer = this.renderer;
        let h = renderer.handler;
        let gl = h.gl;
        h.programs.drawnode_depth.activate();
        sh = h.programs.drawnode_depth._program;
        let shu = sh.uniforms;
        let cam = renderer.activeCamera;
        gl.disable(gl.BLEND);
        gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
        gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
        gl.uniform3fv(shu.eyePositionHigh, cam.eyeHigh);
        gl.uniform3fv(shu.eyePositionLow, cam.eyeLow);
        gl.uniform3fv(shu.frustumPickingColor, cam.frustum._pickingColorU);
        // drawing planet nodes
        let rn = this._renderedNodesInFrustum[cam.getCurrentFrustum()], sl = this._visibleTileLayerSlices;
        let i = rn.length;
        while (i--) {
            rn[i].segment.depthRendering(sh, sl[0]);
        }
        gl.enable(gl.BLEND);
    }
    _collectVectorLayerCollections() {
        this._frustumEntityCollections.length = 0;
        this._frustumEntityCollections = [];
        let i = this.visibleVectorLayers.length;
        while (i--) {
            let vi = this.visibleVectorLayers[i];
            if (vi._fading && vi._refreshFadingOpacity()) {
                this.visibleVectorLayers.splice(i, 1);
            }
            vi.collectVisibleCollections(this._frustumEntityCollections);
            vi.update();
        }
    }
    _frustumEntityCollectionPickingCallback() {
        this.drawPickingEntityCollections(this._frustumEntityCollections);
    }
    /**
     * Starts clear memory thread.
     * @public
     */
    memClear() {
        this._distBeforeMemClear = 0;
        this.camera._insideSegment = null;
        this.layerLock.lock(this._memKey);
        this.terrainLock.lock(this._memKey);
        this._normalMapCreator.lock(this._memKey);
        this._normalMapCreator.clear();
        this.terrain.abortLoading();
        this._tileLoader.abortAll();
        this.quadTreeStrategy.clear();
        this.layerLock.free(this._memKey);
        this.terrainLock.free(this._memKey);
        this._normalMapCreator.free(this._memKey);
        this._createdNodesCount = 0;
    }
    /**
     * Returns ray vector hit ellipsoid coordinates.
     * If the ray doesn't hit ellipsoid it returns 'undefined'.
     * @public
     * @param {Ray} ray - Ray.
     * @returns {Vec3 | undefined} -
     */
    getRayIntersectionEllipsoid(ray) {
        return this.ellipsoid.hitRay(ray.origin, ray.direction);
    }
    /**
     * Project screen coordinates to the planet ellipsoid.
     * @public
     * @param {Vec2 | IBaseInputState } px - Screen coordinates.
     * @returns {Vec3 | undefined} - Cartesian coordinates.
     */
    getCartesianFromPixelEllipsoid(px) {
        let cam = this.renderer.activeCamera;
        return this.ellipsoid.hitRay(cam.eye, cam.unproject(px.x, px.y));
    }
    /**
     * Project screen coordinates to the planet ellipsoid.
     * @public
     * @param {Vec2 | IBaseInputState} px - Screen coordinates.
     * @returns {LonLat | undefined} - Geodetic coordinates.
     */
    getLonLatFromPixelEllipsoid(px) {
        let coords = this.getCartesianFromPixelEllipsoid(px);
        if (coords) {
            return this.ellipsoid.cartesianToLonLat(coords);
        }
    }
    /**
     * Returns mouse position cartesian coordinates on the current terrain.
     * @public
     * @returns {Vec3 | undefined} -
     */
    getCartesianFromMouseTerrain() {
        let ms = this.renderer.events.mouseState;
        let distance = this.getDistanceFromPixel(ms);
        if (distance) {
            return ms.direction.scaleTo(distance).addA(this.renderer.activeCamera.eye);
        }
    }
    /**
     * Returns screen coordinates cartesian coordinates on the current terrain.
     * position or null if input coordinates is outside the planet.
     * @public
     * @param {Vec2} px - Pixel screen 2d coordinates.
     * @returns {Vec3 | undefined} -
     */
    getCartesianFromPixelTerrain(px) {
        let distance = this.getDistanceFromPixel(px);
        if (distance) {
            let direction = px.direction || this.renderer.activeCamera.unproject(px.x, px.y);
            return direction.scaleTo(distance).addA(this.renderer.activeCamera.eye);
        }
    }
    /**
     * Returns geodetic coordinates on the current terrain planet by its screen coordinates.
     * position or null if input coordinates is outside the planet.
     * @public
     * @param {Vec2 | IBaseInputState} px - Pixel screen 2d coordinates.
     * @returns {LonLat | undefined} -
     */
    getLonLatFromPixelTerrain(px) {
        let coords = this.getCartesianFromPixelTerrain(px);
        if (coords) {
            return this.ellipsoid.cartesianToLonLat(coords);
        }
    }
    /**
     * Project cartesian coordinates to screen space.
     * @public
     * @param {Vec3} coords - Cartesian coordinates.
     * @returns {Vec2} - Screen coordinates.
     */
    getPixelFromCartesian(coords) {
        return this.renderer.activeCamera.project(coords);
    }
    /**
     * Project geodetic coordinates to screen space.
     * @public
     * @param {LonLat} lonlat - Geodetic coordinates.
     * @returns {Vec2 | undefined} - Screen coordinates.
     */
    getPixelFromLonLat(lonlat) {
        let coords = this.ellipsoid.lonLatToCartesian(lonlat);
        if (coords) {
            return this.renderer.activeCamera.project(coords);
        }
    }
    /**
     * Returns distance from an active (screen) camera to the planet ellipsoid.
     * @public
     * @param {Vec2} px - Screen coordinates.
     * @returns {number} -
     */
    getDistanceFromPixelEllipsoid(px) {
        let coords = this.getCartesianFromPixelEllipsoid(px);
        if (coords) {
            return coords.distance(this.renderer.activeCamera.eye);
        }
    }
    /**
     * Returns distance from active (screen) camera to the planet terrain by screen coordinates.
     * @public
     * @param {Vec2 | IBaseInputState} px - Screen coordinates.
     * @returns {number | undefined} -
     */
    getDistanceFromPixel(px) {
        if (this.terrain.isEmpty) {
            return this.getDistanceFromPixelEllipsoid(px) || 0;
        }
        else {
            let r = this.renderer;
            let cnv = r.handler.canvas;
            let spx = px.x / cnv.width;
            let spy = (cnv.height - px.y) / cnv.height;
            _tempPickingPix_[0] = _tempPickingPix_[1] = _tempPickingPix_[2] = 0.0;
            let dist = 0;
            r.readDistanceColor(spx, spy, _tempPickingPix_);
            dist = decodeFloatFromRGBAArr(_tempPickingPix_);
            if (!(_tempPickingPix_[0] || _tempPickingPix_[1] || _tempPickingPix_[2])) {
                dist = this.getDistanceFromPixelEllipsoid(px) || 0;
            }
            else if (dist < DEPTH_DISTANCE) {
                r.screenDepthFramebuffer.activate();
                //if (r.screenDepthFramebuffer.isComplete()) {
                r.screenDepthFramebuffer.readPixels(_tempDepthColor_, spx, spy);
                let screenPos = new Vec4(spx * 2.0 - 1.0, spy * 2.0 - 1.0, (_tempDepthColor_[0] / 255.0) * 2.0 - 1.0, 1.0 * 2.0 - 1.0);
                let viewPosition = this.camera.frustums[0].inverseProjectionMatrix.mulVec4(screenPos);
                let dir = px.direction || r.activeCamera.unproject(px.x, px.y);
                dist = -(viewPosition.z / viewPosition.w) / dir.dot(r.activeCamera.getForward());
                //}
                r.screenDepthFramebuffer.deactivate();
            }
            return dist;
        }
    }
    /**
     * Sets camera to the planet geographical extent.
     * @public
     * @param {Extent} extent - Geographical extent.
     */
    viewExtent(extent) {
        if (this.camera) {
            this.camera.viewExtent(extent);
        }
        else {
            this._initialViewExtent = extent;
        }
    }
    /**
     * Fits camera position for the view extent.
     * @public
     * @param {Array.<number>} extentArr - Geographical extent array, (exactly 4 entries)
     * where index 0 - southwest longitude, 1 - latitude southwest, 2 - longitude northeast, 3 - latitude northeast.
     */
    viewExtentArr(extentArr) {
        this.viewExtent(new Extent(new LonLat(extentArr[0], extentArr[1]), new LonLat(extentArr[2], extentArr[3])));
    }
    /**
     * Gets current camera view extent.
     * @public
     * @returns {Extent} -
     */
    getViewExtent() {
        return this._viewExtent;
    }
    /**
     * Sets camera to the planet geographical position.
     * @public
     * @param {LonLat} lonlat - Camera position.
     * @param {LonLat} [lookLonLat] - Viewpoint.
     * @param {Vec3} [up] - Camera up vector.
     */
    viewLonLat(lonlat, lookLonLat, up) {
        this.camera.setLonLat(lonlat, lookLonLat, up);
    }
    /**
     * Fly active camera to the view extent.
     * @public
     * @param {Extent} extent - Geographical extent.
     * @param {Number} [height] - Height on the end of the flight route.
     * @param {Vec3} [up] - Camera UP vector on the end of a flying.
     * @param {Number} [ampl] - Altitude amplitude factor.
     * @param {Function} [startCallback] - Callback that calls before the flying begins.
     * @param {Function} [completeCallback] - Callback that calls after flying when flying is finished.
     */
    flyExtent(extent, height, up, ampl, completeCallback, startCallback) {
        this.camera.flyExtent(extent, height, up, ampl, completeCallback, startCallback);
    }
    /**
     * Fly camera to the point.
     * @public
     * @param {Vec3} cartesian - Point coordinates.
     * @param {Vec3} [look] - Camera "look at" point.
     * @param {Vec3} [up] - Camera UP vector on the end of a flying.
     * @param {Number} [ampl] - Altitude amplitude factor.
     * @param {Function} [completeCallback] - Call the function in the end of flight
     * @param {Function} [startCallback] - Call the function in the beginning
     * @param {Function} [frameCallback] - Each frame callback
     */
    flyCartesian(cartesian, look, up, ampl, completeCallback, startCallback, frameCallback) {
        this.camera.flyCartesian(cartesian, look, up, ampl, completeCallback, startCallback, frameCallback);
    }
    /**
     * Fly camera to the geodetic position.
     * @public
     * @param {LonLat} lonlat - Fly geographical coordinates.
     * @param {Vec3 | LonLat} [look] - Camera viewpoint in the end of the flight.
     * @param {Vec3} [up] - Camera UP vector on the end of a flying.
     * @param {Number} [ampl] - Altitude amplitude factor.
     * @param [completeCallback]
     * @param [startCallback]
     * @param [frameCallback]
     */
    flyLonLat(lonlat, look, up, ampl, completeCallback, startCallback, frameCallback) {
        this.camera.flyLonLat(lonlat, look, up, ampl, completeCallback, startCallback, frameCallback);
    }
    /**
     * Stop current flight.
     * @public
     */
    stopFlying() {
        this.camera.stopFlying();
    }
    updateBillboardsTexCoords() {
        for (let i = 0; i < this.entityCollections.length; i++) {
            this.entityCollections[i].billboardHandler.refreshTexCoordsArr();
        }
        let readyCollections = {};
        for (let i = 0; i < this._layers.length; i++) {
            let li = this._layers[i];
            if (li instanceof Vector) {
                li.each(function (e) {
                    if (e._entityCollection && !readyCollections[e._entityCollection.id]) {
                        e._entityCollection.billboardHandler.refreshTexCoordsArr();
                        readyCollections[e._entityCollection.id] = true;
                    }
                });
            }
        }
    }
    getEntityTerrainPoint(entity, res) {
        let n = this._renderedNodes, i = n.length;
        while (i--) {
            if (n[i].segment.isEntityInside(entity)) {
                return n[i].segment.getEntityTerrainPoint(entity, res);
            }
        }
    }
    async getHeightDefault(lonLat) {
        return new Promise((resolve) => {
            if (this.terrain) {
                this.terrain.getHeightAsync(lonLat.clone(), (alt) => {
                    resolve(alt);
                });
            }
            else {
                resolve(0);
            }
        });
    }
    async getHeightAboveELL(lonLat) {
        return new Promise((resolve) => {
            if (this.terrain) {
                this.terrain.getHeightAsync(lonLat.clone(), (alt) => {
                    resolve(alt + this.terrain.geoid.getHeightLonLat(lonLat));
                });
            }
            else {
                resolve(0);
            }
        });
    }
    onremove() {
        this.memClear();
        this.quadTreeStrategy.destroyBranches();
        this._renderedNodes = [];
    }
}
const PLANET_EVENTS = [
    /**
     * Triggered before globe frame begins to render.
     * @event og.scene.Planet#draw
     */
    "draw",
    /**
     * Triggered when layer has added to the planet.
     * @event og.scene.Planet#layeradd
     */
    "layeradd",
    /**
     * Triggered when base layer changed.
     * @event og.scene.Planet#baselayerchange
     */
    "baselayerchange",
    /**
     * Triggered when layer has removed from the planet.
     * @event og.scene.Planet#layerremove
     */
    "layerremove",
    /**
     * Triggered when some layer visibility changed.
     * @event og.scene.Planet#layervisibilitychange
     */
    "layervisibilitychange",
    /**
     * Triggered when all data is loaded
     * @event og.scene.Planet#rendercompleted
     */
    "rendercompleted",
    /**
     * Triggered when all data is loaded
     * @event og.scene.Planet#terraincompleted
     */
    "terraincompleted",
    /**
     * Triggered when layer data is laded
     * @event og.scene.Planet#terraincompleted
     */
    "layerloadend"
];

function skybox() {
    return new Program("skybox", {
        uniforms: {
            projectionViewMatrix: { type: types.MAT4 },
            uSampler: { type: types.SAMPLERCUBE },
            pos: { type: types.VEC3 }
        },
        attributes: {
            aVertexPosition: { type: types.VEC3, enableArray: true }
        },
        vertexShader: `attribute vec3 aVertexPosition;
            uniform mat4 projectionViewMatrix;
            uniform vec3 pos;
            varying vec3 vTextureCoord;
            void main(void) {
                vTextureCoord = aVertexPosition;
                gl_Position = projectionViewMatrix * vec4(aVertexPosition + pos, 1.0);
            }`,
        fragmentShader: `precision lowp float;
            varying vec3 vTextureCoord;
            uniform samplerCube uSampler;
            void main(void) {
                gl_FragColor = textureCube(uSampler, vTextureCoord);
            }`
    });
}

class SkyBox extends RenderNode {
    constructor(params) {
        super("skybox");
        this.params = params;
        this.vertexPositionBuffer = null;
        this.texture = null;
    }
    static createDefault(RESOURCES_URL) {
        return new SkyBox({
            nx: RESOURCES_URL + "skybox/gal/_nx.jpg",
            px: RESOURCES_URL + "skybox/gal/_px.jpg",
            py: RESOURCES_URL + "skybox/gal/_py.jpg",
            ny: RESOURCES_URL + "skybox/gal/_ny.jpg",
            pz: RESOURCES_URL + "skybox/gal/_pz.jpg",
            nz: RESOURCES_URL + "skybox/gal/_nz.jpg"
        });
    }
    init() {
        this.renderer.handler.addProgram(skybox(), true);
        this.texture = this.renderer.handler.loadCubeMapTexture(this.params);
        this._createBuffers();
        this.drawMode = this.renderer.handler.gl.TRIANGLES;
    }
    frame() {
        let h = this.renderer.handler;
        let gl = h.gl;
        let cam = this.renderer.activeCamera;
        gl.disable(gl.DEPTH_TEST);
        h.programs.skybox.activate();
        let sh = h.programs.skybox._program;
        let shu = sh.uniforms;
        gl.uniformMatrix4fv(shu.projectionViewMatrix, false, cam.getProjectionViewMatrix());
        gl.uniform3fv(shu.pos, cam.eye.toArray());
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
        gl.uniform1i(shu.uSampler, 0);
        let buf = this.vertexPositionBuffer;
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.vertexAttribPointer(sh.attributes.aVertexPosition, buf.itemSize, gl.FLOAT, false, 0, 0);
        gl.drawArrays(this.drawMode, 0, buf.numItems);
        gl.enable(gl.DEPTH_TEST);
    }
    _createBuffers() {
        const vertices = new Float32Array([
            -100000000.0, 100000000.0, -100000000.0,
            -100000000.0, -100000000.0, -100000000.0,
            100000000.0, -100000000.0, -100000000.0,
            100000000.0, -100000000.0, -100000000.0,
            100000000.0, 100000000.0, -100000000.0,
            -100000000.0, 100000000.0, -100000000.0,
            -100000000.0, -100000000.0, 100000000.0,
            -100000000.0, -100000000.0, -100000000.0,
            -100000000.0, 100000000.0, -100000000.0,
            -100000000.0, 100000000.0, -100000000.0,
            -100000000.0, 100000000.0, 100000000.0,
            -100000000.0, -100000000.0, 100000000.0,
            100000000.0, -100000000.0, -100000000.0,
            100000000.0, -100000000.0, 100000000.0,
            100000000.0, 100000000.0, 100000000.0,
            100000000.0, 100000000.0, 100000000.0,
            100000000.0, 100000000.0, -100000000.0,
            100000000.0, -100000000.0, -100000000.0,
            -100000000.0, -100000000.0, 100000000.0,
            -100000000.0, 100000000.0, 100000000.0,
            100000000.0, 100000000.0, 100000000.0,
            100000000.0, 100000000.0, 100000000.0,
            100000000.0, -100000000.0, 100000000.0,
            -100000000.0, -100000000.0, 100000000.0,
            -100000000.0, 100000000.0, -100000000.0,
            100000000.0, 100000000.0, -100000000.0,
            100000000.0, 100000000.0, 100000000.0,
            100000000.0, 100000000.0, 100000000.0,
            -100000000.0, 100000000.0, 100000000.0,
            -100000000.0, 100000000.0, -100000000.0,
            -100000000.0, -100000000.0, -100000000.0,
            -100000000.0, -100000000.0, 100000000.0,
            100000000.0, -100000000.0, -100000000.0,
            100000000.0, -100000000.0, -100000000.0,
            -100000000.0, -100000000.0, 100000000.0,
            100000000.0, -100000000.0, 100000000.0
        ]);
        this.vertexPositionBuffer = this.renderer.handler.createArrayBuffer(vertices, 3, vertices.length / 3);
    }
}

var index$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Axes: Axes,
    Planet: Planet,
    RenderNode: RenderNode,
    SkyBox: SkyBox
});

/**
 * Class represents terrain provider without elevation data.
 * @param {IEmptyTerrainParams} [options] - Provider options:
 * @param {string} [options.name="empty"] - Provider name.
 * @param {boolean} [options.equalizeVertices] -
 * @param {number} [options.minZoom=2] - Minimal visible zoom index when terrain handler works.
 * @param {number} [options.minZoom=50] - Maximal visible zoom index when terrain handler works.
 * @param {number} [options.maxNativeZoom=19] - Maximal available terrain zoom level.
 * @param {Array.<number>} [options.gridSizeByZoom] - Array of segment triangulation grid sizes where array index agreed to the segment zoom index.
 * @param {Array.<number>} [gridSizeByZoom] - Array of values, where each value corresponds to the size of a tile(or segment) on the globe. Each value must be power of two.
 * @param {Geoid} [options.geoid] -
 * @param {string} [options.geoidSrc] -
 */
class EmptyTerrain {
    constructor(options = {}) {
        this.__id = EmptyTerrain.__counter__++;
        this.equalizeVertices = options.equalizeVertices || false;
        this.equalizeNormals = false;
        this.isEmpty = true;
        this.name = options.name || "empty";
        this.minZoom = options.minZoom || 2;
        this.maxZoom = options.maxZoom || 19;
        this.maxNativeZoom = options.maxNativeZoom || this.maxZoom;
        this.gridSizeByZoom = options.gridSizeByZoom || [
            64, 32, 16, 8, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
        ];
        this._maxNodeZoom = this.gridSizeByZoom.length - 1;
        this.plainGridSize = 2;
        this.noDataValues = [];
        this._planet = null;
        this._geoid = options.geoid || new Geoid({
            src: options.geoidSrc || null
        });
        this._isReady = false;
        // const _ellToAltFn = [
        //     (lon, lat, alt, callback) => callback(alt),
        //     (lon, lat, alt, callback) => callback(alt - this._geoid.getHeight(lon, lat)),
        //     (lon, lat, alt, callback) => {
        //         let x = mercator.getTileX(lon, zoom),
        //             y = mercator.getTileY(lat, zoom);
        //         let mslAlt = alt - this._geoid.getHeight(lon, lat);
        //         if (true) {
        //         } else {
        //         }
        //         return callback(mslAlt);
        //     },
        // ];
    }
    /**
     * Sets url rewrite callback, used for custom url rewriting for every tile loading.
     * @public
     * @param {UrlRewriteFunc} ur - The callback that returns tile custom created url.
     */
    setUrlRewriteCallback(ur) {
    }
    get isIdle() {
        return true;
    }
    isEqual(obj) {
        return obj.__id === this.__id;
    }
    static checkNoDataValue(noDataValues, value) {
        return binarySearchFast(noDataValues, value) !== -1;
    }
    isBlur(segment) {
        return false;
    }
    set maxNodeZoom(val) {
        if (val > this.gridSizeByZoom.length - 1) {
            val = this.gridSizeByZoom.length - 1;
        }
        this._maxNodeZoom = val;
    }
    get maxNodeZoom() {
        return this._maxNodeZoom;
    }
    set geoid(geoid) {
        this._geoid = geoid;
    }
    get geoid() {
        return this._geoid;
    }
    getGeoid() {
        return this._geoid;
    }
    /**
     * Loads or creates segment elevation data.
     * @public
     * @param {Segment} segment - Segment to create elevation data.
     */
    handleSegmentTerrain(segment) {
        segment.terrainIsLoading = false;
        segment.terrainReady = true;
        segment.terrainExists = true;
    }
    isReady() {
        return this._isReady;
    }
    abortLoading() {
    }
    clearCache() {
    }
    getHeightAsync(lonLat, callback) {
        callback(0);
        return true;
    }
    loadTerrain(segment, forceLoading = false) {
    }
}
EmptyTerrain.__counter__ = 0;

/**
 * @deprecated
 * Use GlobusRgbTerrain
 * Class that loads segment elevation data, converts it to the array and passes it to the planet segment.
 * @class
 * @extends {GlobusTerrain}
 * @param {string} [name=""] - Terrain provider name.
 * @param {IGlobusTerrainParams} [options] - Provider options:
 * @param {number} [options.minZoom=3] - Minimal visible zoom index when terrain handler works.
 * @param {number} [options.minZoom=14] - Maximal visible zoom index when terrain handler works.
 * @param {number} [options.minNativeZoom=14] - Maximal available terrain zoom level.
 * @param {string} [options.url="//openglobus.org/heights/srtm3/{z}/{y}/{x}.ddm"] - Terrain source path url template. Default is openglobus ddm elevation file.
 * @param {Array.<number>} [options.gridSizeByZoom] - Array of segment triangulation grid sizes where array index agreed to the segment zoom index.
 * @param {number} [options.plainGridSize=32] - Elevation grid size. Default is 32x32. Must be power of two.
 * @param {string} [options.responseType="arraybuffer"] - Response type.
 * @param {number} [options.MAX_LOADING_TILES] - Maximum at one time loading tiles.
 * @param {Array.<number>} [gridSizeByZoom] - Array of values, where each value corresponds to the size of a tile(or segment) on the globe. Each value must be power of two.
 * @param {number} [heightFactor=1] - Elevation height multiplier.
 *
 * @fires GlobusTerrainEvents#load
 * @fires GlobusTerrainEvents#loadend
 */
class GlobusTerrain extends EmptyTerrain {
    constructor(name = "", options = {}) {
        super({
            geoidSrc: "https://openglobus.org/geoid/egm84-30.pgm",
            maxNativeZoom: options.maxNativeZoom || 14,
            ...options
        });
        this._s = options.subdomains || ["a", "b", "c"];
        this.events = createEvents(GLOBUSTERRAIN_EVENTS, this);
        this._requestCount = 0;
        this._requestsPeerSubdomain = 4;
        this.isEmpty = false;
        this.equalizeNormals = true;
        this.name = name || "openglobus";
        this.url = options.url || "https://{s}.srtm3.openglobus.org/{z}/{y}/{x}.ddm";
        this.gridSizeByZoom = options.gridSizeByZoom || [
            64, 32, 32, 16, 16, 8, 8, 8, 16, 16, 16, 32, 32, 32, 32, 16, 8, 4, 2, 2, 2, 2, 2, 2
        ];
        this._heightFactor = options.heightFactor != undefined ? options.heightFactor : 1.0;
        this.noDataValues = options.noDataValues || [];
        for (let i = 0; i < this.noDataValues.length; i++) {
            this.noDataValues[i] *= this._heightFactor;
        }
        this.plainGridSize = options.plainGridSize || 32;
        this._extent = createExtent(options.extent, new Extent(new LonLat(-180.0, -90.0), new LonLat(180.0, 90.0)));
        this._dataType = "arrayBuffer";
        this._maxNodeZoom = this.gridSizeByZoom.length - 1;
        this._elevationCache = {};
        this._fetchCache = {};
        this._loader = new Loader();
        this._urlRewriteCallback = options.urlRewrite || null;
    }
    get loader() {
        return this._loader;
    }
    clearCache() {
        for (let c in this._elevationCache) {
            this._elevationCache[c].heights = null;
            this._elevationCache[c].extent = null;
            delete this._elevationCache[c];
        }
        //@ts-ignore
        this._elevationCache = null;
        this._elevationCache = {};
        for (let c in this._fetchCache) {
            //@ts-ignore
            this._fetchCache[c] = null;
            delete this._fetchCache[c];
        }
        //@ts-ignore
        this._fetchCache = null;
        this._fetchCache = {};
    }
    isBlur(segment) {
        return segment.tileZoom >= 6;
    }
    setElevationCache(tileIndex, tileData) {
        this._elevationCache[tileIndex] = tileData;
    }
    getElevationCache(tileIndex) {
        return this._elevationCache[tileIndex];
    }
    getHeightAsync(lonLat, callback, zoom, firstAttempt) {
        if (!lonLat || lonLat.lat > MAX_LAT || lonLat.lat < MIN_LAT) {
            callback(0);
            return true;
        }
        firstAttempt = firstAttempt != undefined ? firstAttempt : true;
        const [x, y, z, tileGroup] = this._planet.quadTreeStrategy.getTileXY(lonLat, zoom || this.maxZoom);
        let tileIndex = Layer.getTileIndex(x, y, z, tileGroup);
        let cache = this.getElevationCache(tileIndex);
        let merc = forward(lonLat);
        if (cache) {
            if (cache.heights) {
                callback(this._getGroundHeightMerc(merc, cache));
            }
            else {
                callback(0);
            }
            return true;
        }
        else {
            let def = this._fetchCache[tileIndex];
            if (!def) {
                def = this._loader.fetch({
                    src: this.buildURL(x, y, z, tileGroup),
                    type: this._dataType
                });
                this._fetchCache[tileIndex] = def;
            }
            def.then((response) => {
                let extent = getTileExtent(x, y, z);
                if (response.status === "ready") {
                    let cache = {
                        heights: this._createHeights(response.data, null, tileGroup, x, y, z, extent),
                        extent: extent
                    };
                    this.setElevationCache(tileIndex, cache);
                    callback(this._getGroundHeightMerc(merc, cache));
                }
                else if (response.status === "error") {
                    if (firstAttempt && z > this.maxNativeZoom) {
                        firstAttempt = false;
                        this.getHeightAsync(lonLat, callback, this.maxNativeZoom, false);
                        return;
                    }
                    this.setElevationCache(tileIndex, {
                        heights: null,
                        extent: extent
                    });
                    callback(0);
                }
                else {
                    // @ts-ignore
                    this._fetchCache[tileIndex] = null;
                    delete this._fetchCache[tileIndex];
                }
            });
        }
        return false;
    }
    _getGroundHeightMerc(merc, tileData) {
        if (!(tileData.extent && tileData.heights)) {
            return 0;
        }
        let w = tileData.extent.getWidth(), gs = Math.sqrt(tileData.heights.length);
        let size = w / (gs - 1);
        /*
        v2-----------v3
        |            |
        |            |
        |            |
        v0-----------v1
        */
        let i = gs - Math.ceil((merc.lat - tileData.extent.southWest.lat) / size) - 1, j = Math.floor((merc.lon - tileData.extent.southWest.lon) / size);
        let v0Ind = (i + 1) * gs + j, v1Ind = v0Ind + 1, v2Ind = i * gs + j, v3Ind = v2Ind + 1;
        let h0 = tileData.heights[v0Ind], h1 = tileData.heights[v1Ind], h2 = tileData.heights[v2Ind], h3 = tileData.heights[v3Ind];
        let v0 = new Vec3(tileData.extent.southWest.lon + size * j, h0, tileData.extent.northEast.lat - size * i - size), v1 = new Vec3(v0.x + size, h1, v0.z), v2 = new Vec3(v0.x, h2, v0.z + size), v3 = new Vec3(v0.x + size, h3, v0.z + size);
        let xyz = new Vec3(merc.lon, 100000.0, merc.lat), ray = new Ray$1(xyz, new Vec3(0, -1, 0));
        let res = new Vec3();
        let d = ray.hitTriangle(v0, v1, v2, res);
        if (d === Ray$1.INSIDE) {
            return res.y;
        }
        d = ray.hitTriangle(v1, v3, v2, res);
        if (d === Ray$1.INSIDE) {
            return res.y;
        }
        return 0;
    }
    /**
     * Stop loading.
     * @public
     */
    abortLoading() {
        this._loader.abortAll();
    }
    /**
     * Sets terrain data url template.
     * @public
     * @param {string} url - Url template.
     * @example <caption>Default openglobus url template:</caption>:
     * "http://earth3.openglobus.org/{z}/{y}/{x}.ddm"
     */
    setUrl(url) {
        this.url = url;
    }
    /**
     * Sets provider name.
     * @public
     * @param {string} name - Name.
     */
    setName(name) {
        this.name = name;
    }
    isReadyToLoad(segment) {
        return segment._tileGroup === TILEGROUP_COMMON && this._extent.overlaps(segment.getExtentLonLat());
    }
    /**
     * Starts to load segment elevation data.
     * @public
     * @param {Segment} segment - Segment that wants a terrain data.
     * @param {boolean} [forceLoading] -
     */
    loadTerrain(segment, forceLoading = false) {
        if (this._planet.terrainLock.isFree()) {
            segment.terrainReady = false;
            segment.terrainIsLoading = true;
            if (this.isReadyToLoad(segment)) {
                let cache = this.getElevationCache(segment.tileIndex);
                if (cache) {
                    this._applyElevationsData(segment, cache.heights);
                }
                else {
                    this._loader.load({
                        sender: this,
                        src: this._getHTTPRequestString(segment),
                        segment: segment,
                        type: this._dataType,
                        filter: () => (segment.plainReady && segment.node.getState() !== NOTRENDERING) || forceLoading
                    }, (response) => {
                        if (response.status === "ready") {
                            let heights = this._createHeights(response.data, segment, segment._tileGroup, segment.tileX, segment.tileY, segment.tileZoom, segment.getExtent(), segment.tileZoom === this.maxZoom);
                            this.setElevationCache(segment.tileIndex, {
                                heights: heights,
                                extent: segment.getExtent()
                            });
                            this._applyElevationsData(segment, heights);
                        }
                        else if (response.status === "abort") {
                            segment.terrainIsLoading = false;
                        }
                        else if (response.status === "error") {
                            this._applyElevationsData(segment, null);
                        }
                        else {
                            segment.terrainIsLoading = false;
                        }
                    });
                }
            }
            else {
                segment.elevationsNotExists();
            }
        }
        else {
            segment.terrainIsLoading = false;
        }
    }
    _getSubdomain() {
        this._requestCount++;
        return this._s[Math.floor(this._requestCount % (this._requestsPeerSubdomain * this._s.length) / this._requestsPeerSubdomain)];
    }
    buildURL(x, y, z, tileGroup) {
        return stringTemplate(this.url, {
            s: this._getSubdomain(),
            x: x.toString(),
            y: y.toString(),
            z: z.toString()
        });
    }
    /**
     * Creates default query url string.
     * @protected
     * @param {Segment} segment -
     * @returns {string} -
     */
    _createUrl(segment) {
        return this.buildURL(segment.tileX, segment.tileY, segment.tileZoom, segment._tileGroup);
    }
    /**
     * Returns actual url query string.
     * @protected
     * @param {Segment} segment - Segment that loads image data.
     * @returns {string} - Url string.
     */
    _getHTTPRequestString(segment) {
        if (this._urlRewriteCallback) {
            return this._urlRewriteCallback(segment.tileX, segment.tileY, segment.tileZoom, segment._tileGroup) || this._createUrl(segment);
        }
        else {
            return this._createUrl(segment);
        }
    }
    /**
     * Sets url rewrite callback, used for custom url rewriting for every tile loading.
     * @public
     * @param {UrlRewriteFunc} ur - The callback that returns tile custom created url.
     */
    setUrlRewriteCallback(ur) {
        this._urlRewriteCallback = ur;
    }
    /**
     * Converts loaded data to segment elevation data type(column major elevation data array in meters)
     * @public
     * @returns {Array.<number>} -
     */
    _createHeights(data, segment, tileGroup, x, y, z, extent, isMaxZoom) {
        if (this._heightFactor !== 1) {
            let res = new Float32Array(data);
            for (let i = 0, len = res.length; i < len; i++) {
                res[i] = res[i] * this._heightFactor;
            }
            return res;
        }
        return new Float32Array(data);
    }
    /**
     * @protected
     */
    _applyElevationsData(segment, elevations) {
        if (segment) {
            let e = this.events.load;
            if (e.handlers.length) {
                this.events.dispatch(e, {
                    elevations: elevations,
                    segment: segment
                });
            }
            segment.applyTerrain(elevations);
        }
    }
}
const GLOBUSTERRAIN_EVENTS = [
    /**
     * Triggered when current elevation tile has loaded but before rendering.
     * @event og.terrain.GlobusTerrain#load
     */
    "load",
    /**
     * Triggered when all elevation tiles have loaded or loading has stopped.
     * @event og.terrain.GlobusTerrain#loadend
     */
    "loadend"
];

/**
 * Represents an imagery tiles source provider.
 * @class
 * @extends {Layer}
 * @param {string} name - Layer name.
 * @param {IXYZParams} options:
 * @param {number} [options.opacity=1.0] - Layer opacity.
 * @param {Array.<string>} [options.subdomains=['a','b','c']] - Subdomains of the tile service.
 * @param {number} [options.minZoom=0] - Minimal visibility zoom level.
 * @param {number} [options.maxZoom=0] - Maximal visibility zoom level.
 * @param {number} [options.minNativeZoom=0] - Minimal available zoom level.
 * @param {number} [options.maxNativeZoom=19] - Maximal available zoom level.
 * @param {string} [options.attribution] - Layer attribution that displayed in the attribution area on the screen.
 * @param {boolean} [options.isBaseLayer=false] - Base layer flag.
 * @param {boolean} [options.visibility=true] - Layer visibility.
 * @param {string} [options.crossOrigin=true] - If true, all tiles will have their crossOrigin attribute set to ''.
 * @param {string} options.url - Tile url source template(see example below).
 * @param {string} options.textureFilter - texture gl filter. NEAREST, LINEAR, MIPMAP, ANISOTROPIC.
 * @param {Function} options.urlRewrite - Url rewrite function.
 *
 * @fires EventsHandler<XYZEventsList>#load
 * @fires EventsHandler<XYZEventsList>#loadend
 *
 * @example <caption>Creates OpenStreetMap base tile layer</caption>
 * new og.layer.XYZ("OpenStreetMap", {
 *     isBaseLayer: true,
 *     url: "http://b.tile.openstreetmap.org/{z}/{x}/{y}.png",
 *     visibility: true,
 *     attribution: 'Data @ <a href="http://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="http://www.openstreetmap.org/copyright">ODbL</a>'
 * });
 */
class XYZ extends Layer {
    constructor(name, options = {}) {
        super(name, options);
        //@ts-ignore
        this.events = this.events.registerNames(XYZ_EVENTS);
        this.url = options.url || "";
        this._s = options.subdomains || ["a", "b", "c"];
        this.minNativeZoom = options.minNativeZoom || 0;
        this.maxNativeZoom = options.maxNativeZoom || 19;
        this._urlRewriteCallback = options.urlRewrite || null;
        this._requestsPeerSubdomains = 4;
        this._requestCount = 0;
    }
    /**
     * @warning Use XYZ.isIdle in requestAnimationFrame(after setVisibility)
     */
    get isIdle() {
        return super.isIdle && this._planet._tileLoader.getRequestCounter(this) === 0;
    }
    get instanceName() {
        return "XYZ";
    }
    /**
     * Abort loading tiles.
     * @public
     */
    abortLoading() {
        if (this._planet) {
            this._planet._tileLoader.abort(this);
        }
    }
    /**
     * Sets layer visibility.
     * @public
     * @param {boolean} visibility - Layer visibility.
     */
    setVisibility(visibility) {
        if (visibility !== this._visibility) {
            super.setVisibility(visibility);
            if (!visibility) {
                this.abortLoading();
            }
        }
    }
    remove() {
        this.abortLoading();
        super.remove();
        return this;
    }
    /**
     * Sets imagery tiles url source template.
     * @public
     * @param {string} url - Url template.
     * @example
     * http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png
     * where {z}, {x} and {y} - replaces by current tile values, {s} - random domain.
     */
    setUrl(url) {
        this.url = url;
    }
    _checkSegment(segment) {
        return segment._projection.id === this._planet.quadTreeStrategy.projection.id;
    }
    /**
     * Start to load tile material.
     * @public
     * @virtual
     * @param {Material} material - Loads current material.
     * @param {boolean} [forceLoading=false] -
     */
    loadMaterial(material, forceLoading = false) {
        let seg = material.segment;
        if (this._isBaseLayer) {
            material.texture = seg.getDefaultTexture();
        }
        else {
            material.texture = seg.planet.transparentTexture;
        }
        // Q: Maybe we should change "<2" to material.segment.tileZoom < (material.layer.minZoom + 1)
        if (this._planet.layerLock.isFree() || material.segment.tileZoom < 2) {
            material.isReady = false;
            material.isLoading = true;
            if (this._checkSegment(seg)) {
                material.loadingAttempts++;
                this._planet._tileLoader.load({
                    sender: this,
                    src: this._getHTTPRequestString(material.segment),
                    type: "imageBitmap",
                    filter: () => (seg.initialized && seg.node.getState() === RENDERING) || forceLoading,
                    options: {}
                }, (response) => {
                    if (response.status === "ready") {
                        if (material.isLoading) {
                            let e = this.events.load;
                            if (e.handlers.length) {
                                this.events.dispatch(e, material);
                            }
                            material.applyImage(response.data);
                            response.data = null;
                        }
                    }
                    else if (response.status === "abort") {
                        material.isLoading = false;
                    }
                    else if (response.status === "error") {
                        if (material.isLoading) {
                            material.textureNotExists();
                        }
                    }
                }
                //,this.__id
                );
            }
            else {
                material.textureNotExists();
            }
        }
    }
    /**
     * Creates query url.
     * @protected
     * @virtual
     * @param {Segment} segment - Creates specific url for current segment.
     * @returns {string} - Returns url string.
     */
    _createUrl(segment) {
        return stringTemplate(this.url, {
            s: this._getSubdomain(),
            x: segment.tileX.toString(),
            y: segment.tileY.toString(),
            z: segment.tileZoom.toString()
        });
    }
    _getSubdomain() {
        this._requestCount++;
        return this._s[Math.floor(this._requestCount % (this._requestsPeerSubdomains * this._s.length) / this._requestsPeerSubdomains)];
    }
    /**
     * Returns actual url query string.
     * @protected
     * @param {Segment} segment - Segment that loads image data.
     * @returns {string} - Url string.
     */
    _getHTTPRequestString(segment) {
        return this._urlRewriteCallback ? this._urlRewriteCallback(segment, this.url) : this._createUrl(segment);
    }
    /**
     * Sets url rewrite callback, used for custom url rewriting for every tile loading.
     * @public
     * @param {Function} ur - The callback that returns tile custom created url.
     */
    setUrlRewriteCallback(ur) {
        this._urlRewriteCallback = ur;
    }
    applyMaterial(material, forceLoading = false) {
        if (material.isReady) {
            return material.texOffset;
        }
        else if (material.segment.tileZoom < this.minNativeZoom) {
            material.textureNotExists();
        }
        else {
            let segment = material.segment, pn = segment.node, notEmpty = false;
            let mId = this.__id;
            let psegm = material;
            while (pn.parentNode) {
                pn = pn.parentNode;
                psegm = pn.segment.materials[mId];
                if (psegm && psegm.textureExists) {
                    notEmpty = true;
                    break;
                }
            }
            if (segment.passReady) {
                let maxNativeZoom = material.layer.maxNativeZoom;
                if (pn.segment.tileZoom === maxNativeZoom) {
                    material.textureNotExists();
                }
                else if (material.segment.tileZoom <= maxNativeZoom) {
                    !material.isLoading && !material.isReady && this.loadMaterial(material, forceLoading);
                }
                else {
                    let pn = segment.node;
                    while (pn.segment.tileZoom > material.layer.maxNativeZoom) {
                        pn = pn.parentNode;
                    }
                    let pnm = pn.segment.materials[material.layer.__id];
                    if (pnm) {
                        !pnm.isLoading && !pnm.isReady && this.loadMaterial(pnm, true);
                    }
                    else {
                        pnm = pn.segment.materials[material.layer.__id] = material.layer.createMaterial(pn.segment);
                        this.loadMaterial(pnm, true);
                    }
                }
            }
            if (notEmpty) {
                material.appliedNode = pn;
                material.appliedNodeId = pn.nodeId;
                material.texture = psegm.texture;
                let dZ2 = 1.0 / (2 << (segment.tileZoom - pn.segment.tileZoom - 1));
                material.texOffset[0] = segment.tileX * dZ2 - pn.segment.tileX;
                material.texOffset[1] = segment.tileY * dZ2 - pn.segment.tileY;
                material.texOffset[2] = dZ2;
                material.texOffset[3] = dZ2;
            }
            else {
                material.texture = segment.planet.transparentTexture;
                material.texOffset[0] = 0.0;
                material.texOffset[1] = 0.0;
                material.texOffset[2] = 1.0;
                material.texOffset[3] = 1.0;
            }
        }
        return material.texOffset;
    }
    clearMaterial(material) {
        if (material.isReady && material.textureExists) {
            !material.texture.default && material.segment.handler.gl.deleteTexture(material.texture);
            material.texture = null;
        }
        material.isReady = false;
        material.textureExists = false;
        material.isLoading = false;
    }
    /**
     * @protected
     */
    _correctFullExtent() {
        let e = this._extent, em = this._extentMerc;
        let ENLARGE_MERCATOR_LON = POLE + 50000;
        let ENLARGE_MERCATOR_LAT = POLE + 50000;
        if (e.northEast.lat === 90.0) {
            em.northEast.lat = ENLARGE_MERCATOR_LAT;
        }
        if (e.northEast.lon === 180.0) {
            em.northEast.lon = ENLARGE_MERCATOR_LON;
        }
        if (e.southWest.lat === -90.0) {
            em.southWest.lat = -ENLARGE_MERCATOR_LAT;
        }
        if (e.southWest.lon === -180.0) {
            em.southWest.lon = -ENLARGE_MERCATOR_LON;
        }
        if (e.northEast.lat >= MAX_LAT) {
            e.northEast.lat = MAX_LAT;
        }
        if (e.northEast.lat <= MIN_LAT) {
            e.northEast.lat = MIN_LAT;
        }
    }
}
const XYZ_EVENTS = [
    /**
     * Triggered when current tile image has loaded before rendering.
     * @event #load
     */
    "load",
    /**
     * Triggered when all tiles have loaded or loading has stopped.
     * @event #loadend
     */
    "loadend"
];

/**
 * Used to display WMS services as tile layers on the globe.
 * @class
 * @extends {XYZ}
 * @param {string} name - Layer name.
 * @param {Object} options - Options:
 * @param {number} [options.opacity=1.0] - Layer opacity.
 * @param {number} [options.minZoom=0] - Minimal visibility zoom level.
 * @param {number} [options.maxZoom=0] - Maximal visibility zoom level.
 * @param {string} [options.attribution] - Layer attribution that displayed in the attribution area on the screen.
 * @param {boolean} [options.isBaseLayer=false] - Base layer flag.
 * @param {boolean} [options.visibility=true] - Layer visibility.
 * @param {string} options.url - WMS url source.
 * @param {number} [options.width=256] - Tile width.
 * @param {number} [options.height=256] - Tile height.
 * @param {string} options.layers - WMS layers string.
 * @param {string} [options.version="1.1.1"] - WMS version.
 * @param {Object} extra  - Extra parameters (by WMS reference or by WMS service vendors) to pass to WMS service.
 * @example:
 * new og.layer.WMS("USA States", {
 *     isBaseLayer: false,
 *     url: "http://openglobus.org/geoserver/",
 *     layers: "topp:states",
 *     opacity: 0.5,
 *     zIndex: 50,
 *     attribution: 'USA states - geoserver WMS example',
 *     version: "1.1.1",
 *     visibility: false }, {
 *     transparent: true,
 *     sld: "style.sld"}
 * );
 */
class WMS extends XYZ {
    constructor(name, options) {
        super(name, options);
        this._extra = new URLSearchParams(options.extra).toString();
        if (!options.extent) {
            this.setExtent(new Extent(new LonLat(-180.0, -90), new LonLat(180.0, 90)));
        }
        this.layers = options.layers;
        /**
         * WMS tile width.
         * @public
         * @type {number}
         */
        this.imageWidth = options.imageWidth || 256;
        /**
         * WMS tile height.
         * @public
         * @type {number}
         */
        this.imageHeight = options.imageHeight || 256;
        this._getBbox = WMS.get_bbox_v1_1_1;
        this._version = "";
        this.setVersion(options.version);
    }
    static createRequestUrl(url, layers, format = "image/png", version = "1.1.1", request = "GetMap", srs, bbox, width = 256, height = 256, extra) {
        return `${url}/?LAYERS=${layers}&FORMAT=${format}&SERVICE=WMS&VERSION=${version}&REQUEST=${request}&SRS=${srs}&BBOX=${bbox}&WIDTH=${width}&HEIGHT=${height}` + (extra ? `&${extra}` : "");
    }
    static get_bbox_v1_1_1(extent) {
        return `${extent.getWest()},${extent.getSouth()},${extent.getEast()},${extent.getNorth()}`;
    }
    static get_bbox_v1_3_0(extent) {
        return `${extent.getSouth()},${extent.getWest()},${extent.getNorth()},${extent.getEast()}`;
    }
    _checkSegment(segment) {
        return true;
    }
    get instanceName() {
        return "WMS";
    }
    _createUrl(segment) {
        return WMS.createRequestUrl(this.url, this.layers, "image/png", this._version, "GetMap", segment._projection.code, this._getBbox(segment.getExtent()), this.imageWidth, this.imageHeight, this._extra);
    }
    setVersion(version) {
        if (version) {
            this._version = version;
        }
        else {
            this._version = "1.1.1";
        }
        if (this._version === "1.1.1") {
            this._getBbox = WMS.get_bbox_v1_1_1;
        }
        else if (version === "1.3.0") {
            this._getBbox = WMS.get_bbox_v1_3_0;
        }
    }
    _correctFullExtent() {
        const e = this._extent;
        const em = this._extentMerc;
        const ENLARGE_MERCATOR_LON = POLE + 50000;
        const ENLARGE_MERCATOR_LAT = POLE + 50000;
        if (e.northEast.lat === 90.0) {
            em.northEast.lat = ENLARGE_MERCATOR_LAT;
        }
        if (e.northEast.lon === 180.0) {
            em.northEast.lon = ENLARGE_MERCATOR_LON;
        }
        if (e.southWest.lat === -90.0) {
            em.southWest.lat = -ENLARGE_MERCATOR_LAT;
        }
        if (e.southWest.lon === -180.0) {
            em.southWest.lon = -ENLARGE_MERCATOR_LON;
        }
    }
}

class BilTerrain extends GlobusTerrain {
    constructor(options = {}) {
        super("BilTerrain", options);
        this.equalizeVertices = true;
        this.equalizeNormals = true;
        this.minZoom = options.minZoom || 2;
        this.maxZoom = options.maxZoom || 14;
        this.noDataValues = options.noDataValues || [-9999, 32767];
        this.url = options.url || "";
        this._format = "application/bil16";
        this._layers = options.layers || "";
        this._imageSize = options.imageSize || 256;
        this.plainGridSize = options.plainGridSize != undefined
            ? options.plainGridSize
            : isPowerOfTwo(this._imageSize) ? this._imageSize / 2 : nextHighestPowerOfTwo(this._imageSize) / 2;
        this._dataType = "arrayBuffer";
    }
    isBlur(segment) {
        return segment.tileZoom >= 18;
    }
    _createUrl(segment) {
        return WMS.createRequestUrl(this.url, this._layers, this._format, "1.1.1", "GetMap", segment._projection.code, WMS.get_bbox_v1_1_1(segment.getExtent()), this._imageSize, this._imageSize);
    }
    _createHeights(data, segment, tileGroup, tileX, tileY, tileZoom, extent, preventChildren) {
        let bil16 = new Int16Array(data);
        //
        //Non-power of two images
        //
        if (!isPowerOfTwo(this._imageSize)) {
            let outCurrenElevations = new Float32Array(bil16.length);
            //TODO: optimize
            extractElevationTilesNonPowerOfTwo(bil16, outCurrenElevations);
            return outCurrenElevations;
        }
        let elevationsSize = (this.plainGridSize + 1) * (this.plainGridSize + 1);
        let d = 4;
        let outChildrenElevations = new Array(d);
        for (let i = 0; i < d; i++) {
            outChildrenElevations[i] = [];
            for (let j = 0; j < d; j++) {
                outChildrenElevations[i][j] = new Float32Array(elevationsSize);
            }
        }
        let outCurrenElevations = new Float32Array(elevationsSize);
        extractElevationTiles(bil16, this.noDataValues, outCurrenElevations, outChildrenElevations);
        let tileIndex = Layer.getTileIndex(tileX, tileY, tileZoom, tileGroup);
        this.setElevationCache(tileIndex, {
            heights: outCurrenElevations,
            extent: extent
        });
        let dd = this._imageSize / this.plainGridSize;
        for (let i = 0; i < dd; i++) {
            for (let j = 0; j < dd; j++) {
                let x = tileX * 2 + j, y = tileY * 2 + i, z = tileZoom + 1;
                let tileIndex = Layer.getTileIndex(x, y, z, tileGroup);
                this.setElevationCache(tileIndex, {
                    heights: outChildrenElevations[i][j],
                    extent: getTileExtent(x, y, z)
                });
            }
        }
        return outCurrenElevations;
    }
}
function extractElevationTilesNonPowerOfTwo(data, outCurrenElevations) {
    for (let i = 0, len = outCurrenElevations.length; i < len; i++) {
        outCurrenElevations[i] = data[i];
    }
}
function extractElevationTiles(data, noDataValues, outCurrenElevations, outChildrenElevations) {
    let destSize = Math.sqrt(outCurrenElevations.length) - 1;
    let destSizeOne = destSize + 1;
    let sourceSize = Math.sqrt(data.length);
    let dt = sourceSize / destSize;
    let rightHeight = 0, bottomHeight = 0;
    for (let k = 0, currIndex = 0, sourceDataLength = data.length; k < sourceDataLength; k++) {
        let height = data[k];
        let isNoDataCurrent = BilTerrain.checkNoDataValue(noDataValues, height), isNoDataRight = false, isNoDataBottom = false;
        let i = Math.floor(k / sourceSize), j = k % sourceSize;
        let tileX = Math.floor(j / destSize), tileY = Math.floor(i / destSize);
        let destArr = outChildrenElevations[tileY][tileX];
        let ii = i % destSize, jj = j % destSize;
        let destIndex = (ii + tileY) * destSizeOne + jj + tileX;
        destArr[destIndex] = height;
        if ((i + tileY) % dt === 0 && (j + tileX) % dt === 0) {
            outCurrenElevations[currIndex++] = height;
        }
        if ((j + 1) % destSize === 0 && j !== sourceSize - 1) {
            //current tile
            rightHeight = data[k];
            isNoDataRight = BilTerrain.checkNoDataValue(noDataValues, rightHeight);
            let middleHeight = height;
            if (!(isNoDataCurrent || isNoDataRight)) {
                middleHeight = (height + rightHeight) * 0.5;
            }
            destIndex = (ii + tileY) * destSizeOne + jj + 1;
            destArr[destIndex] = middleHeight;
            if ((i + tileY) % dt === 0) {
                outCurrenElevations[currIndex++] = middleHeight;
            }
            //next right tile
            let rightindex = (ii + tileY) * destSizeOne + ((jj + 1) % destSize);
            outChildrenElevations[tileY][tileX + 1][rightindex] = middleHeight;
        }
        if ((i + 1) % destSize === 0 && i !== sourceSize - 1) {
            //current tile
            bottomHeight = data[k + sourceSize];
            isNoDataBottom = BilTerrain.checkNoDataValue(noDataValues, bottomHeight);
            let middleHeight = height;
            if (!(isNoDataCurrent || isNoDataBottom)) {
                middleHeight = (height + bottomHeight) * 0.5;
            }
            destIndex = (ii + 1) * destSizeOne + jj + tileX;
            destArr[destIndex] = middleHeight;
            if ((j + tileX) % dt === 0) {
                outCurrenElevations[currIndex++] = middleHeight;
            }
            //next bottom tile
            let bottomindex = ((ii + 1) % destSize) * destSizeOne + jj + tileX;
            outChildrenElevations[tileY + 1][tileX][bottomindex] = middleHeight;
        }
        if ((j + 1) % destSize === 0 &&
            j !== sourceSize - 1 &&
            (i + 1) % destSize === 0 &&
            i !== sourceSize - 1) {
            //current tile
            let rightBottomHeight = data[k + sourceSize + 1];
            let isNoDataRightBottom = BilTerrain.checkNoDataValue(noDataValues, rightBottomHeight);
            let middleHeight = height;
            if (!(isNoDataCurrent || isNoDataRight || isNoDataBottom || isNoDataRightBottom)) {
                middleHeight = (height + rightHeight + bottomHeight + rightBottomHeight) * 0.25;
            }
            destIndex = (ii + 1) * destSizeOne + (jj + 1);
            destArr[destIndex] = middleHeight;
            outCurrenElevations[currIndex++] = middleHeight;
            //next right tile
            let rightindex = (ii + 1) * destSizeOne;
            outChildrenElevations[tileY][tileX + 1][rightindex] = middleHeight;
            //next bottom tile
            let bottomindex = destSize;
            outChildrenElevations[tileY + 1][tileX][bottomindex] = middleHeight;
            //next right bottom tile
            let rightBottomindex = 0;
            outChildrenElevations[tileY + 1][tileX + 1][rightBottomindex] = middleHeight;
        }
    }
}

/**
 * @class
 * @extends {GlobusTerrain}
 * @param {string} [name=""] - Terrain provider name.
 * @param {IRgbTerrainParams} [options]:
 * @param {boolean} [equalizeNormals=true] - Make normal equalization on the edges of the tiles.
 * @param {string} [key=""] - API key.
 * @param {number} [imageSize=256] - Image size.
 * @param {number} [minHeight=-10000] - Minimal height for rgb to height converter.
 * @param {number} [resolution=0.1] - Height converter resolution.
 */
class RgbTerrain extends GlobusTerrain {
    constructor(name, options = {}) {
        super(name || "RgbTerrain", {
            equalizeVertices: options.equalizeVertices != undefined ? options.equalizeVertices : true,
            maxZoom: options.maxZoom || 17,
            noDataValues: options.noDataValues || [options.minHeight != undefined ? options.minHeight : -10000],
            plainGridSize: options.plainGridSize || 128,
            url: options.url != undefined
                ? options.url
                : `//api.mapbox.com/v4/mapbox.terrain-rgb/{z}/{x}/{y}.pngraw?access_token=${options.key || "<key>"}`,
            gridSizeByZoom: options.gridSizeByZoom || [
                64, 32, 16, 8, 8, 8, 16, 16, 16, 32, 32, 32, 32, 32, 32, 64, 64, 64, 32, 32, 16, 8
            ],
            ...options
        });
        this.equalizeNormals = options.equalizeNormals || false;
        this._dataType = "imageBitmap";
        this._imageSize = options.imageSize || 256;
        this._ctx = this._createTemporalCanvas(this._imageSize);
        this._imageDataCache = {};
        this._minHeight = options.minHeight || -10000.0;
        this._resolution = options.resolution || 0.1;
    }
    static checkNoDataValue(noDataValues, value) {
        if (value > 50000) {
            return true;
        }
        return binarySearchFast(noDataValues, value) !== -1;
    }
    rgb2Height(r, g, b) {
        // Filter for "yellowish" pixels
        if (r === 255) {
            return this._minHeight;
        }
        return this._minHeight + this._resolution * (r * 256 * 256 + g * 256 + b);
    }
    isBlur(segment) {
        return segment.tileZoom >= 16;
    }
    _createTemporalCanvas(size) {
        let canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = size;
        return canvas.getContext("2d", {
            willReadFrequently: true
        });
    }
    _createHeights(data, segment, tileGroup, tileX, tileY, tileZoom, extent, preventChildren) {
        this._ctx.clearRect(0, 0, this._imageSize, this._imageSize);
        this._ctx.drawImage(data, 0, 0);
        let rgbaData = this._ctx.getImageData(0, 0, this._imageSize, this._imageSize).data;
        const SIZE = data.width;
        let availableParentTileX = 0, availableParentTileY = 0, availableParentTileZoom = 0, availableParentData = null, skipPositiveHeights = false;
        //
        // Getting parent segment terrain data, for zero and nodata values for the current segment
        //
        if (segment) {
            if (segment.tileZoom > this.maxNativeZoom) {
                let pn = segment.node;
                while (pn && !pn.segment.terrainExists) {
                    pn = pn.parentNode;
                }
                if (pn) {
                    availableParentTileX = pn.segment.tileX;
                    availableParentTileY = pn.segment.tileY;
                    availableParentTileZoom = pn.segment.tileZoom;
                    availableParentData = pn.segment.elevationData;
                    // in this case maxNativeZoom means sea level
                    skipPositiveHeights = availableParentTileZoom <= 8;
                }
            }
        }
        //
        //Non-power of two images
        //
        if (!isPowerOfTwo(this._imageSize) && SIZE === this._imageSize) {
            let outCurrenElevations = new Float32Array(SIZE * SIZE);
            this.extractElevationTilesRgbNonPowerOfTwo(rgbaData, outCurrenElevations, this._heightFactor);
            return outCurrenElevations;
        }
        //
        // When image size equals grid size
        //
        if (this._imageSize === this.plainGridSize) {
            let elevationsSize = (this.plainGridSize + 1) * (this.plainGridSize + 1);
            let outCurrenElevations = new Float32Array(elevationsSize);
            let [availableParentOffsetX, availableParentOffsetY, availableZoomDiff] = segment ? getTileOffset(segment.tileX, segment.tileY, segment.tileZoom, availableParentTileX, availableParentTileY, availableParentTileZoom) : [0, 0, 0];
            this.extractElevationSimple(rgbaData, this.noDataValues, availableParentData, availableParentOffsetX, availableParentOffsetY, availableZoomDiff, skipPositiveHeights, outCurrenElevations, this._heightFactor, this._imageSize);
            return outCurrenElevations;
        }
        //
        // Power of two images
        //
        let elevationsSize = (this.plainGridSize + 1) * (this.plainGridSize + 1);
        let d = SIZE / this.plainGridSize;
        let outCurrenElevations = new Float32Array(elevationsSize);
        let outChildrenElevations = new Array(d);
        for (let i = 0; i < d; i++) {
            outChildrenElevations[i] = [];
            for (let j = 0; j < d; j++) {
                outChildrenElevations[i][j] = new Float32Array(elevationsSize);
            }
        }
        if (!preventChildren) {
            this.extractElevationTilesRgb(rgbaData, this._heightFactor, this.noDataValues, availableParentData, availableParentTileX, availableParentTileY, availableParentTileZoom, segment ? segment.tileX : 0, segment ? segment.tileY : 0, segment ? segment.tileZoom : 0, skipPositiveHeights, outCurrenElevations, outChildrenElevations);
            // Save children data to cache
            for (let i = 0; i < d; i++) {
                for (let j = 0; j < d; j++) {
                    let [x, y, z] = getChildTileIndex(tileX, tileY, tileZoom, j, i);
                    let tileIndex = Layer.getTileIndex(x, y, z, tileGroup);
                    this.setElevationCache(tileIndex, {
                        heights: outChildrenElevations[i][j],
                        //
                        // @todo: must work for any grids
                        //
                        extent: getTileExtent(x, y, z)
                    });
                }
            }
        }
        else {
            this.extractElevationTilesRgbNoChildren(rgbaData, this._heightFactor, this.noDataValues, availableParentData, availableParentTileX, availableParentTileY, availableParentTileZoom, segment ? segment.tileX : 0, segment ? segment.tileY : 0, segment ? segment.tileZoom : 0, skipPositiveHeights, outCurrenElevations);
        }
        let tileIndex = Layer.getTileIndex(tileX, tileY, tileZoom, tileGroup);
        // Save current data to cache
        this.setElevationCache(tileIndex, {
            heights: outCurrenElevations,
            extent: extent
        });
        return outCurrenElevations;
    }
    getHeightAsync(lonLat, callback, zoom) {
        zoom = zoom != undefined ? zoom : this.maxZoom;
        if (zoom === 0) {
            callback(0);
            return true;
        }
        const qts = this._planet.quadTreeStrategy;
        const [x, y, z, tileGroup] = qts.getTileXY(lonLat, zoom);
        const [i, j] = qts.getLonLatTileOffset(lonLat, x, y, z, this._imageSize);
        const index = (i * this._imageSize + j) * 4;
        const tileIndex = Layer.getTileIndex(x, y, z, tileGroup);
        if (this._imageDataCache[tileIndex]) {
            let data = this._imageDataCache[tileIndex];
            let height = this._heightFactor * this.rgb2Height(data[index], data[index + 1], data[index + 2]);
            let isNoData = RgbTerrain.checkNoDataValue(this.noDataValues, height);
            if (isNoData) {
                return this.getHeightAsync(lonLat, callback, zoom - 1);
            }
            else {
                callback(this._heightFactor * this.rgb2Height(data[index], data[index + 1], data[index + 2]));
                return true;
            }
        }
        let def = this._fetchCache[tileIndex];
        if (!def) {
            def = this._loader.fetch({
                src: this._urlRewriteCallback && this._urlRewriteCallback(x, y, z, tileGroup) || this.buildURL(x, y, z, tileGroup),
                type: this._dataType
            });
            this._fetchCache[tileIndex] = def;
        }
        def.then((response) => {
            if (response.status === "ready") {
                this._ctx.clearRect(0, 0, this._imageSize, this._imageSize);
                this._ctx.drawImage(response.data, 0, 0);
                let data = this._ctx.getImageData(0, 0, 256, 256).data;
                this._imageDataCache[tileIndex] = data;
                let height = this._heightFactor * this.rgb2Height(data[index], data[index + 1], data[index + 2]);
                let isNoData = RgbTerrain.checkNoDataValue(this.noDataValues, height);
                if (isNoData) {
                    return this.getHeightAsync(lonLat, callback, zoom - 1);
                }
                else {
                    callback(this._heightFactor * this.rgb2Height(data[index], data[index + 1], data[index + 2]));
                }
            }
            else if (response.status === "error") {
                return this.getHeightAsync(lonLat, callback, zoom - 1);
            }
            else {
                //@ts-ignore
                this._fetchCache[tileIndex] = null;
                delete this._fetchCache[tileIndex];
            }
        });
        return false;
    }
    extractElevationSimple(rgbaData, noDataValues, availableParentData = null, availableParentOffsetX, availableParentOffsetY, availableZoomDiff, skipPositiveHeights, outCurrenElevations, heightFactor = 1, imageSize) {
        for (let k = 0, len = imageSize * imageSize; k < len; k++) {
            let j = k % imageSize, i = Math.floor(k / imageSize);
            let fromInd4 = k * 4;
            let height = heightFactor * this.rgb2Height(rgbaData[fromInd4], rgbaData[fromInd4 + 1], rgbaData[fromInd4 + 2]);
            let isNoData = RgbTerrain.checkNoDataValue(noDataValues, height);
            if ((isNoData || height === 0) && availableParentData) {
                height = getParentHeight(availableZoomDiff, availableParentOffsetX, availableParentOffsetY, availableParentData, i, j, skipPositiveHeights);
            }
            outCurrenElevations[i * (imageSize + 1) + j] = height;
        }
        for (let i = 0, len = imageSize; i < len; i++) {
            let j = imageSize - 1;
            let fromInd4 = (i * imageSize + j) * 4;
            let height = heightFactor * this.rgb2Height(rgbaData[fromInd4], rgbaData[fromInd4 + 1], rgbaData[fromInd4 + 2]);
            let isNoData = RgbTerrain.checkNoDataValue(noDataValues, height);
            if ((isNoData || height === 0) && availableParentData) {
                height = getParentHeight(availableZoomDiff, availableParentOffsetX, availableParentOffsetY, availableParentData, i, j, skipPositiveHeights);
            }
            outCurrenElevations[i * (imageSize + 1) + imageSize] = height;
        }
        for (let j = 0, len = imageSize; j < len; j++) {
            let i = imageSize - 1;
            let fromInd4 = (i * imageSize + j) * 4;
            let height = heightFactor * this.rgb2Height(rgbaData[fromInd4], rgbaData[fromInd4 + 1], rgbaData[fromInd4 + 2]);
            let isNoData = RgbTerrain.checkNoDataValue(noDataValues, height);
            if ((isNoData || height === 0) && availableParentData) {
                height = getParentHeight(availableZoomDiff, availableParentOffsetX, availableParentOffsetY, availableParentData, i, j, skipPositiveHeights);
            }
            outCurrenElevations[imageSize * (imageSize + 1) + j] = height;
        }
        let height = heightFactor * this.rgb2Height(rgbaData[rgbaData.length - 4], rgbaData[rgbaData.length - 3], rgbaData[rgbaData.length - 2]);
        let isNoData = RgbTerrain.checkNoDataValue(noDataValues, height);
        if ((isNoData || height === 0) && availableParentData) {
            height = getParentHeight(availableZoomDiff, availableParentOffsetX, availableParentOffsetY, availableParentData, imageSize - 1, imageSize - 1, skipPositiveHeights);
        }
        outCurrenElevations[outCurrenElevations.length - 1] = height;
    }
    extractElevationTilesRgbNonPowerOfTwo(rgbaData, outCurrenElevations, heightFactor = 1) {
        for (let i = 0, len = outCurrenElevations.length; i < len; i++) {
            let i4 = i * 4;
            outCurrenElevations[i] = heightFactor * this.rgb2Height(rgbaData[i4], rgbaData[i4 + 1], rgbaData[i4 + 2]);
        }
    }
    extractElevationTilesRgb(rgbaData, heightFactor, noDataValues, availableParentData = null, availableParentTileX, availableParentTileY, availableParentTileZoom, currentTileX, currentTileY, currentTileZoom, skipPositiveHeights, outCurrenElevations, outChildrenElevations) {
        let destSize = Math.sqrt(outCurrenElevations.length) - 1;
        let destSizeOne = destSize + 1;
        let sourceSize = Math.sqrt(rgbaData.length / 4);
        let dt = sourceSize / destSize;
        let rightHeight = 0, bottomHeight = 0, sourceSize4 = 0;
        let [availableParentOffsetX, availableParentOffsetY, availableZoomDiff] = getTileOffset(currentTileX, currentTileY, currentTileZoom, availableParentTileX, availableParentTileY, availableParentTileZoom);
        for (let k = 0, currIndex = 0, sourceDataLength = rgbaData.length / 4; k < sourceDataLength; k++) {
            let k4 = k * 4;
            let height = heightFactor * this.rgb2Height(rgbaData[k4], rgbaData[k4 + 1], rgbaData[k4 + 2]);
            let isNoDataCurrent = RgbTerrain.checkNoDataValue(noDataValues, height), isNoDataRight = false, isNoDataBottom = false;
            let i = Math.floor(k / sourceSize), j = k % sourceSize;
            //
            // Try to get current height from the parent data
            if ((isNoDataCurrent || height === 0) && availableParentData) {
                height = getParentHeight(availableZoomDiff, availableParentOffsetX, availableParentOffsetY, availableParentData, Math.floor(i / dt), Math.floor(j / dt), skipPositiveHeights);
            }
            let tileX = Math.floor(j / destSize), tileY = Math.floor(i / destSize);
            let destArr = outChildrenElevations[tileY][tileX];
            let ii = i % destSize, jj = j % destSize;
            let destIndex = (ii + tileY) * destSizeOne + jj + tileX;
            destArr[destIndex] = height;
            if ((i + tileY) % dt === 0 && (j + tileX) % dt === 0) {
                outCurrenElevations[currIndex++] = height;
            }
            if ((j + 1) % destSize === 0 && j !== sourceSize - 1) {
                //current tile
                rightHeight = heightFactor * this.rgb2Height(rgbaData[k4 + 4], rgbaData[k4 + 5], rgbaData[k4 + 6]);
                isNoDataRight = RgbTerrain.checkNoDataValue(noDataValues, rightHeight);
                //
                // Try to get right height from the parent data
                if ((isNoDataRight || rightHeight === 0) && availableParentData) {
                    rightHeight = getParentHeight(availableZoomDiff, availableParentOffsetX, availableParentOffsetY, availableParentData, Math.floor(i / dt), Math.floor((j + 1) / dt), skipPositiveHeights);
                }
                let middleHeight = height;
                if (!(isNoDataCurrent || isNoDataRight)) {
                    middleHeight = (height + rightHeight) * 0.5;
                }
                destIndex = (ii + tileY) * destSizeOne + jj + 1;
                destArr[destIndex] = middleHeight;
                if ((i + tileY) % dt === 0) {
                    outCurrenElevations[currIndex++] = middleHeight;
                }
                //next right tile
                let rightindex = (ii + tileY) * destSizeOne + ((jj + 1) % destSize);
                outChildrenElevations[tileY][tileX + 1][rightindex] = middleHeight;
            }
            if ((i + 1) % destSize === 0 && i !== sourceSize - 1) {
                //current tile
                sourceSize4 = sourceSize * 4;
                bottomHeight = heightFactor * this.rgb2Height(rgbaData[k4 + sourceSize4], rgbaData[k4 + sourceSize4 + 1], rgbaData[k4 + sourceSize4 + 2]);
                isNoDataBottom = RgbTerrain.checkNoDataValue(noDataValues, bottomHeight);
                //
                // Try to get bottom height from the parent data
                if ((isNoDataBottom || bottomHeight === 0) && availableParentData) {
                    bottomHeight = getParentHeight(availableZoomDiff, availableParentOffsetX, availableParentOffsetY, availableParentData, Math.floor((i + 1) / dt), Math.floor(j / dt), skipPositiveHeights);
                }
                let middleHeight = (height + bottomHeight) * 0.5;
                if (!(isNoDataCurrent || isNoDataBottom)) {
                    middleHeight = (height + bottomHeight) * 0.5;
                }
                destIndex = (ii + 1) * destSizeOne + jj + tileX;
                destArr[destIndex] = middleHeight;
                if ((j + tileX) % dt === 0) {
                    outCurrenElevations[currIndex++] = middleHeight;
                }
                //next bottom tile
                let bottomindex = ((ii + 1) % destSize) * destSizeOne + jj + tileX;
                outChildrenElevations[tileY + 1][tileX][bottomindex] = middleHeight;
            }
            if ((j + 1) % destSize === 0 && j !== sourceSize - 1 &&
                (i + 1) % destSize === 0 && i !== sourceSize - 1) {
                //current tile
                let rightBottomHeight = heightFactor * this.rgb2Height(rgbaData[k4 + sourceSize4 + 4], rgbaData[k4 + sourceSize4 + 5], rgbaData[k4 + sourceSize4 + 6]);
                let isNoDataRightBottom = RgbTerrain.checkNoDataValue(noDataValues, rightBottomHeight);
                //
                // Try to get right bottom height from the parent data
                if ((isNoDataRightBottom || rightBottomHeight === 0) && availableParentData) {
                    rightBottomHeight = getParentHeight(availableZoomDiff, availableParentOffsetX, availableParentOffsetY, availableParentData, Math.floor((i + 1) / dt), Math.floor((j + 1) / dt), skipPositiveHeights);
                }
                let middleHeight = height;
                if (!(isNoDataCurrent || isNoDataRight || isNoDataBottom || isNoDataRightBottom)) {
                    middleHeight = (height + rightHeight + bottomHeight + rightBottomHeight) * 0.25;
                }
                destIndex = (ii + 1) * destSizeOne + (jj + 1);
                destArr[destIndex] = middleHeight;
                outCurrenElevations[currIndex++] = middleHeight;
                //next right tile
                let rightindex = (ii + 1) * destSizeOne;
                outChildrenElevations[tileY][tileX + 1][rightindex] = middleHeight;
                //next bottom tile
                let bottomindex = destSize;
                outChildrenElevations[tileY + 1][tileX][bottomindex] = middleHeight;
                //next right bottom tile
                let rightBottomindex = 0;
                outChildrenElevations[tileY + 1][tileX + 1][rightBottomindex] = middleHeight;
            }
        }
    }
    extractElevationTilesRgbNoChildren(rgbaData, heightFactor, noDataValues, availableParentData = null, availableParentTileX, availableParentTileY, availableParentTileZoom, currentTileX, currentTileY, currentTileZoom, skipPositiveHeights, outCurrenElevations) {
        let destSize = Math.sqrt(outCurrenElevations.length) - 1;
        let destSizeOne = destSize + 1;
        let sourceSize = Math.sqrt(rgbaData.length / 4);
        let dt = sourceSize / destSize;
        let rightHeight = 0, bottomHeight = 0, sourceSize4 = 0;
        let [availableParentOffsetX, availableParentOffsetY, availableZoomDiff] = getTileOffset(currentTileX, currentTileY, currentTileZoom, availableParentTileX, availableParentTileY, availableParentTileZoom);
        for (let k = 0, currIndex = 0, sourceDataLength = rgbaData.length / 4; k < sourceDataLength; k++) {
            let k4 = k * 4;
            let height = heightFactor * this.rgb2Height(rgbaData[k4], rgbaData[k4 + 1], rgbaData[k4 + 2]);
            let isNoDataCurrent = RgbTerrain.checkNoDataValue(noDataValues, height), isNoDataRight = false, isNoDataBottom = false;
            let i = Math.floor(k / sourceSize), j = k % sourceSize;
            if ((isNoDataCurrent || height === 0) && availableParentData) {
                height = getParentHeight(availableZoomDiff, availableParentOffsetX, availableParentOffsetY, availableParentData, Math.floor(currIndex / destSizeOne), currIndex % destSizeOne, skipPositiveHeights);
            }
            let tileX = Math.floor(j / destSize), tileY = Math.floor(i / destSize);
            if ((i + tileY) % dt === 0 && (j + tileX) % dt === 0) {
                outCurrenElevations[currIndex++] = height;
            }
            if ((j + 1) % destSize === 0 && j !== sourceSize - 1) {
                //current tile
                rightHeight = heightFactor * this.rgb2Height(rgbaData[k4 + 4], rgbaData[k4 + 5], rgbaData[k4 + 6]);
                isNoDataRight = RgbTerrain.checkNoDataValue(noDataValues, rightHeight);
                if ((isNoDataRight || rightHeight === 0) && availableParentData) {
                    rightHeight = getParentHeight(availableZoomDiff, availableParentOffsetX, availableParentOffsetY, availableParentData, Math.floor(currIndex / destSizeOne), currIndex % destSizeOne, skipPositiveHeights);
                }
                let middleHeight = height;
                if (!(isNoDataCurrent || isNoDataRight)) {
                    middleHeight = (height + rightHeight) * 0.5;
                }
                if ((i + tileY) % dt === 0) {
                    outCurrenElevations[currIndex++] = middleHeight;
                }
            }
            if ((i + 1) % destSize === 0 && i !== sourceSize - 1) {
                //current tile
                sourceSize4 = sourceSize * 4;
                bottomHeight = heightFactor * this.rgb2Height(rgbaData[k4 + sourceSize4], rgbaData[k4 + sourceSize4 + 1], rgbaData[k4 + sourceSize4 + 2]);
                isNoDataBottom = RgbTerrain.checkNoDataValue(noDataValues, bottomHeight);
                if ((isNoDataBottom || bottomHeight === 0) && availableParentData) {
                    bottomHeight = getParentHeight(availableZoomDiff, availableParentOffsetX, availableParentOffsetY, availableParentData, Math.floor(currIndex / destSizeOne), currIndex % destSizeOne, skipPositiveHeights);
                }
                let middleHeight = (height + bottomHeight) * 0.5;
                if (!(isNoDataCurrent || isNoDataBottom)) {
                    middleHeight = (height + bottomHeight) * 0.5;
                }
                if ((j + tileX) % dt === 0) {
                    outCurrenElevations[currIndex++] = middleHeight;
                }
            }
            if ((j + 1) % destSize === 0 && j !== sourceSize - 1 &&
                (i + 1) % destSize === 0 && i !== sourceSize - 1) {
                //current tile
                let rightBottomHeight = heightFactor * this.rgb2Height(rgbaData[k4 + sourceSize4 + 4], rgbaData[k4 + sourceSize4 + 5], rgbaData[k4 + sourceSize4 + 6]);
                let isNoDataRightBottom = RgbTerrain.checkNoDataValue(noDataValues, rightBottomHeight);
                if ((isNoDataRightBottom || rightBottomHeight === 0) && availableParentData) {
                    rightBottomHeight = getParentHeight(availableZoomDiff, availableParentOffsetX, availableParentOffsetY, availableParentData, Math.floor(currIndex / destSizeOne), currIndex % destSizeOne, skipPositiveHeights);
                }
                let middleHeight = height;
                if (!(isNoDataCurrent || isNoDataRight || isNoDataBottom || isNoDataRightBottom)) {
                    middleHeight = (height + rightHeight + bottomHeight + rightBottomHeight) * 0.25;
                }
                outCurrenElevations[currIndex++] = middleHeight;
            }
        }
    }
}
function getTileOffset(currentTileX, currentTileY, currentTileZoom, parentTileX, parentTileY, parentTileZoom) {
    let dz2 = 2 << (currentTileZoom - parentTileZoom - 1);
    return [currentTileX - dz2 * parentTileX, currentTileY - dz2 * parentTileY, 1.0 / dz2];
}
function getChildTileIndex(currentParentTileX, currentParentTileY, currentParentTileZoom, childOffsetX, childOffsetY) {
    return [currentParentTileX * 2 + childOffsetX, currentParentTileY * 2 + childOffsetY, currentParentTileZoom + 1];
}
function getParentHeight(oneByDz2, offsetX, offsetY, heights, i, j, skipPositiveHeights) {
    let parentGridSize = Math.sqrt(heights.length);
    let pi = Math.floor(offsetY * oneByDz2 * parentGridSize + i * oneByDz2), pj = Math.floor(offsetX * oneByDz2 * parentGridSize + j * oneByDz2);
    let h = heights[pi * parentGridSize + pj];
    return skipPositiveHeights ? (h > 0 ? 0 : h) : h;
}

const urlPref = {
    [TILEGROUP_NORTH]: "north",
    [TILEGROUP_SOUTH]: "south"
};
const urlRewriteFunc = (tileX, tileY, tileZoom, tileGroup) => {
    let g = urlPref[tileGroup];
    if (g)
        return `https://terrain.openglobus.org/poles/${g}/${tileZoom}/${tileX}/${tileY}.png`;
};
class GlobusRgbTerrain extends RgbTerrain {
    constructor(name, options) {
        super(name || "GlobusEarthRgb", {
            maxNativeZoom: 6,
            maxZoom: 17,
            url: "https://{s}.terrain.openglobus.org/all/{z}/{x}/{y}.png",
            urlRewrite: urlRewriteFunc,
            ...options
        });
    }
    isReadyToLoad(segment) {
        return this._extent.overlaps(segment.getExtentLonLat());
    }
}

var index$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BilTerrain: BilTerrain,
    EmptyTerrain: EmptyTerrain,
    GlobusRgbTerrain: GlobusRgbTerrain,
    GlobusTerrain: GlobusTerrain,
    RgbTerrain: RgbTerrain
});

/**
 * Used to load and display a single image over specific corner coordinates on the globe.
 * @class
 * @extends {BaseGeoImage}
 */
class GeoImage extends BaseGeoImage {
    constructor(name, options = {}) {
        super(name, options);
        this._image = options.image || null;
        this._src = options.src || null;
        this._onLoad_ = null;
    }
    get instanceName() {
        return "GeoImage";
    }
    abortLoading() {
        if (this._image instanceof HTMLImageElement) {
            this._image.src = "";
        }
    }
    /**
     * Sets image source url path.
     * @public
     * @param {string} srs - Image url path.
     */
    setSrc(src) {
        this._planet && this._planet._geoImageCreator.remove(this);
        this._src = src;
        this._sourceReady = false;
        this._sourceCreated = false;
        this._image = new Image();
        this._image.crossOrigin = "Anonymous";
        this._onLoad_ = this._onLoad.bind(this);
        this._image.addEventListener("load", this._onLoad_);
        this._image.src = src;
    }
    /**
     * Sets image object.
     * @public
     * @param {Image} image - Image object.
     */
    setImage(image) {
        this._planet && this._planet._geoImageCreator.remove(this);
        this._sourceCreated = false;
        this._sourceReady = false;
        this._image = image;
        this._image.crossOrigin = "Anonymous";
        this._src = image.src;
        if (isImageLoaded(this._image)) {
            this._applyImage(this._image);
        }
        else {
            this._onLoad_ = this._onLoad.bind(this);
            this._image.addEventListener("load", this._onLoad_);
        }
    }
    /**
     * Creates source gl texture.
     * @virtual
     * @protected
     */
    _createSourceTexture() {
        if (!this._sourceCreated && this._image) {
            this._sourceTexture = this._planet.renderer.handler.createTexture_l(this._image);
            this._sourceCreated = true;
        }
    }
    _onLoad(ev) {
        this._applyImage(this._image);
        if (this._image instanceof HTMLImageElement) {
            this._image.removeEventListener("load", this._onLoad_);
        }
        this._onLoad_ = null;
    }
    _applyImage(img) {
        if (img) {
            this._frameWidth = nextHighestPowerOfTwo(img.width * 2, 4096);
            this._frameHeight = nextHighestPowerOfTwo(img.height * 3, 4096);
            this._sourceReady = true;
            if (this._planet) {
                this._planet._geoImageCreator.add(this);
            }
        }
    }
    /**
     * Loads planet segment material. In this case - GeoImage source image.
     * @public
     * @param {Material} material - GeoImage planet material.
     */
    loadMaterial(material) {
        material.isLoading = true;
        this._creationProceeding = true;
        if (!this._sourceReady && this._src) {
            if (this._image) {
                if (this._image instanceof HTMLImageElement) {
                    if (isImageLoaded(this._image)) {
                        this._applyImage(this._image);
                    }
                    else {
                        this._onLoad_ = this._onLoad.bind(this);
                        this._image.addEventListener("load", this._onLoad_);
                    }
                }
            }
            else {
                this._image = new Image();
                this._image.crossOrigin = "Anonymous";
                this._onLoad_ = this._onLoad.bind(this);
                this._image.addEventListener("load", this._onLoad_);
                this._image.src = this._src;
            }
        }
        else if (this._planet) {
            this._planet._geoImageCreator.add(this);
        }
    }
    /**
     * @public
     * @param {Material} material - GeoImage material.
     */
    abortMaterialLoading(material) {
        if (this._image && this._image instanceof HTMLImageElement) {
            this._image.src = "";
        }
        this._creationProceeding = false;
        material.isLoading = false;
        material.isReady = false;
    }
}

class GeoTexture2d extends BaseGeoImage {
    constructor(name, options = {}) {
        super(name, options);
        this._sourceTexture = options.texture || null;
        if (options.texture) {
            this._sourceReady = true;
            this._sourceCreated = true;
        }
        this._frameWidth = options.frameWidth != undefined ? nextHighestPowerOfTwo(options.frameWidth) : 256;
        this._frameHeight = options.frameHeight != undefined ? nextHighestPowerOfTwo(options.frameHeight) : 256;
        this._animate = true;
    }
    get instanceName() {
        return "GeoTexture2d";
    }
    loadMaterial(material) {
        this._planet._geoImageCreator.add(this);
    }
    bindTexture(texture) {
        this._sourceReady = true;
        this._sourceCreated = true;
        this._sourceTexture = texture;
    }
    setSize(width, height) {
        this._frameWidth = width;
        this._frameHeight = height;
        this._frameCreated = false;
    }
    abortMaterialLoading(material) {
        this._creationProceeding = false;
        material.isLoading = false;
        material.isReady = false;
    }
}

/**
 * Used to load and display a video stream by specific corners coordinates on the globe.
 * @class
 * @extends {BaseGeoImage}
 */
class GeoVideo extends BaseGeoImage {
    constructor(name, options = {}) {
        super(name, options);
        this._animate = true;
        this._video = options.videoElement || null;
        this._src = options.src || null;
    }
    get instanceName() {
        return "GeoVideo";
    }
    /**
     * Sets video source url path.
     * @public
     * @param {string} src - Video url path.
     */
    setSrc(src) {
        this._planet && this._planet._geoImageCreator.remove(this);
        this._src = src;
        this._sourceReady = false;
    }
    /**
     * Sets HTML5 video object.
     * @public
     * @param {HTMLVideoElement} video - HTML5 video element object.
     */
    setVideoElement(video) {
        this._planet && this._planet._geoImageCreator.remove(this);
        this._video = video;
        this._src = video.src;
        this._sourceReady = false;
    }
    /**
     * Sets layer visibility.
     * @public
     * @param {boolean} visibility - Layer visibility.
     */
    setVisibility(visibility) {
        if (visibility != this._visibility) {
            super.setVisibility(visibility);
            if (this._planet) {
                if (visibility) {
                    this._sourceReady && this._planet._geoImageCreator.add(this);
                    this._video && this._video.play();
                }
                else {
                    this._sourceReady && this._planet._geoImageCreator.remove(this);
                    this._video && this._video.pause();
                }
            }
        }
    }
    /**
     * Creates or refresh source video GL texture.
     * @virtual
     * @protected
     */
    _createSourceTexture() {
        let gl = this._planet.renderer.handler.gl;
        if (this._sourceCreated) {
            gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._video);
        }
        else {
            this._sourceTexture = this._planet.renderer.handler.createTexture_n_webgl1(this._video);
            this._sourceCreated = true;
        }
    }
    /**
     * @private
     */
    _onCanPlay(video) {
        this._frameWidth = video.videoWidth;
        this._frameHeight = video.videoHeight;
        video.width = video.videoWidth;
        video.height = video.videoHeight;
        video.play();
        this._sourceReady = true;
        this._planet._geoImageCreator.add(this);
    }
    _onError(video) {
        let err = "unknown error";
        switch (video.error.code) {
            case 1:
                err = "video loading aborted";
                break;
            case 2:
                err = "network loading error";
                break;
            case 3:
                err = "video decoding failed / corrupted data or unsupported codec";
                break;
            case 4:
                err = "video not supported";
                break;
        }
        console.warn(`Error: ${err} error-code=${video.error.code})`);
    }
    /**
     * Loads planet segment material. In this case - GeoImage source video.
     * @public
     * @param {Material} material - GeoImage planet material.
     */
    loadMaterial(material) {
        material.isLoading = true;
        this._creationProceeding = true;
        if (!this._sourceReady && this._src) {
            if (this._video) {
                if (this._video.readyState === this._video.HAVE_ENOUGH_DATA) {
                    this._onCanPlay(this._video);
                }
                else if (this._video.src) {
                    let that = this;
                    this._video.addEventListener("canplay", function (e) {
                        that._onCanPlay(this);
                    });
                }
            }
            else {
                this._video = document.createElement("video");
                this._video.crossOrigin = "Anonymous";
                let that = this;
                this._video.addEventListener("canplay", function () {
                    that._onCanPlay(this);
                });
                this._video.addEventListener("error", function () {
                    that._onError(this);
                });
            }
            this._video.autoplay = true;
            this._video.loop = true;
            this._video.src = this._src;
            this._video.muted = true;
            this._video.setAttribute("playsinline", "true");
            this._video.setAttribute("webkit-playsinline", "true");
        }
        else {
            this._planet._geoImageCreator.add(this);
        }
    }
    /**
     * @virtual
     * @param {Material} material - GeoImage material.
     */
    abortMaterialLoading(material) {
        this._video && (this._video.src = "");
        this._creationProceeding = false;
        material.isLoading = false;
        material.isReady = false;
    }
}

/**
 * Layer to render KMLs files
 * @class
 * @extends {Vector}
 * @param {string} name
 * @param {*} [options]
 */
class KML extends Vector {
    constructor(name, options = {}) {
        super(name, options);
        this._billboard = options.billboard || {
            src: "https://openglobus.org/examples/billboards/carrot.png"
        };
        this._color = options.color || "#6689db";
    }
    get instanceName() {
        return "KML";
    }
    _extractCoordonatesFromKml(xmlDoc) {
        const raw = Array.from(xmlDoc.getElementsByTagName("coordinates"));
        const rawText = raw.map(item => item.textContent.trim());
        const coordinates = rawText.map(item => item
            .replace(/\n/g, " ")
            .replace(/\t/g, " ")
            .replace(/ +/g, " ")
            .split(" ")
            .map((co) => co.split(",").map(parseFloat)));
        return coordinates;
    }
    _AGBRtoRGBA(agbr) {
        if (!agbr || agbr.length != 8)
            return;
        const a = parseInt(agbr.slice(0, 2), 16) / 255;
        const b = parseInt(agbr.slice(2, 4), 16);
        const g = parseInt(agbr.slice(4, 6), 16);
        const r = parseInt(agbr.slice(6, 8), 16);
        return `rgba(${r},${g},${b},${a})`;
    }
    /**
     * @protected
     returns array of longitude, latitude, altitude (altitude optional)
     */
    _parseKMLcoordinates(coords) {
        const coordinates = coords.innerHTML.trim()
            .replace(/\n/g, ' ')
            .replace(/\t/g, ' ')
            .replace(/ +/g, ' ')
            .split(" ")
            .map((co) => co.split(",").map(parseFloat));
        return coordinates;
    }
    _kmlPlacemarkToEntity(placemark, extent) {
        if (!placemark)
            return;
        const nameTags = Array.from(placemark.getElementsByTagName("name"));
        const name = nameTags && nameTags.length > 0 ? nameTags[0].innerHTML.trim() : '';
        const { iconHeading, iconURL, iconColor, lineWidth, lineColor } = this._extractStyle(placemark);
        // TODO handle MultiGeometry
        const lonLats = [];
        for (const coord of placemark.getElementsByTagName("coordinates")) {
            const coordinates = this._parseKMLcoordinates(coord) || [[0, 0, 0]];
            for (const lonlatalt of coordinates) {
                const [lon, lat, alt] = lonlatalt;
                lonLats.push(new LonLat(lon, lat, alt));
                if (lon < extent.southWest.lon)
                    extent.southWest.lon = lon;
                if (lat < extent.southWest.lat)
                    extent.southWest.lat = lat;
                if (lon > extent.northEast.lon)
                    extent.northEast.lon = lon;
                if (lat > extent.northEast.lat)
                    extent.northEast.lat = lat;
            }
        }
        if (lonLats.length === 1) {
            const hdgrad = iconHeading * 0.01745329; // radians
            return new Entity({
                name,
                lonlat: lonLats[0],
                billboard: {
                    src: iconURL,
                    size: [24, 24],
                    color: iconColor,
                    rotation: hdgrad
                },
                properties: {
                    color: iconColor,
                    heading: iconHeading
                }
            });
        }
        else {
            return new Entity({
                polyline: {
                    pathLonLat: [lonLats],
                    thickness: lineWidth,
                    color: lineColor,
                    isClosed: false
                }
            });
        }
    }
    _extractStyle(placemark) {
        let iconColor;
        let iconHeading;
        let iconURL;
        let lineColor;
        let lineWidth;
        const style = placemark.getElementsByTagName("Style")[0];
        if (style) {
            let iconstyle = style.getElementsByTagName("IconStyle")[0];
            if (iconstyle) {
                let color = iconstyle.getElementsByTagName("color")[0];
                if (color)
                    iconColor = this._AGBRtoRGBA(color.innerHTML.trim());
                let heading = iconstyle.getElementsByTagName("heading")[0];
                if (heading) {
                    const hdg = parseFloat(heading.innerHTML.trim());
                    if (hdg >= 0 && hdg <= 360)
                        iconHeading = hdg % 360;
                }
                let icon = iconstyle.getElementsByTagName("Icon")[0];
                if (icon) {
                    let href = icon.getElementsByTagName("href")[0];
                    if (href) {
                        iconURL = href.innerHTML.trim();
                    }
                }
            }
            let linestyle = style.getElementsByTagName("LineStyle")[0];
            if (linestyle) {
                let color = linestyle.getElementsByTagName("color")[0];
                if (color)
                    lineColor = this._AGBRtoRGBA(color.innerHTML.trim());
                let width = linestyle.getElementsByTagName("width")[0];
                if (width !== undefined)
                    lineWidth = parseFloat(width.innerHTML.trim());
            }
        }
        if (!iconColor)
            iconColor = "#FFFFFF";
        if (!iconHeading)
            iconHeading = 0;
        if (!iconURL)
            iconURL = "https://openglobus.org/examples/billboards/carrot.png";
        if (!lineColor)
            lineColor = "#FFFFFF";
        if (!lineWidth)
            lineWidth = 1;
        return { iconHeading, iconURL, iconColor, lineWidth, lineColor };
    }
    _parseKML(xml, extent, entities) {
        if (!entities)
            entities = [];
        if (xml.documentElement.nodeName !== "kml")
            return entities;
        for (const placemark of xml.getElementsByTagName("Placemark")) {
            const entity = this._kmlPlacemarkToEntity(placemark, extent);
            if (entity)
                entities.push(entity);
        }
        return entities;
    }
    _convertKMLintoEntities(xml) {
        const extent = new Extent(new LonLat(180.0, 90.0), new LonLat(-180.0, -90.0));
        const entities = this._parseKML(xml, extent);
        return { entities, extent };
    }
    /**
     * Creates billboards or polylines from array of lonlat.
     * @protected
     * @param {Array} coordonates
     * @param {string} color
     * @returns {any}
     */
    _convertCoordonatesIntoEntities(coordinates, color, billboard) {
        const extent = new Extent(new LonLat(180.0, 90.0), new LonLat(-180.0, -90.0));
        const addToExtent = (c) => {
            const lon = c[0], lat = c[1];
            if (lon < extent.southWest.lon)
                extent.southWest.lon = lon;
            if (lat < extent.southWest.lat)
                extent.southWest.lat = lat;
            if (lon > extent.northEast.lon)
                extent.northEast.lon = lon;
            if (lat > extent.northEast.lat)
                extent.northEast.lat = lat;
        };
        const _pathes = [];
        coordinates.forEach((kmlFile) => kmlFile.forEach((p) => _pathes.push(p)));
        const entities = _pathes.map((path) => {
            if (path.length === 1) {
                const lonlat = path[0];
                const _entity = new Entity({ lonlat, billboard });
                addToExtent(lonlat);
                return _entity;
            }
            else if (path.length > 1) {
                const pathLonLat = path.map((item) => {
                    addToExtent(item);
                    return new LonLat(item[0], item[1], item[2]);
                });
                const _entity = new Entity({
                    polyline: { pathLonLat: [pathLonLat], thickness: 3, color, isClosed: false }
                });
                return _entity;
            }
        });
        return { entities, extent };
    }
    /**
     * @protected
     * @returns {Document}
     */
    _getXmlContent(file) {
        return new Promise((resolve) => {
            const fileReader = new FileReader();
            fileReader.onload = async (i) => resolve(new DOMParser().parseFromString(i.target.result, "text/xml"));
            fileReader.readAsText(file);
        });
    }
    _expandExtents(extent1, extent2) {
        if (!extent1)
            return extent2;
        if (extent2.southWest.lon < extent1.southWest.lon)
            extent1.southWest.lon = extent2.southWest.lon;
        if (extent2.southWest.lat < extent1.southWest.lat)
            extent1.southWest.lat = extent2.southWest.lat;
        if (extent2.northEast.lon > extent1.northEast.lon)
            extent1.northEast.lon = extent2.northEast.lon;
        if (extent2.northEast.lat > extent1.northEast.lat)
            extent1.northEast.lat = extent2.northEast.lat;
        return extent1;
    }
    /**
     * @public
     * @param {File[]} kmls
     * @param {string} [color]
     * @param {Billboard} [billboard]
     * @returns {Promise<{entities: Entity[], extent: Extent}>}
     */
    async addKmlFromFiles(kmls, color, billboard) {
        if (!Array.isArray(kmls))
            return null;
        const kmlObjs = await Promise.all(kmls.map(this._getXmlContent));
        const coordonates = kmlObjs.map(this._extractCoordonatesFromKml);
        const { entities, extent } = this._convertCoordonatesIntoEntities(coordonates, color || this._color, billboard || this._billboard);
        this._extent = this._expandExtents(this._extent, extent);
        entities.forEach(this.add.bind(this));
        return { entities, extent };
    }
    /**
     * @param {string} color
     * @public
     */
    setColor(color) {
        this._color = color;
        this._billboard.color = color;
    }
    _getKmlFromUrl(url) {
        return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            request.open("GET", url, true);
            request.responseType = "document";
            request.overrideMimeType("text/xml");
            request.onload = () => {
                if (request.readyState === request.DONE && request.status === 200) {
                    resolve(request.responseXML);
                }
                else {
                    reject(new Error("no valid kml file"));
                }
            };
            request.send();
        });
    }
    /**
     * @public
     * @param {string} url - Url of the KML to display. './myFile.kml' or 'http://mySite/myFile.kml' for example.
     * @param {string} [color]
     * @param {Billboard} [billboard]
     * @returns {Promise<{entities: Entity[], extent: Extent}>}
     */
    async addKmlFromUrl(url, color, billboard) {
        const kml = await this._getKmlFromUrl(url);
        /*
                const coordonates = this._extractCoordonatesFromKml(kml);
                const { entities, extent } = this._convertCoordonatesIntoEntities(
                    [coordonates],
                    color || this._color,
                    billboard || this._billboard
                );
        */
        const { entities, extent } = this._convertKMLintoEntities(kml);
        this._extent = this._expandExtents(this._extent, extent);
        entities.forEach(this.add.bind(this));
        return { entities, extent };
    }
}

class OpenStreetMap extends XYZ {
    constructor(name, options = {}) {
        super(name || "OpenStreetMap", {
            iconSrc: "https://tile.openstreetmap.org/8/138/95.png",
            url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
            attribution: 'Data @ OpenStreetMap contributors, ODbL',
            isBaseLayer: true,
            maxNativeZoom: 19,
            defaultTextures: [{ color: "#AAD3DF" }, { color: "#F2EFE9" }],
            isSRGB: false,
            shininess: 18,
            specular: [0.00063, 0.00055, 0.00032],
            ambient: [0.2, 0.2, 0.3],
            diffuse: [0.9, 0.9, 0.7],
            ...options
        });
    }
}

function toQuadKey(x, y, z) {
    var index = '';
    for (let i = z; i > 0; i--) {
        var b = 0;
        var mask = 1 << (i - 1);
        if ((x & mask) !== 0)
            b++;
        if ((y & mask) !== 0)
            b += 2;
        index += b.toString();
    }
    return index;
}
class Bing extends XYZ {
    constructor(name, options = {}) {
        super(name || "Bing", {
            iconSrc: "https://ecn.t0.tiles.virtualearth.net/tiles/a120.jpeg?n=z&g=7146",
            subdomains: ['t0', 't1', 't2', 't3'],
            url: "https://ecn.{s}.tiles.virtualearth.net/tiles/a{quad}.jpeg?n=z&g=7146",
            isBaseLayer: true,
            textureFilter: "LINEAR",
            maxNativeZoom: 17,
            defaultTextures: [{ color: "#001522" }, { color: "#E4E6F3" }],
            attribution: `<div style="transform: scale(0.8); margin-top:-2px;"><a href="https://www.bing.com" target="_blank"><img style="position: relative; top: 2px;" title="Bing Imagery" src="https://sandcastle.cesium.com/CesiumUnminified/Assets/Images/bing_maps_credit.png"></a> ¬© 2021 Microsoft Corporation</div>`,
            urlRewrite: (s, u) => {
                return stringTemplate(u, {
                    's': this._getSubdomain(),
                    'quad': toQuadKey(s.tileX, s.tileY, s.tileZoom)
                });
            },
            specular: [0.00063, 0.00055, 0.00032],
            ambient: "rgb(90,90,90)",
            diffuse: "rgb(350,350,350)",
            shininess: 20,
            nightTextureCoefficient: 2.7,
            ...options
        });
    }
}

var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Bing: Bing,
    CanvasTiles: CanvasTiles,
    GeoImage: GeoImage,
    GeoTexture2d: GeoTexture2d,
    GeoVideo: GeoVideo,
    KML: KML,
    LAYER_EVENTS: LAYER_EVENTS,
    Layer: Layer,
    Material: Material,
    OpenStreetMap: OpenStreetMap,
    Vector: Vector,
    WMS: WMS,
    XYZ: XYZ
});

const CLOCK_EVENTS = ["tick", "end", "start", "stop"];
/**
 * Class represents application timer that stores custom current julian datetime, and time speed multiplier.
 * @class
 * @param {Object} [params] - Clock parameters:
 * @param {JulianDate} [params.startDate=0.0] - Julian start date.
 * @param {JulianDate} [params.endDate=0.0] - Julian end date.
 * @param {JulianDate} [params.currentDate] - Julian current date. Default: current date.
 * @param {number} [params.multiplier=1.0] - Time speed multiplier.
 */
class Clock {
    constructor(params = {}) {
        this.__handler = null;
        /**
         * Timer activity.
         * @public
         * @type {boolean}
         */
        this.active = true;
        this.__id = Clock.__counter__++;
        this.events = createEvents(CLOCK_EVENTS, this);
        this.name = params.name || "";
        this.startDate = params.startDate || 0;
        this.endDate = params.endDate || 0;
        let currentDate = params.currentDate || DateToUTC(new Date());
        if (params.startDate && currentDate < params.startDate) {
            currentDate = params.startDate;
        }
        if (params.endDate && currentDate > params.endDate) {
            currentDate = params.endDate;
        }
        this.currentDate = currentDate;
        this._multiplier = params.multiplier !== undefined ? params.multiplier : 1.0;
        this._running = 1;
        this.deltaTicks = 0;
        this.active = true;
        this._intervalDelay = 0;
        this._intervalStart = 0;
        this._intervalCallback = null;
    }
    clearInterval() {
        this._intervalDelay = 0;
        this._intervalStart = 0;
        this._intervalCallback = null;
    }
    setInterval(delay, callback) {
        this._intervalStart = this.currentDate;
        this._intervalDelay = delay * ONE_BY_MILLISECONDS_PER_DAY;
        this._intervalCallback = callback;
    }
    /**
     * Sets current clock datetime.
     * @public
     * @param {Object} date - JavaScript Date object.
     */
    setDate(date) {
        let d = DateToUTC(date);
        if (this.startDate && d < this.startDate) {
            d = this.startDate;
        }
        if (this.endDate && d > this.endDate) {
            d = this.endDate;
        }
        this.currentDate = d;
    }
    /**
     * Returns current application date.
     * @public
     * @returns {Date} - Current date.
     */
    getDate() {
        return UTCtoDate(this.currentDate);
    }
    reset() {
        if (this.startDate) {
            this.currentDate = this.startDate;
        }
    }
    tick(dt) {
        let m = this._multiplier * this._running;
        this.deltaTicks = dt * m;
        if (this.active) {
            let cd = addMilliseconds(this.currentDate, this.deltaTicks);
            if (m > 0) {
                if (this.endDate && cd > this.endDate) {
                    this.currentDate = this.startDate;
                    this.events.dispatch(this.events.end, this);
                }
                else {
                    this.currentDate = cd;
                }
            }
            else {
                if (this.startDate && cd < this.startDate) {
                    this.currentDate = this.endDate;
                    this.events.dispatch(this.events.end, this);
                }
                else {
                    this.currentDate = cd;
                }
            }
            if (this._intervalCallback) {
                if (this.currentDate - this._intervalStart >= this._intervalDelay) {
                    this._intervalStart = this.currentDate;
                    this._intervalCallback(this);
                }
            }
            this.events.dispatch(this.events.tick, this);
        }
    }
    /**
     * @public
     * @param {Clock} clock - Clock instance to compare.
     * @returns {boolean} - Returns true if a clock is the same instance.
     */
    isEqual(clock) {
        return this.__id === clock.__id;
    }
    start() {
        if (this._running === 0) {
            this._running = 1;
            this.events.dispatch(this.events.start, this);
        }
    }
    get multiplier() {
        return this._multiplier;
    }
    set multiplier(value) {
        this._multiplier = value;
    }
    stop() {
        if (this._running === 1) {
            this._running = 0;
            this.events.dispatch(this.events.stop, this);
        }
    }
}
Clock.__counter__ = 0;

/**
 * This is shader program controller that used by handler object to access the shader
 * program capabilities, like switching program during the rendering.
 * Get access to the program from ...handler.programs.<program name> etc.
 * @class
 * @param {Handler} handler - Handler.
 * @param {Program} program - Shader program.
 */
class ProgramController {
    constructor(handler, program) {
        this._program = program;
        this._handler = handler;
        this._activated = false;
    }
    /**
     * Lazy create program call.
     * @public
     */
    initialize() {
        if (this._handler.gl) {
            this._program.createProgram(this._handler.gl);
        }
    }
    /**
     * Returns controller's shader program.
     * @public
     * @return {Program} -
     */
    getProgram() {
        return this._program;
    }
    /**
     * Activates current shader program.
     * @public
     * @returns {ProgramController} -
     */
    activate() {
        if (!this._activated) {
            this._handler.activeProgram.deactivate();
            this._handler.activeProgram = this;
            let p = this._program;
            this._activated = true;
            p.enableAttribArrays();
            p.use();
        }
        return this;
    }
    /**
     * Remove program from handler
     * @public
     */
    remove() {
        let p = this._handler.programs;
        if (p[this._program.name]) {
            if (this._activated) {
                this.deactivate();
            }
            this._program.delete();
            delete p[this._program.name];
        }
    }
    /**
     * Deactivate shader program. This is not necessary while activate function used.
     * @public
     */
    deactivate() {
        this._program.disableAttribArrays();
        this._activated = false;
    }
    /**
     * Returns program activity.
     * @public
     * @return {boolean} -
     */
    isActive() {
        return this._activated;
    }
    /**
     * Sets program uniforms and attributes values and return controller instance.
     * @public
     * @param {Record<string, any>} params - Object with variable name and value like { value: 12, someArray:[1,2,3], uSampler: texture,... }
     * @return {ProgramController} -
     */
    set(params) {
        this.activate();
        this._program.set(params);
        return this;
    }
    /**
     * Draw index buffer with this program.
     * @public
     * @param {number} mode - Gl draw mode
     * @param {WebGLBuffer} buffer - Buffer to draw.
     * @return {ProgramController} Returns current shader controller instance.
     */
    drawIndexBuffer(mode, buffer) {
        this._program.drawIndexBuffer(mode, buffer);
        return this;
    }
    /**
     * Calls Gl drawArray function.
     * @param {number} mode - Gl draw mode.
     * @param {number} numItems - draw items count.
     * @return {ProgramController} Returns current shader controller instance.
     */
    drawArrays(mode, numItems) {
        this._program.drawArrays(mode, numItems);
        return this;
    }
}

class Node {
    constructor() {
        this.next = null;
        this.prev = null;
        this.data = null;
    }
}
/**
 * @class Stack<T>
 * @param {number} [size=256] - Stack size
 */
class Stack {
    constructor(size = 256) {
        this._current = new Node();
        this._head = this._current;
        for (let i = 0; i < size; i++) {
            let n = new Node();
            n.prev = this._current;
            this._current.next = n;
            this._current = n;
        }
        this._current = this._head;
    }
    current() {
        return this._current;
    }
    push(data) {
        this._current = this._current.next;
        this._current.data = data;
    }
    pop() {
        let res = this._current.data;
        //this._current.data = null;
        this._current = this._current.prev;
        return res;
    }
    popPrev() {
        this._current = this._current.prev;
        return this._current.data;
    }
}

const vendorPrefixes = ["", "WEBKIT_", "MOZ_"];
const CONTEXT_TYPE = ["webgl2", "webgl"];
// Maximal mipmap levels
const MAX_LEVELS = 2;
/**
 * A WebGL handler for accessing low-level WebGL capabilities.
 * @class
 * @param {string | HTMLCanvasElement} canvasTarget - Canvas element target.
 * or undefined creates hidden canvas and handler becomes hidden.
 * @param {Object} [params] - Handler options:
 * @param {number} [params.anisotropy] - Anisotropy filter degree. 8 is default.
 * @param {number} [params.width] - Hidden handler width. 256 is default.
 * @param {number} [params.height] - Hidden handler height. 256 is default.
 * @param {Array.<string>} [params.extensions] - Additional WebGL extension list. Available by default: EXT_texture_filter_anisotropic.
 */
class Handler {
    constructor(canvasTarget, params = {}) {
        this.framebufferStack = new Stack();
        this._requestAnimationFrameId = 0;
        /**
         * Draw single frame.
         * @public
         */
        this.drawFrame = () => {
            /** Calculating frame time */
            let now = window.performance.now();
            this.deltaTime = now - this._lastAnimationFrameTime;
            this._lastAnimationFrameTime = now;
            this.defaultClock.tick(this.deltaTime);
            for (let i = 0; i < this._clocks.length; i++) {
                this._clocks[i].tick(this.deltaTime);
            }
            /** Canvas resize checking */
            let canvas = this.canvas;
            if (Math.floor(canvas.clientWidth * this._params.pixelRatio) !== canvas.width || Math.floor(canvas.clientHeight * this._params.pixelRatio) !== canvas.height) {
                if (canvas.clientWidth === 0 || canvas.clientHeight === 0) {
                    this.stop();
                }
                else if (!document.hidden) {
                    this.start();
                    this.setSize(canvas.clientWidth, canvas.clientHeight);
                }
            }
            /** Draw frame */
            this._frameCallback();
        };
        this.events = createEvents(["visibilitychange", "resize"]);
        this._throttledDrawFrame = this.drawFrame;
        this.defaultClock = new Clock();
        this._clocks = [];
        this.deltaTime = 0;
        this.canvas = null;
        this.gl = null;
        this.programs = {};
        this.activeProgram = null;
        this._canvasSize = [0, 0];
        this._params = {
            anisotropy: params.anisotropy || 4,
            width: params.width || 256,
            height: params.height || 256,
            pixelRatio: getUrlParam('og_dpi') || params.pixelRatio || 1.0,
            extensions: params.extensions || [],
            context: params.context || {}
        };
        this._oneByHeight = 1.0 / (this._params.height * this._params.pixelRatio);
        this.extensions = {};
        this._canvasTarget = canvasTarget;
        this._lastAnimationFrameTime = 0;
        this._initialized = false;
        this._frameCallback = function () {
        };
        this.transparentTexture = null;
        this.defaultTexture = null;
        this.framebufferStack = new Stack();
        this.createTexture_n = this.createTexture_n_webgl2.bind(this);
        this.createTexture_l = this.createTexture_l_webgl2.bind(this);
        this.createTexture_mm = this.createTexture_mm_webgl2.bind(this);
        this.createTexture_a = this.createTexture_a_webgl2.bind(this);
        this.createTexture = {
            "NEAREST": this.createTexture_n,
            "LINEAR": this.createTexture_l,
            "MIPMAP": this.createTexture_mm,
            "ANISOTROPIC": this.createTexture_a
        };
        this.createTextureDefault = this.createTexture_n;
        this.ONCANVASRESIZE = null;
        this._createCanvas();
        if (params.autoActivate || isEmpty(params.autoActivate)) {
            this.initialize();
        }
    }
    set frameDelay(delay) {
        if (delay === 0) {
            this._throttledDrawFrame = this.drawFrame;
        }
        else {
            this._throttledDrawFrame = throttle(this.drawFrame, delay);
        }
    }
    isInitialized() {
        return this._initialized;
    }
    _createCanvas() {
        if (this._canvasTarget) {
            if (this._canvasTarget instanceof HTMLElement) {
                this.canvas = this._canvasTarget;
            }
            else {
                this.canvas = (document.getElementById(this._canvasTarget) || document.querySelector(this._canvasTarget));
            }
        }
        else {
            this.canvas = document.createElement("canvas");
            this.canvas.width = this._params.width;
            this.canvas.height = this._params.height;
        }
    }
    /**
     * The return value is null if the extension is not supported, or an extension object otherwise.
     * @param {WebGLRenderingContext | WebGL2RenderingContext | null} gl - WebGl context pointer.
     * @param {string} name - Extension name.
     * @returns {any} -
     */
    static getExtension(gl, name) {
        if (!gl)
            return;
        let i, ext;
        for (i in vendorPrefixes) {
            ext = gl.getExtension(vendorPrefixes[i] + name);
            if (ext) {
                return ext;
            }
        }
    }
    /**
     * Returns a drawing context on the canvas, or null if the context identifier is not supported.
     * @param {HTMLCanvasElement} canvas - HTML canvas object.
     * @param {any} [contextAttributes] - See canvas.getContext contextAttributes.
     * @returns {WebGLContextExt | null} -
     */
    static getContext(canvas, contextAttributes) {
        let ctx = null;
        try {
            let urlParams = new URLSearchParams(location.search);
            let ver = urlParams.get('og_ver');
            if (ver) {
                ctx = canvas.getContext(ver, contextAttributes);
                if (ctx) {
                    ctx.type = ver;
                }
            }
            else {
                for (let i = 0; i < CONTEXT_TYPE.length; i++) {
                    ctx = canvas.getContext(CONTEXT_TYPE[i], contextAttributes);
                    if (ctx) {
                        ctx.type = CONTEXT_TYPE[i];
                        break;
                    }
                }
            }
        }
        catch (ex) {
            cons.logErr("exception during the GL context initialization");
        }
        if (!ctx) {
            cons.logErr("could not initialise WebGL");
        }
        return ctx;
    }
    /**
     * Sets animation frame function.
     * @public
     * @param {Function} callback - Frame callback.
     */
    setFrameCallback(callback) {
        callback && (this._frameCallback = callback);
    }
    /**
     * Creates empty texture.
     * @public
     * @param {number} [width=1] - Specifies the width of the texture image.
     * @param {number} [height=1] - Specifies the width of the texture image.
     * @param {string} [filter="NEAREST"] - Specifies GL_TEXTURE_MIN(MAX)_FILTER texture value.
     * @param {string} [internalFormat="RGBA"] - Specifies the color components in the texture.
     * @param {string} [format="RGBA"] - Specifies the format of the texel data.
     * @param {string} [type="UNSIGNED_BYTE"] - Specifies the data type of the texel data.
     * @param {number} [level=0] - Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createEmptyTexture2DExt(width = 1, height = 1, filter = "NEAREST", internalFormat = "RGBA", format = "RGBA", type = "UNSIGNED_BYTE", level = 0) {
        let gl = this.gl;
        let texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, level, gl[internalFormat.toUpperCase()], width, height, 0, gl[format.toUpperCase()], gl[type.toUpperCase()], null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl[filter.toUpperCase()]);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl[filter.toUpperCase()]);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
    /**
     * Creates Empty NEAREST filtered texture.
     * @public
     * @param {number} width - Empty texture width.
     * @param {number} height - Empty texture height.
     * @param {number} [internalFormat]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createEmptyTexture_n(width, height, internalFormat) {
        let gl = this.gl;
        let texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
    /**
     * Creates empty LINEAR filtered texture.
     * @public
     * @param {number} width - Empty texture width.
     * @param {number} height - Empty texture height.
     * @param {number} [internalFormat]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createEmptyTexture_l(width, height, internalFormat) {
        let gl = this.gl;
        let texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
    /**
     * Creates NEAREST filter texture.
     * @public
     * @param {HTMLCanvasElement | Image} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture=null]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_n_webgl1(image, internalFormat, texture = null) {
        let gl = this.gl;
        texture = texture || gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
    /**
     * Creates LINEAR filter texture.
     * @public
     * @param {ImageSource} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_l_webgl1(image, internalFormat, texture = null) {
        let gl = this.gl;
        texture = texture || gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
    /**
     * Creates MIPMAP filter texture.
     * @public
     * @param {ImageSource} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_mm_webgl1(image, internalFormat, texture = null) {
        let gl = this.gl;
        texture = texture || gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
    /**
     * Creates ANISOTROPY filter texture.
     * @public
     * @param {ImageSource} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_a_webgl1(image, internalFormat, texture = null) {
        let gl = this.gl;
        texture = texture || gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameterf(gl.TEXTURE_2D, this.extensions.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._params.anisotropy);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
    /**
     * Creates NEAREST filter texture.
     * @public
     * @param {ImageSource} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_n_webgl2(image, internalFormat, texture = null) {
        let gl = this.gl;
        texture = texture || gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        //gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        gl.texStorage2D(gl.TEXTURE_2D, 1, internalFormat || gl.RGBA8, image.width, image.height);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
    /**
     * Creates LINEAR filter texture.
     * @public
     * @param {ImageSource} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_l_webgl2(image, internalFormat, texture = null) {
        let gl = this.gl;
        texture = texture || gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        //gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        gl.texStorage2D(gl.TEXTURE_2D, 1, internalFormat || gl.RGBA8, image.width, image.height);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
    /**
     * Creates MIPMAP filter texture.
     * @public
     * @param {ImageSource} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_mm_webgl2(image, internalFormat, texture = null) {
        let gl = this.gl;
        texture = texture || gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        //gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        gl.texStorage2D(gl.TEXTURE_2D, MAX_LEVELS, internalFormat || gl.RGBA8, image.width, image.height);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
    /**
     * Creates ANISOTROPY filter texture.
     * @public
     * @param {ImageSource} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_a_webgl2(image, internalFormat, texture = null) {
        let gl = this.gl;
        texture = texture || gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        //gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        gl.texStorage2D(gl.TEXTURE_2D, MAX_LEVELS, internalFormat || gl.RGBA8, image.width, image.height);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameterf(gl.TEXTURE_2D, this.extensions.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._params.anisotropy);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
    /**
     * Creates cube texture.
     * @public
     * @param {Texture3DParams} params - Face image urls:
     * @param {string} params.px - Positive X or right image url.
     * @param {string} params.nx - Negative X or left image url.
     * @param {string} params.py - Positive Y or up image url.
     * @param {string} params.ny - Negative Y or bottom image url.
     * @param {string} params.pz - Positive Z or face image url.
     * @param {string} params.nz - Negative Z or back image url.
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    loadCubeMapTexture(params) {
        let gl = this.gl;
        let texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        let faces = [
            [params.px, gl.TEXTURE_CUBE_MAP_POSITIVE_X],
            [params.nx, gl.TEXTURE_CUBE_MAP_NEGATIVE_X],
            [params.py, gl.TEXTURE_CUBE_MAP_POSITIVE_Y],
            [params.ny, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y],
            [params.pz, gl.TEXTURE_CUBE_MAP_POSITIVE_Z],
            [params.nz, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]
        ];
        let imageCanvas = new ImageCanvas();
        imageCanvas.fillEmpty();
        let emptyImage = imageCanvas.getImage();
        for (let i = 0; i < faces.length; i++) {
            let face = faces[i][1];
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
            //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            gl.texImage2D(face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, emptyImage);
        }
        for (let i = 0; i < faces.length; i++) {
            let face = faces[i][1];
            let image = new Image();
            image.crossOrigin = "";
            image.onload = (function (texture, face, image) {
                return function () {
                    if (gl && texture) {
                        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
                        //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
                        gl.texImage2D(face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                    }
                };
            })(texture, face, image);
            image.src = faces[i][0];
        }
        return texture;
    }
    /**
     * Adds shader program to the handler.
     * @public
     * @param {Program} program - Shader program.
     * @param {boolean} [notActivate] - If it's true program will not compile.
     * @return {Program} -
     */
    addProgram(program, notActivate = false) {
        if (!this.programs[program.name]) {
            let sc = new ProgramController(this, program);
            this.programs[program.name] = sc;
            this._initProgramController(sc);
            if (notActivate) {
                sc._activated = false;
            }
        }
        else {
            console.warn(`Shader program: "${program.name}" already exists.`);
        }
        return program;
    }
    /**
     * Removes shader program from handler.
     * @public
     * @param {string} name - Shader program name.
     */
    removeProgram(name) {
        this.programs[name] && this.programs[name].remove();
    }
    /**
     * Adds shader programs to the handler.
     * @public
     * @param {Array.<Program>} programsArr - Shader program array.
     */
    addPrograms(programsArr) {
        for (let i = 0; i < programsArr.length; i++) {
            this.addProgram(programsArr[i]);
        }
    }
    /**
     * Used in addProgram
     * @protected
     * @param {ProgramController} sc - Program controller
     */
    _initProgramController(sc) {
        if (this._initialized) {
            sc.initialize();
            if (!this.activeProgram) {
                this.activeProgram = sc;
                sc.activate();
            }
            else {
                sc.deactivate();
                this.activeProgram._program.enableAttribArrays();
                this.activeProgram._program.use();
            }
        }
    }
    /**
     * Used in init function.
     * @private
     */
    _initPrograms() {
        for (let p in this.programs) {
            this._initProgramController(this.programs[p]);
        }
    }
    /**
     * Initialize additional WebGL extensions.
     * @public
     * @param {string} extensionStr - Extension name.
     * @param {boolean} showLog - Show logging.
     * @return {any} -
     */
    initializeExtension(extensionStr, showLog = false) {
        if (!(this.extensions && this.extensions[extensionStr])) {
            let ext = Handler.getExtension(this.gl, extensionStr);
            if (ext) {
                this.extensions[extensionStr] = ext;
            }
            else if (showLog) {
                console.warn("og.webgl.Handler: extension '" + extensionStr + "' doesn't initialize.");
            }
        }
        return this.extensions && this.extensions[extensionStr];
    }
    /**
     * Main function that initialize handler.
     * @public
     */
    initialize() {
        if (this._initialized)
            return;
        if (!this.canvas)
            return;
        this.gl = Handler.getContext(this.canvas, this._params.context);
        if (!this.gl)
            return;
        this._initialized = true;
        /** Sets default extensions */
        this._params.extensions.push("EXT_texture_filter_anisotropic");
        if (this.gl.type === "webgl") {
            this._params.extensions.push("OES_standard_derivatives");
            this._params.extensions.push("OES_element_index_uint");
            this._params.extensions.push("WEBGL_depth_texture");
            this._params.extensions.push("ANGLE_instanced_arrays");
            //this._params.extensions.push("WEBGL_draw_buffers");
            //this._params.extensions.push("EXT_frag_depth");
        }
        else {
            this._params.extensions.push("EXT_color_buffer_float");
            this._params.extensions.push("OES_texture_float_linear");
            //this._params.extensions.push("WEBGL_draw_buffers");
        }
        let i = this._params.extensions.length;
        while (i--) {
            this.initializeExtension(this._params.extensions[i], true);
        }
        if (this.gl.type === "webgl") {
            this.createTexture_n = this.createTexture_n_webgl1.bind(this);
            this.createTexture_l = this.createTexture_l_webgl1.bind(this);
            this.createTexture_mm = this.createTexture_mm_webgl1.bind(this);
            this.createTexture_a = this.createTexture_a_webgl1.bind(this);
        }
        else {
            this.createTexture_n = this.createTexture_n_webgl2.bind(this);
            this.createTexture_l = this.createTexture_l_webgl2.bind(this);
            this.createTexture_mm = this.createTexture_mm_webgl2.bind(this);
            this.createTexture_a = this.createTexture_a_webgl2.bind(this);
        }
        this.createTexture["NEAREST"] = this.createTexture_n;
        this.createTexture["LINEAR"] = this.createTexture_l;
        this.createTexture["MIPMAP"] = this.createTexture_mm;
        this.createTexture["ANISOTROPIC"] = this.createTexture_a;
        if (!this.extensions.EXT_texture_filter_anisotropic) {
            this.createTextureDefault = this.createTexture_mm;
        }
        else {
            this.createTextureDefault = this.createTexture_a;
        }
        /** Initializing shaders and rendering parameters*/
        this._initPrograms();
        this._setDefaults();
        this.intersectionObserver = new IntersectionObserver((entries) => {
            this._toggleVisibilityChange(entries[entries.length - 1].isIntersecting);
        }, { threshold: 0 });
        this.intersectionObserver.observe(this.canvas);
        this.resizeObserver = new ResizeObserver(entries => {
            this._toggleVisibilityChange(entries[0].contentRect.width !== 0 && entries[0].contentRect.height !== 0);
        });
        this.resizeObserver.observe(this.canvas);
        document.addEventListener("visibilitychange", () => {
            this._toggleVisibilityChange(document.visibilityState === 'visible');
        });
    }
    _toggleVisibilityChange(visibility) {
        if (visibility) {
            this.start();
            this.ONCANVASRESIZE && this.ONCANVASRESIZE();
            this.events.dispatch(this.events.visibilitychange, true);
        }
        else {
            this.events.dispatch(this.events.visibilitychange, false);
            this.stop();
        }
    }
    /**
     * Sets default gl render parameters. Used in init function.
     * @protected
     */
    _setDefaults() {
        let gl = this.gl;
        if (!gl)
            return;
        if (!this.canvas)
            return;
        gl.depthFunc(gl.LESS);
        gl.enable(gl.DEPTH_TEST);
        this.setSize(this.canvas.clientWidth || this._params.width, this.canvas.clientHeight || this._params.height);
        gl.frontFace(gl.CCW);
        gl.cullFace(gl.BACK);
        gl.enable(gl.CULL_FACE);
        gl.disable(gl.BLEND);
        this.createDefaultTexture({ color: "rgba(0,0,0,0.0)" }, (t) => {
            this.transparentTexture = t;
        });
        this.createDefaultTexture({ color: "rgba(255, 255, 255, 1.0)" }, (t) => {
            this.defaultTexture = t;
        });
    }
    getCanvasSize() {
        return this._canvasSize;
    }
    /**
     * Creates STREAM_DRAW ARRAY buffer.
     * @public
     * @param {number} itemSize - Array item size.
     * @param {number} numItems - Items quantity.
     * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
     * @param {number} [bytes=4] -
     * @return {WebGLBufferExt} -
     */
    createStreamArrayBuffer(itemSize, numItems, usage, bytes = 4) {
        let gl = this.gl;
        let buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, numItems * itemSize * bytes, usage || gl.STREAM_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        buffer.itemSize = itemSize;
        buffer.numItems = numItems;
        return buffer;
    }
    /**
     * Sets stream buffer.
     * @public
     * @param {WebGLBufferExt} buffer -
     * @param {TypedArray} array -
     * @param {number} [offset=0] -
     * @return {WebGLBufferExt} -
     */
    setStreamArrayBuffer(buffer, array, offset = 0) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, offset, array);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return buffer;
    }
    /**
     * Creates ARRAY buffer.
     * @public
     * @param {TypedArray} array - Input array.
     * @param {number} itemSize - Array item size.
     * @param {number} numItems - Items quantity.
     * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
     * @return {WebGLBufferExt} -
     */
    createArrayBuffer(array, itemSize, numItems, usage) {
        let gl = this.gl;
        let buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, array, usage || gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        buffer.itemSize = itemSize;
        buffer.numItems = numItems;
        return buffer;
    }
    /**
     * Creates ARRAY buffer specific length.
     * @public
     * @param {number} size -
     * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
     * @return {WebGLBufferExt} -
     */
    createArrayBufferLength(size, usage) {
        let gl = this.gl;
        let buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, size, usage || gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        buffer.itemSize = 1;
        buffer.numItems = size;
        return buffer;
    }
    /**
     * Creates ELEMENT ARRAY buffer.
     * @public
     * @param {TypedArray} array - Input array.
     * @param {number} itemSize - Array item size.
     * @param {number} numItems - Items quantity.
     * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
     * @return {Object} -
     */
    createElementArrayBuffer(array, itemSize, numItems, usage) {
        let gl = this.gl;
        let buffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, usage || gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        buffer.itemSize = itemSize;
        buffer.numItems = numItems || array.length;
        return buffer;
    }
    /**
     * Sets handler canvas size.
     * @public
     * @param {number} w - Canvas width.
     * @param {number} h - Canvas height.
     */
    setSize(w, h) {
        this._params.width = w;
        this._params.height = h;
        if (this.canvas) {
            this.canvas.width = w * this._params.pixelRatio;
            this.canvas.height = h * this._params.pixelRatio;
            this._canvasSize[0] = this.canvas.width;
            this._canvasSize[1] = this.canvas.height;
            this._oneByHeight = 1.0 / this.canvas.height;
            this.gl && this.gl.viewport(0, 0, w, h);
            this.ONCANVASRESIZE && this.ONCANVASRESIZE(this.canvas);
            this.events.dispatch(this.events.resize, this);
        }
    }
    get pixelRatio() {
        return this._params.pixelRatio;
    }
    set pixelRatio(pr) {
        this._params.pixelRatio = pr;
        this.setSize(this._params.width, this._params.height);
    }
    /**
     * Returns context screen width.
     * @public
     * @returns {number} -
     */
    getWidth() {
        return this.canvas ? this.canvas.width : 0;
    }
    /**
     * Returns context screen height.
     * @public
     * @returns {number} -
     */
    getHeight() {
        return this.canvas ? this.canvas.height : 0;
    }
    /**
     * Returns canvas aspect ratio.
     * @public
     * @returns {number} -
     */
    getClientAspect() {
        return this.canvas ? this.canvas.clientWidth / this.canvas.clientHeight : 0;
    }
    /**
     * Returns canvas center coordinates.
     * @public
     * @returns {number} -
     */
    getCenter() {
        let c = this.canvas;
        return c ? new Vec2(Math.round(c.width * 0.5), Math.round(c.height * 0.5)) : new Vec2();
    }
    /**
     * Clearing gl frame.
     * @public
     */
    clearFrame() {
        let gl = this.gl;
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }
    /**
     * Starts animation loop.
     * @public
     */
    start() {
        if (!this._requestAnimationFrameId && this._initialized) {
            this._animationFrameCallback();
        }
    }
    stop() {
        if (this._requestAnimationFrameId) {
            window.cancelAnimationFrame(this._requestAnimationFrameId);
            this._requestAnimationFrameId = 0;
        }
    }
    isStopped() {
        return !this._requestAnimationFrameId;
    }
    /**
     * Check is gl context type equals webgl2
     * @public
     */
    isWebGl2() {
        return this.gl ? this.gl.type === "webgl2" : false;
    }
    /**
     * Make animation.
     * @protected
     */
    _animationFrameCallback() {
        this._requestAnimationFrameId = window.requestAnimationFrame(() => {
            this._throttledDrawFrame();
            this._requestAnimationFrameId && this._animationFrameCallback();
        });
    }
    /**
     * Creates default texture object
     * @public
     * @param {IDefaultTextureParams | null} params - Texture parameters:
     * @param {(texture: WebGLTextureExt) => void} [success] - Creation callback
     */
    createDefaultTexture(params, success) {
        let imgCnv;
        let texture;
        if (params && params.color) {
            imgCnv = new ImageCanvas(2, 2);
            imgCnv.fillColor(params.color);
            texture = this.createTexture_n(imgCnv.getCanvas());
            texture.default = true;
            success(texture);
        }
        else if (params && params.url) {
            let img = new Image();
            let that = this;
            img.onload = function () {
                texture = that.createTextureDefault(img);
                texture.default = true;
                success(texture);
            };
            img.src = params.url;
        }
        else {
            imgCnv = new ImageCanvas(2, 2);
            imgCnv.fillColor("#C5C5C5");
            texture = this.createTexture_n(imgCnv.getCanvas());
            texture.default = true;
            success(texture);
        }
    }
    deleteTexture(texture) {
        if (texture && !texture.default) {
            this.gl.deleteTexture(texture);
        }
    }
    /**
     * @public
     */
    destroy() {
        this.resizeObserver?.disconnect();
        this.intersectionObserver?.disconnect();
        this.stop();
        //
        // Dispose shaders
        //
        for (let p in this.programs) {
            this.removeProgram(p);
        }
        //
        // Clear WebGL context
        //
        let gl = this.gl;
        if (gl) {
            gl.deleteTexture(this.transparentTexture);
            this.transparentTexture = null;
            gl.deleteTexture(this.defaultTexture);
            this.defaultTexture = null;
            this.framebufferStack = new Stack();
            //
            // Clear attrib pointers
            //
            let numAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            let tmp = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, tmp);
            for (let ii = 0; ii < numAttribs; ++ii) {
                gl.disableVertexAttribArray(ii);
                gl.vertexAttribPointer(ii, 4, gl.FLOAT, false, 0, 0);
                gl.vertexAttrib1f(ii, 0);
            }
            gl.deleteBuffer(tmp);
            //
            // Clear all possible textures
            //
            let numTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            for (let ii = 0; ii < numTextureUnits; ++ii) {
                gl.activeTexture(gl.TEXTURE0 + ii);
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
            //
            // Hard reset
            //
            gl.activeTexture(gl.TEXTURE0);
            gl.useProgram(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            gl.disable(gl.BLEND);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.DITHER);
            gl.disable(gl.SCISSOR_TEST);
            gl.blendColor(0, 0, 0, 0);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.ONE, gl.ZERO);
            gl.clearColor(0, 0, 0, 0);
            gl.clearDepth(1);
            gl.clearStencil(-1);
        }
        //
        // Destroy canvas
        //
        if (this.canvas) {
            if (this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
            }
            this.canvas.width = 1;
            this.canvas.height = 1;
            this.canvas = null;
        }
        this.gl = null;
        this._initialized = false;
    }
    addClock(clock) {
        if (!clock.__handler) {
            clock.__handler = this;
            this._clocks.push(clock);
        }
    }
    addClocks(clockArr) {
        for (let i = 0; i < clockArr.length; i++) {
            this.addClock(clockArr[i]);
        }
    }
    removeClock(clock) {
        if (clock.__handler) {
            let c = this._clocks;
            let i = c.length;
            while (i--) {
                if (c[i].isEqual(clock)) {
                    clock.__handler = null;
                    c.splice(i, 1);
                    break;
                }
            }
        }
    }
}

/**
 * Class represents multisample framebuffer.
 * @class
 * @param {Handler} handler - WebGL handler.
 * @param {Object} [options] - Framebuffer options:
 */
class Multisample extends BaseFramebuffer {
    constructor(handler, options = {}) {
        super(handler, options);
        this._internalFormat = options.internalFormat ? options.internalFormat.toUpperCase() : "RGBA8";
        this._msaa = options.msaa != undefined ? options.msaa : 4;
        this._glFilter = 0;
        this.renderbuffers = new Array(this._size);
    }
    destroy() {
        let gl = this.handler.gl;
        if (!gl)
            return;
        for (let i = 0; i < this.renderbuffers.length; i++) {
            gl.deleteRenderbuffer(this.renderbuffers[i]);
        }
        this.renderbuffers = new Array(this._size);
        gl.deleteFramebuffer(this._fbo);
        gl.deleteRenderbuffer(this._depthRenderbuffer);
        this._depthRenderbuffer = null;
        this._fbo = null;
        this._active = false;
    }
    /**
     * Framebuffer initialization.
     * @public
     */
    init() {
        let gl = this.handler.gl;
        if (!gl)
            return;
        this._glFilter = gl[this._filter];
        this._fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
        let colorAttachments = [];
        for (let i = 0; i < this.renderbuffers.length; i++) {
            let rb = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, rb);
            if (this._msaa > 0) {
                gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._msaa, gl[this._internalFormat], this._width, this._height);
            }
            else {
                gl.renderbufferStorage(gl.RENDERBUFFER, gl[this._internalFormat], this._width, this._height);
            }
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, rb);
            colorAttachments.push(gl.COLOR_ATTACHMENT0 + i);
            this.renderbuffers[i] = rb;
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        }
        gl.drawBuffers(colorAttachments);
        if (this._useDepth) {
            this._depthRenderbuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderbuffer);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._msaa, gl[this._depthComponent], this._width, this._height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._depthRenderbuffer);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    blitTo(framebuffer, attachmentIndex = 0) {
        let gl = this.handler.gl;
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._fbo);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer._fbo);
        gl.readBuffer(gl.COLOR_ATTACHMENT0 + attachmentIndex);
        gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
        gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, framebuffer._width, framebuffer._height, gl.COLOR_BUFFER_BIT, this._glFilter);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    }
}

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Framebuffer: Framebuffer,
    Handler: Handler,
    Multisample: Multisample,
    Program: Program,
    types: types
});

const STAMP_SPACER = "_";
const _sortByPriority = function (a, b) {
    return Number(a.priority < b.priority);
};
class KeyboardHandler {
    constructor() {
        this._currentlyPressedKeys = {};
        this._pressedKeysCallbacks = {};
        this._unpressedKeysCallbacks = {};
        this._charkeysCallbacks = {};
        this._anykeyCallback = null;
        this._event = null;
        this._active = true;
        this._stampCache = {};
        document.onkeydown = (event) => {
            this._event = event;
            this._active && this.handleKeyDown();
        };
        document.onkeyup = (event) => {
            this._event = event;
            this._active && this.handleKeyUp();
        };
    }
    getcurrentlyPressedKeys() {
        return this._currentlyPressedKeys;
    }
    getPressedKeysCallbacks() {
        return this._pressedKeysCallbacks;
    }
    getUnpressedKeysCallbacks() {
        return this._unpressedKeysCallbacks;
    }
    getCharkeysCallbacks() {
        return this._charkeysCallbacks;
    }
    removeEvent(event, keyCode, callback) {
        let st = this._getStamp(event, keyCode, callback._openglobus_id);
        if (callback._openglobus_id && this._stampCache[st]) {
            //this._stampCache[st] = null;
            delete this._stampCache[st];
            if (event === "keypress") {
                this._removeCallback(this._pressedKeysCallbacks[keyCode], callback);
            }
            else if (event === "keyfree") {
                this._removeCallback(this._unpressedKeysCallbacks[keyCode], callback);
            }
            else if (event === "charkeypress") {
                this._removeCallback(this._charkeysCallbacks[keyCode], callback);
            }
        }
    }
    _removeCallback(handlers, callback) {
        for (let i = 0; i < handlers.length; i++) {
            if (handlers[i].callback._openglobus_id === callback._openglobus_id) {
                handlers.splice(i, 1);
            }
        }
    }
    _getStamp(name, keyCode, ogid) {
        return `${name}${STAMP_SPACER}${keyCode}${STAMP_SPACER}${ogid}`;
    }
    _stamp(name, keyCode, obj) {
        const ogid = stamp(obj);
        const st = this._getStamp(name, keyCode, ogid);
        if (!this._stampCache[st]) {
            this._stampCache[st] = ogid;
            return true;
        }
        return false;
    }
    setActivity(activity) {
        this._active = activity;
    }
    releaseKeys() {
        this._currentlyPressedKeys = {};
    }
    addEvent(event, keyCode, callback, sender, priority) {
        // Event is already bound with the callback
        if (!this._stamp(event, keyCode, callback))
            return;
        if (priority === undefined) {
            priority = 1600;
        }
        switch (event) {
            case "keyfree":
                if (!this._unpressedKeysCallbacks[keyCode]) {
                    this._unpressedKeysCallbacks[keyCode] = [];
                }
                this._unpressedKeysCallbacks[keyCode].push({ callback: callback, sender: sender, priority: priority });
                this._unpressedKeysCallbacks[keyCode].sort(_sortByPriority);
                break;
            case "keypress":
                if (keyCode == null) {
                    this._anykeyCallback = { callback: callback, sender: sender || this };
                }
                else {
                    if (!this._pressedKeysCallbacks[keyCode]) {
                        this._pressedKeysCallbacks[keyCode] = [];
                    }
                    this._pressedKeysCallbacks[keyCode].push({ callback: callback, sender: sender, priority: priority });
                    this._pressedKeysCallbacks[keyCode].sort(_sortByPriority);
                }
                break;
            case "charkeypress":
                if (!this._charkeysCallbacks[keyCode]) {
                    this._charkeysCallbacks[keyCode] = [];
                }
                this._charkeysCallbacks[keyCode].push({ callback: callback, sender: sender, priority: priority });
                this._charkeysCallbacks[keyCode].sort(_sortByPriority);
                break;
        }
    }
    isKeyPressed(keyCode) {
        return this._currentlyPressedKeys[keyCode];
    }
    handleKeyDown() {
        // If you want to get a key code just uncomment and check console
        //console.log(this._event!.keyCode);
        this._anykeyCallback && this._anykeyCallback.callback.call(this._anykeyCallback.sender, this._event);
        this._currentlyPressedKeys[this._event.keyCode] = true;
        for (let ch in this._charkeysCallbacks) {
            if (String.fromCharCode(this._event.keyCode) === String.fromCharCode(Number(ch))) {
                let ccl = this._charkeysCallbacks[ch];
                for (let i = 0; i < ccl.length; i++) {
                    ccl[i].callback.call(ccl[i].sender, this._event);
                }
            }
        }
        if (this._event.keyCode == input.KEY_ALT || this._event.keyCode == input.KEY_SHIFT) {
            this._event.preventDefault();
        }
    }
    handleKeyUp() {
        if (this._currentlyPressedKeys[this._event.keyCode] || this._event.keyCode === input.KEY_PRINTSCREEN) {
            for (let pk in this._unpressedKeysCallbacks) {
                if (this._currentlyPressedKeys[pk] || this._event.keyCode === input.KEY_PRINTSCREEN && Number(pk) === input.KEY_PRINTSCREEN) {
                    let cpk = this._unpressedKeysCallbacks[pk];
                    for (let i = 0; i < cpk.length; i++) {
                        cpk[i].callback.call(cpk[i].sender, this._event);
                    }
                }
            }
        }
        this._currentlyPressedKeys[this._event.keyCode] = false;
    }
    handleEvents() {
        for (let pk in this._pressedKeysCallbacks) {
            if (this._currentlyPressedKeys[pk]) {
                let cpk = this._pressedKeysCallbacks[pk];
                for (let i = 0; i < cpk.length; i++) {
                    cpk[i].callback.call(cpk[i].sender, this._event);
                }
            }
        }
    }
}

class MouseHandler {
    constructor(htmlObject) {
        this._htmlObject = htmlObject;
    }
    setEvent(event, sender, callback) {
        switch (event) {
            case "mousewheel":
                // this._htmlObject.addEventListener('mousewheel', function (event: WheelEventExt) {
                //     let delta = event.deltaY || event.detail || event.wheelDelta || 0;
                //     if (event.wheelDelta == undefined) {
                //         event.wheelDelta = delta * (-120);
                //     }
                //     callback.call(sender, event);
                //     event.preventDefault();
                // }, false);
                this._htmlObject.addEventListener('wheel', function (event) {
                    let delta = event.deltaY || event.detail || event.wheelDelta || 0;
                    if (event.wheelDelta == undefined) {
                        event.wheelDelta = delta * (-120);
                    }
                    callback.call(sender, event);
                    event.preventDefault();
                }, false);
                break;
            case "mousedown":
                this._htmlObject.addEventListener('mousedown', function (event) {
                    let rect = this.getBoundingClientRect();
                    callback.call(sender, event, {
                        button: event.button,
                        clientX: event.clientX - rect.left,
                        clientY: event.clientY - rect.top
                    });
                });
                this._htmlObject.addEventListener('contextmenu', function (event) {
                    event.preventDefault();
                    return false;
                });
                break;
            case "mouseup":
                this._htmlObject.addEventListener('mouseup', function (event) {
                    let rect = this.getBoundingClientRect();
                    callback.call(sender, event, {
                        button: event.button,
                        clientX: event.clientX - rect.left,
                        clientY: event.clientY - rect.top
                    });
                });
                break;
            case "mousemove":
                this._htmlObject.addEventListener('mousemove', function (event) {
                    let rect = this.getBoundingClientRect();
                    callback.call(sender, event, {
                        clientX: event.clientX - rect.left,
                        clientY: event.clientY - rect.top
                    });
                });
                break;
            case "mouseleave":
                this._htmlObject.addEventListener('mouseleave', function (event) {
                    callback.call(sender, event);
                });
                break;
            case "mouseout":
                this._htmlObject.addEventListener('mouseout', function (event) {
                    callback.call(sender, event);
                });
                break;
            case "mouseover":
                this._htmlObject.addEventListener('mouseover', function (event) {
                    callback.call(sender, event);
                });
                break;
            case "mouseenter":
                this._htmlObject.addEventListener('mouseenter', function (event) {
                    callback.call(sender, event);
                });
                break;
        }
    }
}

class TouchHandler {
    constructor(htmlObject) {
        this._htmlObject = htmlObject;
    }
    setEvent(event, sender, callback) {
        switch (event) {
            case "touchcancel":
                this._htmlObject.addEventListener('touchcancel', function (event) {
                    event.preventDefault();
                    const rect = this.getBoundingClientRect();
                    const eventExt = Object.assign(event, { offsetLeft: rect.left, offsetTop: rect.top });
                    callback.call(sender, eventExt);
                });
                break;
            case "touchstart":
                this._htmlObject.addEventListener('touchstart', function (event) {
                    event.preventDefault();
                    const rect = this.getBoundingClientRect();
                    const eventExt = Object.assign(event, { offsetLeft: rect.left, offsetTop: rect.top });
                    callback.call(sender, eventExt);
                });
                break;
            case "touchend":
                this._htmlObject.addEventListener('touchend', function (event) {
                    event.preventDefault();
                    const rect = this.getBoundingClientRect();
                    const eventExt = Object.assign(event, { offsetLeft: rect.left, offsetTop: rect.top });
                    callback.call(sender, eventExt);
                });
                break;
            case "touchmove":
                this._htmlObject.addEventListener('touchmove', function (event) {
                    event.preventDefault();
                    const rect = this.getBoundingClientRect();
                    const eventExt = Object.assign(event, { offsetLeft: rect.left, offsetTop: rect.top });
                    callback.call(sender, eventExt);
                });
                break;
        }
    }
}

function createRendererEvents(renderer) {
    return new RendererEvents(renderer);
}
const LB_M = 0b0001;
const RB_M = 0b0010;
const MB_M = 0b0100;
const ISBLACK = (c) => !(c[0] || c[1] || c[2]);
const NOTBLACK = (c) => !!(c[0] || c[1] || c[2]);
/**
 * Stores current picking rgb color.
 * @type {Array.<number>} - (exactly 3 entries)
 */
let _currPickingColor = new Uint8Array(4);
let _tempCurrPickingColor = new Uint8Array(4);
/**
 * Stores previous picked rgb color.
 * @type {Array.<number>} - (exactly 3 entries)
 */
let _prevPickingColor = new Uint8Array(4);
/**
 * Renderer events handler.
 * @class
 * @param {Renderer} renderer - Renderer object, events that works for.
 */
class RendererEvents extends Events {
    constructor(renderer) {
        super(RENDERER_EVENTS);
        this.renderer = renderer;
        this._touchHandler = new TouchHandler(renderer.handler.canvas);
        this._mouseHandler = new MouseHandler(renderer.handler.canvas);
        this._keyboardHandler = new KeyboardHandler();
        this._active = true;
        this.clickRadius = 15;
        this.mouseState = {
            clientX: 0,
            clientY: 0,
            pos: new Vec2(),
            x: 0,
            y: 0,
            nx: 0,
            ny: 0,
            prev_x: 0,
            prev_y: 0,
            direction: new Vec3(),
            leftButtonUp: false,
            rightButtonUp: false,
            middleButtonUp: false,
            leftButtonDown: false,
            rightButtonDown: false,
            middleButtonDown: false,
            leftButtonHold: false,
            rightButtonHold: false,
            middleButtonHold: false,
            leftButtonDoubleClick: false,
            rightButtonDoubleClick: false,
            middleButtonDoubleClick: false,
            leftButtonClick: false,
            rightButtonClick: false,
            middleButtonClick: false,
            moving: false,
            justStopped: false,
            doubleClickDelay: 500,
            clickDelay: 200,
            wheelDelta: 0,
            sys: null,
            pickingObject: null,
            renderer: renderer
        };
        this.touchState = {
            moving: false,
            touchEnd: false,
            touchStart: false,
            touchCancel: false,
            doubleTouch: false,
            doubleTouchDelay: 550,
            doubleTouchRadius: 10,
            clientX: 0,
            clientY: 0,
            pos: new Vec2(),
            x: 0,
            y: 0,
            nx: 0,
            ny: 0,
            prev_x: 0,
            prev_y: 0,
            direction: new Vec3(),
            sys: null,
            pickingObject: null,
            renderer: renderer
        };
        this._isMouseInside = false;
        this._entityPickingEventsActive = true;
        this._dblTchCoords = new Vec2();
        this._oneTouchStart = false;
        this._dblTchBegins = 0;
        this._mousestopThread = null;
        this._ldblClkBegins = 0;
        this._rdblClkBegins = 0;
        this._mdblClkBegins = 0;
        this._lClkBegins = 0;
        this._rClkBegins = 0;
        this._mClkBegins = 0;
        this._lclickX = 0;
        this._lclickY = 0;
        this._rclickX = 0;
        this._rclickY = 0;
        this._mclickX = 0;
        this._mclickY = 0;
    }
    pointerEvent() {
        let ms = this.mouseState, ts = this.touchState;
        return (ms.moving ||
            ms.justStopped ||
            ts.moving ||
            ts.touchStart ||
            ts.touchEnd ||
            ms.wheelDelta !== 0);
    }
    get active() {
        return this._active;
    }
    set active(isActive) {
        this._active = isActive;
        this._keyboardHandler.setActivity(isActive);
    }
    /**
     * Used in render node frame.
     * @public
     */
    handleEvents() {
        if (this._active) {
            this.mouseState.direction = this.renderer.activeCamera.unproject(this.mouseState.x, this.mouseState.y);
            //
            // TODO: Replace in some other place with a thought that we do
            // not need to make unproject when we do not make touching
            this.touchState.direction = this.renderer.activeCamera.unproject(this.touchState.x, this.touchState.y);
            this._keyboardHandler.handleEvents();
            this.handleMouseEvents();
            this.handleTouchEvents();
            this.entityPickingEvents();
        }
    }
    on(name, p0, p1, p2, keyPriority) {
        if (name === "keypress" || name === "charkeypress" || name === "keyfree") {
            this._keyboardHandler.addEvent(name, p0, p1, p2, keyPriority);
        }
        else {
            super.on(name, p0, p1, p2);
        }
    }
    off(name, p1, p2) {
        if (name === "keypress" || name === "charkeypress" || name === "keyfree") {
            this._keyboardHandler.removeEvent(name, p1, p2);
        }
        else {
            super.off(name, p1);
        }
    }
    /**
     * Check key is pressed.
     * @public
     * @param {number} keyCode - Key code
     * @return {boolean}
     */
    isKeyPressed(keyCode) {
        return this._keyboardHandler.isKeyPressed(keyCode);
    }
    releaseKeys() {
        this._keyboardHandler.releaseKeys();
    }
    /**
     * Renderer events initialization.
     * @public
     */
    initialize() {
        this._mouseHandler.setEvent("mouseup", this, this.onMouseUp);
        this._mouseHandler.setEvent("mousemove", this, this.onMouseMove);
        this._mouseHandler.setEvent("mousedown", this, this.onMouseDown);
        this._mouseHandler.setEvent("mousewheel", this, this.onMouseWheel);
        this._mouseHandler.setEvent("mouseleave", this, this.onMouseLeave);
        this._mouseHandler.setEvent("mouseenter", this, this.onMouseEnter);
        this._touchHandler.setEvent("touchstart", this, this.onTouchStart);
        this._touchHandler.setEvent("touchend", this, this.onTouchEnd);
        this._touchHandler.setEvent("touchcancel", this, this.onTouchCancel);
        this._touchHandler.setEvent("touchmove", this, this.onTouchMove);
    }
    /**
     * @protected
     */
    onMouseWheel(event) {
        this.mouseState.sys = event;
        this.mouseState.wheelDelta = event.wheelDelta || 0;
    }
    updateButtonsStates(buttons) {
        let ms = this.mouseState;
        if ((buttons & LB_M) && ms.leftButtonDown) {
            ms.leftButtonDown = true;
        }
        else {
            ms.leftButtonHold = false;
            ms.leftButtonDown = false;
        }
        if ((buttons & RB_M) && ms.rightButtonDown) {
            ms.rightButtonDown = true;
        }
        else {
            ms.rightButtonHold = false;
            ms.rightButtonDown = false;
        }
        if ((buttons & MB_M) && ms.middleButtonDown) {
            ms.middleButtonDown = true;
        }
        else {
            ms.middleButtonHold = false;
            ms.middleButtonDown = false;
        }
    }
    onMouseMove(sys, event) {
        let ms = this.mouseState;
        this.updateButtonsStates(sys.buttons);
        ms.sys = sys;
        let ex = event.clientX, ey = event.clientY, r = this.clickRadius;
        if (Math.abs(this._lclickX - ex) >= r && Math.abs(this._lclickY - ey) >= r) {
            this._ldblClkBegins = 0;
            this._lClkBegins = 0;
        }
        if (Math.abs(this._rclickX - ex) >= r && Math.abs(this._rclickY - ey) >= r) {
            this._rdblClkBegins = 0;
            this._rClkBegins = 0;
        }
        if (Math.abs(this._mclickX - ex) >= r && Math.abs(this._mclickY - ey) >= r) {
            this._mdblClkBegins = 0;
            this._mClkBegins = 0;
        }
        if (ms.clientX === event.clientX && ms.clientY === event.clientY) {
            return;
        }
        ms.clientX = event.clientX;
        ms.clientY = event.clientY;
        let h = this.renderer.handler;
        ms.pos.x = ms.x = event.clientX * h.pixelRatio;
        ms.pos.y = ms.y = event.clientY * h.pixelRatio;
        ms.nx = ms.x / h.canvas.width;
        ms.ny = ms.y / h.canvas.height;
        ms.moving = true;
        //dispatch stop mouse event
        clearTimeout(this._mousestopThread);
        this._mousestopThread = setTimeout(function () {
            ms.justStopped = true;
        }, 100);
    }
    onMouseLeave(sys) {
        this._isMouseInside = false;
        this.mouseState.sys = sys;
        this.dispatch(this.mouseleave, this.mouseState);
    }
    onMouseEnter(sys) {
        this._isMouseInside = true;
        this.mouseState.sys = sys;
        this.dispatch(this.mouseenter, this.mouseState);
    }
    onMouseDown(sys, event) {
        if (event.button === input.MB_LEFT) {
            this._lClkBegins = window.performance.now();
            this._lclickX = event.clientX;
            this._lclickY = event.clientY;
            this.mouseState.sys = sys;
            this.mouseState.leftButtonDown = true;
        }
        else if (event.button === input.MB_RIGHT) {
            this._rClkBegins = window.performance.now();
            this._rclickX = event.clientX;
            this._rclickY = event.clientY;
            this.mouseState.sys = sys;
            this.mouseState.rightButtonDown = true;
        }
        else if (event.button === input.MB_MIDDLE) {
            this._mClkBegins = window.performance.now();
            this._mclickX = event.clientX;
            this._mclickY = event.clientY;
            this.mouseState.sys = sys;
            this.mouseState.middleButtonDown = true;
        }
    }
    onMouseUp(sys, event) {
        let ms = this.mouseState;
        ms.sys = sys;
        let t = window.performance.now();
        if (event.button === input.MB_LEFT) {
            ms.leftButtonDown = false;
            ms.leftButtonUp = true;
            if (Math.abs(this._lclickX - event.clientX) < this.clickRadius &&
                Math.abs(this._lclickY - event.clientY) < this.clickRadius &&
                t - this._lClkBegins <= ms.clickDelay) {
                if (this._ldblClkBegins) {
                    let deltatime = window.performance.now() - this._ldblClkBegins;
                    if (deltatime <= ms.doubleClickDelay) {
                        ms.leftButtonDoubleClick = true;
                    }
                    this._ldblClkBegins = 0;
                }
                else {
                    this._ldblClkBegins = window.performance.now();
                }
                ms.leftButtonClick = true;
                this._lClkBegins = 0;
            }
        }
        else if (event.button === input.MB_RIGHT) {
            ms.rightButtonDown = false;
            ms.rightButtonUp = true;
            if (Math.abs(this._rclickX - event.clientX) < this.clickRadius &&
                Math.abs(this._rclickY - event.clientY) < this.clickRadius &&
                t - this._rClkBegins <= ms.clickDelay) {
                if (this._rdblClkBegins) {
                    let deltatime = window.performance.now() - this._rdblClkBegins;
                    if (deltatime <= ms.doubleClickDelay) {
                        ms.rightButtonDoubleClick = true;
                    }
                    this._rdblClkBegins = 0;
                }
                else {
                    this._rdblClkBegins = window.performance.now();
                }
                ms.rightButtonClick = true;
                this._rClkBegins = 0;
            }
        }
        else if (event.button === input.MB_MIDDLE) {
            ms.middleButtonDown = false;
            ms.middleButtonUp = true;
            if (Math.abs(this._mclickX - event.clientX) < this.clickRadius &&
                Math.abs(this._mclickY - event.clientY) < this.clickRadius &&
                t - this._mClkBegins <= ms.clickDelay) {
                if (this._mdblClkBegins) {
                    let deltatime = window.performance.now() - this._mdblClkBegins;
                    if (deltatime <= ms.doubleClickDelay) {
                        ms.middleButtonDoubleClick = true;
                    }
                    this._mdblClkBegins = 0;
                }
                else {
                    this._mdblClkBegins = window.performance.now();
                }
                ms.middleButtonClick = true;
                this._mClkBegins = 0;
            }
        }
    }
    onTouchStart(event) {
        let ts = this.touchState;
        ts.sys = event;
        ts.clientX = event.touches.item(0).clientX - event.offsetLeft;
        ts.clientY = event.touches.item(0).clientY - event.offsetTop;
        let h = this.renderer.handler;
        ts.pos.x = ts.x = ts.clientX * h.pixelRatio;
        ts.pos.y = ts.y = ts.clientY * h.pixelRatio;
        ts.nx = ts.x / h.canvas.width;
        ts.ny = ts.y / h.canvas.height;
        ts.prev_x = ts.x;
        ts.prev_y = ts.y;
        ts.touchStart = true;
        if (event.touches.length === 1) {
            this._dblTchCoords.x = ts.x;
            this._dblTchCoords.y = ts.y;
            this._oneTouchStart = true;
        }
        else {
            this._oneTouchStart = false;
        }
    }
    /**
     * @protected
     */
    onTouchEnd(event) {
        let ts = this.touchState;
        ts.sys = event;
        ts.touchEnd = true;
        if (event.touches.length === 0) {
            ts.prev_x = ts.x;
            ts.prev_y = ts.y;
            if (this._oneTouchStart) {
                if (this._dblTchBegins) {
                    let deltatime = window.performance.now() - this._dblTchBegins;
                    if (deltatime <= ts.doubleTouchDelay) {
                        ts.doubleTouch = true;
                    }
                    this._dblTchBegins = 0;
                }
                this._dblTchBegins = window.performance.now();
                this._oneTouchStart = false;
            }
        }
    }
    onTouchCancel(event) {
        let ts = this.touchState;
        ts.sys = event;
        ts.touchCancel = true;
    }
    onTouchMove(event) {
        let ts = this.touchState;
        ts.clientX = event.touches.item(0).clientX - event.offsetLeft;
        ts.clientY = event.touches.item(0).clientY - event.offsetTop;
        let h = this.renderer.handler;
        ts.x = ts.clientX * h.pixelRatio;
        ts.y = ts.clientY * h.pixelRatio;
        ts.nx = ts.x / h.canvas.width;
        ts.ny = ts.y / h.canvas.height;
        ts.sys = event;
        ts.moving = true;
        let dX = ts.x - ts.prev_x;
        let dY = ts.y - ts.prev_y;
        if (Math.abs(dX) > 9 || Math.abs(dY) > 9) {
            this._dblTchBegins = 0;
            this._oneTouchStart = false;
        }
    }
    entityPickingEvents() {
        let ts = this.touchState, ms = this.mouseState;
        // Triggers mouseleave when mouse goes outside the viewport
        if (this._isMouseInside !== this._entityPickingEventsActive) {
            this._entityPickingEventsActive = this._isMouseInside;
            if (!this._entityPickingEventsActive) {
                let r = this.renderer;
                let c = _currPickingColor;
                let co = r.getPickingObjectArr(c);
                if (co) {
                    let pe = co.rendererEvents;
                    ms.pickingObject = co;
                    pe && pe.dispatch(pe.mouseleave, ms);
                    ts.pickingObject = co;
                    pe && pe.dispatch(pe.touchleave, ts);
                }
                _currPickingColor[0] = _currPickingColor[1] = _currPickingColor[2] = _currPickingColor[3] =
                    _prevPickingColor[0] = _prevPickingColor[1] = _prevPickingColor[2] = _prevPickingColor[3] =
                        _tempCurrPickingColor[0] = _tempCurrPickingColor[1] = _tempCurrPickingColor[2] = _tempCurrPickingColor[3] = 0.0;
            }
        }
        if (this._isMouseInside && !(ms.leftButtonHold || ms.rightButtonHold || ms.middleButtonHold)) {
            let r = this.renderer;
            let c = _currPickingColor, p = _prevPickingColor, t = _tempCurrPickingColor;
            if (ts.x || ts.y) {
                r.readPickingColor(ts.nx, 1 - ts.ny, t);
            }
            else {
                r.readPickingColor(ms.nx, 1 - ms.ny, t);
            }
            p[0] = c[0];
            p[1] = c[1];
            p[2] = c[2];
            c[0] = t[0];
            c[1] = t[1];
            c[2] = t[2];
            ms.pickingObject = null;
            ts.pickingObject = null;
            let co = r.getPickingObjectArr(c);
            ms.pickingObject = co;
            ts.pickingObject = co;
            //object is changed
            if (c[0] !== p[0] || c[1] !== p[1] || c[2] !== p[2]) {
                //current is black
                if (ISBLACK(c)) {
                    let po = r.getPickingObjectArr(p);
                    if (po) {
                        let pe = po.rendererEvents;
                        ms.pickingObject = po;
                        pe && pe.dispatch(pe.mouseleave, ms);
                        ts.pickingObject = po;
                        pe && pe.dispatch(pe.touchleave, ts);
                    }
                }
                else {
                    //current ia not black
                    //previous is not black
                    if (NOTBLACK(p)) {
                        let po = r.getPickingObjectArr(p);
                        if (po) {
                            let pe = po.rendererEvents;
                            ms.pickingObject = po;
                            pe && pe.dispatch(pe.mouseleave, ms);
                            ts.pickingObject = po;
                            pe && pe.dispatch(pe.touchleave, ts);
                        }
                    }
                    if (co) {
                        let ce = co.rendererEvents;
                        ms.pickingObject = co;
                        ce && ce.dispatch(ce.mouseenter, ms);
                        ts.pickingObject = co;
                        ce && ce.dispatch(ce.touchenter, ts);
                    }
                }
            }
        }
    }
    handleMouseEvents() {
        let _this = this;
        let ms = this.mouseState;
        let po = ms.pickingObject, pe = null;
        if (ms.leftButtonClick) {
            if (po) {
                pe = po.rendererEvents;
                pe && pe.dispatch(pe.lclick, ms);
            }
            this.dispatch(_this.lclick, ms);
            ms.leftButtonClick = false;
        }
        if (ms.rightButtonClick) {
            if (po) {
                pe = po.rendererEvents;
                pe && pe.dispatch(pe.rclick, ms);
            }
            this.dispatch(_this.rclick, ms);
            ms.rightButtonClick = false;
        }
        if (ms.middleButtonClick) {
            if (po) {
                pe = po.rendererEvents;
                pe && pe.dispatch(pe.mclick, ms);
            }
            this.dispatch(_this.mclick, ms);
            ms.middleButtonClick = false;
        }
        if (ms.leftButtonDown) {
            if (ms.leftButtonHold) {
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.lhold, ms);
                }
                this.dispatch(_this.lhold, ms);
            }
            else {
                ms.leftButtonHold = true;
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.ldown, ms);
                }
                this.dispatch(_this.ldown, ms);
            }
        }
        if (ms.rightButtonDown) {
            if (ms.rightButtonHold) {
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.rhold, ms);
                }
                this.dispatch(_this.rhold, ms);
            }
            else {
                ms.rightButtonHold = true;
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.rdown, ms);
                }
                this.dispatch(_this.rdown, ms);
            }
        }
        if (ms.middleButtonDown) {
            if (ms.middleButtonHold) {
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.mhold, ms);
                }
                this.dispatch(_this.mhold, ms);
            }
            else {
                ms.middleButtonHold = true;
                if (po) {
                    pe = po.rendererEvents;
                    pe && pe.dispatch(pe.mdown, ms);
                }
                this.dispatch(_this.mdown, ms);
            }
        }
        if (ms.leftButtonUp) {
            if (po) {
                pe = po.rendererEvents;
                pe && pe.dispatch(pe.lup, ms);
            }
            this.dispatch(_this.lup, ms);
            ms.leftButtonUp = false;
            ms.leftButtonHold = false;
        }
        if (ms.rightButtonUp) {
            if (po) {
                pe = po.rendererEvents;
                pe && pe.dispatch(pe.rup, ms);
            }
            this.dispatch(_this.rup, ms);
            ms.rightButtonUp = false;
            ms.rightButtonHold = false;
        }
        if (ms.middleButtonUp) {
            if (po) {
                pe = po.rendererEvents;
                pe && pe.dispatch(pe.mup, ms);
            }
            this.dispatch(_this.mup, ms);
            ms.middleButtonUp = false;
            ms.middleButtonHold = false;
        }
        if (ms.leftButtonDoubleClick) {
            if (po) {
                pe = po.rendererEvents;
                pe && pe.dispatch(pe.ldblclick, ms);
            }
            this.dispatch(_this.ldblclick, ms);
            ms.leftButtonDoubleClick = false;
        }
        if (ms.rightButtonDoubleClick) {
            if (po) {
                pe = po.rendererEvents;
                pe && pe.dispatch(pe.rdblclick, ms);
            }
            this.dispatch(_this.rdblclick, ms);
            ms.rightButtonDoubleClick = false;
        }
        if (ms.middleButtonDoubleClick) {
            if (po) {
                pe = po.rendererEvents;
                pe && pe.dispatch(pe.mdblclick, ms);
            }
            this.dispatch(_this.mdblclick, ms);
            ms.middleButtonDoubleClick = false;
        }
        if (ms.wheelDelta) {
            if (po) {
                pe = po.rendererEvents;
                pe && pe.dispatch(pe.mousewheel, ms);
            }
            this.dispatch(_this.mousewheel, ms);
        }
        if (ms.moving) {
            if (po) {
                pe = po.rendererEvents;
                pe && pe.dispatch(pe.mousemove, ms);
            }
            this.dispatch(_this.mousemove, ms);
            ms.prev_x = ms.x;
            ms.prev_y = ms.y;
        }
        if (ms.justStopped) {
            this.dispatch(_this.mousestop, ms);
        }
    }
    /**
     * @protected
     */
    handleTouchEvents() {
        let _this = this;
        let ts = this.touchState;
        let tpo = ts.pickingObject, tpe = null;
        if (ts.touchCancel) {
            this.dispatch(_this.touchcancel, ts);
            ts.touchCancel = false;
        }
        if (ts.touchStart) {
            let r = this.renderer;
            r.readPickingColor(ts.nx, 1 - ts.ny, _currPickingColor);
            let co = r.getPickingObjectArr(_currPickingColor);
            tpo = ts.pickingObject = co;
            if (tpo) {
                tpe = tpo.rendererEvents;
                tpe && tpe.dispatch(tpe.touchstart, ts);
            }
            this.dispatch(_this.touchstart, ts);
            ts.touchStart = false;
        }
        if (ts.doubleTouch) {
            if (tpo) {
                tpe = tpo.rendererEvents;
                tpe && tpe.dispatch(tpe.doubletouch, ts);
            }
            this.dispatch(_this.doubletouch, ts);
            ts.doubleTouch = false;
        }
        if (ts.touchEnd) {
            if (tpo) {
                tpe = tpo.rendererEvents;
                tpe && tpe.dispatch(tpe.touchend, ts);
            }
            this.dispatch(_this.touchend, ts);
            ts.x = 0;
            ts.y = 0;
            ts.touchEnd = false;
        }
        if (ts.moving) {
            if (tpo) {
                tpe = tpo.rendererEvents;
                tpe && tpe.dispatch(tpe.touchmove, ts);
            }
            this.dispatch(_this.touchmove, ts);
            ts.prev_x = ts.x;
            ts.prev_y = ts.y;
        }
    }
}
const RENDERER_EVENTS = [
    /**
     * Triggered before scene frame is rendered(before render nodes).
     * @event og.RendererEvents#draw
     */
    "draw",
    /**
     * Triggered after all transparent object are drawn
     * @event og.RendererEvents#drawtransparent
     */
    "drawtransparent",
    /**
     * Triggered after scene frame is rendered(after render nodes).
     * @event og.RendererEvents#postdraw
     */
    "postdraw",
    /**
     * Triggered when screen is resized.
     * @event og.RendererEvents#resize
     */
    "resize",
    /**
     * Triggered when screen is resized.
     * @event og.RendererEvents#resizeend
     */
    "resizeend",
    /**
     * Mouse enters the work screen
     * @event og.RendererEvents#mouseenter
     */
    "mouseenter",
    /**
     * Mouse leaves the work screen
     * @event og.RendererEvents#mouseleave
     */
    "mouseleave",
    /**
     * Mouse is moving.
     * @event og.RendererEvents#mousemove
     */
    "mousemove",
    /**
     * Mouse is just stopped.
     * @event og.RendererEvents#mousestop
     */
    "mousestop",
    /**
     * Mouse left button clicked.
     * @event og.RendererEvents#lclick
     */
    "lclick",
    /**
     * Mouse right button clicked.
     * @event og.RendererEvents#rclick
     */
    "rclick",
    /**
     * Mouse middle button clicked.
     * @event og.RendererEvents#mclick
     */
    "mclick",
    /**
     * Mouse left button double click.
     * @event og.RendererEvents#ldblclick
     */
    "ldblclick",
    /**
     * Mouse right button double click.
     * @event og.RendererEvents#rdblclick
     */
    "rdblclick",
    /**
     * Mouse middle button double click.
     * @event og.RendererEvents#mdblclick
     */
    "mdblclick",
    /**
     * Mouse left button up(stop pressing).
     * @event og.RendererEvents#lup
     */
    "lup",
    /**
     * Mouse right button up(stop pressing).
     * @event og.RendererEvents#rup
     */
    "rup",
    /**
     * Mouse middle button up(stop pressing).
     * @event og.RendererEvents#mup
     */
    "mup",
    /**
     * Mouse left button is just pressed down(start pressing).
     * @event og.RendererEvents#ldown
     */
    "ldown",
    /**
     * Mouse right button is just pressed down(start pressing).
     * @event og.RendererEvents#rdown
     */
    "rdown",
    /**
     * Mouse middle button is just pressed down(start pressing).
     * @event og.RendererEvents#mdown
     */
    "mdown",
    /**
     * Mouse left button is pressing.
     * @event og.RendererEvents#lhold
     */
    "lhold",
    /**
     * Mouse right button is pressing.
     * @event og.RendererEvents#rhold
     */
    "rhold",
    /**
     * Mouse middle button is pressing.
     * @event og.RendererEvents#mhold
     */
    "mhold",
    /**
     * Mouse wheel is rotated.
     * @event og.RendererEvents#mousewheel
     */
    "mousewheel",
    /**
     * Triggered when touching starts.
     * @event og.RendererEvents#touchstart
     */
    "touchstart",
    /**
     * Triggered when touching ends.
     * @event og.RendererEvents#touchend
     */
    "touchend",
    /**
     * Triggered when touching cancel.
     * @event og.RendererEvents#touchcancel
     */
    "touchcancel",
    /**
     * Triggered when touch is move.
     * @event og.RendererEvents#touchmove
     */
    "touchmove",
    /**
     * Triggered when double touch.
     * @event og.RendererEvents#doubletouch
     */
    "doubletouch",
    /**
     * Triggered when touch leaves picked object.
     * @event og.RendererEvents#touchleave
     */
    "touchleave",
    /**
     * Triggered when touch enter picking object.
     * @event og.RendererEvents#touchenter
     */
    "touchenter"
];

function depth() {
    return new Program("depth", {
        uniforms: {
            depthTexture: "sampler2d"
        },
        attributes: {
            corners: "vec2"
        },
        vertexShader: `#version 300 es
            
            in vec2 corners;
            
            out vec2 tc;

            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
                tc = corners * 0.5 + 0.5;
            }`,
        fragmentShader: `#version 300 es

            precision highp float;

            #define MAX_FRUSTUMS 4

            uniform sampler2D depthTexture;
           
            in vec2 tc;

            layout(location = 0) out vec4 fragColor;

            float LinearizeDepth(in vec2 uv)
            {
                float depth = texture(depthTexture, tc).x;
                return depth;//(2.0 * zNear) / (zFar + zNear - depth * (zFar - zNear));
            }
            
            void main(void) {
                float c = LinearizeDepth(tc);
                fragColor = vec4(c, c, c, 1.0);
            }`
    });
}

/**
 * 2D Rectangle class.
 * @class
 * @param {number} [left] - Left coordinate. 0 - default.
 * @param {number} [top] - Top coordinate. 0 - default.
 * @param {number} [right] - Right coordinate. 0 - default.
 * @param {number} [bottom] - Bottom coordinate. 0 - default.
 */
class Rectangle {
    constructor(left = 0, top = 0, right = 0, bottom = 0) {
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
    }
    set(left = 0, top = 0, right = 0, bottom = 0) {
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
    }
    /**
     * Clone rectangle object.
     * @public
     * @returns {Rectangle}
     */
    clone() {
        return new Rectangle(this.left, this.top, this.right, this.bottom);
    }
    /**
     * Returns rectangle width.
     * @public
     * @type {number}
     */
    getWidth() {
        return Math.abs(this.right - this.left);
    }
    /**
     * Returns rectangle height.
     * @public
     * @type {number}
     */
    getHeight() {
        return Math.abs(this.bottom - this.top);
    }
    /**
     * Returns rectangle area.
     * @public
     * @type {number}
     */
    getSquare() {
        return this.getHeight() * this.getWidth();
    }
    /**
     * Returns rectangle diagonal size.
     * @public
     * @type {number}
     */
    getDiagonal() {
        let w = this.getWidth(), h = this.getHeight();
        return Math.sqrt(h * h + w * w);
    }
    /**
     * Returns true if rectangle fits their size in width and height.
     * @public
     * @param {number} width - Width.
     * @param {number} height - Height.
     * @type {boolean}
     */
    fit(width, height) {
        return this.getWidth() === width && this.getHeight() === height;
    }
    isInside(x, y) {
        return x >= this.left && x <= this.right && y >= this.top && y <= this.bottom;
    }
}

class ImagesCacheManager {
    constructor() {
        this.imagesCache = {};
        this._counter = 0;
        this._pendingsQueue = new QueueArray();
        this._imageIndexCounter = 0;
    }
    load(src, success) {
        if (this.imagesCache[src]) {
            success(this.imagesCache[src]);
        }
        else {
            let req = { "src": src, "success": success };
            if (this._counter >= 1) {
                this._pendingsQueue.unshift(req);
            }
            else {
                this._exec(req);
            }
        }
    }
    _exec(req) {
        this._counter++;
        const that = this;
        let img = new Image();
        img.crossOrigin = '';
        img.onload = function () {
            that.imagesCache[req.src] = img;
            img.__nodeIndex = that._imageIndexCounter++;
            req.success(img);
            that._dequeueRequest();
        };
        img.onerror = function () {
            that._dequeueRequest();
        };
        img.src = req.src;
    }
    _dequeueRequest() {
        this._counter--;
        if (this._pendingsQueue.length && this._counter < 1) {
            while (this._pendingsQueue.length) {
                let req = this._pendingsQueue.pop();
                if (req) {
                    if (this.imagesCache[req.src]) {
                        if (this._counter <= 0) {
                            this._counter = 0;
                        }
                        else {
                            this._counter--;
                        }
                        req.success(this.imagesCache[req.src]);
                    }
                    else {
                        this._exec(req);
                        break;
                    }
                }
            }
        }
    }
}

/**
 * Texture atlas stores images in one texture. Each image has its own
 * atlas texture coordinates.
 * @class
 * @param {number} [width=1024] - Texture atlas width, if it hasn't 1024 default.
 * @param {number} [height=1024] - Texture atlas height, if it hasn't 1024 default.
 */
class TextureAtlas {
    constructor(width = 1024, height = 1024) {
        this.nodes = new Map();
        this.texture = null;
        this.canvas = new ImageCanvas(width, height);
        this.clearCanvas();
        this._handler = null;
        this._images = [];
        this._btree = null;
        this._imagesCacheManager = new ImagesCacheManager();
        this.borderSize = 4;
    }
    /**
     * Returns atlas javascript image object.
     * @public
     * @returns {HTMLImageElement} -
     */
    getImage() {
        return this.canvas.getImage();
    }
    /**
     * Returns canvas object.
     * @public
     * @returns {HTMLCanvasElement} -
     */
    getCanvas() {
        return this.canvas.getCanvas();
    }
    /**
     * Clear atlas with black.
     * @public
     */
    clearCanvas() {
        this.canvas.fillEmpty();
    }
    /**
     * Sets openglobus gl handler that creates gl texture.
     * @public
     * @param {Handler} handler - WebGL handler.
     */
    assignHandler(handler) {
        this._handler = handler;
        this.createTexture();
    }
    /**
     * Returns image diagonal size.
     * @param {HTMLImageElementExt} image - Image object.
     * @returns {number} -
     */
    getDiagonal(image) {
        let w = image.atlasWidth || image.width, h = image.atlasHeight || image.height;
        return Math.sqrt(w * w + h * h);
    }
    /**
     * Adds image to the atlas and returns created node with texture coordinates of the stored image.
     * @public
     * @param {HTMLImageElementExt} image - Input javascript image object.
     * @param {boolean} [fastInsert] - If it's true atlas doesn't restore all images again
     * and store image in the current atlas scheme.
     * @returns {TextureAtlasNode | undefined} -
     */
    addImage(image, fastInsert = false) {
        if (!(image.width && image.height)) {
            return;
        }
        this._images.push(image);
        this._makeAtlas(fastInsert);
        if (image.__nodeIndex != undefined) {
            return this.get(image.__nodeIndex);
        }
    }
    _completeNode(nodes, node) {
        if (node) {
            let w = this.canvas.getWidth(), h = this.canvas.getHeight();
            let im = node.image;
            let r = node.rect;
            let bs = Math.round(this.borderSize * 0.5);
            this.canvas.drawImage(im, r.left + bs, r.top + bs, im.atlasWidth || 0, im.atlasHeight || 0);
            let tc = node.texCoords;
            tc[0] = (r.left + bs) / w;
            tc[1] = (r.top + bs) / h;
            tc[2] = (r.left + bs) / w;
            tc[3] = (r.bottom - bs) / h;
            tc[4] = (r.right - bs) / w;
            tc[5] = (r.bottom - bs) / h;
            tc[6] = (r.right - bs) / w;
            tc[7] = (r.bottom - bs) / h;
            tc[8] = (r.right - bs) / w;
            tc[9] = (r.top + bs) / h;
            tc[10] = (r.left + bs) / w;
            tc[11] = (r.top + bs) / h;
            nodes.set(im.__nodeIndex, node);
        }
    }
    /**
     * Main atlas making function.
     * @protected
     * @param {boolean} [fastInsert] - If it's true atlas doesn't restore all images again
     * and store image in the current atlas scheme.
     */
    _makeAtlas(fastInsert = false) {
        if (fastInsert && this._btree) {
            let im = this._images[this._images.length - 1];
            this._completeNode(this.nodes, this._btree.insert(im));
        }
        else {
            let im = this._images.slice(0);
            im.sort(function (b, a) {
                return ((a.atlasWidth || a.width) - (b.atlasWidth || b.width) ||
                    (a.atlasHeight || a.height) - (b.atlasHeight || b.height));
            });
            this._btree = new TextureAtlasNode(new Rectangle(0, 0, this.canvas.getWidth(), this.canvas.getHeight()));
            this._btree.atlas = this;
            this.clearCanvas();
            let newNodes = new Map();
            for (let i = 0; i < im.length; i++) {
                this._completeNode(newNodes, this._btree.insert(im[i]));
            }
            //@ts-ignore
            this.nodes = null;
            this.nodes = newNodes;
        }
    }
    get(key) {
        return this.nodes.get(key);
    }
    set(key, value) {
        this.nodes.set(key, value);
    }
    /**
     * Creates atlas gl texture.
     * @public
     */
    createTexture(img, internalFormat) {
        if (this._handler) {
            this._handler.gl.deleteTexture(this.texture);
            if (img) {
                this.canvas.resize(img.width, img.height);
                this.canvas.drawImage(img, 0, 0, img.width, img.height);
            }
            this.texture = this._handler.createTexture_l(this.canvas.getCanvas(), internalFormat);
        }
    }
    /**
     * Asynchronous function that loads and creates image to the image cache, and call success callback when it's done.
     * @public
     * @param {string} src - Image object src string.
     * @param {ImagesCacheManagerCallback} success - The callback that handles the image loads done.
     */
    loadImage(src, success) {
        this._imagesCacheManager.load(src, success);
    }
    getImageTexCoordinates(img) {
        if (img.__nodeIndex != null) {
            let n = this.get(img.__nodeIndex);
            if (n) {
                return n.texCoords;
            }
        }
    }
}
/**
 * Atlas binary tree node.
 * @class
 * @param {Rectangle} rect - Node image rectangle.
 * @param {number[]} texCoords - Node image rectangle.
 */
class TextureAtlasNode {
    constructor(rect, texCoords) {
        this.childNodes = null;
        this.image = null;
        this.rect = rect || new Rectangle();
        this.texCoords = texCoords || [];
        this.atlas = null;
    }
    insert(img) {
        if (this.childNodes) {
            let newNode = this.childNodes[0].insert(img);
            if (newNode) {
                return newNode;
            }
            return this.childNodes[1].insert(img);
        }
        else {
            if (this.image != null) {
                return;
            }
            let rc = this.rect;
            const w = (img.atlasWidth || img.width) + this.atlas.borderSize;
            const h = (img.atlasHeight || img.height) + this.atlas.borderSize;
            if (w > rc.getWidth() || h > rc.getHeight()) {
                return;
            }
            if (rc.fit(w, h)) {
                this.image = img;
                return this;
            }
            this.childNodes = new Array(2);
            this.childNodes[0] = new TextureAtlasNode();
            this.childNodes[0].atlas = this.atlas;
            this.childNodes[1] = new TextureAtlasNode();
            this.childNodes[1].atlas = this.atlas;
            const dw = rc.getWidth() - w;
            const dh = rc.getHeight() - h;
            if (dw > dh) {
                // this.childNodes[0].rect = new Rectangle(rc.left, rc.top, rc.left + w, rc.bottom);
                // this.childNodes[1].rect = new Rectangle(rc.left + w, rc.top, rc.right, rc.bottom);
                this.childNodes[0].rect.set(rc.left, rc.top, rc.left + w, rc.bottom);
                this.childNodes[1].rect.set(rc.left + w, rc.top, rc.right, rc.bottom);
            }
            else {
                // this.childNodes[0].rect = new Rectangle(rc.left, rc.top, rc.right, rc.top + h);
                // this.childNodes[1].rect = new Rectangle(rc.left, rc.top + h, rc.right, rc.bottom);
                this.childNodes[0].rect.set(rc.left, rc.top, rc.right, rc.top + h);
                this.childNodes[1].rect.set(rc.left, rc.top + h, rc.right, rc.bottom);
            }
            return this.childNodes[0].insert(img);
        }
    }
}

//@todo: get the value from shader module
const MAX_SIZE = 11;
class FontTextureAtlas extends TextureAtlas {
    constructor(width, height) {
        super(width, height);
        this.width = 0;
        this.height = 0;
        this.gliphSize = 0;
        this.distanceRange = 0;
        this.nodes = new Map();
        this.kernings = {};
    }
    get(key) {
        return this.nodes.get(key);
    }
}
class FontTextureAtlasNode extends TextureAtlasNode {
    constructor(rect, texCoords) {
        super(rect, texCoords);
        this.emptySize = 1;
        this.metrics = {
            id: 0,
            char: "",
            width: 0,
            height: 0,
            x: 0,
            y: 0,
            chnl: 0,
            index: 0,
            page: 0,
            xadvance: 0,
            xoffset: 0,
            yoffset: 0,
            nChar: "",
            nCode: 0,
            nWidth: 0,
            nHeight: 0,
            nAdvance: 0,
            nXOffset: 0,
            nYOffset: 0
        };
    }
}
class FontAtlas {
    constructor(catalogSrc) {
        this.atlasesArr = [];
        this.atlasIndexes = {};
        this.atlasIndexesDeferred = {};
        this.tokenImageSize = 64;
        this.samplerArr = new Uint32Array(MAX_SIZE);
        this.sdfParamsArr = new Float32Array(MAX_SIZE * 4);
        this._handler = null;
        this.catalogSrc = catalogSrc || "./";
    }
    assignHandler(handler) {
        this._handler = handler;
    }
    getFontIndex(face) {
        let fullName = this.getFullIndex(face);
        // Try to load font from the directory
        if (!this.atlasIndexes[fullName]) {
            this.loadFont(face, this.catalogSrc, `${face}.json`);
        }
        if (!this.atlasIndexesDeferred[fullName]) {
            this.atlasIndexesDeferred[fullName] = new Deferred();
        }
        return this.atlasIndexesDeferred[fullName].promise;
    }
    getFullIndex(face) {
        return face.trim().toLowerCase();
    }
    _applyFontDataToAtlas(atlas, data, index = 0) {
        let chars = data.chars;
        atlas.height = data.common.scaleH;
        atlas.width = data.common.scaleW;
        atlas.gliphSize = data.info.size;
        atlas.distanceRange = data.distanceField.distanceRange;
        let w = atlas.width, h = atlas.height, s = atlas.gliphSize;
        this.sdfParamsArr[index * 4] = w;
        this.sdfParamsArr[index * 4 + 1] = h;
        this.sdfParamsArr[index * 4 + 2] = s;
        this.sdfParamsArr[index * 4 + 3] = atlas.distanceRange;
        let idToChar = {};
        for (let i = 0; i < chars.length; i++) {
            let ci = chars[i];
            let ti = ci.char;
            idToChar[ci.id] = ti;
            let r = new Rectangle(ci.x, ci.y, ci.x + ci.width, ci.y + ci.height);
            let tc = new Array(12);
            tc[0] = r.left / w;
            tc[1] = r.top / h;
            tc[2] = r.left / w;
            tc[3] = r.bottom / h;
            tc[4] = r.right / w;
            tc[5] = r.bottom / h;
            tc[6] = r.right / w;
            tc[7] = r.bottom / h;
            tc[8] = r.right / w;
            tc[9] = r.top / h;
            tc[10] = r.left / w;
            tc[11] = r.top / h;
            let taNode = new FontTextureAtlasNode(r, tc);
            let ciNorm = ci.char.normalize('NFKC');
            let ciCode = ciNorm.charCodeAt(0);
            //taNode.metrics = ci;
            let m = taNode.metrics;
            m.id = ci.id;
            m.char = ci.char;
            m.width = ci.width;
            m.height = ci.height;
            m.x = ci.x;
            m.y = ci.y;
            m.chnl = ci.chnl;
            m.index = ci.index;
            m.page = ci.page;
            m.xadvance = ci.xadvance;
            m.xoffset = ci.xoffset;
            m.yoffset = ci.yoffset;
            m.nChar = ciNorm;
            m.nCode = ciCode;
            m.nWidth = taNode.metrics.width / s;
            m.nHeight = taNode.metrics.height / s;
            m.nAdvance = taNode.metrics.xadvance / s;
            m.nXOffset = taNode.metrics.xoffset / s;
            m.nYOffset = 1.0 - taNode.metrics.yoffset / s;
            taNode.emptySize = 1;
            atlas.nodes.set(ciNorm.charCodeAt(0), taNode);
        }
        atlas.kernings = {};
        for (let i = 0; i < data.kernings.length; i++) {
            let ki = data.kernings[i];
            let first = ki.first, second = ki.second;
            //let charFirst = idToChar[first],
            //    charSecond = idToChar[second];
            // if (!atlas.kernings[charFirst]) {
            //     atlas.kernings[charFirst] = {};
            // }
            //
            // atlas.kernings[charFirst][charSecond] = ki.amount / s;
            if (!atlas.kernings[first]) {
                atlas.kernings[first] = {};
            }
            atlas.kernings[first][second] = ki.amount / s;
        }
    }
    initFont(faceName, dataJson, imageBase64) {
        let index = this.atlasesArr.length;
        let fullName = this.getFullIndex(faceName);
        this.atlasIndexes[fullName] = index;
        let def = this.atlasIndexesDeferred[fullName];
        if (!def) {
            def = this.atlasIndexesDeferred[fullName] = new Deferred();
        }
        this.samplerArr[this.atlasesArr.length] = index;
        // TODO: FontTextureAtlas();
        let atlas = new FontTextureAtlas();
        atlas.height = 0;
        atlas.width = 0;
        atlas.gliphSize = 0;
        atlas.distanceRange = 0;
        atlas.kernings = {};
        atlas.assignHandler(this._handler);
        this.atlasesArr[index] = atlas;
        this._applyFontDataToAtlas(atlas, dataJson, index);
        let img = new Image();
        img.onload = () => {
            this._createTexture(atlas, img);
            def.resolve(index);
        };
        img.src = imageBase64;
    }
    _createTexture(atlas, img) {
        atlas.createTexture(img);
    }
    loadFont(faceName, srcDir, atlasUrl) {
        let index = this.atlasesArr.length;
        let fullName = this.getFullIndex(faceName);
        this.atlasIndexes[fullName] = index;
        let def = this.atlasIndexesDeferred[fullName];
        if (!def) {
            def = this.atlasIndexesDeferred[fullName] = new Deferred();
        }
        this.samplerArr[this.atlasesArr.length] = index;
        // TODO: FontTextureAtlas();
        let atlas = new FontTextureAtlas();
        atlas.height = 0;
        atlas.width = 0;
        atlas.gliphSize = 0;
        atlas.distanceRange = 0;
        atlas.kernings = {};
        atlas.assignHandler(this._handler);
        this.atlasesArr[index] = atlas;
        fetch(`${srcDir}/${atlasUrl}`)
            .then((response) => {
            if (!response.ok) {
                throw Error(`Unable to load "${srcDir}/${atlasUrl}"`);
            }
            //return response.json(response);
            return response.json();
        })
            .then((data) => {
            this._applyFontDataToAtlas(atlas, data, index);
            let img = new Image();
            img.onload = () => {
                this._createTexture(atlas, img);
                def.resolve(index);
            };
            img.src = `${srcDir}/${data.pages[0]}`;
            img.crossOrigin = "Anonymous";
        })
            .catch(err => {
            def.reject();
            return { 'status': "error", 'msg': err.toString() };
        });
    }
}

function screenFrame() {
    return new Program("screenFrame", {
        uniforms: {
            texture: "sampler2d"
        },
        attributes: {
            corners: "vec3"
        },
        vertexShader: `attribute vec2 corners;
            
            varying vec2 tc;
            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
                tc = corners * 0.5 + 0.5;
            }`,
        fragmentShader: `precision highp float;
            uniform sampler2D texture;
            
            varying vec2 tc;
            
            void main(void) {
                gl_FragColor = texture2D( texture, tc );
            }`
    });
}

function toneMapping() {
    return new Program("toneMapping", {
        uniforms: {
            hdrBuffer: "sampler2d",
            exposure: "float",
            gamma: "float",
            whitepoint: "float"
        },
        attributes: {
            corners: "vec3"
        },
        vertexShader: `#version 300 es
            
            in vec2 corners;
            
            out vec2 tc;

            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
                tc = corners * 0.5 + 0.5;
            }`,
        fragmentShader: `#version 300 es

            precision highp float;

            #ifndef saturate
                #define saturate(a) clamp(a, 0.0, 1.0)
            #endif

            uniform sampler2D hdrBuffer;

            uniform float whitepoint;
            uniform float exposure;
            uniform float gamma;

            vec3 LinearToneMapping(vec3 color) {
                return exposure * color;
            }

            vec3 ReinhardToneMapping2(vec3 color) {
                return vec3(1.0) - exp(-color * exposure);
            }

            vec3 ReinhardToneMapping(vec3 color) {
                color *= exposure;
                return saturate(color / (vec3(1.0) + color));
            }

            #define Uncharted2Helper(x) max(((x * (0.15 * x + 0.10 * 0.50) + 0.20 * 0.02) / (x * (0.15 * x + 0.50) + 0.20 * 0.30)) - 0.02 / 0.30, vec3(0.0))

            vec3 Uncharted2ToneMapping(vec3 color) {
                color *= exposure;
                return saturate(Uncharted2Helper(color) / Uncharted2Helper(vec3(whitepoint)));
            }

            vec3 OptimizedCineonToneMapping(vec3 color) {
                color *= exposure;
                color = max(vec3(0.0), color - 0.004);
                return pow((color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06), vec3(2.2));
            }

            vec3 ACESFilmicToneMapping(vec3 color) {
                color *= exposure;
                return saturate((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14));
            }

            in vec2 tc;

            layout(location = 0) out vec4 fragColor;
            
            void main(void) {
                vec4 hdrColor = texture(hdrBuffer, tc).rgba;
                
                float oneByGamma = gamma / gamma;
                float oneByWhitePoint = whitepoint / whitepoint;
                vec3 mapped = ReinhardToneMapping2(hdrColor.rgb) * oneByGamma * oneByWhitePoint;
                //vec3 mapped = ACESFilmicToneMapping(hdrColor.rgb) * oneByGamma * oneByWhitePoint;

                mapped = pow(mapped, vec3(1.0 / gamma));
        
                fragColor = vec4(mapped, hdrColor.a);
            }`
    });
}

const MSAA_DEFAULT = 0;
let __pickingCallbackCounter__ = 0;
let __depthCallbackCounter__ = 0;
let __distanceCallbackCounter__ = 0;
function clientWaitAsync(gl, sync, flags) {
    return new Promise((resolve, reject) => {
        function check() {
            const res = gl.clientWaitSync(sync, flags, 0);
            if (res == gl.WAIT_FAILED) {
                reject();
            }
            else if (res == gl.TIMEOUT_EXPIRED) {
                requestAnimationFrame(check);
            }
            else {
                resolve();
            }
        }
        check();
    });
}
class Renderer {
    constructor(handler, params = {}) {
        this._readPickingBuffer_webgl1 = () => {
            this.pickingFramebuffer.activate();
            this.pickingFramebuffer.readAllPixels(this._tempPickingPix_);
            this.pickingFramebuffer.deactivate();
        };
        this._readPickingBuffer_webgl2 = () => {
            const gl = this.handler.gl;
            const buf = this._pickingPixelBuffer;
            if (!this._skipPickingFrame) {
                this._skipPickingFrame = true;
                let dest = this._tempPickingPix_;
                let w = this.pickingFramebuffer.width, h = this.pickingFramebuffer.height;
                this.pickingFramebuffer.activate();
                gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
                gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);
                gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, 0);
                gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
                this.pickingFramebuffer.deactivate();
                const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
                gl.flush();
                clientWaitAsync(gl, sync, 0).then(() => {
                    this._skipPickingFrame = false;
                    gl.deleteSync(sync);
                    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
                    gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dest);
                    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
                });
            }
        };
        this._readDistanceBuffer_webgl1 = () => {
            this.distanceFramebuffer.activate();
            this.distanceFramebuffer.readAllPixels(this._tempDistancePix_);
            this.distanceFramebuffer.deactivate();
        };
        this._readDistanceBuffer_webgl2 = () => {
            const gl = this.handler.gl;
            const buf = this._distancePixelBuffer;
            if (!this._skipDistanceFrame) {
                this._skipDistanceFrame = true;
                let dest = this._tempDistancePix_;
                let w = this.distanceFramebuffer.width, h = this.distanceFramebuffer.height;
                this.distanceFramebuffer.activate();
                gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
                gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);
                gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, 0);
                gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
                this.distanceFramebuffer.deactivate();
                const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
                gl.flush();
                clientWaitAsync(gl, sync, 0).then(() => {
                    this._skipDistanceFrame = false;
                    gl.deleteSync(sync);
                    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
                    gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dest);
                    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
                });
            }
        };
        this.div = null;
        this.handler = handler;
        this.exposure = params.exposure || 3.01;
        this.gamma = params.gamma || 0.47;
        this.whitepoint = 1.0;
        this.brightThreshold = 0.9;
        this._renderNodesArr = [];
        this.renderNodes = {};
        this.activeCamera = null;
        this.events = createRendererEvents(this);
        this.controls = {};
        if (params.controls) {
            for (let i in params.controls) {
                this.controls[params.controls[i].name] = params.controls[i];
            }
        }
        this.controlsBag = {};
        this.colorObjects = new Map();
        this._pickingCallbacks = [];
        this.pickingFramebuffer = null;
        this._tempPickingPix_ = new Uint8Array([]);
        this.distanceFramebuffer = null;
        this._distanceCallbacks = [];
        this._tempDistancePix_ = new Uint8Array([]);
        this._depthCallbacks = [];
        this.depthFramebuffer = null;
        let urlParams = new URLSearchParams(location.search);
        let msaaParam = urlParams.get('og_msaa');
        if (msaaParam) {
            this._msaa = Number(urlParams.get('og_msaa'));
        }
        else {
            this._msaa = params.msaa != undefined ? params.msaa : MSAA_DEFAULT;
        }
        this._internalFormat = "RGBA16F";
        this._format = "RGBA";
        this._type = "FLOAT";
        this.sceneFramebuffer = null;
        this.blitFramebuffer = null;
        this.toneMappingFramebuffer = null;
        this._initialized = false;
        /**
         * Texture atlas for the billboards images. One atlas per node.
         * @public
         * @type {TextureAtlas}
         */
        this.billboardsTextureAtlas = new TextureAtlas();
        /**
         * Texture atlas for the billboards images. One atlas per node.
         * @public
         * @type {TextureAtlas}
         */
        this.geoObjectsTextureAtlas = new TextureAtlas();
        /**
         * Texture font atlas for the font families and styles. One atlas per node.
         * @public
         * @type {FontAtlas}
         */
        this.fontAtlas = new FontAtlas(params.fontsSrc);
        this._entityCollections = [];
        this._currentOutput = "screen";
        this._fnScreenFrame = null;
        this.labelWorker = new LabelWorker(4);
        this.__useDistanceFramebuffer__ = true;
        this.screenDepthFramebuffer = null;
        this.screenFramePositionBuffer = null;
        this.screenTexture = {};
        this.outputTexture = null;
        this._skipDistanceFrame = false;
        this._distancePixelBuffer = null;
        this._skipPickingFrame = false;
        this._pickingPixelBuffer = null;
        this._readDistanceBuffer = this._readDistanceBuffer_webgl2;
        this._readPickingBuffer = this._readPickingBuffer_webgl2;
        if (params.autoActivate || isEmpty(params.autoActivate)) {
            this.start();
        }
    }
    enableBlendOneSrcAlpha() {
        let gl = this.handler.gl;
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    }
    enableBlendDefault() {
        let gl = this.handler.gl;
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
    }
    /**
     * Sets renderer events activity.
     * @param {Boolean} activity - Events activity.
     */
    setEventsActivity(activity) {
        this.events.active = activity;
    }
    addDepthCallback(sender, callback) {
        let id = __depthCallbackCounter__++;
        this._depthCallbacks.push({
            id: id, callback: callback, sender: sender
        });
        return id;
    }
    removeDepthCallback(id) {
        for (let i = 0; i < this._depthCallbacks.length; i++) {
            if (id === this._depthCallbacks[i].id) {
                this._depthCallbacks.splice(i, 1);
                break;
            }
        }
    }
    addDistanceCallback(sender, callback) {
        let id = __distanceCallbackCounter__++;
        this._distanceCallbacks.push({
            id: id, callback: callback, sender: sender
        });
        return id;
    }
    removeDistanceCallback(id) {
        for (let i = 0; i < this._distanceCallbacks.length; i++) {
            if (id === this._distanceCallbacks[i].id) {
                this._distanceCallbacks.splice(i, 1);
                break;
            }
        }
    }
    /**
     * Adds picking rendering callback function.
     * @param {object} sender - Callback context.
     * @param {Function} callback - Rendering callback.
     * @returns {Number} Handler id
     */
    addPickingCallback(sender, callback) {
        let id = __pickingCallbackCounter__++;
        this._pickingCallbacks.push({
            id: id, callback: callback, sender: sender
        });
        return id;
    }
    /**
     * Removes picking rendering callback function.
     * @param {Number} id - Handler id to remove.
     */
    removePickingCallback(id) {
        for (let i = 0; i < this._pickingCallbacks.length; i++) {
            if (id === this._pickingCallbacks[i].id) {
                this._pickingCallbacks.splice(i, 1);
                break;
            }
        }
    }
    getPickingObject(r, g, b) {
        return this.colorObjects.get(`${r}_${g}_${b}`);
    }
    getPickingObjectArr(arr) {
        return this.colorObjects.get(`${arr[0]}_${arr[1]}_${arr[2]}`);
    }
    getPickingObject3v(vec) {
        return this.colorObjects.get(`${vec.x}_${vec.y}_${vec.z}`);
    }
    /**
     * Assign picking color to the object.
     * @public
     * @param {Object} obj - Object that presume to be picked.
     */
    assignPickingColor(obj) {
        if (!obj._pickingColor || obj._pickingColor.isZero()) {
            let r = 0, g = 0, b = 0;
            let str = "0_0_0";
            while (!(r || g || b) || this.colorObjects.has(str)) {
                r = randomi(1, 255);
                g = randomi(1, 255);
                b = randomi(1, 255);
                str = `${r}_${g}_${b}`;
            }
            if (!obj._pickingColor) {
                obj._pickingColor = new Vec3(r, g, b);
            }
            else {
                obj._pickingColor.set(r, g, b);
            }
            obj._pickingColorU = new Float32Array([r / 255, g / 255, b / 255]);
            this.colorObjects.set(str, obj);
        }
    }
    /**
     * Removes picking color from object.
     * @public
     * @param {Object} obj - Object to remove picking color.
     */
    clearPickingColor(obj) {
        if (obj._pickingColor && !obj._pickingColor.isZero()) {
            let c = obj._pickingColor;
            if (!c.isZero()) {
                this.colorObjects.delete(`${c.x}_${c.y}_${c.z}`);
                c.x = c.y = c.z = 0;
            }
        }
    }
    /**
     * Get the client width.
     * @public
     * @returns {number} -
     */
    getWidth() {
        return this.handler.canvas.clientWidth;
    }
    /**
     * Get the client height.
     * @public
     * @returns {number} -
     */
    getHeight() {
        return this.handler.canvas.clientHeight;
    }
    /**
     * Get center of the canvas
     * @public
     * @returns {Vec2} -
     */
    getCenter() {
        let cnv = this.handler.canvas;
        return new Vec2(Math.round(cnv.width * 0.5), Math.round(cnv.height * 0.5));
    }
    /**
     * Get center of the screen viewport
     * @public
     * @returns {Vec2} -
     */
    getClientCenter() {
        let cnv = this.handler.canvas;
        return new Vec2(Math.round(cnv.clientWidth * 0.5), Math.round(cnv.clientHeight * 0.5));
    }
    /**
     * Add the given control to the renderer.
     * @param {Control} control - Control.
     */
    addControl(control) {
        control.addTo(this);
    }
    /**
     * Add the given controls array to the planet node.
     * @param {Array.<Control>} cArr - Control array.
     */
    addControls(cArr) {
        for (let i = 0; i < cArr.length; i++) {
            cArr[i].addTo(this);
        }
    }
    /**
     * Remove control from the renderer.
     * @param {Control} control  - Control.
     */
    removeControl(control) {
        control.remove();
    }
    isInitialized() {
        return this._initialized;
    }
    /**
     * Renderer initialization.
     * @public
     */
    initialize() {
        if (this._initialized) {
            return;
        }
        else {
            this._initialized = true;
        }
        this.handler.initialize();
        this.billboardsTextureAtlas.assignHandler(this.handler);
        this.geoObjectsTextureAtlas.assignHandler(this.handler);
        this.fontAtlas.assignHandler(this.handler);
        this.handler.setFrameCallback(() => {
            this.draw();
        });
        this.activeCamera = new Camera(this, {
            eye: new Vec3(0, 0, 0), look: new Vec3(0, 0, -1), up: new Vec3(0, 1, 0)
        });
        this.events.initialize();
        // Bind console key
        this.events.on("charkeypress", input.KEY_APOSTROPHE, function () {
            cons.setVisibility(!cons.getVisibility());
        });
        this.handler.addProgram(screenFrame());
        this.pickingFramebuffer = new Framebuffer(this.handler, {
            width: 640, height: 480
        });
        this.pickingFramebuffer.init();
        this._tempPickingPix_ = new Uint8Array(this.pickingFramebuffer.width * this.pickingFramebuffer.height * 4);
        this.distanceFramebuffer = new Framebuffer(this.handler, {
            width: 320, height: 240
        });
        this.distanceFramebuffer.init();
        this._tempDistancePix_ = new Uint8Array(this.distanceFramebuffer.width * this.distanceFramebuffer.height * 4);
        //this._tempDistancePix_ = new Uint8Array(4);
        this.depthFramebuffer = new Framebuffer(this.handler, {
            size: 2,
            internalFormat: ["RGBA", "DEPTH_COMPONENT24"],
            format: ["RGBA", "DEPTH_COMPONENT"],
            type: ["UNSIGNED_BYTE", "UNSIGNED_INT"],
            attachment: ["COLOR_ATTACHMENT", "DEPTH_ATTACHMENT"],
            useDepth: false
        });
        this.depthFramebuffer.init();
        this.screenDepthFramebuffer = new Framebuffer(this.handler, {
            useDepth: false
        });
        this.screenDepthFramebuffer.init();
        if (this.handler.gl.type === "webgl") {
            this._readDistanceBuffer = this._readDistanceBuffer_webgl1;
            this._readPickingBuffer = this._readPickingBuffer_webgl1;
            this.sceneFramebuffer = new Framebuffer(this.handler);
            this.sceneFramebuffer.init();
            this._fnScreenFrame = this._screenFrameNoMSAA;
            this.screenTexture = {
                screen: this.sceneFramebuffer.textures[0],
                picking: this.pickingFramebuffer.textures[0],
                distance: this.distanceFramebuffer.textures[0],
                depth: this.screenDepthFramebuffer.textures[0]
            };
        }
        else {
            let _maxMSAA = this.getMaxMSAA(this._internalFormat);
            if (this._msaa > _maxMSAA) {
                this._msaa = _maxMSAA;
            }
            this.handler.addPrograms([toneMapping()]);
            this.handler.addPrograms([depth()]);
            this.sceneFramebuffer = new Multisample(this.handler, {
                size: 1,
                msaa: this._msaa,
                internalFormat: this._internalFormat,
                filter: "LINEAR"
            });
            this.sceneFramebuffer.init();
            this.blitFramebuffer = new Framebuffer(this.handler, {
                size: 1,
                useDepth: false,
                internalFormat: this._internalFormat,
                format: this._format,
                type: this._type,
                filter: "NEAREST"
            });
            this.blitFramebuffer.init();
            this.toneMappingFramebuffer = new Framebuffer(this.handler, {
                useDepth: false
            });
            this.toneMappingFramebuffer.init();
            this._fnScreenFrame = this._screenFrameMSAA;
            this.screenTexture = {
                screen: this.toneMappingFramebuffer.textures[0],
                picking: this.pickingFramebuffer.textures[0],
                distance: this.distanceFramebuffer.textures[0],
                depth: this.screenDepthFramebuffer.textures[0],
                frustum: this.depthFramebuffer.textures[0]
            };
            this._initReadPixelsBuffers();
        }
        this.handler.ONCANVASRESIZE = () => {
            this._resizeStart();
            this.events.dispatch(this.events.resize, this.handler.canvas);
            this._resizeEnd();
            //clearTimeout(__resizeTimeout);
            // __resizeTimeout = setTimeout(() => {
            //     this._resizeEnd();
            //     this.events.dispatch(this.events.resizeend, this.handler.canvas);
            // }, 320);
            this.events.dispatch(this.events.resizeend, this.handler.canvas);
        };
        this.screenFramePositionBuffer = this.handler.createArrayBuffer(new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), 2, 4);
        this.outputTexture = this.screenTexture.screen;
        this._initializeRenderNodes();
        this._initializeControls();
    }
    _initReadPixelsBuffers() {
        let gl = this.handler.gl;
        this._distancePixelBuffer = gl.createBuffer();
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this._distancePixelBuffer);
        gl.bufferData(gl.PIXEL_PACK_BUFFER, this.distanceFramebuffer.width * this.distanceFramebuffer.height * 4, gl.STREAM_READ);
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
        this._pickingPixelBuffer = gl.createBuffer();
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this._pickingPixelBuffer);
        gl.bufferData(gl.PIXEL_PACK_BUFFER, this.pickingFramebuffer.width * this.pickingFramebuffer.height * 4, gl.STREAM_READ);
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    }
    _initializeControls() {
        let temp = this.controls;
        this.controls = {};
        for (let i in temp) {
            this.addControl(temp[i]);
        }
    }
    resize() {
        this._resizeEnd();
    }
    setCurrentScreen(screenName) {
        this._currentOutput = screenName;
        if (this.screenTexture[screenName]) {
            this.outputTexture = this.screenTexture[screenName];
        }
    }
    _resizeStart() {
        let c = this.handler.canvas;
        this.activeCamera.setAspectRatio(c.width / c.height);
        this.sceneFramebuffer.setSize(c.width * 0.5, c.height * 0.5);
        this.blitFramebuffer && this.blitFramebuffer.setSize(c.width * 0.5, c.height * 0.5, true);
    }
    _resizeEnd() {
        let c = this.handler.canvas;
        this.activeCamera.setAspectRatio(c.width / c.height);
        this.sceneFramebuffer.setSize(c.width, c.height);
        this.blitFramebuffer && this.blitFramebuffer.setSize(c.width, c.height, true);
        this.toneMappingFramebuffer && this.toneMappingFramebuffer.setSize(c.width, c.height, true);
        this.depthFramebuffer && this.depthFramebuffer.setSize(c.clientWidth, c.clientHeight, true);
        this.screenDepthFramebuffer && this.screenDepthFramebuffer.setSize(c.clientWidth, c.clientHeight, true);
        if (this.handler.gl.type === "webgl") {
            this.screenTexture.screen = this.sceneFramebuffer.textures[0];
            this.screenTexture.picking = this.pickingFramebuffer.textures[0];
            this.screenTexture.distance = this.distanceFramebuffer.textures[0];
            this.screenTexture.depth = this.screenDepthFramebuffer.textures[0];
            this.screenTexture.frustum = this.depthFramebuffer.textures[0];
        }
        else {
            this.screenTexture.screen = this.toneMappingFramebuffer.textures[0];
            this.screenTexture.picking = this.pickingFramebuffer.textures[0];
            this.screenTexture.distance = this.distanceFramebuffer.textures[0];
            this.screenTexture.depth = this.screenDepthFramebuffer.textures[0];
            this.screenTexture.frustum = this.depthFramebuffer.textures[0];
        }
        this.setCurrentScreen(this._currentOutput);
    }
    removeNode(renderNode) {
        // TODO: replace from RenderNode to this method
        renderNode.remove();
    }
    /**
     * Adds render node to the renderer.
     * @public
     * @param {RenderNode} renderNode - Render node.
     */
    addNode(renderNode) {
        if (!this.renderNodes[renderNode.name]) {
            renderNode.assign(this);
            this._renderNodesArr.unshift(renderNode);
            this.renderNodes[renderNode.name] = renderNode;
        }
        else {
            cons.logWrn(`Node name ${renderNode.name} already exists.`);
        }
    }
    _initializeRenderNodes() {
        for (let i = 0; i < this._renderNodesArr.length; i++) {
            this._renderNodesArr[i].initialize();
        }
    }
    /**
     * Adds render node to the renderer before specific node.
     * @public
     * @param {RenderNode} renderNode - Render node.
     * @param {RenderNode} renderNodeBefore - Insert before the renderNodeBefore node.
     */
    addNodeBefore(renderNode, renderNodeBefore) {
        if (!this.renderNodes[renderNode.name]) {
            renderNode.assign(this);
            this.renderNodes[renderNode.name] = renderNode;
            for (let i = 0; i < this._renderNodesArr.length; i++) {
                if (this._renderNodesArr[i].isEqual(renderNodeBefore)) {
                    this._renderNodesArr.splice(i, 0, renderNode);
                    break;
                }
            }
            this._renderNodesArr.unshift(renderNode);
        }
        else {
            cons.logWrn(`Node name ${renderNode.name} already exists.`);
        }
    }
    /**
     * Adds render nodes array to the renderer.
     * @public
     * @param {Array.<RenderNode>} nodesArr - Render nodes array.
     */
    addNodes(nodesArr) {
        for (let i = 0; i < nodesArr.length; i++) {
            this.addNode(nodesArr[i]);
        }
    }
    getMaxMSAA(internalFormat) {
        let gl = this.handler.gl;
        let samples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl[internalFormat], gl.SAMPLES);
        return samples[0];
    }
    getMSAA() {
        return this._msaa;
    }
    /**
     * TODO: replace with cache friendly linked list by BillboardHandler, LabelHandler etc.
     */
    enqueueEntityCollectionsToDraw(ecArr) {
        this._entityCollections.push.apply(this._entityCollections, ecArr);
    }
    /**
     * Draws opaque items entity collections.
     * @protected
     */
    _drawOpaqueEntityCollections() {
        let ec = this._entityCollections;
        if (ec.length) {
            this.enableBlendDefault();
            // pointClouds pass
            let i = ec.length;
            while (i--) {
                ec[i]._fadingOpacity && ec[i].pointCloudHandler.draw();
            }
        }
    }
    /**
     * Draws transparent items entity collections.
     * @protected
     */
    _drawTransparentEntityCollections() {
        let ec = this._entityCollections;
        if (ec.length) {
            let gl = this.handler.gl;
            this.enableBlendDefault();
            // GeoObjects
            let i = ec.length;
            while (i--) {
                let eci = ec[i];
                if (ec[i]._fadingOpacity) {
                    eci.events.dispatch(eci.events.draw, eci);
                    ec[i].geoObjectHandler.draw();
                }
            }
            // billboards pass
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.billboardsTextureAtlas.texture);
            i = ec.length;
            while (i--) {
                let eci = ec[i];
                eci._fadingOpacity && eci.billboardHandler.draw();
            }
            // labels pass
            let fa = this.fontAtlas.atlasesArr;
            for (i = 0; i < fa.length; i++) {
                gl.activeTexture(gl.TEXTURE0 + i);
                gl.bindTexture(gl.TEXTURE_2D, fa[i].texture);
            }
            i = ec.length;
            while (i--) {
                ec[i]._fadingOpacity && ec[i].labelHandler.draw();
            }
            // rays
            i = ec.length;
            while (i--) {
                ec[i]._fadingOpacity && ec[i].rayHandler.draw();
            }
            // polyline pass
            i = ec.length;
            while (i--) {
                ec[i]._fadingOpacity && ec[i].polylineHandler.draw();
            }
            // Strip pass
            i = ec.length;
            while (i--) {
                ec[i]._fadingOpacity && ec[i].stripHandler.draw();
            }
        }
    }
    _clearEntityCollectionQueue() {
        this._entityCollections.length = 0;
        this._entityCollections = [];
    }
    /**
     * Draw nodes.
     * @public
     */
    draw() {
        this.activeCamera.checkMoveEnd();
        let e = this.events;
        e.handleEvents();
        let sceneFramebuffer = this.sceneFramebuffer;
        sceneFramebuffer.activate();
        let h = this.handler, gl = h.gl;
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.enableBlendDefault();
        e.dispatch(e.draw, this);
        let frustums = this.activeCamera.frustums;
        let pointerEvent = e.pointerEvent();
        let mouseHold = e.mouseState.leftButtonDown || e.mouseState.rightButtonDown;
        // Rendering scene nodes and entityCollections
        let rn = this._renderNodesArr;
        let k = frustums.length;
        while (k--) {
            this.activeCamera.setCurrentFrustum(k);
            gl.clear(gl.DEPTH_BUFFER_BIT);
            let i = rn.length;
            while (i--) {
                rn[i].preDrawNode();
            }
            this._drawOpaqueEntityCollections();
            i = rn.length;
            while (i--) {
                this.enableBlendDefault();
                rn[i].drawNode();
            }
            this._drawTransparentEntityCollections();
            this._clearEntityCollectionQueue();
            e.dispatch(e.drawtransparent, this);
            if (pointerEvent && !mouseHold) {
                this._drawPickingBuffer();
            }
            this.__useDistanceFramebuffer__ && this._drawDistanceBuffer();
        }
        sceneFramebuffer.deactivate();
        this.blitFramebuffer && sceneFramebuffer.blitTo(this.blitFramebuffer, 0);
        if (pointerEvent) {
            if (h.isWebGl2()) {
                // It works ONLY for 0 (closest) frustum
                this._drawDepthBuffer();
            }
            this._readPickingBuffer();
        }
        this.__useDistanceFramebuffer__ && this._readDistanceBuffer();
        // Tone mapping followed by rendering on the screen
        this._fnScreenFrame();
        e.dispatch(e.postdraw, this);
        e.mouseState.wheelDelta = 0;
        e.mouseState.justStopped = false;
        e.mouseState.moving = false;
        e.touchState.moving = false;
    }
    _screenFrameMSAA() {
        let h = this.handler;
        let sh = h.programs.toneMapping, p = sh._program, gl = h.gl;
        gl.disable(gl.DEPTH_TEST);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.screenFramePositionBuffer);
        gl.vertexAttribPointer(p.attributes.corners, 2, gl.FLOAT, false, 0, 0);
        this.toneMappingFramebuffer.activate();
        sh.activate();
        // screen texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.blitFramebuffer.textures[0]);
        gl.uniform1i(p.uniforms.hdrBuffer, 0);
        gl.uniform1f(p.uniforms.gamma, this.gamma);
        gl.uniform1f(p.uniforms.exposure, this.exposure);
        gl.uniform1f(p.uniforms.whitepoint, this.whitepoint);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        this.toneMappingFramebuffer.deactivate();
        // SCREEN PASS
        sh = h.programs.screenFrame;
        p = sh._program;
        sh.activate();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.outputTexture);
        gl.uniform1i(p.uniforms.texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.enable(gl.DEPTH_TEST);
    }
    _screenFrameNoMSAA() {
        let h = this.handler;
        let sh = h.programs.screenFrame, p = sh._program, gl = h.gl;
        gl.disable(gl.DEPTH_TEST);
        sh.activate();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.outputTexture);
        gl.uniform1i(p.uniforms.texture, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.screenFramePositionBuffer);
        gl.vertexAttribPointer(p.attributes.corners, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.enable(gl.DEPTH_TEST);
    }
    /**
     * Draw picking objects framebuffer.
     * @private
     */
    _drawPickingBuffer() {
        this.pickingFramebuffer.activate();
        let h = this.handler;
        let gl = h.gl;
        if (this.activeCamera.isFirstPass) {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        }
        else {
            gl.clear(gl.DEPTH_BUFFER_BIT);
        }
        let dp = this._pickingCallbacks;
        for (let i = 0, len = dp.length; i < len; i++) {
            //
            // draw picking scenes, usually we don't need blending,
            // but sometimes set it manually in the callbacks
            //
            gl.disable(gl.BLEND);
            /**
             * This callback renders picking frame.
             */
            dp[i].callback.call(dp[i].sender);
            gl.enable(gl.BLEND);
        }
        this.pickingFramebuffer.deactivate();
    }
    /**
     * Draw picking objects framebuffer.
     * @protected
     */
    _drawDistanceBuffer() {
        this.distanceFramebuffer.activate();
        let h = this.handler;
        let gl = h.gl;
        if (this.activeCamera.isFirstPass) {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        }
        else {
            gl.clear(gl.DEPTH_BUFFER_BIT);
        }
        gl.disable(gl.BLEND);
        let dp = this._distanceCallbacks;
        let i = dp.length;
        while (i--) {
            /**
             * This callback renders distance frame.
             */
            dp[i].callback.call(dp[i].sender);
        }
        gl.enable(gl.BLEND);
        this.distanceFramebuffer.deactivate();
    }
    _drawDepthBuffer() {
        this.depthFramebuffer.activate();
        let h = this.handler;
        let gl = h.gl;
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);
        let dp = this._depthCallbacks;
        let i = dp.length;
        while (i--) {
            /**
             * This callback renders depth frame.
             */
            dp[i].callback.call(dp[i].sender);
        }
        this.depthFramebuffer.deactivate();
        //
        // PASS to depth visualization
        this.screenDepthFramebuffer.activate();
        let sh = h.programs.depth, p = sh._program;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.screenFramePositionBuffer);
        gl.vertexAttribPointer(p.attributes.corners, 2, gl.FLOAT, false, 0, 0);
        sh.activate();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.depthFramebuffer.textures[1]);
        gl.uniform1i(p.uniforms.depthTexture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        this.screenDepthFramebuffer.deactivate();
    }
    readPickingColor(x, y, outColor) {
        let w = this.pickingFramebuffer.width;
        let h = this.pickingFramebuffer.height;
        x = Math.round(x * w);
        y = Math.round(y * h);
        let ind = (y * w + x) * 4;
        outColor[0] = this._tempPickingPix_[ind];
        outColor[1] = this._tempPickingPix_[ind + 1];
        outColor[2] = this._tempPickingPix_[ind + 2];
    }
    readDistanceColor(x, y, outColor) {
        let w = this.distanceFramebuffer.width;
        let h = this.distanceFramebuffer.height;
        x = Math.round(x * w);
        y = Math.round(y * h);
        let ind = (y * w + x) * 4;
        outColor[0] = this._tempDistancePix_[ind];
        outColor[1] = this._tempDistancePix_[ind + 1];
        outColor[2] = this._tempDistancePix_[ind + 2];
    }
    /**
     * Function starts renderer
     * @public
     */
    start() {
        if (!this._initialized) {
            this.initialize();
        }
        this.handler.start();
    }
    destroy() {
        for (let i in this.controls) {
            this.controls[i].remove();
        }
        for (let i = 0; i < this._renderNodesArr.length; i++) {
            this._renderNodesArr[i].remove();
        }
        this.div = null;
        this._renderNodesArr = [];
        this.renderNodes = {};
        this.activeCamera = null;
        this.controls = {};
        this.controlsBag = {};
        this.colorObjects.clear();
        // @ts-ignore
        this.colorObjects = null;
        this._pickingCallbacks = [];
        this.pickingFramebuffer = null;
        //@ts-ignore
        this._tempPickingPix_ = null;
        this.distanceFramebuffer = null;
        this._distanceCallbacks = [];
        //@ts-ignore
        this._tempDistancePix_ = null;
        this._depthCallbacks = [];
        this.depthFramebuffer = null;
        this.sceneFramebuffer = null;
        this.blitFramebuffer = null;
        this.toneMappingFramebuffer = null;
        // todo
        //this.billboardsTextureAtlas.clear();
        //this.geoObjectsTextureAtlas.clear()
        //this.fontAtlas.clear();
        this._entityCollections = [];
        this.handler.ONCANVASRESIZE = null;
        this.handler.destroy();
        // @ts-ignore
        this.handler = null;
        this._initialized = false;
    }
}

// #StandWithUkraine
const DEFAULT_NIGHT_SRC = `/night.png`;
const DEFAULT_SPEC_SRC = `/spec.png`;
const DEFAULT_RESOURCES_SRC = '/res';
/** @const {string} */
const PLANET_NAME_PREFIX = "globus_planet_";
/**
 * Creates a WebGL context with globe.
 * @class
 *
 * @example <caption>Basic initialization</caption>
 * globus = new Globe({
 *     'atmosphere': false,
 *     'target': 'globus',
 *     'name': 'Earth',
 *     'controls': [
 *          new control.MouseNavigation({ autoActivate: true }),
 *          new control.KeyboardNavigation({ autoActivate: true }),
 *          new control.EarthCoordinates({ autoActivate: true, center: false }),
 *          new control.LayerSwitcher({ autoActivate: true }),
 *          new control.ZoomControl({ autoActivate: true }),
 *          new control.TouchNavigation({ autoActivate: true }),
 *          new control.Sun({ autoActivate: true })
 *      ],
 *     'terrain': new GlobusTerrain(),
 *     'layers': [
 *          new XYZ("OpenStreetMap", { isBaseLayer: true, url: "http://b.tile.openstreetmap.org/{z}/{x}/{y}.png", visibility: true, attribution: 'Data @ <a href="http://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="http://www.openstreetmap.org/copyright">ODbL</a>' })
 *      ],
 *     'autoActivate': true
 * });
 *
 * @param {IGlobeParams} options - Options:
 * @param {string|HTMLElement} options.target - HTML element id where planet canvas have to be created.
 * @param {string} [options.name] - Planet name. Default is uniq identifier.
 * @param {EmptyTerrain} [options.terrain] - Terrain provider. Default no terrain - og.terrain.EmptyTerrain.
 * @param {Array.<Control>} [options.controls] - Renderer controls array.
 * @param {Array.<Layer>} [options.layers] - Planet layers.
 * @param {Extent| [[number, number],[number, number]]} [options.viewExtent] - Viewable starting extent.
 * @param {boolean} [options.autoActivate=true] - Globe rendering auto activation flag. True is default.
 * @param {HTMLElement} [options.attributionContainer] - Container for attribution list.
 * @param {number} [options.maxGridSize=128] = Maximal segment grid size. 128 is default
 * @param {string} [options.fontsSrc] -  Fonts collection url.
 * @param {string} [options.resourcesSrc] - Resources root src.
 * @param {string} [options.nightTextureSrc] - Night glowing image sources
 * @param {string} [options.specularTextureSrc] - Specular water mask image sourcr
 * @param {number} [options.maxAltitude=15000000.0] - Maximal camera altitude above terrain
 * @param {number} [options.minAltitude=1.0] - Minimal camera altitude above terrain
 * @param {number} [options.maxEqualZoomAltitude=15000000.0] - Maximal altitude since segments on the screen became the same zoom level
 * @param {number} [options.minEqualZoomAltitude=10000.0] - Minimal altitude since segments on the screen became the same zoom level
 * @param {number} [options.minEqualZoomCameraSlope=0.8] - Minimal camera slope above te globe where segments on the screen became the same zoom level
 * @param {number} [options.loadingBatchSize=12] -
 * @param {number} [options.quadTreeStrategyPrototype] - Prototype of quadTree. QuadTreeStrategy for Earth is default.
 * @param {number} [options.msaa=0] - MSAA antialiasing parameter: 2,4,8,16. Default is 0.
 * @param {number} [options.dpi] - Device pixel ratio. Default is current screen DPI.
 * @param {boolean} [options.atmosphereEnabled] - Enables atmosphere effect.
 * @param {boolean} [options.transtitionOpacityEnabled] - Enables terrain smooth opacity transition effect.
 * @param {IAtmosphereParams} [options.atmosphereParameters] - Atmosphere model parameters.
 * @param {number} [options.gamma] - Gamma
 * @param {number} [options.exposure] - Exposure
 */
class Globe {
    constructor(options) {
        this.$target = null;
        this._instanceID = `__globus${Globe.__counter__++ ? Globe.__counter__ : ""}__`;
        window[this._instanceID] = this;
        //
        // Canvas creation
        //
        this._canvas = document.createElement("canvas");
        this._canvas.id = `canvas${this._instanceID}`;
        this._canvas.style.width = "100%";
        this._canvas.style.height = "100%";
        this._canvas.style.display = "block";
        this._canvas.style.opacity = "0.0";
        this._canvas.style.transition = "opacity 150ms";
        /**
         * Dom element where WebGL canvas creates
         * @public
         * @type {Element}
         */
        this.$inner = document.createElement('div');
        this.$inner.classList.add("og-inner");
        this.$inner.appendChild(this._canvas);
        this.$inner.attributions = document.createElement('div');
        if (options.attributionContainer) {
            options.attributionContainer.appendChild(this.$inner.attributions);
        }
        else {
            this.$inner.attributions.classList.add("og-attribution");
            this.$inner.appendChild(this.$inner.attributions);
        }
        if (options.target) {
            this.attachTo(options.target);
        }
        const _disableWheel = (e) => {
            e.preventDefault();
        };
        this._canvas.onmouseenter = function () {
            document.addEventListener("mousewheel", _disableWheel, {
                capture: false,
                passive: false
            });
        };
        this._canvas.onmouseleave = function () {
            document.removeEventListener("mousewheel", _disableWheel);
        };
        this.renderer = new Renderer(new Handler(this._canvas, {
            autoActivate: false,
            pixelRatio: options.dpi || (window.devicePixelRatio + 0.15),
            context: {
                //alpha: false,
                antialias: false,
                premultipliedAlpha: false
            }
        }), {
            autoActivate: false,
            msaa: options.msaa,
            fontsSrc: options.fontsSrc,
            gamma: options.gamma,
            exposure: options.exposure,
        });
        this.renderer.div = this.$inner;
        // Skybox
        if (options.skybox) {
            this.renderer.addNode(options.skybox);
        }
        this._planetName = options.name ? options.name : PLANET_NAME_PREFIX + Globe.__counter__;
        this.planet = new Planet({
            name: this._planetName,
            frustums: options.frustums,
            ellipsoid: options.ellipsoid,
            maxGridSize: options.maxGridSize,
            nightTextureSrc: options.nightTextureSrc === null ? null : `${options.resourcesSrc || DEFAULT_RESOURCES_SRC}${DEFAULT_NIGHT_SRC}`,
            specularTextureSrc: options.specularTextureSrc === null ? null : `${options.resourcesSrc || DEFAULT_RESOURCES_SRC}${DEFAULT_SPEC_SRC}`,
            minAltitude: options.minAltitude,
            maxAltitude: options.maxAltitude || 15000000,
            maxEqualZoomAltitude: options.maxEqualZoomAltitude,
            minEqualZoomAltitude: options.minEqualZoomAltitude,
            minEqualZoomCameraSlope: options.minEqualZoomCameraSlope,
            quadTreeStrategyPrototype: options.quadTreeStrategyPrototype,
            maxLoadingRequests: options.maxLoadingRequests,
            atmosphereEnabled: options.atmosphereEnabled,
            transitionOpacityEnabled: options.transitionOpacityEnabled,
            atmosphereParameters: options.atmosphereParameters,
        });
        // Attach terrain provider (can be one object or array)
        if (options.terrain) {
            //@todo: refactoring
            if (Array.isArray(options.terrain)) {
                this.planet.setTerrain(options.terrain[0]); // If array get the terrain from 1st element
            }
            else {
                this.planet.setTerrain(options.terrain);
            }
        }
        else {
            this.planet.setTerrain(new EmptyTerrain());
        }
        this.renderer.addNode(this.planet);
        // Add controls
        if (options.controls) {
            this.planet.addControls(options.controls);
        }
        else {
            this.planet.addControls([
                new ZoomControl(),
                options.useEarthNavigation ? new EarthNavigation() : new MouseNavigation({ minSlope: options.minSlope }),
                new TouchNavigation(),
                new EarthCoordinates(),
                new ScaleControl(),
                new CompassButton()
            ]);
        }
        const _controls = this.renderer.controls;
        let sun;
        for (let i in _controls) {
            if (_controls[i] instanceof Sun) {
                sun = _controls[i];
                break;
            }
        }
        if (!sun) {
            this.sun = new Sun();
            this.planet.addControl(this.sun);
        }
        else {
            this.sun = sun;
        }
        if (options.sun) {
            if (options.sun.active !== undefined && !options.sun.active) {
                this.sun.deactivate();
            }
            if (options.sun.stopped === true) {
                this.sun.stop();
            }
        }
        if (options.layers) {
            this.planet.addLayers(options.layers);
        }
        // TODO: view center, altitude, extent
        let ve = options.viewExtent;
        if (ve) {
            if (ve instanceof Array) {
                this.planet.viewExtentArr(ve);
            }
            else {
                this.planet.viewExtent(ve);
            }
        }
        // Run!
        if (options.autoActivate || isEmpty(options.autoActivate)) {
            this.start();
        }
    }
    start() {
        this.renderer.start();
        this.fadeIn();
    }
    /**
     * Starts screen brightness fading in effect by the duration time.
     * @public
     */
    fadeIn() {
        this._canvas.style.opacity = "1.0";
    }
    /**
     * Starts screen brightness fading out effect by the duration time.
     * @public
     */
    fadeOut() {
        this._canvas.style.opacity = "0";
    }
    attachTo(target, isFirst) {
        this.detach();
        let t;
        if (target instanceof HTMLElement) {
            t = target;
        }
        else {
            t = document.getElementById(target) || document.querySelector(target);
        }
        if (t) {
            this.$target = t;
            if (isFirst && this.$target.firstChild) {
                this.$target.insertBefore(this.$inner, this.$target.firstChild);
            }
            else {
                t.appendChild(this.$inner);
            }
        }
    }
    detach() {
        if (this.$target) {
            // Remember that when container is zero
            // sized(display none etc.) renderer frame will be stopped
            this.$target.removeChild(this.$inner);
            this.$target = null;
        }
    }
    destroy() {
        this.detach();
        this.planet.layers.forEach(l => l.remove());
        this.planet.destroy();
        this.renderer.destroy();
        window[this._instanceID] = null;
    }
}
Globe.__counter__ = 0;

/**
 * Mars ellipsoid object.
 * @type {Ellipsoid}
 */
const mars = new Ellipsoid(3396200.0, 3389508.0);

/**
 * Moon ellipsoid object.
 * @type {Ellipsoid}
 */
const moon = new Ellipsoid(1737400.0, 1737400.0); // Equitorial Radius (m), Polar Radius (m)

const TEMPLATE = `<div class="og-popup {className}">
      <div class="og-popup-content-wrapper">
        <div class="og-popup-content"></div>
      </div>
      <div class="og-popup-tip-container">
        <div class="og-popup-tip"></div>
      </div>
      <div class="og-popup-toolbar">
        <div class="og-popup-btn og-popup-close">${CLOSE_ICON}</div>
      </div>
      <div class="og-popup-title">{title}</div>
    </div>`;
const POPUP_EVENTS = ["open", "close"];
class Popup extends View {
    constructor(options) {
        super({
            template: stringTemplate(TEMPLATE, {
                title: options.title || ""
            }),
            classList: options.className ? [options.className] : [],
            ...options
        });
        //@ts-ignore
        this.events = this.events.registerNames(POPUP_EVENTS);
        this._content = options.content || "";
        this.$content = null;
        this.$tip = null;
        this.$title = null;
        this._planet = options.planet;
        this._offset = options.offset || [0, 0];
        this._lonLat = createLonLat(options.lonLat);
        this._cartPos = new Vec3();
        this._visibility = options.visibility || false;
        this.render();
    }
    _updatePosition() {
        this.setCartesian3v(this._cartPos);
    }
    setScreen(p) {
        if (this._planet) {
            let r = this._planet.renderer.handler.pixelRatio;
            this.el.style.transform =
                `translate(${p.x / r - this.clientWidth * 0.5}px, ${p.y / r - this._planet.renderer.handler.canvas.clientHeight - this.$tip.clientHeight}px)`;
        }
    }
    get clientWidth() {
        return this.el ? this.el.clientWidth : 0;
    }
    get clientHeight() {
        return this.el ? this.el.clientHeight : 0;
    }
    setOffset(x = 0, y = 0) {
        this._offset[0] = x;
        this._offset[1] = y;
        if (this.el) {
            this.el.style.left = `${x}px`;
            this.el.style.bottom = `${y}px`;
        }
        return this;
    }
    render(params) {
        super.render(params);
        this.$content = this.select(".og-popup-content");
        this.$title = this.select(".og-popup-title");
        this.$tip = this.select(".og-popup-tip-container");
        this.setOffset(this._offset[0], this._offset[1]);
        this.setContent(this._content);
        this.setLonLat(this._lonLat);
        this.setVisibility(this._visibility);
        this.select(".og-popup-close").addEventListener("click", () => {
            this.hide();
        });
        return this;
    }
    setVisibility(visibility) {
        if (visibility) {
            this.show();
        }
        else {
            this.hide();
        }
        return this;
    }
    getContainer() {
        return this.$content;
    }
    getToolbarContainer() {
        return this.select(".og-popup-toolbar");
    }
    show() {
        this._visibility = true;
        if (this._planet) {
            this._planet.events.on("draw", this._updatePosition, this);
            this.appendTo(this._planet.renderer.div);
            this.events.dispatch(this.events.open, this);
        }
        return this;
    }
    hide() {
        this._visibility = false;
        if (this.el && this.el.parentNode) {
            this._planet.events.off("draw", this._updatePosition);
            this.el.parentNode.removeChild(this.el);
            this.events.dispatch(this.events.close, this);
        }
        return this;
    }
    setCartesian3v(cart, height = 0) {
        this._cartPos = cart;
        if (this._planet) {
            let cam = this._planet.camera;
            let f = this._planet.ellipsoid.equatorialSize + height, g = cam._lonLat.height;
            let look = cart.sub(cam.eye), v = Math.sqrt((f + g) * (f + g) - f * f);
            if (v > look.length() && cam.getForward().dot(look.normalize()) > 0.0) {
                this.el.style.display = "block";
                this.setScreen(cam.project(cart));
            }
            else {
                this.el.style.display = "none";
            }
        }
        return this;
    }
    setTitle(html) {
        if (this.$title) {
            this.$title.innerHTML = html;
        }
    }
    setLonLat(lonLat) {
        this._lonLat = lonLat;
        if (this._planet) {
            this.setCartesian3v(this._planet.ellipsoid.lonLatToCartesian(lonLat), lonLat.height);
        }
    }
    setContent(content) {
        if (content) {
            this.clear();
            this._content = content;
            if (this.$content) {
                if (typeof content === "string") {
                    this.$content.innerHTML = content;
                }
                else {
                    this.$content.appendChild(content);
                }
            }
        }
    }
    clear() {
        this._content = null;
        if (this.$content) {
            this.$content.innerHTML = "";
        }
    }
}

class SegmentLonLatEqui extends SegmentLonLat {
    constructor(node, planet, tileZoom, extent) {
        super(node, planet, tileZoom, extent);
        this._projection = equi;
        this.isPole = false;
        this._tileGroup = TILEGROUP_COMMON;
    }
    _getMaxZoom() {
        return 150;
    }
    _assignTileYIndexes(extent) {
        const lat = extent.getCenter().lat;
        this.tileY = getTileCellIndex(lat, extent.getHeight(), 90.0);
        this.tileYN = this.tileY - 1;
        this.tileYS = this.tileY + 1;
    }
    _assignTileXIndexes(extent) {
        let lon = extent.getCenter().lon;
        this.tileX = getTileCellIndex(lon, extent.getWidth(), -180);
        let p2 = (1 << this.tileZoom) * 2;
        this.tileXE = (this.tileX + 1) % p2;
        this.tileXW = (p2 + this.tileX - 1) % p2;
    }
}

class EquiEntityCollectionNodeLonLat extends EntityCollectionNode {
    constructor(strategy, partId, parent, extent, planet, zoom) {
        super(strategy, partId, parent, extent, planet, zoom);
        this.strategy = strategy;
    }
    createChildrenNodes() {
        const s = this.strategy;
        const ext = this.extent;
        const size_x = ext.getWidth() * 0.5;
        const size_y = ext.getHeight() * 0.5;
        const ne = ext.northEast;
        const sw = ext.southWest;
        const c = new LonLat(sw.lon + size_x, sw.lat + size_y);
        const nd = this.childrenNodes;
        const p = this.layer._planet;
        const z = this.zoom + 1;
        nd[NW] = new EquiEntityCollectionNodeLonLat(s, NW, this, new Extent(new LonLat(sw.lon, sw.lat + size_y), new LonLat(sw.lon + size_x, ne.lat)), p, z);
        nd[NE] = new EquiEntityCollectionNodeLonLat(s, NE, this, new Extent(c, new LonLat(ne.lon, ne.lat)), p, z);
        nd[SW] = new EquiEntityCollectionNodeLonLat(s, SW, this, new Extent(new LonLat(sw.lon, sw.lat), c), p, z);
        nd[SE] = new EquiEntityCollectionNodeLonLat(s, SE, this, new Extent(new LonLat(sw.lon + size_x, sw.lat), new LonLat(ne.lon, sw.lat + size_y)), p, z);
    }
    _setExtentBounds() {
        this.bsphere.setFromExtent(this.layer._planet.ellipsoid, this.extent);
    }
    __setLonLat__(entity) {
        if (entity._lonLat.isZero()) {
            entity._lonLat = this.layer._planet.ellipsoid.cartesianToLonLat(entity._cartesian);
        }
        return entity._lonLat;
    }
    isVisible() {
        if (this.strategy._renderingNodesWest[this.nodeId]) {
            return true;
        }
        else if (this.strategy._renderingNodesEast[this.nodeId]) {
            return true;
        }
        return false;
    }
    isInside(entity) {
        return this.extent.isInside(entity._lonLat);
    }
    renderCollection(outArr, visibleNodes, renderingNode) {
        if (this.extent.southWest.lon < 0) {
            this.strategy._renderingNodesWest[this.nodeId] = true;
        }
        else {
            this.strategy._renderingNodesEast[this.nodeId] = true;
        }
        if (this.deferredEntities.length && !this._inTheQueue) {
            if (this.layer.async) {
                this.strategy._queueDeferredNode(this);
            }
            else {
                this.applyCollection();
            }
        }
        const ec = this.entityCollection;
        ec._fadingOpacity = this.layer._fadingOpacity;
        ec.scaleByDistance = this.layer.scaleByDistance;
        ec.pickingScale = this.layer.pickingScale;
        if (!ec.isEmpty()) {
            outArr.push(ec);
        }
    }
}

class EquiEntityCollectionsTreeStrategy extends EntityCollectionsTreeStrategy {
    constructor(layer, nodeCapacity) {
        super(layer, nodeCapacity);
        let planet = layer._planet;
        this._entityCollectionsTreeWest = new EquiEntityCollectionNodeLonLat(this, NW, null, Extent.createFromArray([-180, -90, 0, 90]), planet, 0);
        this._entityCollectionsTreeEast = new EquiEntityCollectionNodeLonLat(this, NW, null, Extent.createFromArray([0, -90, 180, 90]), planet, 0);
        this._renderingNodesWest = {};
        this._renderingNodesEast = {};
    }
    insertEntity(entity, rightNow = false) {
        if (entity._lonLat.lon < 0) {
            this._entityCollectionsTreeWest.__setLonLat__(entity);
            this._entityCollectionsTreeWest.insertEntity(entity, rightNow);
        }
        else {
            this._entityCollectionsTreeEast.__setLonLat__(entity);
            this._entityCollectionsTreeEast.insertEntity(entity, rightNow);
        }
    }
    setPickingEnabled(pickingEnabled) {
        this._entityCollectionsTreeWest.traverseTree((node) => {
            node.entityCollection.setPickingEnabled(pickingEnabled);
        });
        this._entityCollectionsTreeEast.traverseTree((node) => {
            node.entityCollection.setPickingEnabled(pickingEnabled);
        });
    }
    dispose() {
        //@ts-ignore
        this._entityCollectionsTreeWest = null;
        //@ts-ignore
        this._entityCollectionsTreeEast = null;
        this._renderingNodesWest = {};
        this._renderingNodesEast = {};
    }
    insertEntities(entitiesForTree) {
        let westEntities = [], eastEntities = [];
        for (let i = 0, len = entitiesForTree.length; i < len; i++) {
            let entity = entitiesForTree[i];
            if (entity._lonLat.lon < 0) {
                westEntities.push(entity);
                this._entityCollectionsTreeWest.__setLonLat__(entity);
            }
            else {
                eastEntities.push(entity);
                this._entityCollectionsTreeEast.__setLonLat__(entity);
            }
        }
        this._entityCollectionsTreeWest.buildTree(westEntities);
        this._entityCollectionsTreeEast.buildTree(eastEntities);
    }
    collectVisibleEntityCollections(outArr) {
        this._renderingNodesWest = {};
        this._renderingNodesEast = {};
        let pqs = this._layer._planet.quadTreeStrategy;
        // Wset
        this._secondPASS = [];
        this._entityCollectionsTreeWest.collectRenderCollectionsPASS1(pqs._visibleNodesWest, outArr);
        let i = this._secondPASS.length;
        while (i--) {
            this._secondPASS[i].collectRenderCollectionsPASS2(pqs._visibleNodesWest, outArr, this._secondPASS[i].nodeId);
        }
        // East
        this._secondPASS = [];
        this._entityCollectionsTreeEast.collectRenderCollectionsPASS1(pqs._visibleNodesEast, outArr);
        i = this._secondPASS.length;
        while (i--) {
            this._secondPASS[i].collectRenderCollectionsPASS2(pqs._visibleNodesEast, outArr, this._secondPASS[i].nodeId);
        }
    }
}

class EquiQuadTreeStrategy extends QuadTreeStrategy {
    constructor(planet) {
        super(planet, "Mars", equi);
        this._westExtent = Extent.createFromArray([-180, -90, 0, 90]);
        this._eastExtent = Extent.createFromArray([0, -90, 180, 90]);
        this._visibleNodesWest = {};
        this._visibleNodesEast = {};
    }
    init() {
        this._quadTreeList = [
            new Node$1(SegmentLonLatEqui, this.planet, 0, null, 0, this._westExtent),
            new Node$1(SegmentLonLatEqui, this.planet, 0, null, 0, this._eastExtent)
        ];
    }
    getTileXY(lonLat, zoom) {
        let z = zoom, x = -1, y = -1, pz = (1 << z);
        if (lonLat.lon > 0) {
            x = getTileCellIndex(lonLat.lon, 180 / pz, 0) + pz;
        }
        else {
            x = getTileCellIndex(lonLat.lon, 180 / pz, -180);
        }
        y = getTileCellIndex(lonLat.lat, 180 / pz, 90);
        return [x, y, z, TILEGROUP_COMMON];
    }
    getLonLatTileOffset(lonLat, x, y, z, gridSize) {
        let coords = lonLat;
        let extent = new Extent();
        if (lonLat.lon > 0) {
            extent = getTileCellExtent(x - (1 << z), y, z, this._eastExtent);
        }
        else {
            extent = getTileCellExtent(x, y, z, this._westExtent);
        }
        let sizeImgW = extent.getWidth() / (gridSize - 1), sizeImgH = extent.getHeight() / (gridSize - 1);
        let i = gridSize - Math.ceil((coords.lat - extent.southWest.lat) / sizeImgH) - 1, j = Math.floor((coords.lon - extent.southWest.lon) / sizeImgW);
        return [i, j];
    }
    createEntitiCollectionsTreeStrategy(layer, nodeCapacity) {
        return new EquiEntityCollectionsTreeStrategy(layer, nodeCapacity);
    }
    collectVisibleNode(node) {
        let ext = node.segment.getExtent();
        if (ext.southWest.lon < 0) {
            this._visibleNodesWest[node.nodeId] = node;
        }
        else {
            this._visibleNodesEast[node.nodeId] = node;
        }
    }
    _clearVisibleNodes() {
        this._visibleNodesWest = {};
        this._visibleNodesEast = {};
    }
}

class EPSG4326QuadTreeStrategy extends QuadTreeStrategy {
    constructor(planet) {
        super(planet, "EPSG4326", EPSG4326);
    }
    init() {
        this._quadTreeList = [
            new Node$1(SegmentLonLatEqui, this.planet, 0, null, 0, Extent.createFromArray([-180, -90, 0, 90])),
            new Node$1(SegmentLonLatEqui, this.planet, 0, null, 0, Extent.createFromArray([0, -90, 180, 90]))
        ];
    }
}

class Wgs84QuadTreeStrategy extends QuadTreeStrategy {
    constructor(planet) {
        super(planet, "wgs84", EPSG4326);
    }
    init() {
        this._quadTreeList = [
            new Node$1(SegmentLonLatEqui, this.planet, 0, null, 0, Extent.createFromArray([-180, -90, 180, 90]))
        ];
    }
}

const quadTreeStrategyType = {
    epsg4326: EPSG4326QuadTreeStrategy,
    earth: EarthQuadTreeStrategy,
    equi: EquiQuadTreeStrategy,
    wgs84: Wgs84QuadTreeStrategy
};

export { ALIGN, BilTerrain, Billboard, Bing, Camera, CanvasTiles, Clock, Control, EarthQuadTreeStrategy, Ellipsoid, EmptyTerrain, Entity, EntityCollection, EquiQuadTreeStrategy, Events, Extent, Framebuffer, GeoImage, GeoObject, GeoTexture2d, GeoVideo, Geoid, Geometry, GeometryTypeEnum, Globe, GlobusRgbTerrain, GlobusTerrain, Handler, KML, LAYER_EVENTS, Label, Layer, LightSource, Line2, Line3, LonLat, Mat3, Mat4, Material, Multisample, Object3d, OpenStreetMap, Plane, Planet, PlanetCamera, PointCloud, Polyline, Popup, Program, QuadTreeStrategy, Quat, Ray$1 as Ray, RenderNode, Renderer, RgbTerrain, Strip, Vec2, Vec3, Vec4, Vector, WMS, Wgs84QuadTreeStrategy, XYZ, index$5 as bv, index$4 as control, input, jd, index$1 as layer, mars, math, mercator, moon, quadTreeStrategyType, index$3 as scene, index$2 as terrain, shared as utils, index as webgl, wgs84 };
//# sourceMappingURL=og.esm.js.map
